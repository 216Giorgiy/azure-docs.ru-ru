## Указание форматов

### Определение TextFormat

Если для свойства format задано значение **TextFormat**, в разделе **Format** вы можете указать следующие **необязательные** свойства.

| Свойство | Описание | Допустимые значения | Обязательно |
| -------- | ----------- | -------- | -------- | 
| columnDelimiter | Знак, используемый для разделения столбцов в файле. | Допускается только один знак. Значение по умолчанию — запятая (,). | Нет |
| rowDelimiter | Знак, используемый для разделения строк в файле. | Допускается только один знак. По умолчанию используется одно из следующих значений: для чтения — [\\r\\n, \\r, \\n], для записи — \\r\\n. | Нет |
| escapeChar | Специальный знак, используемый для экранирования разделителя столбцов в содержимом входного файла. <br/><br/>Для таблицы нельзя указать и escapeChar, и quoteChar. | Допускается только один знак. Значение по умолчанию отсутствует. <br/><br/>Например, если в качестве разделителя столбцов используется запятая (,), но этот знак встречается и в тексте (пример: "Hello, world"), то в качестве знака экранирования можно определить знак доллара ($) и использовать в исходном тексте строку "Hello$, world". | Нет | 
| quoteChar | Знак, используемый в качестве кавычки для заключения строкового значения. Разделители столбцов и строк внутри знаков кавычек будут рассматриваться как часть строкового значения. Это свойство применимо к входным и выходным наборам данных.<br/><br/>Для таблицы невозможно одновременно указать свойства escapeChar и quoteChar. | Допускается только один знак. Значение по умолчанию отсутствует. <br/><br/>Например, если в качестве разделителя столбцов используется запятая (,) и нужно, чтобы этот знак встречался в тексте (например, <Hello, world>), то можно в качестве знака кавычек определить двойную кавычку (") и использовать в исходном тексте строку "Hello, world". | Нет |
| nullValue | Один или несколько знаков, используемых для представления значения NULL. | Один или несколько знаков. Значения по умолчанию: "\\N" и "NULL" для чтения и "\\N" для записи. | Нет |
| encodingName | Имя кодировки. | Допустимое имя кодировки. Ознакомьтесь с описанием свойства [Encoding.EncodingName](https://msdn.microsoft.com/library/system.text.encoding.aspx). Пример: windows-1250 или shift\_jis. По умолчанию используется UTF-8. | Нет | 
| firstRowAsHeader | Указывает, следует ли рассматривать первую строки в качестве заголовка. Фабрика данных считывает первую строку входного набора данных как заголовок. Фабрика данных записывает первую строку как заголовок в выходной набор данных. <br/><br/>Ознакомьтесь с примерами сценариев использования [**firstRowAsHeader** и **skipLineCount**](#scenarios-for-using-firstrowasheader-and-skiplinecount). | True,<br/>False (по умолчанию) | Нет |
| skipLineCount | Указывает количество строк, которые нужно пропустить при чтении данных из входных файлов. Если указаны skipLineCount и firstRowAsHeader, то сначала пропускаются строки, после чего из входного файла считываются данные заголовка. <br/><br/>Ознакомьтесь с примерами сценариев использования [firstRowAsHeader и skipLineCount](#scenarios-for-using-firstrowasheader-and-skiplinecount). | Число | Нет | 
| treatEmptyAsNull | Указывает, следует ли интерпретировать строки со значением NULL или пустые строки как значение NULL при чтении данных из входного файла. | True (по умолчанию),<br/>False | Нет |  

#### Пример TextFormat
В следующем примере показаны некоторые свойства формата для TextFormat.

	"typeProperties":
	{
	    "folderPath": "mycontainer/myfolder",
	    "fileName": "myblobname"
	    "format":
	    {
	        "type": "TextFormat",
	        "columnDelimiter": ",",
	        "rowDelimiter": ";",
	        "quoteChar": """,
	        "NullValue": "NaN"
			"firstRowAsHeader": true,
			"skipLineCount": 0,
			"treatEmptyAsNull": true
	    }
	},

Чтобы использовать escapeChar вместо quoteChar, вместо строки с quoteChar укажите следующее:

	"escapeChar": "$",



### Сценарии использования firstRowAsHeader и skipLineCount

- Вы выполняете копирование из нефайлового источника в текстовый файл и хотите добавить строку заголовка, содержащую метаданные схемы (например, схемы SQL). В этом случае укажите firstRowAsHeader со значением true в выходном наборе данных.
- Вы копируете данные из текстового файла, содержащего строку заголовка, в нефайловый приемник и хотите удалить эту строку. Укажите firstRowAsHeader со значением true во входном наборе данных.
- Вы копируете данные из текстового файла и хотите пропустить несколько строк в его начале, которые не содержат ни данных, ни заголовка. Укажите skipLineCount, чтобы задать число пропускаемых строк. Если остальная часть файла содержит строку заголовка, то можно также указать firstRowAsHeader. Если указаны skipLineCount и firstRowAsHeader, то сначала пропускаются строки, после чего из входного файла считываются данные заголовка.

### Определение AvroFormat
Если для свойства format выбрано значение AvroFormat, вам не нужно указывать какие-либо свойства в подразделе Format раздела typeProperties. Пример:

	"format":
	{
	    "type": "AvroFormat",
	}

Сведения об использовании формата Avro в таблице Hive см. в [учебнике по Apache Hive](https://cwiki.apache.org/confluence/display/Hive/AvroSerDe).

### Указание JsonFormat

Если для свойства format задано значение **JsonFormat**, то в разделе **Format** вы можете указать следующие **необязательные** свойства.

| Свойство | Описание | Обязательно |
| -------- | ----------- | -------- |
| filePattern | Шаблон данных, хранящихся в каждом JSON-файле. Допустимые значения: **setOfObjects** и **arrayOfObjects**. Значение **по умолчанию** — **setOfObjects**. Сведения об этих шаблонах см. в разделах ниже.| Нет |
| encodingName | Имя кодировки. Список допустимых имен кодировок приведен в описании свойства [Encoding.EncodingName](https://msdn.microsoft.com/library/system.text.encoding.aspx). Например: windows-1250 или shift\_jis. **По умолчанию** используется **UTF-8**. | Нет | 
| nestingSeparator | Символ, используемый для разделения уровней вложенности. Значение по умолчанию — точка (.). | Нет | 


#### Шаблон файла setOfObjects

Каждый файл содержит один объект или несколько разделенных строками или объединенных объектов. Если этот параметр выбран в выходном наборе данных, то в результате копирования будет создан JSON-файл, где каждый объект будет находиться в отдельной строке (файл с разделителем-строкой).

**один объект**

	{
		"time": "2015-04-29T07:12:20.9100000Z",
		"callingimsi": "466920403025604",
		"callingnum1": "678948008",
		"callingnum2": "567834760",
		"switch1": "China",
		"switch2": "Germany"
	}

**JSON с разделителем-строкой**

	{"time":"2015-04-29T07:12:20.9100000Z","callingimsi":"466920403025604","callingnum1":"678948008","callingnum2":"567834760","switch1":"China","switch2":"Germany"}
	{"time":"2015-04-29T07:13:21.0220000Z","callingimsi":"466922202613463","callingnum1":"123436380","callingnum2":"789037573","switch1":"US","switch2":"UK"}
	{"time":"2015-04-29T07:13:21.4370000Z","callingimsi":"466923101048691","callingnum1":"678901578","callingnum2":"345626404","switch1":"Germany","switch2":"UK"}
	{"time":"2015-04-29T07:13:22.0960000Z","callingimsi":"466922202613463","callingnum1":"789037573","callingnum2":"789044691","switch1":"UK","switch2":"Australia"}
	{"time":"2015-04-29T07:13:22.0960000Z","callingimsi":"466922202613463","callingnum1":"123436380","callingnum2":"789044691","switch1":"US","switch2":"Australia"}

**объединенный JSON**

	{
		"time": "2015-04-29T07:12:20.9100000Z",
		"callingimsi": "466920403025604",
		"callingnum1": "678948008",
		"callingnum2": "567834760",
		"switch1": "China",
		"switch2": "Germany"
	}
	{
		"time": "2015-04-29T07:13:21.0220000Z",
		"callingimsi": "466922202613463",
		"callingnum1": "123436380",
		"callingnum2": "789037573",
		"switch1": "US",
		"switch2": "UK"
	}
	{
		"time": "2015-04-29T07:13:21.4370000Z",
		"callingimsi": "466923101048691",
		"callingnum1": "678901578",
		"callingnum2": "345626404",
		"switch1": "Germany",
		"switch2": "UK"
	}


#### Шаблон файла arrayOfObjects. 

Каждый файл содержит массив объектов.

	[
	    {
	        "time": "2015-04-29T07:12:20.9100000Z",
	        "callingimsi": "466920403025604",
	        "callingnum1": "678948008",
	        "callingnum2": "567834760",
	        "switch1": "China",
	        "switch2": "Germany"
	    },
	    {
	        "time": "2015-04-29T07:13:21.0220000Z",
	        "callingimsi": "466922202613463",
	        "callingnum1": "123436380",
	        "callingnum2": "789037573",
	        "switch1": "US",
	        "switch2": "UK"
	    },
	    {
	        "time": "2015-04-29T07:13:21.4370000Z",
	        "callingimsi": "466923101048691",
	        "callingnum1": "678901578",
	        "callingnum2": "345626404",
	        "switch1": "Germany",
	        "switch2": "UK"
	    },
	    {
	        "time": "2015-04-29T07:13:22.0960000Z",
	        "callingimsi": "466922202613463",
	        "callingnum1": "789037573",
	        "callingnum2": "789044691",
	        "switch1": "UK",
	        "switch2": "Australia"
	    },
	    {
	        "time": "2015-04-29T07:13:22.0960000Z",
	        "callingimsi": "466922202613463",
	        "callingnum1": "123436380",
	        "callingnum2": "789044691",
	        "switch1": "US",
	        "switch2": "Australia"
	    },
	    {
	        "time": "2015-04-29T07:13:24.2120000Z",
	        "callingimsi": "466922201102759",
	        "callingnum1": "345698602",
	        "callingnum2": "789097900",
	        "switch1": "UK",
	        "switch2": "Australia"
	    },
	    {
	        "time": "2015-04-29T07:13:25.6320000Z",
	        "callingimsi": "466923300236137",
	        "callingnum1": "567850552",
	        "callingnum2": "789086133",
	        "switch1": "China",
	        "switch2": "Germany"
	    }
	]

### Пример JsonFormat

Если у вас есть JSON-файл со следующим содержимым:

	{
		"Id": 1,
		"Name": {
			"First": "John",
			"Last": "Doe"
		},
		"Tags": ["Data Factory”, "Azure"]
	}

и вы хотите скопировать его в таблицу SQL Azure в следующем формате:

Идентификатор | Name.First | Name.Middle | Name.Last | Теги
--- | ---------- | ----------- | --------- | ----
1 | Артем | null | Кузнецов | ["Data Factory", "Azure"]

Входной набор данных с типом JsonFormat определяется следующим образом (частичное определение только соответствующих частей):

	"properties": {
		"structure": [
			{"name": "Id", "type": "Int"},
			{"name": "Name.First", "type": "String"},
			{"name": "Name.Middle", "type": "String"},
			{"name": "Name.Last", "type": "String"},
			{"name": "Tags", "type": "string"}
		],
		"typeProperties":
		{
			"folderPath": "mycontainer/myfolder",
			"format":
			{
				"type": "JsonFormat",
				"filePattern": "setOfObjects",
				"encodingName": "UTF-8",
				"nestingSeparator": "."
			}
		}
	}

Если структура не определена, действие копирования сведет структуру по умолчанию и скопирует каждый элемент.

#### Поддерживаемая структура JSON
Обратите внимание на следующее.

- Каждый объект в коллекции пар "имя-значение" сопоставлен с одной строкой данных в табличном формате. Объекты могут быть вложенными, и вы можете определить, как свести структуру в наборе данных с разделителем вложения (.) по умолчанию. Пример см. в разделе [Пример JsonFormat](#jsonformat-example) выше.
- Если структура не определена в наборе данных фабрики данных, действие копирования обнаружит схему из первого объекта и выполнит сведение всего объекта.
- Если входной JSON-файл содержит массив, действие копирования преобразует все значение массива в строку. Это действие можно пропустить с помощью [сопоставления или фильтрации столбцов](#column-mapping-with-translator-rules).
- Если на том же уровне существует повторяющиеся имена, то действие копирования выберет последнее из них.
- В именах свойств учитывается регистр. Два свойства с одинаковым именем, но в разных регистрах, рассматриваются как два отдельных свойства.

### Указание OrcFormat
Если для свойства format выбрано значение OrcFormat, вам не нужно указывать какие-либо свойства в подразделе Format раздела typeProperties. Пример:

	"format":
	{
	    "type": "OrcFormat",
	}

> [AZURE.IMPORTANT] Если вы не копируете ORC-файлов **как есть** между локальным и облачным хранилищами данных, то на компьютере шлюза необходимо установить 8 JRE (среду выполнения Java). Для 64-разрядного шлюза требуется 64-разрядная версия JRE, а для 32-разрядного шлюза — 32-разрядная версия JRE. Обе эти версии доступны [здесь](http://go.microsoft.com/fwlink/?LinkId=808605). Выберите ту, что вам подходит.

Обратите внимание на следующее.

-	Данные сложных типов (STRUCT, MAP, LIST, UNION) не поддерживаются.
-	Для ORC-файлов используется три [параметра сжатия](http://hortonworks.com/blog/orcfile-in-hdp-2-better-compression-better-performance/): NONE, ZLIB и SNAPPY. Фабрика данных поддерживает чтение данных из ORC-файла в любом из этих форматов. Для чтения данных используется кодек сжатия из метаданных. Однако при записи в ORC-файл фабрика данных по умолчанию выбирает ZLIB. В настоящее время изменить это поведение нельзя.

<!---HONumber=AcomDC_0831_2016-->