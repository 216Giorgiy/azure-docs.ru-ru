> [!div class="op_single_selector"]
> * [Node.js](../articles/iot-hub/iot-hub-node-node-twin-how-to-configure.md)
> * [C#/Node.js](../articles/iot-hub/iot-hub-csharp-node-twin-how-to-configure.md)
> * [C#](../articles/iot-hub/iot-hub-csharp-csharp-twin-how-to-configure.md)
> * [Java](../articles/iot-hub/iot-hub-java-java-twin-how-to-configure.md)
> * [Python](../articles/iot-hub/iot-hub-python-python-twin-how-to-configure.md)
> 
> 

## <a name="introduction"></a>Введение

Изучив руководство [Приступая к работе с двойниками устройств][lnk-twin-tutorial], вы узнали, как задать метаданные устройства в серверной части решения с помощью *тегов*, сообщить об условиях устройства из приложения устройства с помощью *сообщаемых свойств* и запросить эти сведения с помощью языка запросов, похожего на SQL.

В этом руководстве представлены сведения об удаленной настройке приложений устройства с помощью *требуемых свойств* и *сообщаемых свойств* двойника устройства. В частности, здесь показано, как на основе требуемых и сообщаемых свойств двойника устройства реализовать многошаговую настройку приложения устройства, а также обеспечить полную видимость состояния этой операции на всех устройствах в серверной части решения. Дополнительные сведения о роли конфигураций устройств см. в статье [Общие сведения об управлении устройствами с помощью Центра Интернета вещей][lnk-dm-overview].

Если не вдаваться в подробности, двойники устройства позволяют серверной части решения просто указать целевую конфигурацию для управляемых устройств, не заботясь об отправке конкретных команд. Таким образом, устройство может самостоятельно выбирать оптимальный способ обновления конфигурации (это важно в сценариях Интернета вещей, где условия работы конкретного устройства могут помешать мгновенно выполнить некоторые команды), а также должно постоянно отправлять отчеты о текущем состоянии и возможных сбоях при обновлении состояния в серверной части решения. Эта концепция играет важную роль в управлении большими наборами устройств, так как позволяет серверной части решения полностью отслеживать процесс настройки на всех устройствах.

> [!NOTE]
> В сценариях, где управление устройствами осуществляется в интерактивном режиме (включение вентилятора с помощью пользовательского приложения), используйте [прямые методы][lnk-methods].
> 
> 

В этом руководстве серверная часть решения изменяет конфигурацию телеметрии целевого устройства, в результате чего приложение устройства выполняет процесс из нескольких этапов для применения обновлений конфигурации (например, принудительная перезагрузка модуля приложения, которая в этом руководстве выполняется с небольшой задержкой).

Серверная часть решения сохраняет конфигурацию в требуемых свойствах двойника устройства следующим образом.

        {
            ...
            "properties": {
                ...
                "desired": {
                    "telemetryConfig": {
                        "configId": "{id of the configuration}",
                        "sendFrequency": "{config}"
                    }
                }
                ...
            }
            ...
        }

> [!NOTE]
> Так как конфигурации могут быть сложными объектами, им назначаются уникальные идентификаторы (хэши или [идентификаторы GUID][lnk-guid]) для упрощения их сравнения.
> 
> 

Приложение устройства сообщает о своей текущей конфигурации, отображая требуемое свойство **telemetryConfig** в сообщаемых свойствах.

        {
            "properties": {
                ...
                "reported": {
                    "telemetryConfig": {
                        "configId": "{id of the current configuration}",
                        "sendFrequency": "{current configuration}",
                        "status": "Success",
                    }
                }
                ...
            }
        }

Обратите внимание, что свойство **telemetryConfig** имеет дополнительное свойство **status**, используемое для сообщения состояния процесса обновления конфигурации.

Получив новую требуемую конфигурацию, приложение устройства сообщает об ожидающей конфигурации, изменяя определенные сведения.

        {
            "properties": {
                ...
                "reported": {
                    "telemetryConfig": {
                        "configId": "{id of the current configuration}",
                        "sendFrequency": "{current configuration}",
                        "status": "Pending",
                        "pendingConfig": {
                            "configId": "{id of the pending configuration}",
                            "sendFrequency": "{pending configuration}"
                        }
                    }
                }
                ...
            }
        }

Через некоторое время приложение устройства сообщит об успешном выполнении или сбое этой операции, обновив это свойство.
Обратите внимание, что серверная часть решения может в любое время запросить состояние процесса конфигурации на всех устройствах.

В этом учебнике описаны следующие процедуры.

* создание приложения имитации устройства, которое получает обновления конфигурации от серверной части решения и сообщает о нескольких обновлениях как о *сообщаемых свойствах* в процессе обновления конфигурации;
* создание внутреннего приложения, которое обновляет требуемую конфигурацию устройства, а затем запрашивает процесс обновления конфигурации.

<!-- links -->

[lnk-methods]: ../articles/iot-hub/iot-hub-devguide-direct-methods.md
[lnk-dm-overview]: ../articles/iot-hub/iot-hub-device-management-overview.md
[lnk-twin-tutorial]: ../articles/iot-hub/iot-hub-node-node-twin-getstarted.md
[lnk-guid]: https://en.wikipedia.org/wiki/Globally_unique_identifier
