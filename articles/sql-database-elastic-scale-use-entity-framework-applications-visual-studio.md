<properties 
	pageTitle="Использование эластичного масштабирования (Elastic Scale) с Entity Framework" 
	description="Эластичное масштабирование упрощает масштабирование, а Entity Framework удобно использовать для программирования баз данных" 
	services="sql-database" 
	documentationCenter="" 
	manager="stuartozer" 
	authors="Joseidz" 
	editor=""/>

<tags 
	ms.service="sql-database" 
	ms.workload="sql-database" 
	ms.tgt_pltfrm="na" 
	ms.devlang="na" 
	ms.topic="article" 
	ms.date="02/03/2015" 
	ms.author="Joseidz@microsoft.com"/>

# Использование эластичного масштабирования (Elastic Scale) с Entity Framework 
 
При создании приложений можно использовать эластичное масштабирование баз данных SQL Azure вместе с Microsoft Entity Framework (EF). Эластичное масштабирование дает возможность увеличивать и уменьшать мощности путем сегментирования и масштабирования уровня данных приложения. В этом документе показаны изменения, которые следует внести в приложение Entity Framework для интеграции эластичного масштабирования. Основное внимание уделяется совмещению [методов управления сегментами эластичного масштабирования](http://go.microsoft.com/?linkid=9862595) и [маршрутизации на основе данных](./sql-database-elastic-scale-data-dependent-routing.md) с подходом **Code First** в Entity Framework. Учебник по EF [Code First - новая база данных](http://msdn.microsoft.com/data/jj193542.aspx) в данном документе принят за рабочий пример. Пример кода в этом документе является частью примеров по эластичному масштабированию в примерах кода Visual Studio.
  
## Загрузка и выполнение примера кода
Как загрузить код для этой статьи

* Требуется Visual Studio 2012 или более поздней версии. 
* Запустите Visual Studio. 
* В Visual Studio выберите последовательно "Файл" -> "Создать проект". 
* В диалоговом окне "Новый проект" перейдите к **Примеры в сети** для **Visual C#** и введите "эластичное масштабирование" в поле поиска в правом верхнем углу.
    
    ![Entity Framework and elastic scale sample app][1] 

    Выберите пример **Эластичное масштабирование с базой данных SQL Azure - интеграция с платформой Entity Framework**. Примите условия лицензии, после чего пример будет загружен. 

Чтобы запустить пример, необходимо создать три пустые базы данных в базе данных SQL Azure:

* База данных диспетчера сопоставления сегментов
* База данных сегмента 1
* База данных сегмента 2

Создав эти базы данных, замените заполнители в файле **Program.cs** именем своего сервера баз данных SQL Azure, именами баз данных и учетными данными для подключения к этим базам. Постройте решение в Visual Studio. Visual Studio загрузит необходимые в процессе построения пакеты NuGet для Elastic Scale, Entity Framework и Transient Fault. Убедитесь, что для вашего решения включена функция восстановления пакетов NuGet. Этот параметр можно включить, щелкнув файл решения правой кнопкой мыши в обозревателе решений Visual Studio. 

## Рабочие процессы Entity Framework 

Разработчики Entity Framework используют один из следующих четырех рабочих процессов для построения приложений и обеспечения сохранения объектов приложения. 

* **Code First (новая база данных)**. Разработчик EF в коде приложения создает модель, затем на ее основе платформа EF создает базу данных. 
* **Code First (существующая база данных)**. Разработчик позволяет EF сформировать для модели код приложения на основе существующей базы данных.
* **Model First**. Разработчик создает модель в конструкторе Entity Framework, затем Entity Framework создает базу данных на основе модели.
* **Database First**. Разработчик использует инструментарий EF для получения модели из существующей базы данных. 

Во всех подходах класс DbContext используются для прозрачного управления подключениями к базе данных и схемой базы данных приложения. Как будет показано далее, различные конструкторы базового класса DbContext дают разный уровень управления при создании соединений и схем, при начальной загрузке базы данных. В основном сложности связаны с тем, что управление подключениями к базе данных, обеспечиваемое EF, пересекается с функциями управления подключением интерфейсов маршрутизации на основе данных, предоставляемых Azure Database Elastic Scale. 

## Предположения, касающиеся эластичного масштабирования 

Определения терминов см. в [глоссарии эластичного масштабирования](./sql-database-elastic-scale-glossary.md).

При использовании эластичного масштабирования баз данных SQL Azure данные приложения разделаются на сегменты называемые шардлетами.  Шардлеты идентифицируются по ключу сегментирования и сопоставляются с определенными базами данных. Приложение может иметь любое количество баз данных и распределять шардлеты по мере необходимости для предоставления достаточной емкости и производительности, исходя из текущих бизнес-требований. Сопоставление значений ключей сегментирования к базам данных хранится в сопоставлении сегментов (shard map). Его предоставляют API-интерфейсы эластичного масштабирования. Для краткости мы называем эту функцию Shard Map Management (управление сопоставлениями сегментов) или SMM. Сопоставление сегментов также выступает в качестве посредника подключений к базе данных для запросов с ключом сегментирования. Мы называем эту функцию маршрутизация на основе данных. 
 
Диспетчер сопоставления сегментов в Elastic Scale защищает пользователей от получения несогласованных представлений данных шардлета, которые могут иметь место при выполнении параллельных операций управления шардлетом (например, при перемещении данных из одного сегмента в другой). Для предотвращения таких случаев подключения к базе данных для приложения Elastic Scale проводятся через сопоставления сегментов Elastic Scale. Это позволяет сопоставлению сегментов автоматически завершить соединение с базой данных, если операции управления сегментами могут повлиять на шардлет, для которого создано соединение. Этот подход необходимо интегрировать с некоторыми функциями платформы EF, например, в случае создания нового подключения на основе существующего нужно проверять факт существования базы данных. В общем случае наши наблюдения показали, что стандартные конструкторы DbContext работают надежно только для закрытых подключений к базе данных, которые можно безопасно клонировать для работы в EF. В противоположность этому принцип проектирования Elastic Scale заключается в использовании открытых подключений только через посредника. Можно прийти к выводу, что закрытие подключения через посредника в Elastic Scale перед его передачей в EF DbContext может решить проблему. Однако, закрыв подключение и полагаясь на то, что EF откроет его снова, разработчик откажется от проверок согласованности, выполняемых Elastic Scale. Однако, функции миграции в EF используют эти подключения для управления схемой базы данных таким образом, что это эти действия видны и в приложении. В идеальном случае мы бы хотели бы сохранить и объединить все эти возможности эластичного масштабирования и платформы EF в одном приложении. В следующем разделе эти свойства и требования описываются более подробно. 


## Требования 

При работе с API платформы Entity Framework и Elastic Scale, мы хотим сохранить следующие свойства: 

* **Масштабирование**. Для добавления и удаления баз данных из уровня данных сегментированного приложения согласно требованиям приложения к ресурсам. Это означает контроль создания и удаления баз данных, а также использование API диспетчера сопоставления сегментов Elastic Scale для управления базами данных и сопоставлениями шардлетов. 

* **Согласованность**: В приложении применяется сегментирование и используются возможности Elastic Scale по маршрутизации на основе данных. Чтобы избежать повреждения данных и получения неправильных результатов запросов, соединения проходят через посредника в виде диспетчера сопоставления сегментов Elastic Scale. Это также позволяет использовать проверки и поддерживать согласованность данных.
 
* **Code First**. Чтобы сохранить удобства парадигмы платформы EF Code First. В парадигме Code First классы приложения прозрачно сопоставляются со структурами базы данных. Код приложения взаимодействует с наборами DbSet, в которых упрятаны большинство используемых аспектов обработки базы данных.
 
* **Схема**. Entity Framework берет на себя создание начальной схемы базы данных и последующего развития схемы в ходе миграций. Если сохранить эти возможности, то адаптация приложения будет таким же простым как развитие данных. 

Следующее руководство показывает, как с помощью эластичного масштабирования баз данных в SQL Azure достичь соответствия этим требованиям для приложений Code First. 

## Маршрутизация на основе данных с помощью EF DbContext 

Подключения к базам данных в платформе Entity Framework обычно управляются через подклассы **DbContext**. Создайте эти подклассы, сделав их производными от **DbContext**. Здесь определяются **DbSets**, реализующие коллекции CLR-объектов для приложения на основе базы данных. В контексте маршрутизации на основе данных можно выделить несколько полезных свойств, которые не обязательно будут применимы в других сценариях использования приложений EF Сode First. 

* База данных уже существует и зарегистрирована в сопоставлении сегментов эластичного масштабирования. 
* Схема приложения уже развернута в базу данных (как описано ниже). 
* Подключения маршрутизации на основе данных проходят через сопоставление сегментов эластичного масштабирования. 

Для интеграции **DbContext** с маршрутизацией на основе данных в случае горизонтального масштабирования нужно сделать следующее.

1. Создать подключения к физическим базам данных через интерфейсы диспетчера сопоставления сегментов Elastic Scale. 
2. Обернуть подключение подклассом **DbContext**
3. Передать подключение в базовые классы **DbContext**, чтобы вся необходимая обработка также была выполнена и на стороне EF. 

Этот подход показан в следующем примере кода. (Этот код также есть в соответствующем проекте Visual Studio)

    public class ElasticScaleContext<T> : DbContext
    {
    public DbSet<Blog> Blogs { get; set; }
    ...

        // C'tor for data dependent routing. This call will open a validated connection 
        // routed to the proper shard by the shard map manager. 
        // Note that the base class c'tor call will fail for an open connection
        // if migrations need to be done and SQL credentials are used. This is the reason for the 
        // separation of c'tors into the data-dependent routing case (this c'tor) and the internal c'tor for new shards.
        public ElasticScaleContext(ShardMap shardMap, T shardingKey, string connectionStr)
            : base(CreateDDRConnection(shardMap, shardingKey, connectionStr), 
            true /* contextOwnsConnection */)
        {
        }

        // Only static methods are allowed in calls into base class c'tors
        private static DbConnection CreateDDRConnection(
        ShardMap shardMap, 
        T shardingKey, 
        string connectionStr)
        {
            // No initialization
            Database.SetInitializer<ElasticScaleContext<T>>(null);

            // Ask shard map to broker a validated connection for the given key
            SqlConnection conn = shardMap.OpenConnectionForKey<T>
                                (shardingKey, connectionStr, ConnectionOptions.Validate);
            return conn;
        }    

## Основные моменты
* Новый конструктор заменяет конструктор по умолчанию подкласса DbContext 
* Новый конструктор принимает аргументы, которые требуются для маршрутизации на основе данных эластичного масштабирования: 
    * сопоставление сегментов для доступа к интерфейсам маршрутизации на основе данных, 
    * ключ сегментирования для определения шардлета, 
    * Строка подключения с учетными данными для подключения к сегменту через маршрутизацию на основе данных. 
* Вызов конструктора базового класса приводит к выполнению статического метода, реализующего все действия, необходимые для маршрутизации на основе данных. 
    * Он использует вызов **OpenConnectionForKey** интерфейсов эластичного масштабирования в сопоставлении сегментов для установления открытого соединения. 
    * Сопоставление создает открытое соединение к сегменту, в котором содержится шардлет, соответствующий заданному ключу сегментирования.
    * Это открытое подключение передается обратно в конструктор базового класса **DbContext**, чтобы EF использовал его вместо автоматического создания нового подключения. Таким образом подключение помечается Elastic Scale, что гарантирует согласованность данных при выполнении операций по управлению сопоставлением сегментов.  
  
Используйте в коде новый конструктор для подкласса DbContext вместо конструктора по умолчанию. Пример: 

    // Create and save a new blog.

    Console.Write("Enter a name for a new blog: "); 
    var name = Console.ReadLine(); 

    using (var db = new ElasticScaleContext<int>( 
                            sharding.ShardMap,  
                            tenantId1,  
                            connStrBldr.ConnectionString)) 
    { 
        var blog = new Blog { Name = name }; 
        db.Blogs.Add(blog); 
        db.SaveChanges(); 

        // Display all Blogs for tenant 1 
        var query = from b in db.Blogs 
                    orderby b.Name 
                    select b; 
     ... 
    }

Новый конструктор открывает подключение к сегменту, который содержит данные для шардлета, определяемого значением **tenantid1**. Код в блоке **using** не изменяется, чтобы с помощью EF дать доступ к **DbSet** блогов в сегменте для **tenantid1**. Это меняет семантику кода в блоке using таким образом, что все операции с базой данных теперь относятся к одному сегменту, где хранится **tenantid1**. Например, LINQ-запрос к **DbSet** блогов будет возвращать только блоги, хранящиеся в текущем сегменте.  

####Обработка временных сбоев
Команда Microsoft Patterns & Practices опубликовала библиотеку [Блок приложений обработки временных сбоев](http://msdn.microsoft.com/library/dn440719(v=pandp.60.aspx)). Библиотека используется с Elastic Scale в сочетании с EF. Тем не менее обеспечьте возврат всех временных исключений в место, где после временного сбоя будет использоваться новый конструктор, чтобы все попытки установки нового подключения выполнялись с помощью измененных нами конструкторов. В противном случае не гарантируется установка подключения с правильным сегментом и нет гарантий, что подключение будет поддерживаться в случае изменения в сопоставлении сегментов. 

В следующем примере кода показано, как можно использовать политику повторов SQL в новых конструкторах подкласса **DbContext**. 

    SqlDatabaseUtils.SqlRetryPolicy.ExecuteAction(() => 
    { 
        using (var db = new ElasticScaleContext<int>( 
                                sharding.ShardMap,  
                                tenantId1,  
                                connStrBldr.ConnectionString)) 
            { 
                    var blog = new Blog { Name = name }; 
                    db.Blogs.Add(blog); 
                    db.SaveChanges(); 
            ... 
            } 
        }); 

Политика **SqlDatabaseUtils.SqlRetryPolicy** в приведенном выше коде определена как **SqlDatabaseTransientErrorDetectionStrategy** с числом попыток равным 10 и 5-секундным временем ожидания между повторами попытки. Такой подход согласуется с рекомендациями для EF и транзакций, инициированных пользователями (см. [Ограничения в стратегиях с повторами попыток (далее EF6)](http://msdn.microsoft.com/data/dn307226). В обоих случаях требуется, чтобы приложение определяло область действия, куда возвращается временное исключение: чтобы снова открыть транзакцию или (как показано) повторно создать контекст из подходящего конструктора, использующего библиотеки эластичного масштабирования.

Необходимость определять место в области действия, куда возвращаются временные исключения, также исключает использование встроенной стратегии **SqlAzureExecutionStrategy**, поставляемой с EF. **SqlAzureExecutionStrategy** будет снова открывать подключение, но не будет использовать **OpenConnectionForKey**, и поэтому обходить все проверки, выполняемые при вызове **OpenConnectionForKey**. Вместо этого в примере кода используется встроенная стратегия **DefaultExecutionStrategy**, также поставляемая с EF. В отличие от **SqlAzureExecutionStrategy**, она работает должным образом в сочетании с политикой повторов из библиотеки обработки временных сбоев. Политика выполнения задана в классе **ElasticScaleDbConfiguration**. Обратите внимание, что мы решили не использовать **DefaultSqlExecutionStrategy**, так как она предполагает использование **SqlAzureExecutionStrategy** при появлении временных исключений, что может привести к неправильному поведению, как описано выше. Дополнительную информацию о различных политиках повтора и EF см. в разделе [Устойчивость подключения в EF](http://msdn.microsoft.com/data/dn456835.aspx).     

#### Переделка конструктора
Вышеприведенные примеры кода показывают переделку конструктора по умолчанию, необходимую для приложения, использующего маршрутизацию на основе данных Elastic Scale с платформой Entity Framework. Следующая таблица обобщает этот подход для других конструкторов. 


Текущий конструктор  | Переделанный конструктор для данных | Базовый конструктор | Примечания
---------- | ----------- | ------------|----------
MyContext() |ElasticScaleContext(ShardMap, TKey) |DbContext(DbConnection, bool) |Подключение должно быть функцией сопоставления карты сегментов и ключа маршрутизации на основе данных. Нужно обойти автоматическое создание подключения в EF и вместо этого использовать сопоставление сегментов в качестве посредника подключения. 
MyContext(string)|ElasticScaleContext(ShardMap, TKey) |DbContext(DbConnection, bool) |Подключение является функцией сопоставления карты сегментов и ключа маршрутизации на основе данных. Фиксированное имя базы данных или строка подключения не сработает, т.к. они обходят проверку в сопоставлении сегментов. 
MyContext(DbCompiledModel) |ElasticScaleContext(ShardMap, TKey, DbCompiledModel) |DbContext(DbConnection, DbCompiledModel, bool) |Подключение будет создано для заданной карты сегментов и ключа сегментирования по предоставленной модели. Скомпилированная модель будет передаваться в базовый конструктор.
MyContext(DbConnection, bool) |ElasticScaleContext(ShardMap, TKey, bool) |DbContext(DbConnection, bool) |Подключение должно быть зависимым от карты сегментов и ключа. Оно не может поступать в качестве входного аргумента (если этот аргумент ранее не был получен с помощью сопоставления сегментов и ключа). Будет передаваться логическое значение. 
MyContext(string, DbCompiledModel) |ElasticScaleContext(ShardMap, TKey, DbCompiledModel) |DbContext(DbConnection, DbCompiledModel, bool) |Подключение должно быть зависимым от карты сегментов и ключа. Оно не может поступать в качестве входного аргумента (если этот аргумент не был получен с помощью сопоставления сегментов и ключа). Будет передана скомпилированная модель. 
MyContext(ObjectContext, bool) |ElasticScaleContext(ShardMap, TKey, ObjectContext, bool) |DbContext(ObjectContext, bool) |Новый конструктор должен обеспечить перенаправление подключений в ObjectContext, переданного в качестве входных данных, на подключение, которым управляет Elastic Scale. Подробное рассмотрение ObjectContext выходит за рамки данного документа.
MyContext(DbConnection, DbCompiledModel,bool) |ElasticScaleContext(ShardMap, TKey, DbCompiledModel, bool)| DbContext(DbConnection, DbCompiledModel, bool); |Подключение должно быть зависимым от карты сегментов и ключа. Подключение не может поступать в виде входного аргумента (если этот аргумент ранее не был получен с помощью сопоставления сегментов и ключа). Модель и логическое значение передаются конструктор базового класса. 

## Развертывание схемы сегментирования через миграции EF 

Автоматическое управление схемой - одно из удобств, предоставляемых платформой Entity Framework. В контексте приложения Elastic Scale желательно сохранить эту возможность автоматической подготовки схемы для вновь созданных сегментов при добавлении баз данных в сегментированное приложение. Основной случай использования - увеличение емкости уровня данных для сегментированных приложений, использующих EF. Опора на возможности платформы EF по управлению схемами сокращает затраты на администрирование баз данных в сегментированных приложениях, построенных на основе EF. 

Развертывание схемы с помощью миграций EF лучше всего работает для **неоткрытых подключений**. Это отличается от сценария с маршрутизацией на основе данных, основой которого выступает открытое подключение, предоставляемое Elastic Scale. Еще одно различие состоит в требовании к согласованности: Хоть и желательно обеспечить согласованность всех подключений с маршрутизацией на основе данных для защиты от параллельно выполняемых операций с сопоставлениями сегментов, это не является проблемой при начальном развертывании схемы в новой базе данных, которая еще не зарегистрирована в сопоставлении сегментов и не выделена для размещения шардлетов. Таким образом, для этих сценариев можно полагаться на обычные подключения к базе данных в противовес маршрутизации на основе данных.  

Это приводит к подходу, где развертывание схемы с помощью миграций EF тесно связано с регистрацией новой базы данных в качестве сегмента в сопоставлении сегментов приложения. При этом подразумевается выполнение следующих условий: 

* База данных уже создана. 
* База данных пуста - в ней нет пользовательской схемы и данных.
* База данных еще не доступна для маршрутизации на основе данных через API эластичного масштабирования. 

При выполнении этих условий можно создать обычное неоткрытое **SqlConnection**, чтобы запустить миграции EF для развертывания схемы. Этот подход показан в следующем примере кода. 

        // Enter a new shard - i.e. an empty database - to the shard map, allocate a first tenant to it  
        // and kick off EF intialization of the database to deploy schema 

        public void RegisterNewShard(string server, string database, string connStr, int key) 
        { 

            Shard shard = this.ShardMap.CreateShard(new ShardLocation(server, database)); 

            SqlConnectionStringBuilder connStrBldr = new SqlConnectionStringBuilder(connStr); 
            connStrBldr.DataSource = server; 
            connStrBldr.InitialCatalog = database; 

            // Go into a DbContext to trigger migrations and schema deployment for the new shard. 
            // This requires an un-opened connection. 
            using (var db = new ElasticScaleContext<int>(connStrBldr.ConnectionString)) 
            { 
                // Run a query to engage EF migrations 
                (from b in db.Blogs 
                    select b).Count(); 
            } 

            // Register the mapping of the tenant to the shard in the shard map. 
            // After this step, data-dependent routing on the shard map can be used 

            this.ShardMap.CreatePointMapping(key, shard); 
        } 
 

В этом примере показан метод **RegisterNewShard**, который регистрирует сегменты в сопоставлении сегментов эластичного масштабирования, развертывает схему через миграции EF и сохраняет сопоставление ключа сегментирования с сегментом. Он использует конструктор подкласса **DbContext** (в примере **ElasticScaleContext**), который принимает в качестве входных данных строку подключения SQL. Код этого конструктора довольно прост, как показывает следующий пример. 


        // C'tor to deploy schema and migrations to a new shard 
        protected internal ElasticScaleContext(string connectionString) 
            : base(SetInitializerForConnection(connectionString)) 
        { 
        } 

        // Only static methods are allowed in calls into base class c'tors 
        private static string SetInitializerForConnection(string connnectionString) 
        { 
            // We want existence checks so that the schema can get deployed 
            Database.SetInitializer<ElasticScaleContext<T>>( 
        new CreateDatabaseIfNotExists<ElasticScaleContext<T>>()); 

            return connnectionString; 
        } 
 
Можно использовать версию конструктора, унаследованную от базового класса. Однако при подключении код должен обеспечить использование для EF инициализатора по умолчанию. Поэтому присутствует вызов статического метода перед вызовом конструктора базового класса со строкой подключения. Обратите внимание, что регистрация сегментов должна выполняться в другом домене приложения или процесса, чтобы параметры инициализатора EF не конфликтовали. 


## Ограничения 

Подходы, описанные в данном документе, имеют несколько ограничений: 

* Прежде чем использовать эластичное масштабирование, приложения EF, использующие **LocalDb**, нужно перенести в обычную базу данных SQL Server. Приложение, работающее с **LocalDb**, невозможно масштабировать путем сегментирования с помощью эластичного масштабирования. Обратите внимание, что во время разработки **LocalDb** по-прежнему можно использовать. 

* Все изменения в приложении, которые подразумевают изменение схемы базы данных, должны проходить через миграции EF на всех сегментах. В примере кода для этого документа не показано как делается. Рассмотрите возможность использования операции Update-Database с параметром ConnectionString для перебора всех сегментов. Или извлеките сценарий T-SQL для ожидающейся миграции с помощью Update-Database с параметром -Script и примените этот сценарий к сегментам.  

* Предполагается, что вся обработка в базе данных для выполнения запроса ведется в пределах одного сегмента, который идентифицируется ключом сегментирования, предоставленным в запросе. Однако это предположение не всегда является верным. Например, в случае когда невозможно предоставить ключ сегментирования. Для решения этой проблемы библиотеки эластичного масштабирования предоставляют класс **MultiShardQuery**, который реализует абстракцию подключения для отправки запросов в несколько сегментов. Описание использования **MultiShardQuery** вместе с EF выходит за рамки данного документа



## Заключение 

Приложения Entity Framework легко могут использовать преимущества эластичного масштабирования баз данных SQL Azure. С помощью рекомендаций, описанных в этом документе, приложения EF могут использовать возможности эластичного масштабирования для маршрутизации на основе данных, если разработчик перепишет конструкторы подклассов **DbContext**, используемых в приложении EF. Это ограничивает внесение изменений местами применения классов **DbContext**. Кроме того приложения EF могут продолжать использовать преимущества автоматического развертывания схемы, объединив действия, вызывающие необходимые миграции EF, с регистрацией новых сегментов и сопоставлений в сопоставлении сегментов Elastic Scale. 


[AZURE.INCLUDE [elastic-scale-include](../includes/elastic-scale-include.md)]

<!--Image references-->
[1]: ./media/sql-database-elastic-scale-using-entity-framework/sample.png

<!--HONumber=47-->
