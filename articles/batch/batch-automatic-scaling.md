---
title: "Автомасштабирование вычислительных узлов в пуле пакетной службы Azure | Документация Майкрософт"
description: "Включение автоматического масштабирования в облачном пуле для динамического изменения количества вычислительных узлов в пуле."
services: batch
documentationcenter: 
author: tamram
manager: timlt
editor: tysonn
ms.assetid: c624cdfc-c5f2-4d13-a7d7-ae080833b779
ms.service: batch
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: vm-windows
ms.workload: multiple
ms.date: 02/27/2017
ms.author: tamram
ms.custom: H1Hack27Feb2017
translationtype: Human Translation
ms.sourcegitcommit: 2c9877f84873c825f96b62b492f49d1733e6c64e
ms.openlocfilehash: 9dbfa813ea64666779f1f85b3ccda2b4fa1a755b
ms.lasthandoff: 03/15/2017


---
# <a name="create-an-automatic-scaling-formula-for-scaling-compute-nodes-in-a-batch-pool"></a>Создание формулы автоматического масштабирования для масштабирования вычислительных узлов в пуле пакетной службы

При автоматическом масштабировании пакетная служба Azure может динамически добавлять или удалять вычислительные узлы в пуле в зависимости от определенных вами параметров. Вы можете сэкономить время и деньги благодаря автоматическому изменению объема вычислительной мощности, используемой приложением, т. е. по мере увеличения потребностей в ресурсах для задачи задания узлы будут добавляться, а по мере снижения потребностей — удаляться.

Автоматическое масштабирование можно включить для пула вычислительных узлов путем связывания с этим пулом определенной вами *формулы автомасштабирования*, например, с помощью метода [PoolOperations.EnableAutoScale][net_enableautoscale] в библиотеке [.NET пакетной службы](batch-dotnet-get-started.md). Затем пакетная служба использует эту формулу для определения количества вычислительных узлов, необходимого для выполнения рабочей нагрузки. Пакетная служба отвечает на периодически собираемые образцы данных метрик службы и изменяет количество вычислительных узлов в пуле через настраиваемый интервал в соответствии с указанной формулой.

Автоматическое масштабирование можно включить во время создания пула или для существующего пула. Также можно изменить назначенную формулу для пула со включенным автоматическим масштабированием. Пакетная служба позволяет не только вычислять формулы перед их назначением пулам, но и отслеживать состояние автоматического масштабирования.

## <a name="automatic-scaling-formulas"></a>Формулы автоматического масштабирования
Формула автомасштабирования — это определяемое вами строковое значение, содержащее одну или несколько инструкций. Оно назначается элементу пула [autoScaleFormula][rest_autoscaleformula] (REST API пакетной службы) или свойству [CloudPool.AutoScaleFormula][net_cloudpool_autoscaleformula] (.NET пакетной службы). При назначении пулу формулы пакетная служба с ее помощью определяет целевое количество вычислительных узлов в пуле для следующего интервала обработки (подробнее об интервалах см. ниже). Размер строки формулы не может превышать 8 КБ, а сама строка может содержать до 100 инструкций, разделенных точкой с запятой, а также разрывы строк и комментарии.

Вы можете представить, что формулы автоматического масштабирования — это язык автомасштабирования пакетной службы. Инструкции в формуле представляют собой выражения свободной формы, которые могут включать служебные (определяемые службой пакетной обработки) и пользовательские переменные (определяемые пользователем). С этими переменными могут выполняться различные операции с помощью встроенных типов, операторов и функций. Например, инструкция может принимать следующую форму:

```
$myNewVariable = function($ServiceDefinedVariable, $myCustomVariable);
```

Обычно формулы содержат несколько инструкций, выполняющих операции со значениями, полученными в предыдущих инструкциях. Например, сначала получим значение для `variable1`, а затем передадим его функции для заполнения `variable2`:

```
$variable1 = function1($ServiceDefinedVariable);
$variable2 = function2($OtherServiceDefinedVariable, $variable1);
```

Ваша цель — с помощью инструкций в формуле выяснить количество вычислительных узлов, до которого следует изменить масштаб пула, т. е. **целевое** количество **выделенных узлов**. Это количество может быть меньше или больше текущего количества узлов в пуле или быть равным ему. Пакетная служба вычисляет формулу автомасштабирования пула с указанным интервалом ([интервалы автоматического масштабирования](#automatic-scaling-interval) описаны ниже). Затем она изменит целевое количество узлов в пуле на количество, полученное из формулы автоматического масштабирования на момент оценки.

Например, эта формула автоматического масштабирования из двух строк указывает, что количество узлов должно изменяться в соответствии с количеством активных задач, максимальное количество вычислительных узлов равно 10:

```
$averageActiveTaskCount = avg($ActiveTasks.GetSample(TimeInterval_Minute * 15));
$TargetDedicated = min(10, $averageActiveTaskCount);
```

В нескольких следующих разделах статьи рассматриваются различные сущности, которые входят в формулы автоматического масштабирования, включая переменные, операторы, операции и функции. Вы узнаете, как получить различные вычислительные ресурсы и задачи метрики в пакетной службе. Эти показатели можно использовать для интеллектуальной корректировки количества узлов пула на основе использования ресурсов и состояния задач. Затем вы научитесь составлять формулы и включать автоматическое масштабирование в пуле с помощью пакета API-интерфейсов пакетной службы REST и .NET. В завершение мы рассмотрим несколько примеров формул.

> [!IMPORTANT]
> Каждая учетная запись пакетной службы Azure имеет ограничение на максимальное количество ядер (соответственно и вычислительных узлов), которые могут использоваться для обработки. Пакетная служба будет создавать узлы только до достижения этого предельного количества ядер. Поэтому она может не достичь целевого количества вычислительных узлов, определяемого формулой. Сведения о просмотре и увеличении квот для учетной записи приведены в статье [Квоты и ограничения пакетной службы Azure](batch-quota-limit.md) .
> 
> 

## <a name="variables"></a>Переменные
В формуле автоматического масштабирования можно использовать как **служебные**, так и **пользовательские** переменные. Служебные переменные встроены в пакетную службу. Некоторые из них доступны для чтения и записи, а некоторые — только для чтения. Пользовательские переменные — это переменные, которые определяете *вы*. В приведенном выше примере формулы из двух строк `$TargetDedicated` — служебная переменная , а `$averageActiveTaskCount` — пользовательская переменная.

В таблицах ниже показаны переменные для чтения и записи, а также только для чтения, определенные пакетной службой.

Вы можете **получить** и **установить** значения этих служебных переменных для управления количеством вычислительных узлов в пуле.

| Определяемые службой переменные для чтения и записи | Описание |
| --- | --- |
| $TargetDedicated |**Целевое** количество **выделенных вычислительных узлов** для пула. Это количество вычислительных узлов, до которого нужно масштабировать пул. Это целевое количество, так как оно может остаться недостижимым для пула. Это может произойти, если целевое количество узлов снова изменилось после очередного вычисления формулы автоматического масштабирования перед тем, как пул достиг первоначального целевого количества. Это также может произойти, если до достижения целевого количества узлов была достигнута квота узла учетной записи пакетной службы или основная квота. |
| $NodeDeallocationOption |Действие, выполняемое после удаления вычислительных узлов из пула. Возможные значения:<ul><li>**requeue** — немедленное завершение задач с перемещением в очередь заданий, чтобы запланировать их выполнение заново;<li>**terminate** — немедленное завершение задач с удалением из очереди заданий;<li>**taskcompletion** — ожидание завершения выполнения текущих задач с удалением узла из пула;<li>**retaineddata** — ожидание очистки всех сохраненных в узле данных локальных задач перед удалением узла из пула.</ul> |

Можно **получить** значения этих определяемых службой переменных, чтобы вносить изменения с учетом метрик из пакетной службы.

| Определяемые службой переменные только для чтения | Описание |
| --- | --- |
| $CPUPercent |Средний объем использования ЦП в процентах. |
| $WallClockSeconds |Затраченное время в секундах. |
| $MemoryBytes |Среднее количество используемых мегабайт. |
| $DiskBytes |Среднее количество гигабайт, используемых на локальных дисках. |
| $DiskReadBytes |Количество считанных байт. |
| $DiskWriteBytes |Количество записанных байт. |
| $DiskReadOps |Количество операций чтения с диска. |
| $DiskWriteOps |Количество операций записи на диск. |
| $NetworkInBytes |Количество входящих байт. |
| $NetworkOutBytes |Количество исходящих байт. |
| $SampleNodeCount |Количество вычислительных узлов. |
| $ActiveTasks |Количество задач в активном состоянии. |
| $RunningTasks |Количество задач в состоянии выполнения. |
| $PendingTasks |Сумма $ActiveTasks и $RunningTasks. |
| $SucceededTasks |Количество успешно выполненных задач. |
| $FailedTasks |Количество задач, которые не удалось выполнить. |
| $CurrentDedicated |Текущее количество выделенных вычислительных узлов. |

> [!TIP]
> Приведенные выше определяемые службой переменные только для чтения — это *объекты*, предоставляющие различные методы доступа к данным, связанным с каждым объектом. Дополнительные сведения см. в разделе [Получение выборки данных](#getsampledata) ниже.
> 
> 

## <a name="types"></a>Типы
В формуле поддерживаются следующие **типы** :

* double
* doubleVec
* doubleVecList
* string
* timestamp. timestamp является комплексной структурой, которая содержит следующие элементы:
  
  * year
  * month (1-12)
  * day (1-31)
  * weekday (в формате числа, например 1 — понедельник);
  * hour (час в 24-часовом формате, например 13 соответствует 13:00);
  * minute (00–59)
  * second (00–59)
* timeInterval
  
  * TimeInterval_Zero
  * TimeInterval_100ns
  * TimeInterval_Microsecond
  * TimeInterval_Millisecond
  * TimeInterval_Second
  * TimeInterval_Minute
  * TimeInterval_Hour
  * TimeInterval_Day
  * TimeInterval_Week
  * TimeInterval_Year

## <a name="operations"></a>Операции
Для перечисленных выше типов разрешены следующие **операции** .

| Операция | Поддерживаемые операторы | Тип результата |
| --- | --- | --- |
| double *оператор* double |+, -, *, / |double |
| double *оператор* timeinterval |* |timeInterval |
| doubleVec *оператор* double |+, -, *, / |doubleVec |
| doubleVec *оператор* doubleVec |+, -, *, / |doubleVec |
| timeinterval *оператор* double |*, / |timeInterval |
| timeinterval *оператор* timeinterval |+, - |timeInterval |
| timeinterval *оператор* timestamp |+ |timestamp |
| timestamp *оператор* timeinterval |+ |timestamp |
| timestamp *оператор* timestamp |- |timeInterval |
| *оператор*double |-, ! |double |
| *оператор*timeInterval |- |timeInterval |
| double *оператор* double |<, <=, ==, >=, >, != |double |
| string *оператор* string |<, <=, ==, >=, >, != |double |
| timestamp *оператор* timestamp |<, <=, ==, >=, >, != |double |
| timeinterval *оператор* timeinterval |<, <=, ==, >=, >, != |double |
| double *оператор* double |&&, &#124;&#124; |double |

При тестировании double с тернарным оператором (`double ? statement1 : statement2`) ненулевое значение равно **true**, а нулевое — **false**.

## <a name="functions"></a>Функции
Для определения формулы автомасштабирования доступны следующие предопределенные **функции** .

| Функция | Тип возвращаемого значения | Описание |
| --- | --- | --- |
| avg(doubleVecList) |double |Среднее значение для всех значений в doubleVecList. |
| len(doubleVecList) |double |Возвращает длину вектора, созданного из doubleVecList. |
| lg(double) |double |Возвращает логарифм double по основанию 2. |
| lg(doubleVecList) |doubleVec |Возвращает покомпонентный логарифм double по основанию 2. В качестве параметра необходимо явно передать vec(double). В противном случае предполагается использование версии lg(double). |
| ln(double) |double |Возвращает натуральный логарифм double. |
| ln(doubleVecList) |doubleVec |Возвращает покомпонентный логарифм double по основанию 2. В качестве параметра необходимо явно передать vec(double). В противном случае предполагается использование версии lg(double). |
| log(double) |double |Возвращает логарифм double по основанию 10. |
| log(doubleVecList) |doubleVec |Возвращает покомпонентный логарифм double по основанию 10. Для единственного параметра double необходимо явно передать vec(double). В противном случае предполагается использование версии log(double). |
| max(doubleVecList) |double |Возвращает максимальное значение в doubleVecList. |
| min(doubleVecList) |double |Возвращает минимальное значение в doubleVecList. |
| norm(doubleVecList) |double |Возвращает&2;-норму вектора, созданного из doubleVecList. |
| percentile(doubleVec v, double p) |double |Возвращает элемент процентиля вектора v. |
| rand() |double |Возвращает случайное значение от 0,0 до 1,0. |
| range(doubleVecList) |double |Возвращает разницу между минимальным и максимальным значениями в doubleVecList. |
| std(doubleVecList) |double |Возвращает среднеквадратичное отклонение выборки для значений в doubleVecList. |
| stop() | |Останавливает вычисление выражения автоматического масштабирования. |
| sum(doubleVecList) |double |Возвращает сумму всех компонентов doubleVecList. |
| time(string dateTime="") |Timestamp |Возвращает отметку времени для текущего времени, если параметр не передан, и отметку времени для строки dateTime, если параметр передан. Поддерживаемые форматы даты и времени: W3C-DTF и RFC 1123. |
| val(doubleVec v, double i) |double |Возвращает значение элемента с индексом i в векторе v с начальным индексом 0. |

Некоторые функции, описанные в таблице выше, могут принимать список в качестве аргумента. Список значений, разделенных запятыми, — это любая комбинация типов *double* и *doubleVec*. Например:

`doubleVecList := ( (double | doubleVec)+(, (double | doubleVec) )* )?`

Значение *doubleVecList* перед оценкой преобразуется в один тип *doubleVec*. Например, если `v = [1,2,3]`, то вызов `avg(v)` эквивалентен вызову `avg(1,2,3)`. Вызов `avg(v, 7)` эквивалентен вызову `avg(1,2,3,7)`.

## <a name="getsampledata"></a>Получение выборки данных
Формулы автоматического масштабирования работают с данными метрик (выборками), предоставленными пакетной службой. Формула увеличивает или уменьшает размер пула на основе значений, полученных от службы. Описанные выше служебные переменные только для чтения — это объекты, предоставляющие разные методы доступа к данным, связанным с объектом. Например, следующее выражение иллюстрирует запрос для получения данных об использовании ЦП за последние пять минут.

```
$CPUPercent.GetSample(TimeInterval_Minute * 5)
```

| Метод | Описание |
| --- | --- |
| GetSample() |Метод `GetSample()` возвращает вектор выборок данных.<br/><br/>Выборка — это данные метрики за 30 секунд. Другими словами, выборки делаются каждые 30 секунд. Но, как описано ниже, существует задержка между получением выборки и моментом, когда выборка станет доступна формуле. Таким образом, не все выборки за заданный период времени могут быть доступны для оценки формулой.<ul><li>`doubleVec GetSample(double count)`<br/>Указывает нужное количество выборок из числа самых свежих.<br/><br/>`GetSample(1)` возвращает последнюю доступную выборку. Этот метод не следует использовать для таких метрик, как `$CPUPercent`, так как нет возможности узнать, *когда* была получена эта выборка. Она может оказаться свежей, но может и устареть, если в системе возникли проблемы. Для таких параметров лучше использовать интервалы, как показано ниже.<li>`doubleVec GetSample((timestamp or timeinterval) startTime [, double samplePercent])`<br/>Задает интервал времени для данных выборки. Также можно указать долю выборок, которые должны быть доступны в течение запрошенного интервала времени.<br/><br/>`$CPUPercent.GetSample(TimeInterval_Minute * 10)` вернет 20 выборок, если в журнале CPUPercent присутствуют все выборки за последние десять минут. Но если данные за последнюю минуту еще недоступны, этот метод вернет только 18 выборок. В данном случае:<br/><br/>Метод `$CPUPercent.GetSample(TimeInterval_Minute * 10, 95)` завершится сбоем, так как доступно только 90 процентов выборок.<br/><br/>Метод `$CPUPercent.GetSample(TimeInterval_Minute * 10, 80)` будет выполнен успешно.<li>`doubleVec GetSample((timestamp or timeinterval) startTime, (timestamp or timeinterval) endTime [, double samplePercent])`<br/>Задает интервал времени для сбора данных, т. е. начало и конец сбора.<br/><br/>Как упоминалось выше, полученный образец становится доступным для формулы с задержкой. Это необходимо учитывать при использовании метода `GetSample` . Ознакомьтесь с `GetSamplePercent` ниже. |
| GetSamplePeriod() |Возвращает период выборок, которые были получены в историческом наборе данных выборок. |
| Count() |Возвращает общее количество выборок в журнале метрик. |
| HistoryBeginTime() |Возвращает метку времени самой старой доступной выборки данных метрики. |
| GetSamplePercent() |Возвращает процент выборок, которые доступны для заданного интервала времени. Например:<br/><br/>`doubleVec GetSamplePercent( (timestamp or timeinterval) startTime [, (timestamp or timeinterval) endTime] )`<br/><br/>Так как метод `GetSample` завершается сбоем, то если процент возвращаемых выборок меньше указанного в параметре `samplePercent`, можно сначала воспользоваться методом `GetSamplePercent` для проверки. Затем при недостаточном количестве выборок можно выполнить другое действие без прерывания оценки автоматического масштабирования. |

### <a name="samples-sample-percentage-and-the-getsample-method"></a>Выборки, процент выборок и метод *GetSample()*
Основной операцией формулы автоматического масштабирования является получение данных метрик для задач и ресурсов и изменение размера пула на основе этих данных. Поэтому важно иметь четкое представление о том, как формулы автоматического масштабирования взаимодействуют с данными метрик (выборками).

**Примеры**

Пакетная служба периодически принимает *выборки* метрик задач и ресурсов, делая их доступными для формул автомасштабирования. Эти выборки записываются пакетной службой каждые 30 секунд. Однако обычно это происходит с небольшой задержкой, которая приводит к временному зазору между временем записи этих выборок и временем, когда формулы автоматического масштабирования получают к ним доступ (и могут прочесть их). Кроме того, по тем или иным причинам (включая проблемы с сетью или другие проблемы инфраструктуры) для некоторых интервалов выборки могут не записаться. В результате возникают выборки с "неполными" данными.

**Процент выборок**

При передаче `samplePercent` в метод `GetSample()` или при вызове метода `GetSamplePercent()` знак процента означает сравнение общего *возможного* количества выборок, записанных пакетной службой, и количества выборок, которые фактически *доступны* для формулы автомасштабирования.

Для примера рассмотрим промежуток времени в 10 минут. Поскольку выборки записываются каждые 30 секунд, максимальное общее количество выборок, записанных пакетной службой в течение 10 минут, должно равняться 20 (по 2 в минуту). Однако из-за задержек, присущих механизму отчетности, или других проблем в инфраструктуре Azure возможна ситуация, когда только 15 выборок будут доступны для формулы автоматического масштабирования. Это означает, что за этот 10-минутный период для формулы фактически доступно только **75 %** от общего количества записанных выборок.

**Метод GetSample() и диапазоны выборок**

Формулы автоматического масштабирования будут увеличивать и уменьшать размер пулов, добавляя или удаляя узлы. Поскольку узлы стоят денег, нужно гарантировать, что формулы используют метод интеллектуального анализа, который основан на достаточном объеме данных. Поэтому в формулах рекомендуется использовать анализ тенденций. С таким анализом пулы будут увеличиваться и уменьшаться на основе *диапазона* собранных выборок.

Чтобы сделать это, используйте метод `GetSample(interval look-back start, interval look-back end)` для возврата **вектора** выборок.

```
$runningTasksSample = $RunningTasks.GetSample(1 * TimeInterval_Minute, 6 * TimeInterval_Minute);
```

Когда пакетная служба вычисляет приведенную выше строку, она возвращает диапазон выборок в виде вектора значений. Например:

```
$runningTasksSample=[1,1,1,1,1,1,1,1,1,1];
```

Собрав вектор выборок, можно использовать функции, например `min()`, `max()` и `avg()`, чтобы извлечь из собранного диапазона информативные значения.

Для повышения безопасности можно настроить *сбой* вычисления формулы в случае, если процент выборок за определенный период окажется меньше заданного значения. Если при принудительном сбое вычисления формулы заданный процент выборок недоступен, пакетная служба прекращает оценивать формулу, а размер пула не изменяется. Чтобы указать необходимый процент выборок для успешного вычисления, укажите его как третий параметр в методе `GetSample()`. Здесь указано, что обязательный процент выборок равен 75 %:

```
$runningTasksSample = $RunningTasks.GetSample(60 * TimeInterval_Second, 120 * TimeInterval_Second, 75);
```

Кроме того, из-за упомянутой ранее задержки доступности выборок всегда необходимо указывать диапазон времени с временем начала на одну минуту раньше. Это объясняется тем, что передача выборок через систему занимает около минуты, поэтому примеры в диапазоне `(0 * TimeInterval_Second, 60 * TimeInterval_Second)` часто недоступны. Опять же, можно использовать параметр процента `GetSample()` для принудительного требования определенного процента выборок.

> [!IMPORTANT]
> **Настоятельно рекомендуем** **не полагаться*только* на метод `GetSample(1)` в формулах автомасштабирования**. Это объясняется тем, что метод `GetSample(1)` фактически запрашивает у пакетной службы последнюю доступную выборку независимо от того, как давно она была получена. Поскольку это только одна выборка, которая к тому же может быть устаревшей, она может не давать общее представление о последнем состоянии задачи или ресурса. Если метод `GetSample(1)`все же используется, убедитесь, что он является частью большей инструкции, а не единственной точкой данных, от которой зависит ваша формула.
> 
> 

## <a name="metrics"></a>Метрики
При определении формулы можно использовать метрики **ресурсов** и **задач**. Целевое количество выделенных узлов в пуле определяется на основе данных метрики, которые были получены и оценены. Дополнительные сведения о каждой метрике см. в разделе [Переменные](#variables) выше.

<table>
  <tr>
    <th>Метрика</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td><b>Ресурс</b></td>
    <td><p><b>Метрики ресурсов</b> основаны на использовании ресурсов ЦП, памяти и пропускной способности вычислительных узлов, а также количестве узлов.</p>
        <p> Для внесения изменений с учетом количества узлов используются следующие служебные переменные:</p>
    <p><ul>
      <li>$TargetDedicated</li>
            <li>$CurrentDedicated</li>
            <li>$SampleNodeCount</li>
    </ul></p>
    <p>Для внесения изменений с учетом потребляемых ресурсов используются следующие служебные переменные:</p>
    <p><ul>
      <li>$CPUPercent</li>
      <li>$WallClockSeconds</li>
      <li>$MemoryBytes</li>
      <li>$DiskBytes</li>
      <li>$DiskReadBytes</li>
      <li>$DiskWriteBytes</li>
      <li>$DiskReadOps</li>
      <li>$DiskWriteOps</li>
      <li>$NetworkInBytes</li>
      <li>$NetworkOutBytes</li></ul></p>
  </tr>
  <tr>
    <td><b>Задача.</b></td>
    <td><p><b>Метрики задач</b> основаны на состоянии задач (активные, ожидающие и завершенные). Для внесения изменений в размер пула с учетом метрик задач используются следующие служебные переменные:</p>
    <p><ul>
      <li>$ActiveTasks</li>
      <li>$RunningTasks</li>
      <li>$PendingTasks</li>
      <li>$SucceededTasks</li>
            <li>$FailedTasks</li></ul></p>
        </td>
  </tr>
</table>

## <a name="write-an-autoscale-formula"></a>Написание формулы автомасштабирования
Формула автомасштабирования создается путем формирования инструкций с помощью указанных выше компонентов и объединения этих инструкций в полную формулу. В этом разделе мы создадим пример формулы автомасштабирования, с помощью которой можно выполнять некоторые задачи масштабирования из реальной жизни.

Сначала определим требования к новой формуле автомасштабирования. Формула должна выполнять следующее:

1. **Увеличивать** целевое количество вычислительных узлов в пуле при высокой загрузке ЦП.
2. **Уменьшать** целевое количество вычислительных узлов в пуле при низкой загрузке ЦП.
3. Всегда ограничивать **максимальное** количество узлов до 400.

Может потребоваться *увеличить* количество узлов в периоды высокой загрузки ЦП. Для этого необходимо определить инструкцию, которая присваивает пользовательской переменной `$totalNodes` значение, равное 110 % от текущего целевого количества узлов, если минимальное среднее использование ЦП за последние 10 минут превышало 70 %. В противном случае будет использоваться текущее выделенное значение.

```
$totalNodes =
    (min($CPUPercent.GetSample(TimeInterval_Minute * 10)) > 0.7) ?
    ($CurrentDedicated * 1.1) : $CurrentDedicated;
```

Чтобы `$totalNodes`уменьшить*количество узлов в периоды низкой загрузки ЦП, следующая инструкция задает той же переменной* значение 90 % от текущего целевого количества узлов, если среднее использование ЦП за последние 60 минут было ниже 20 %. В противном случае будет использоваться текущее значение переменной `$totalNodes`, заполненное в приведенной выше инструкции.

```
$totalNodes =
    (avg($CPUPercent.GetSample(TimeInterval_Minute * 60)) < 0.2) ?
    ($CurrentDedicated * 0.9) : $totalNodes;
```

Теперь мы ограничим целевое количество выделенных вычислительных узлов **максимальным значением** 400:

```
$TargetDedicated = min(400, $totalNodes)
```

Вот полная формула:

```
$totalNodes =
    (min($CPUPercent.GetSample(TimeInterval_Minute * 10)) > 0.7) ?
    ($CurrentDedicated * 1.1) : $CurrentDedicated;
$totalNodes =
    (avg($CPUPercent.GetSample(TimeInterval_Minute * 60)) < 0.2) ?
    ($CurrentDedicated * 0.9) : $totalNodes;
$TargetDedicated = min(400, $totalNodes)
```

## <a name="create-an-autoscale-enabled-pool"></a>Создание пула с поддержкой автомасштабирования
Для создания пула с поддержкой автомасштабирования можно воспользоваться одним из следующих методов.

**Пакетная служба (.NET)**

1. Создайте пул с помощью метода [BatchClient.PoolOperations.CreatePool](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.createpool.aspx).
2. Задайте для свойства [CloudPool.AutoScaleEnabled](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleenabled.aspx) значение `true`.
3. Задайте свойство [CloudPool.AutoScaleFormula](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleformula.aspx) с помощью формулы автомасштабирования.
4. (Необязательно.) Задайте свойство [CloudPool.AutoScaleEvaluationInterval](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoScaleevaluationinterval.aspx) (значение по умолчанию — 15 минут).
5. Зафиксируйте пул с помощью метода [CloudPool.Commit](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.commit.aspx) или [CommitAsync](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.commitasync.aspx).

**REST API пакетной службы**

* [Добавьте пул в учетную запись.](https://msdn.microsoft.com/library/azure/dn820174.aspx) Укажите элементы `enableAutoScale` и `autoScaleFormula` в запросе REST API, чтобы настроить автомасштабирование для пула при его создании.

В следующем фрагменте кода создается пул с поддержкой автомасштабирования с помощью библиотеки [.NET пакетной службы][net_api]. Формула автомасштабирования пула устанавливает целевое количество узлов в 5 по понедельникам и в 1 в остальные дни недели. [Интервал автомасштабирования](#automatic-scaling-interval) составляет 30 минут. В этом и других фрагментах кода C#, приведенных в этой статье, myBatchClient представляет собой правильно инициализированный экземпляр [BatchClient][net_batchclient].

```csharp
CloudPool pool = myBatchClient.PoolOperations.CreatePool("mypool", "3", "small");
pool.AutoScaleEnabled = true;
pool.AutoScaleFormula = "$TargetDedicated = (time().weekday == 1 ? 5:1);";
pool.AutoScaleEvaluationInterval = TimeSpan.FromMinutes(30);
pool.Commit();
```

Кроме REST API пакетной службы и пакета SDK для .NET, для работы с автомасштабированием можно использовать любые другие [пакеты SDK пакетной службы](batch-apis-tools.md#batch-development-apis), [командлеты PowerShell пакетной службы](batch-powershell-cmdlets-get-started.md) и [интерфейс командной строки пакетной службы](batch-cli-get-started.md).

> [!IMPORTANT]
> При создании пула с поддержкой автомасштабирования **не** нужно указывать параметр `targetDedicated`. Кроме того, если вы хотите вручную изменить размер пула с включенным автомасштабированием (например, с помощью [BatchClient.PoolOperations.ResizePool][net_poolops_resizepool]), то вам необходимо сначала **отключить** автомасштабирование пула, а затем изменить его размер.
> 
> 

### <a name="automatic-scaling-interval"></a>Интервал автоматического масштабирования
По умолчанию пакетная служба изменяет размер пула по указанной формуле автомасштабирования каждые **15 минут**. Однако этот интервал можно настроить с помощью следующих свойств пула:

* [CloudPool.AutoScaleEvaluationInterval][net_cloudpool_autoscaleevalinterval] (.NET пакетной службы)
* [autoScaleEvaluationInterval][rest_autoscaleinterval] (REST API)

Минимальный интервал составляет пять минут, а максимальный — 168 часов. Если указан интервал за пределами этого диапазона, пакетная служба возвращает ошибку "Неправильный запрос (400)".

> [!NOTE]
> В настоящее время автоматическое масштабирование предназначено не для реагирования на изменения в течение нескольких секунд, а для постепенного изменения размера пула в ходе выполнения рабочей нагрузки.
> 
> 

## <a name="enable-autoscaling-on-an-existing-pool"></a>Включение автомасштабирования в имеющемся пуле
Если вы уже создали пул с заданным количеством вычислительных узлов, используя параметр *targetDedicated*, по-прежнему можно включить автоматическое масштабирование в пуле. Каждый пакет SDK пакетной службы предоставляет операцию включения автомасштабирования, например:

* [BatchClient.PoolOperations.EnableAutoScale][net_enableautoscale] (.NET пакетной службы)
* [Включение автомасштабирования пула][rest_enableautoscale] (REST API)

При включении автомасштабирования в имеющемся пуле применяются следующие условия:

* Если автомасштабирование в пуле **отключено** при выполнении запроса на включение автомасштабирования, *необходимо* указать допустимую формулу автомасштабирования. *При необходимости* можно указать интервал оценки автомасштабирования. Если интервал не указан, используется значение по умолчанию, равное 15 минутам.
* Если в пуле **включено** автомасштабирование, можно указать формулу автомасштабирования или интервал оценки, либо и то, и другое. Необходимо указать по крайней мере одно из этих свойств.
  
  * Если указать новый интервал оценки автомасштабирования, имеющееся расписание оценки будет остановлено и запустится новое. Время начала нового расписания — это время подачи запроса на включение автомасштабирования.
  * Если опустить формулу автомасштабирования или интервал оценки, в пакетной службе и далее будет использоваться текущее значение этого параметра.

> [!NOTE]
> Если во время создания пула было указано значение параметра *targetDedicated* , оно игнорируется во время оценки формулы автоматического масштабирования.
> 
> 

В этом фрагменте кода C# для включения автомасштабирования в имеющемся пуле используется библиотека [.NET пакетной службы][net_api].

```csharp
// Define the autoscaling formula. This formula sets the target number of nodes
// to 5 on Mondays, and 1 on every other day of the week
string myAutoScaleFormula = "$TargetDedicated = (time().weekday == 1 ? 5:1);";

// Set the autoscale formula on the existing pool
myBatchClient.PoolOperations.EnableAutoScale(
    "myexistingpool",
    autoscaleFormula: myAutoScaleFormula);
```

### <a name="update-an-autoscale-formula"></a>Обновление формулы автомасштабирования
Используйте тот же запрос на включение автомасштабирования, чтобы *обновить* формулу в имеющемся пуле с поддержкой автомасштабирования (например, с помощью [EnableAutoScale][net_enableautoscale] в .NET пакетной службы). Специальной операции обновления автомасштабирования не существует. Например, если после выполнения следующего кода автомасштабирование уже включено в myexistingpool, его формула автомасштабирования заменяется содержимым `myNewFormula`.

```csharp
myBatchClient.PoolOperations.EnableAutoScale(
    "myexistingpool",
    autoscaleFormula: myNewFormula);
```

### <a name="update-the-autoscale-interval"></a>Обновление интервала автомасштабирования
Для изменения интервала оценки автомасштабирования имеющегося пула с поддержкой автомасштабирования используется тот же метод [EnableAutoScale][net_enableautoscale], что и при обновлении формулы автомасштабирования. Например, чтобы задать для интервала оценки автомасштабирования значение 60 минут в пуле с уже включенным автомасштабированием, необходимо сделать следующее:

```csharp
myBatchClient.PoolOperations.EnableAutoScale(
    "myexistingpool",
    autoscaleEvaluationInterval: TimeSpan.FromMinutes(60));
```

## <a name="evaluate-an-autoscale-formula"></a>Оценка формулы автомасштабирования
Прежде чем применить формулу к пулу, ее можно оценить. Таким образом можно выполнить тестовый запуск формулы, чтобы увидеть, как ее инструкции выполняют оценку, до запуска формулы в рабочей среде.

Чтобы оценить формулу автомасштабирования, сначала необходимо **включить автоматическое масштабирование** в пуле с помощью **допустимой формулы**. Если в пуле необходимо протестировать формулу, для которой еще не включено автомасштабирование, можно воспользоваться формулой одной строки `$TargetDedicated = 0` при первом включении автомасштабирования. Затем для оценки формулы, которую требуется протестировать, выполните одно из следующих действий:

* Вызовите метод [BatchClient.PoolOperations.EvaluateAutoScale](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.evaluateautoscale.aspx) или [EvaluateAutoScaleAsync](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.evaluateautoscaleasync.aspx).
  
    Для выполнения оценки этим методам .NET пакетной службы требуется идентификатор имеющегося пула и строка, содержащая формулу автомасштабирования. Результаты оценки содержатся в возвращаемом экземпляре [AutoScaleEvaluation](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscaleevaluation.aspx).
* [Оцените формулу автомасштабирования.](https://msdn.microsoft.com/library/azure/dn820183.aspx)
  
    В этом запросе REST API укажите идентификатор пула в универсальном коде ресурса и формулу автомасштабирования в элементе *autoScaleFormula* текста запроса. Ответ операции содержит все сведения об ошибках, которые могут быть связаны с формулой.

В этом фрагменте кода [.NET пакетной службы][net_api] мы оценим формулу перед ее применением к объекту [CloudPool][net_cloudpool]. Если в пуле не включено автомасштабирование, сначала необходимо его включить.

```csharp
// First obtain a reference to an existing pool
CloudPool pool = batchClient.PoolOperations.GetPool("myExistingPool");

// If autoscaling isn't already enabled on the pool, enable it.
// You can't evaluate an autoscale formula on non-autoscale-enabled pool.
if (pool.AutoScaleEnabled == false)
{
    // We need a valid autoscale formula to enable autoscaling on the
    // pool. This formula is valid, but won't resize the pool:
    pool.EnableAutoScale(
        autoscaleFormula: $"$TargetDedicated = {pool.CurrentDedicated};",
        autoscaleEvaluationInterval: TimeSpan.FromMinutes(5));

    // Batch limits EnableAutoScale calls to once every 30 seconds.
    // Because we want to apply our new autoscale formula below if it
    // evaluates successfully, and we *just* enabled autoscaling on
    // this pool, we pause here to ensure we pass that threshold.
    Thread.Sleep(TimeSpan.FromSeconds(31));

    // Refresh the properties of the pool so that we've got the
    // latest value for AutoScaleEnabled
    pool.Refresh();
}

// We must ensure that autoscaling is enabled on the pool prior to
// evaluating a formula
if (pool.AutoScaleEnabled == true)
{
    // The formula to evaluate - adjusts target number of nodes based on
    // day of week and time of day
    string myFormula = @"
        $curTime = time();
        $workHours = $curTime.hour >= 8 && $curTime.hour < 18;
        $isWeekday = $curTime.weekday >= 1 && $curTime.weekday <= 5;
        $isWorkingWeekdayHour = $workHours && $isWeekday;
        $TargetDedicated = $isWorkingWeekdayHour ? 20:10;
    ";

    // Perform the autoscale formula evaluation. Note that this does not
    // actually apply the formula to the pool.
    AutoScaleRun eval =
        batchClient.PoolOperations.EvaluateAutoScale(pool.Id, myFormula);

    if (eval.Error == null)
    {
        // Evaluation success - print the results of the AutoScaleRun.
        // This will display the values of each variable as evaluated by the
        // autoscale formula.
        Console.WriteLine("AutoScaleRun.Results: " +
            eval.Results.Replace("$", "\n    $"));

        // Apply the formula to the pool since it evaluated successfully
        batchClient.PoolOperations.EnableAutoScale(pool.Id, myFormula);
    }
    else
    {
        // Evaluation failed, output the message associated with the error
        Console.WriteLine("AutoScaleRun.Error.Message: " +
            eval.Error.Message);
    }
}
```

В случае успешной оценки формулы в этом фрагменте будет получен результат, подобный приведенному ниже:

```
AutoScaleRun.Results:
    $TargetDedicated=10;
    $NodeDeallocationOption=requeue;
    $curTime=2016-10-13T19:18:47.805Z;
    $isWeekday=1;
    $isWorkingWeekdayHour=0;
    $workHours=0
```

## <a name="get-information-about-autoscale-runs"></a>Получение сведений о выполнениях автомасштабирования
Чтобы убедиться, что формула работает, как ожидалось, мы рекомендуем периодически проверять результаты выполнений автомасштабирования, которые пакетная служба запускает в пуле. Чтобы сделать это, получите (или обновите) ссылку на пул и проверьте свойства последнего выполнения автомасштабирования в этом пуле.

В .NET пакетной службы свойство [CloudPool.AutoScaleRun](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscalerun.aspx) обладает несколькими свойствами, которые предоставляют сведения о последнем выполнении автомасштабирования в пуле пакетной службы.

* [AutoScaleRun.Timestamp.](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscalerun.timestamp.aspx)
* [AutoScaleRun.Results;](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscalerun.results.aspx)
* [AutoScaleRun.Error;](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscalerun.error.aspx)

В REST API запрос [Получение сведений о пуле](https://msdn.microsoft.com/library/dn820165.aspx) возвращает сведения о пуле, в том числе результаты последнего выполнения автомасштабирования в [autoScaleRun](https://msdn.microsoft.com/library/dn820165.aspx#bk_autrun).

В следующем фрагменте кода C# для вывода сведений о последнем выполнении автомасштабирования в пуле myPool используется библиотека .NET пакетной службы:

```csharp
Cloud pool = myBatchClient.PoolOperations.GetPool("myPool");
Console.WriteLine("Last execution: " + pool.AutoScaleRun.Timestamp);
Console.WriteLine("Result:" + pool.AutoScaleRun.Results.Replace("$", "\n  $"));
Console.WriteLine("Error: " + pool.AutoScaleRun.Error);
```

Пример выходных данных в результате выполнения предыдущего фрагмента:

```
Last execution: 10/14/2016 18:36:43
Result:
  $TargetDedicated=10;
  $NodeDeallocationOption=requeue;
  $curTime=2016-10-14T18:36:43.282Z;
  $isWeekday=1;
  $isWorkingWeekdayHour=0;
  $workHours=0
Error:
```

## <a name="example-autoscale-formulas"></a>Примеры формул автомасштабирования
Давайте рассмотрим некоторые формулы, которые демонстрируют различные способы настройки количества вычислительных ресурсов в пуле.

### <a name="example-1-time-based-adjustment"></a>Пример 1. Изменение с учетом времени
Возможно, вы решили изменить размер пула в зависимости от дня недели и времени дня, чтобы количество узлов в пуле увеличивалось или уменьшалось соответствующим образом.

Эта формула сначала получает значение текущего времени. В рабочие дни (1–5) и часы (8:00–18:00) целевой размер пула равен 20 узлам. В противном случае он равен 10 узлам.

```
$curTime = time();
$workHours = $curTime.hour >= 8 && $curTime.hour < 18;
$isWeekday = $curTime.weekday >= 1 && $curTime.weekday <= 5;
$isWorkingWeekdayHour = $workHours && $isWeekday;
$TargetDedicated = $isWorkingWeekdayHour ? 20:10;
```

### <a name="example-2-task-based-adjustment"></a>Пример 2. Изменение с учетом задачи
В этом примере размер пула настраивается в зависимости от количества задач в очереди. Обратите внимание, что в строках формул допускаются комментарии и разрывы строк.

```csharp
// Get pending tasks for the past 15 minutes.
$samples = $ActiveTasks.GetSamplePercent(TimeInterval_Minute * 15);
// If we have fewer than 70 percent data points, we use the last sample point,
// otherwise we use the maximum of last sample point and the history average.
$tasks = $samples < 70 ? max(0,$ActiveTasks.GetSample(1)) : max( $ActiveTasks.GetSample(1), avg($ActiveTasks.GetSample(TimeInterval_Minute * 15)));
// If number of pending tasks is not 0, set targetVM to pending tasks, otherwise
// half of current dedicated.
$targetVMs = $tasks > 0? $tasks:max(0, $TargetDedicated/2);
// The pool size is capped at 20, if target VM value is more than that, set it
// to 20. This value should be adjusted according to your use case.
$TargetDedicated = max(0, min($targetVMs, 20));
// Set node deallocation mode - keep nodes active only until tasks finish
$NodeDeallocationOption = taskcompletion;
```

### <a name="example-3-accounting-for-parallel-tasks"></a>Пример 3. Параллельные задачи
Вот еще один пример, который изменяет размер пула на основе числа задач. В этой формуле также учитывается значение [MaxTasksPerComputeNode][net_maxtasks], которое было задано для пула. Это особенно полезно, если в пуле поддерживается [параллельное выполнение задач](batch-parallel-node-tasks.md) .

```csharp
// Determine whether 70 percent of the samples have been recorded in the past
// 15 minutes; if not, use last sample
$samples = $ActiveTasks.GetSamplePercent(TimeInterval_Minute * 15);
$tasks = $samples < 70 ? max(0,$ActiveTasks.GetSample(1)) : max( $ActiveTasks.GetSample(1),avg($ActiveTasks.GetSample(TimeInterval_Minute * 15)));
// Set the number of nodes to add to one-fourth the number of active tasks (the
// MaxTasksPerComputeNode property on this pool is set to 4, adjust this number
// for your use case)
$cores = $TargetDedicated * 4;
$extraVMs = (($tasks - $cores) + 3) / 4;
$targetVMs = ($TargetDedicated + $extraVMs);
// Attempt to grow the number of compute nodes to match the number of active
// tasks, with a maximum of 3
$TargetDedicated = max(0,min($targetVMs,3));
// Keep the nodes active until the tasks finish
$NodeDeallocationOption = taskcompletion;
```

### <a name="example-4-setting-an-initial-pool-size"></a>Пример 4. Настройка исходного размера пула
В этом примере показан фрагмент кода C# с помощью формулы автоматического масштабирования, которая задает размер пула в определенное число узлов на начальный период времени. Затем он корректирует размер пула на основе количества запущенных и активных задач по истечению начального периода времени.

Формула в приведенном ниже фрагменте кода выполняет следующие действия.

* Она задает исходный размер пула в&4; узла.
* Не изменяет размер пула в течение первых 10 минут его жизненного цикла.
* После первых 10 минут она получает максимальное количество запущенных и активных задач за последние 60 минут.
  * Если оба значения равны 0 (то есть за 60 минут не было ни активных, ни запущенных задач), то размер пула устанавливается в 0.
  * Если любое из значений больше нуля, изменений не производится.

```csharp
string now = DateTime.UtcNow.ToString("r");
string formula = string.Format(@"
    $TargetDedicated = {1};
    lifespan         = time() - time(""{0}"");
    span             = TimeInterval_Minute * 60;
    startup          = TimeInterval_Minute * 10;
    ratio            = 50;

    $TargetDedicated = (lifespan > startup ? (max($RunningTasks.GetSample(span, ratio), $ActiveTasks.GetSample(span, ratio)) == 0 ? 0 : $TargetDedicated) : {1});
    ", now, 4);
```

## <a name="next-steps"></a>Дальнейшие действия
* [Повышение эффективности вычислительных ресурсов в пакетной службе Azure благодаря параллельному выполнению задач на узлах](batch-parallel-node-tasks.md) содержит сведения о том, как можно одновременно выполнять несколько задач на вычислительных узлах пула. Помимо автоматического масштабирования, эта функция позволяет уменьшить длительность выполнения заданий для некоторых рабочих нагрузок, тем самым обеспечивая сокращение затрат.
* Еще одна возможность повысить эффективность — гарантировать, что приложение пакетной службы отправляет запросы в пакетную службу наиболее оптимальным способом. Из статьи [Эффективные запросы к пакетной службе Azure](batch-efficient-list-queries.md)вы узнаете, как ограничить объем данных, передаваемых по сети при потенциальном запросе состояния тысяч вычислительных узлов или задач.

[net_api]: https://msdn.microsoft.com/library/azure/mt348682.aspx
[net_batchclient]: http://msdn.microsoft.com/library/azure/microsoft.azure.batch.batchclient.aspx
[net_cloudpool]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.aspx
[net_cloudpool_autoscaleformula]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleformula.aspx
[net_cloudpool_autoscaleevalinterval]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleevaluationinterval.aspx
[net_enableautoscale]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.enableautoscale.aspx
[net_maxtasks]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.maxtaskspercomputenode.aspx
[net_poolops_resizepool]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.resizepool.aspx

[rest_api]: https://msdn.microsoft.com/library/azure/dn820158.aspx
[rest_autoscaleformula]: https://msdn.microsoft.com/library/azure/dn820173.aspx
[rest_autoscaleinterval]: https://msdn.microsoft.com/library/azure/dn820173.aspx
[rest_enableautoscale]: https://msdn.microsoft.com/library/azure/dn820173.aspx

