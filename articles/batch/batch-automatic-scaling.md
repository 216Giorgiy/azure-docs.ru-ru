<properties
	pageTitle="Автоматическое масштабирование вычислительных узлов в пуле пакетной службы Azure | Microsoft Azure"
	description="Включение автоматического масштабирования в облачном пуле для динамического изменения количества вычислительных узлов в пуле."
	services="batch"
	documentationCenter=""
	authors="mmacy"
	manager="timlt"
	editor="tysonn"/>

<tags
	ms.service="batch"
	ms.devlang="na"
	ms.topic="article"
	ms.tgt_pltfrm="vm-windows"
	ms.workload="multiple"
	ms.date="09/27/2016"
	ms.author="marsma"/>

# Автоматическое масштабирование вычислительных узлов в пуле пакетной службы Azure

При автоматическом масштабировании пакетная служба Azure может динамически добавлять или удалять вычислительные узлы в пуле в зависимости от определенных вами параметров. Вы можете сэкономить время и деньги благодаря автоматическому изменению объема вычислительной мощности, используемой приложением, т. е. по мере увеличения потребностей в ресурсах для задачи задания узлы будут добавляться, а по мере снижения потребностей — удаляться.

Автоматическое масштабирование можно включить для пула вычислительных узлов путем связывания с этим пулом определенной вами *формулы автоматического масштабирования*, например, с помощью метода [PoolOperations.EnableAutoScale][net_enableautoscale] в библиотеке [.NET пакетной службы](batch-dotnet-get-started.md). Затем пакетная служба использует эту формулу для определения количества вычислительных узлов, необходимого для выполнения рабочей нагрузки. Пакетная служба отвечает на периодически собираемые образцы данных метрик службы и изменяет количество вычислительных узлов в пуле через настраиваемый интервал в соответствии с указанной формулой.

Автоматическое масштабирование можно включить во время создания пула или для существующего пула. Также можно изменить назначенную формулу для пула со включенным автоматическим масштабированием. Пакетная служба позволяет не только вычислять формулы перед их назначением пулам, но и отслеживать состояние автоматического масштабирования.

## Формулы автоматического масштабирования

Формула автоматического масштабирования — это определяемое вами строковое значение, содержащее одну или несколько инструкций. Оно назначается элементу пула [autoScaleFormula][rest_autoscaleformula] (REST API пакетной службы) или свойству [CloudPool.AutoScaleFormula][net_cloudpool_autoscaleformula] (.NET пакетной службы). При назначении пулу формулы пакетная служба с ее помощью определяет целевое количество вычислительных узлов в пуле для следующего интервала обработки (подробнее об интервалах см. ниже). Размер строки формулы не может превышать 8 КБ, а сама строка может содержать до 100 инструкций, разделенных точкой с запятой, а также разрывы строк и комментарии.

Вы можете представить, что формулы автоматического масштабирования — это язык автомасштабирования пакетной службы. Инструкции в формуле представляют собой выражения свободной формы, которые могут включать служебные (определяемые службой пакетной обработки) и пользовательские переменные (определяемые пользователем). С этими переменными могут выполняться различные операции с помощью встроенных типов, операторов и функций. Например, инструкция может принимать следующую форму:

`$myNewVariable = function($ServiceDefinedVariable, $myCustomVariable);`

Обычно формулы содержат несколько инструкций, выполняющих операции со значениями, полученными в предыдущих инструкциях. Например, сначала получим значение для `variable1`, а затем передадим его функции для заполнения `variable2`:

```
$variable1 = function1($ServiceDefinedVariable);
$variable2 = function2($OtherServiceDefinedVariable, $variable1);
```

Ваша цель — с помощью инструкций в формуле выяснить количество вычислительных узлов, до которого следует изменить масштаб пула, т. е. **целевое** количество **выделенных узлов**. Это количество может быть меньше или больше текущего количества узлов в пуле или быть равным ему. Пакетная служба вычисляет формулу автоматического масштабирования пула с указанным интервалом ([интервалы автоматического масштабирования](#automatic-scaling-interval) описаны ниже). Затем она изменит целевое количество узлов в пуле на количество, полученное из формулы автоматического масштабирования на момент оценки.

Например, эта формула автоматического масштабирования из двух строк указывает, что количество узлов должно изменяться в соответствии с количеством активных задач, максимальное количество вычислительных узлов равно 10:

```
$averageActiveTaskCount = avg($ActiveTasks.GetSample(TimeInterval_Minute * 15));
$TargetDedicated = min(10, $averageActiveTaskCount);
```

В нескольких следующих разделах статьи рассматриваются различные сущности, которые входят в формулы автоматического масштабирования, включая переменные, операторы, операции и функции. Вы узнаете, как получить различные вычислительные ресурсы и задачи метрики в пакетной службе. Эти показатели можно использовать для интеллектуальной корректировки количества узлов пула на основе использования ресурсов и состояния задач. Затем вы научитесь составлять формулы и включать автоматическое масштабирование в пуле с помощью пакета API-интерфейсов пакетной службы REST и .NET. В завершение мы рассмотрим несколько примеров формул.

> [AZURE.IMPORTANT] Каждая учетная запись пакетной службы Azure имеет ограничение на максимальное количество ядер (соответственно и вычислительных узлов), которые могут использоваться для обработки. Пакетная служба будет создавать узлы только до достижения этого предельного количества ядер. Поэтому она может не достичь целевого количества вычислительных узлов, определяемого формулой. Сведения о просмотре и увеличении квот для учетной записи приведены в статье [Квоты и ограничения пакетной службы Azure](batch-quota-limit.md).

## Переменные

В формуле автоматического масштабирования можно использовать как **служебные**, так и **пользовательские** переменные. Служебные переменные встроены в пакетную службу. Некоторые из них доступны для чтения и записи, а некоторые — только для чтения. Пользовательские переменные — это переменные, которые определяете *вы*. В приведенном выше примере формулы из двух строк `$TargetDedicated` — служебная переменная , а `$averageActiveTaskCount` — пользовательская переменная.

В таблицах ниже показаны переменные для чтения и записи, а также только для чтения, определенные пакетной службой.

Можно **получить** и **установить** значение этих служебных переменных для управления количеством вычислительных узлов в пуле:

| Определяемые службой переменные для чтения и записи | Описание |
| --- | --- |
| $TargetDedicated | **Целевое** количество **выделенных вычислительных узлов** для пула. Это количество вычислительных узлов, до которого нужно масштабировать пул. Это целевое количество, так как оно может остаться недостижимым для пула. Это может произойти, если целевое количество узлов снова изменилось после очередного вычисления формулы автоматического масштабирования перед тем, как пул достиг первоначального целевого количества. Это также может произойти, если до достижения целевого количества узлов была достигнута квота узла учетной записи пакетной службы или основная квота. |
| $NodeDeallocationOption | Действие, выполняемое после удаления вычислительных узлов из пула. Возможные значения:<ul><li>**requeue**: немедленно прекращает задачи и помещает их обратно в очередь задания для повторного планирования.<li>**terminate**: немедленно прекращает задачи и удаляет их из очереди задания.<li>**taskcompletion**: ожидает завершения запущенных задач, а затем удаляет узел из пула.<li>**retaineddata**: ожидает очистки всех данных, сохраненных на узле локальными задачами, перед удалением узла из пула.</ul> |

Можно **получить** значения этих определяемых службой переменных, чтобы вносить изменения с учетом метрик из пакетной службы.

| Определяемые службой переменные только для чтения | Описание |
| --- | --- |
| $CPUPercent | Средний объем использования ЦП в процентах. |
| $WallClockSeconds | Затраченное время в секундах. |
| $MemoryBytes | Среднее количество используемых мегабайт. |
| $DiskBytes | Среднее количество гигабайт, используемых на локальных дисках. |
| $DiskReadBytes | Количество считанных байт. |
| $DiskWriteBytes | Количество записанных байт. |
| $DiskReadOps | Количество операций чтения с диска. |
| $DiskWriteOps | Количество операций записи на диск. |
| $NetworkInBytes | Количество входящих байт. |
| $NetworkOutBytes | Количество исходящих байт. |
| $SampleNodeCount | Количество вычислительных узлов. |
| $ActiveTasks | Количество задач в активном состоянии. |
| $RunningTasks | Количество задач в состоянии выполнения. |
| $PendingTasks | Сумма $ActiveTasks и $RunningTasks. |
| $SucceededTasks | Количество успешно выполненных задач. |
| $FailedTasks | Количество задач, которые не удалось выполнить. |
| $CurrentDedicated | Текущее количество выделенных вычислительных узлов. |

> [AZURE.TIP] Приведенные выше определяемые службой переменные только для чтения — это *объекты*, предоставляющие различные методы доступа к данным, связанным с каждым объектом. Дополнительные сведения см. в разделе [Получение выборки данных](#getsampledata) ниже.

## Типы

В формуле поддерживаются следующие **типы**:

- double
- doubleVec
- doubleVecList
- string
- timestamp. timestamp является комплексной структурой, которая содержит следующие элементы:

	- year
	- month (1-12)
	- day (1-31)
	- weekday (в формате числа, например 1 — понедельник);
	- hour (час в 24-часовом формате, например 13 соответствует 13:00);
	- minute (00–59)
	- second (00–59)
- timeInterval

	- TimeInterval\_Zero
	- TimeInterval\_100ns
	- TimeInterval\_Microsecond
	- TimeInterval\_Millisecond
	- TimeInterval\_Second
	- TimeInterval\_Minute
	- TimeInterval\_Hour
	- TimeInterval\_Day
	- TimeInterval\_Week
	- TimeInterval\_Year

## Операции

Для перечисленных выше типов разрешены следующие **операции**.

| Операция | Поддерживаемые операторы | Тип результата |
| ------------------------------------- | --------------------- | ------------- |
| double *оператор* double | +, -, *, / | double |
| double *оператор* timeinterval | * | timeInterval |
| doubleVec *оператор* double | +, -, *, / | doubleVec |
| doubleVec *оператор* doubleVec | +, -, *, / | doubleVec |
| timeinterval *оператор* double | *, / | timeInterval |
| timeinterval *оператор* timeinterval | +, - | timeInterval |
| timeinterval *оператор* timestamp | + | Timestamp |
| timestamp *оператор* timeinterval | + | Timestamp |
| timestamp *оператор* timestamp | — | timeinterval | | *оператор*double | -, ! | double | | *оператор*timeinterval | — | timeinterval | | double *оператор* double | <, <=, ==, >=, >, != | double | | string *оператор* string | <, <=, ==, >=, >, != | double | | timestamp *оператор* timestamp | <, <=, ==, >=, >, != | double | | timeinterval *оператор* timeinterval | <, <=, ==, >=, >, != | double | | double *оператор* double | &&, || | double |

При тестировании double с тернарным оператором (`double ? statement1 : statement2`) ненулевое значение равно **true**, а нулевое — **false**.

## Functions

Для определения формулы автомасштабирования доступны следующие предопределенные **функции**.

| Функция | Тип возвращаемого значения | Описание
| --------------------------------- | ------------- | --------- |
| avg(doubleVecList) | double | Среднее значение для всех значений в doubleVecList.
| len(doubleVecList) | double | Возвращает длину вектора, созданного из doubleVecList.
| lg(double) | double | Возвращает логарифм double по основанию 2.
| lg(doubleVecList) | doubleVec | Возвращает покомпонентный логарифм double по основанию 2. В качестве параметра необходимо явно передать vec(double). В противном случае предполагается использование версии lg(double).
| ln(double) | double | Возвращает натуральный логарифм double.
| ln(doubleVecList) | doubleVec | Возвращает покомпонентный логарифм double по основанию 2. В качестве параметра необходимо явно передать vec(double). В противном случае предполагается использование версии lg(double).
| log(double) | double | Возвращает логарифм double по основанию 10.
| log(doubleVecList) | doubleVec | Возвращает покомпонентный логарифм double по основанию 10. Для единственного параметра double необходимо явно передать vec(double). В противном случае предполагается использование версии log(double).
| max(doubleVecList) | double | Возвращает максимальное значение в doubleVecList.
| min(doubleVecList) | double | Возвращает минимальное значение в doubleVecList.
| norm(doubleVecList) | double | Возвращает 2-норму вектора, созданного из doubleVecList.
| percentile(doubleVec v, double p) | double | Возвращает элемент процентиля вектора v.
| rand() | double | Возвращает случайное значение от 0,0 до 1,0.
| range(doubleVecList) | double | Возвращает разницу между минимальным и максимальным значениями в doubleVecList.
| std(doubleVecList) | double | Возвращает среднеквадратичное отклонение выборки для значений в doubleVecList.
| stop() | | Останавливает вычисление выражения автоматического масштабирования.
| sum(doubleVecList) | double | Возвращает сумму всех компонентов doubleVecList.
| time(string dateTime="") | Timestamp | Возвращает отметку времени для текущего времени, если параметр не передан, и отметку времени для строки dateTime, если параметр передан. Поддерживаемые форматы даты и времени: W3C-DTF и RFC 1123.
| val(doubleVec v, double i) | double | Возвращает значение элемента с индексом i в векторе v с начальным индексом 0.

Некоторые функции, описанные в таблице выше, могут принимать список в качестве аргумента. Список значений, разделенных запятыми, — это любая комбинация типов *double* и *doubleVec*. Например:

`doubleVecList := ( (double | doubleVec)+(, (double | doubleVec) )* )?`

Значение *doubleVecList* перед оценкой преобразуется в один тип *doubleVec*. Например, если `v = [1,2,3]`, то вызов `avg(v)` эквивалентен вызову `avg(1,2,3)`. Вызов `avg(v, 7)` эквивалентен вызову `avg(1,2,3,7)`.

## <a name="getsampledata"></a>Получение выборки данных

Формулы автоматического масштабирования работают с данными метрик (выборками), предоставленными пакетной службой. Формула увеличивает или уменьшает размер пула на основе значений, полученных от службы. Описанные выше служебные переменные только для чтения — это объекты, предоставляющие разные методы доступа к данным, связанным с объектом. Например, следующее выражение иллюстрирует запрос для получения данных об использовании ЦП за последние пять минут.

`$CPUPercent.GetSample(TimeInterval_Minute * 5)`

| Метод | Описание |
| --- | --- |
| GetSample() | Метод `GetSample()` возвращает вектор выборок данных.<br/><br/>Выборка — это данные метрики за 30 секунд. Другими словами, выборки делаются каждые 30 секунд. Но, как описано ниже, существует задержка между получением выборки и моментом, когда выборка станет доступна формуле. Таким образом, не все выборки за заданный период времени могут быть доступны для оценки формулой.<ul><li>`doubleVec GetSample(double count)`<br/>Указывает количество получаемых выборок из самых последних полученных выборок.<br/><br/>`GetSample(1)` возвращает последнюю доступную выборку. Этот метод не следует использовать для таких метрик, как `$CPUPercent`, так как нет возможности узнать, *когда* была получена эта выборка. Она может оказаться свежей, но может и устареть, если в системе возникли проблемы. Для таких параметров лучше использовать интервалы, как показано ниже.<li>`doubleVec GetSample((timestamp or timeinterval) startTime [, double samplePercent])`<br/>Задает интервал времени для данных выборки. Также можно указать долю выборок, которые должны быть доступны в течение запрошенного интервала времени.<br/><br/>`$CPUPercent.GetSample(TimeInterval_Minute * 10)` вернет 20 выборок, если в журнале CPUPercent присутствуют все выборки за последние десять минут. Но если данные за последнюю минуту еще недоступны, этот метод вернет только 18 выборок. В этом случае:<br/><br/>`$CPUPercent.GetSample(TimeInterval_Minute * 10, 95)` выдаст ошибку, так как доступно только 90 процентов выборок.<br/><br/>`$CPUPercent.GetSample(TimeInterval_Minute * 10, 80)` выполнится успешно.<li>`doubleVec GetSample((timestamp or timeinterval) startTime, (timestamp or timeinterval) endTime [, double samplePercent])`<br/>Указывает интервал времени для сбора данных со временем начала и окончания.<br/><br/>Как упоминалось выше, полученный образец становится доступным для формулы с задержкой. Это необходимо учитывать при использовании метода `GetSample`. Ознакомьтесь с `GetSamplePercent` ниже.|
| GetSamplePeriod() | Возвращает период выборок, которые были получены в историческом наборе данных выборок. |
| Count() | Возвращает общее количество выборок в журнале метрик. |
| HistoryBeginTime() | Возвращает метку времени самой старой доступной выборки данных метрики. |
| GetSamplePercent() |Возвращает процент выборок, которые доступны для заданного интервала времени. Пример: <br/><br/>`doubleVec GetSamplePercent( (timestamp or timeinterval) startTime [, (timestamp or timeinterval) endTime] )`<br/><br/>Так как метод `GetSample` завершается сбоем, если процент возвращаемых выборок меньше указанного в параметре `samplePercent`, можно сначала воспользоваться методом `GetSamplePercent` для проверки. Затем при недостаточном количестве выборок можно выполнить другое действие без прерывания оценки автоматического масштабирования.|

### Выборки, процент выборок и метод *GetSample()*

Основной операцией формулы автоматического масштабирования является получение данных метрик для задач и ресурсов и изменение размера пула на основе этих данных. Поэтому важно иметь четкое представление о том, как формулы автоматического масштабирования взаимодействуют с данными метрик (выборками).

**Примеры**

Пакетная служба периодически принимает *выборки* метрик задач и ресурсов, делая их доступными для формул автомасштабирования. Эти выборки записываются пакетной службой каждые 30 секунд. Однако обычно это происходит с небольшой задержкой, которая приводит к временному зазору между временем записи этих выборок и временем, когда формулы автоматического масштабирования получают к ним доступ (и могут прочесть их). Кроме того, по тем или иным причинам (включая проблемы с сетью или другие проблемы инфраструктуры) для некоторых интервалов выборки могут не записаться. В результате возникают выборки с "неполными" данными.

**Процент выборок**

При передаче `samplePercent` в метод `GetSample()` или при вызове метода `GetSamplePercent()` знак процента означает сравнение общего *возможного* количества выборок, записанных пакетной службой, и количества выборок, которые фактически *доступны* для формулы автомасштабирования.

Для примера рассмотрим промежуток времени в 10 минут. Поскольку выборки записываются каждые 30 секунд, максимальное общее количество выборок, записанных пакетной службой в течение 10 минут, должно равняться 20 (по 2 в минуту). Однако из-за задержек, присущих механизму отчетности, или других проблем в инфраструктуре Azure возможна ситуация, когда только 15 выборок будут доступны для формулы автоматического масштабирования. Это означает, что за этот 10-минутный период для формулы фактически доступно только **75 %** от общего количества записанных выборок.

**Метод GetSample() и диапазоны выборок**

Формулы автоматического масштабирования будут увеличивать и уменьшать размер пулов, добавляя или удаляя узлы. Поскольку узлы стоят денег, нужно гарантировать, что формулы используют метод интеллектуального анализа, который основан на достаточном объеме данных. Поэтому в формулах рекомендуется использовать анализ тенденций. С таким анализом пулы будут увеличиваться и уменьшаться на основе *диапазона* собранных выборок.

Чтобы сделать это, используйте метод `GetSample(interval look-back start, interval look-back end)` для возврата **вектора** выборок.

`runningTasksSample = $RunningTasks.GetSample(1 * TimeInterval_Minute, 6 * TimeInterval_Minute);`

Когда пакетная служба вычисляет приведенную выше строку, она возвращает диапазон выборок в виде вектора значений. Например:

`runningTasksSample=[1,1,1,1,1,1,1,1,1,1];`

Собрав вектор выборок, можно использовать функции, например `min()`, `max()` и `avg()`, чтобы извлечь из собранного диапазона информативные значения.

Для повышения безопасности можно настроить *сбой* вычисления формулы в случае, если процент выборок за определенный период окажется меньше заданного значения. Если при принудительном сбое вычисления формулы заданный процент выборок недоступен, пакетная служба прекращает оценивать формулу, а размер пула не изменяется. Чтобы указать необходимый процент выборок для успешного вычисления, укажите его как третий параметр в методе `GetSample()`. Здесь указано, что обязательный процент выборок равен 75 %:

`runningTasksSample = $RunningTasks.GetSample(60 * TimeInterval_Second, 120 * TimeInterval_Second, 75);`

Кроме того, из-за упомянутой ранее задержки доступности выборок всегда необходимо указывать диапазон времени с временем начала на одну минуту раньше. Это объясняется тем, что передача выборок через систему занимает около минуты, поэтому примеры в диапазоне `(0 * TimeInterval_Second, 60 * TimeInterval_Second)` часто недоступны. Опять же, можно использовать параметр процента `GetSample()` для принудительного требования определенного процента выборок.

> [AZURE.IMPORTANT] **Настоятельно рекомендуем** **не полагаться *только* на метод `GetSample(1)` в формулах автомасштабирования**. Это объясняется тем, что метод `GetSample(1)` фактически запрашивает у пакетной службы последнюю доступную выборку независимо от того, как давно она была получена. Поскольку это только одна выборка, которая к тому же может быть устаревшей, она может не давать общее представление о последнем состоянии задачи или ресурса. Если метод `GetSample(1)` все же используется, убедитесь, что он является частью большей инструкции, а не единственной точкой данных, от которой зависит ваша формула.

## Метрики

При определении формулы можно использовать метрики **ресурсов** и **задач**. Целевое количество выделенных узлов в пуле определяется на основе данных метрики, которые были получены и оценены. Дополнительные сведения о каждой метрике см. в разделе [Переменные](#variables) выше.

<table>
  <tr>
    <th>Метрика</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td><b>Ресурс</b></td>
    <td><p><b>Метрики ресурсов</b>&#160;основаны на использовании ЦП, использовании памяти и пропускной способности вычислительных узлов, а также количестве узлов.</p>
		<p> Для внесения изменений с учетом количества узлов используются следующие служебные переменные:</p>
    <p><ul>
      <li>$TargetDedicated</li>
			<li>$CurrentDedicated</li>
			<li>$SampleNodeCount</li>
    </ul></p>
    <p>Для внесения изменений с учетом потребляемых ресурсов используются следующие служебные переменные:</p>
    <p><ul>
      <li>$CPUPercent</li>
      <li>$WallClockSeconds</li>
      <li>$MemoryBytes</li>
      <li>$DiskBytes</li>
      <li>$DiskReadBytes</li>
      <li>$DiskWriteBytes</li>
      <li>$DiskReadOps</li>
      <li>$DiskWriteOps</li>
      <li>$NetworkInBytes</li>
      <li>$NetworkOutBytes</li></ul></p>
  </tr>
  <tr>
    <td><b>Задача.</b></td>
    <td><p><b>Метрики задач</b> основаны на состоянии задач (активные, ожидающие и завершенные). Для внесения изменений в размер пула с учетом метрик задач используются следующие служебные переменные:</p>
    <p><ul>
      <li>$ActiveTasks</li>
      <li>$RunningTasks</li>
      <li>$PendingTasks</li>
      <li>$SucceededTasks</li>
			<li>$FailedTasks</li></ul></p>
		</td>
  </tr>
</table>

## Построение формулы автомасштабирования

Формула автомасштабирования создается путем формирования инструкций с помощью указанных выше компонентов и объединения этих инструкций в полную формулу. Например, в следующем примере мы создадим формулу, сначала определив требования к ней. Она должна:

1. Увеличивать целевое количество вычислительных узлов в пуле при высокой загрузке ЦП.
2. Уменьшать целевое количество вычислительных узлов в пуле при низкой загрузке ЦП.
3. Всегда ограничивать максимальное количество узлов до 400.

Нам может потребоваться *увеличить* количество узлов в периоды высокой загрузки ЦП. Для этого мы определим инструкцию, которая присваивает пользовательской переменной $TotalNodes значение, равное 110 % от текущего целевого количества узлов, если минимальное среднее использование ЦП за последние 10 минут превышало 70 %.

`$TotalNodes = (min($CPUPercent.GetSample(TimeInterval_Minute*10)) > 0.7) ? ($CurrentDedicated * 1.1) : $CurrentDedicated;`

Следующая инструкция задает той же переменной значение 90 % от текущего целевого количества узлов, если среднее использование ЦП за последние 60 минут было *ниже* 20 %. Это позволит уменьшить целевое количество узлов при снижении загрузки ЦП. Обратите внимание, что эта инструкция также использует пользовательскую переменную *$TotalNodes*, заданную в предыдущей инструкции.

`$TotalNodes = (avg($CPUPercent.GetSample(TimeInterval_Minute * 60)) < 0.2) ? ($CurrentDedicated * 0.9) : $TotalNodes;`

Теперь мы ограничим целевое количество выделенных вычислительных узлов **максимальным значением** 400:

`$TargetDedicated = min(400, $TotalNodes)`

Вот полная формула:

```
$TotalNodes = (min($CPUPercent.GetSample(TimeInterval_Minute*10)) > 0.7) ? ($CurrentDedicated * 1.1) : $CurrentDedicated;
$TotalNodes = (avg($CPUPercent.GetSample(TimeInterval_Minute*60)) < 0.2) ? ($CurrentDedicated * 0.9) : $TotalNodes;
$TargetDedicated = min(400, $TotalNodes)
```

> [AZURE.NOTE] Формула автоматического масштабирования состоит из переменных, типов, операций и функций [REST API пакетной службы][rest_api]. Они используются в строках формулы даже при работе с библиотекой [.NET пакетной службы][net_api].

## Создание пула со включенным автоматическим масштабированием

Чтобы включить автоматическое масштабирование при создании пула, воспользуйтесь одним из следующих способов:

- [New-AzureBatchPool](https://msdn.microsoft.com/library/azure/mt125936.aspx) — этот командлет Azure PowerShell использует параметр AutoScaleFormula для определения формулы автомасштабирования.
- [BatchClient.PoolOperations.CreatePool](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.createpool.aspx) — когда этот метод .NET вызывается для создания пула, в пуле задаются свойства [CloudPool.AutoScaleEnabled](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleenabled.aspx) и [CloudPool.AutoScaleFormula](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleformula.aspx) для включения автомасштабирования.
- [Добавление пула в учетную запись](https://msdn.microsoft.com/library/azure/dn820174.aspx) — в этом запросе REST API используются элементы enableAutoScale и autoScaleFormula для настройки автомасштабирования пула во время его создания.

> [AZURE.IMPORTANT] При создании пула с поддержкой автомасштабирования с помощью одного из приведенных выше методов параметр *targetDedicated* для пула указывать **не** нужно. Кроме того, обратите внимание, что если вы хотите вручную изменить размер пула с включенным автомасштабированием (например, с помощью [BatchClient.PoolOperations.ResizePool][net_poolops_resizepool]), вам необходимо сначала **отключить** автомасштабирование пула, а затем изменить его размер.

В следующем фрагменте кода показано создание пула с поддержкой автомасштабирования ([CloudPool][net_cloudpool]) с помощью библиотеки [.NET пакетной службы][net_api]. Формула автоматического масштабирования пула устанавливает целевое количество узлов в пять по понедельникам и в один в остальные дни недели. Кроме того, интервал автомасштабирования равен 30 минутам (см. раздел [Интервал автоматического масштабирования](#automatic-scaling-interval) ниже). В этом и других фрагментах кода C#, приведенных в этой статье, myBatchClient представляет собой полностью инициализированный экземпляр [BatchClient][net_batchclient].

```
CloudPool pool = myBatchClient.PoolOperations.CreatePool("mypool", "3", "small");
pool.AutoScaleEnabled = true;
pool.AutoScaleFormula = "$TargetDedicated = (time().weekday==1?5:1);";
pool.AutoScaleEvaluationInterval = TimeSpan.FromMinutes(30);
pool.Commit();
```

### Интервал автоматического масштабирования

По умолчанию пакетная служба изменяет размер пула по указанной формуле автомасштабирования каждые **15 минут**. Однако этот интервал можно настроить с помощью следующих свойств пула:

- REST API — [autoScaleEvaluationInterval][rest_autoscaleinterval];
- API .NET — [CloudPool.AutoScaleEvaluationInterval][net_cloudpool_autoscaleevalinterval].

Минимальный интервал составляет пять минут, а максимальный — 168 часов. Если указан интервал за пределами этого диапазона, пакетная служба возвращает ошибку "Неправильный запрос (400)".

> [AZURE.NOTE] В настоящее время автоматическое масштабирование предназначено не для реагирования на изменения в течение нескольких секунд, а для постепенного изменения размера пула в ходе выполнения рабочей нагрузки.

## Включение автоматического масштабирования после создания пула

Если вы уже настроили пул с указанным количеством вычислительных узлов с помощью параметра *targetDedicated*, такой пул можно обновить позднее, настроив для него автомасштабирование. Это можно сделать одним из следующих способов:

- [BatchClient.PoolOperations.EnableAutoScale][net_enableautoscale] — этот метод .NET принимает идентификатор имеющегося пула и формулу автомасштабирования, которую нужно применить к этому пулу.
- [Включить автоматическое масштабирование в пуле][rest_enableautoscale] — для этого запроса REST API в универсальном коде ресурса (URI) передается идентификатор имеющегося пула, а в тексте запроса — формула автомасштабирования.

> [AZURE.NOTE] Если во время создания пула было указано значение параметра *targetDedicated*, оно игнорируется во время оценки формулы автоматического масштабирования.

Этот фрагмент кода демонстрирует включение автомасштабирования для имеющегося пула с помощью библиотеки [.NET пакетной службы][net_api]. Обратите внимание, что при включении и обновлении формулы для существующего пула используется один и тот же метод. Таким образом, если автоматическое масштабирование уже включено, этот метод будет *обновлять* формулу для указанного пула. Этот фрагмент кода предполагает, что mypool — это идентификатор имеющегося пула [CloudPool][net_cloudpool].

		 // Define the autoscaling formula. In this snippet, the  formula sets the target number of nodes to 5 on
		 // Mondays, and 1 on every other day of the week
		 string myAutoScaleFormula = "$TargetDedicated = (time().weekday==1?5:1);";

		 // Update the existing pool's autoscaling formula by calling the BatchClient.PoolOperations.EnableAutoScale
		 // method, passing in both the pool's ID and the new formula.
		 myBatchClient.PoolOperations.EnableAutoScale("mypool", myAutoScaleFormula);

## Оценка формулы автоматического масштабирования

Рекомендуется оценивать формулу, прежде чем использовать ее в приложении. Формула оценивается путем тестового выполнения для существующего пула. Это можно сделать, используя следующее:

- [BatchClient.PoolOperations.EvaluateAutoScale](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.evaluateautoscale.aspx) или [BatchClient.PoolOperations.EvaluateAutoScaleAsync](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.evaluateautoscaleasync.aspx) — для этих методов .NET требуется идентификатор имеющегося пула и строка, которая содержит формулу автомасштабирования. Результаты вызова содержатся в экземпляре класса [AutoScaleEvaluation](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscaleevaluation.aspx).
- [Вычислить формулу автоматического масштабирования](https://msdn.microsoft.com/library/azure/dn820183.aspx) — в этом запросе REST API идентификатор пула указывается в универсальном коде ресурса (URI). Формула автомасштабирования указывается в элементе *autoScaleFormula* в тексте запроса. Ответ операции содержит все сведения об ошибках, которые могут быть связаны с формулой.

> [AZURE.NOTE] Чтобы оценить формулу автомасштабирования, необходимо сначала включить автоматическое масштабирование в пуле, используя допустимую формулу.

В этом фрагменте кода, использующем библиотеку [.NET пакетной службы][net_api], мы оценим формулу перед ее применением к пулу [CloudPool][net_cloudpool].

```
// First obtain a reference to the existing pool
CloudPool pool = myBatchClient.PoolOperations.GetPool("mypool");

// We must ensure that autoscaling is enabled on the pool prior to evaluating a formula
if (pool.AutoScaleEnabled.HasValue && pool.AutoScaleEnabled.Value)
{
	// The formula to evaluate - adjusts target number of nodes based on day of week and time of day
	string myFormula = @"
		$CurTime=time();
		$WorkHours=$CurTime.hour>=8 && $CurTime.hour<18;
		$IsWeekday=$CurTime.weekday>=1 && $CurTime.weekday<=5;
		$IsWorkingWeekdayHour=$WorkHours && $IsWeekday;
		$TargetDedicated=$IsWorkingWeekdayHour?20:10;
	";

	// Perform the autoscale formula evaluation. Note that this does not actually apply the formula to
	// the pool.
	AutoScaleEvaluation eval = client.PoolOperations.EvaluateAutoScale(pool.Id, myFormula);

	if (eval.AutoScaleRun.Error == null)
	{
		// Evaluation success - print the results of the AutoScaleRun. This will display the values of each
		// variable as evaluated by the autoscale formula.
		Console.WriteLine("AutoScaleRun.Results: " + eval.AutoScaleRun.Results);

		// Apply the formula to the pool since it evaluated successfully
		client.PoolOperations.EnableAutoScale(pool.Id, myFormula);
	}
	else
	{
		// Evaluation failed, output the message associated with the error
		Console.WriteLine("AutoScaleRun.Error.Message: " + eval.AutoScaleRun.Error.Message);
	}
}
```

В случае успешной оценки формулы в этом фрагменте будет получен результат, подобный приведенному ниже:

`AutoScaleRun.Results: $TargetDedicated = 10;$NodeDeallocationOption = requeue;$CurTime = 2015 - 08 - 25T20: 08:42.271Z;$IsWeekday = 1;$IsWorkingWeekdayHour = 0;$WorkHours = 0`

## Получение сведений о выполнении автоматического масштабирования

Чтобы убедиться, что формула работает ожидаемым образом, следует периодически проверять результаты автоматического масштабирования.

- [CloudPool.AutoScaleRun](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscalerun.aspx) — при использовании библиотеки .NET это свойство пула предоставляет экземпляр класса [AutoScaleRun](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscalerun.aspx). Этот класс предоставляет следующие свойства последнего выполнения автоматического масштабирования:
  - [AutoScaleRun.Error;](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscalerun.error.aspx)
  - [AutoScaleRun.Results;](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscalerun.results.aspx)
  - [AutoScaleRun.Timestamp.](https://msdn.microsoft.com/library/azure/microsoft.azure.batch.autoscalerun.timestamp.aspx)
- [Получение сведений о пуле](https://msdn.microsoft.com/library/dn820165.aspx) — этот запрос REST API возвращает сведения о пуле, в том числе результаты последнего выполнения автомасштабирования.

## <a name="examples"></a>Примеры формул

Рассмотрим примеры, показывающие лишь несколько способов использования формул для автоматического масштабирования вычислительных ресурсов в пуле.

### Пример 1. Изменение с учетом времени

Возможно, вы решили изменить размер пула в зависимости от дня недели и времени дня, чтобы количество узлов в пуле увеличивалось или уменьшалось соответствующим образом:

```
$CurTime=time();
$WorkHours=$CurTime.hour>=8 && $CurTime.hour<18;
$IsWeekday=$CurTime.weekday>=1 && $CurTime.weekday<=5;
$IsWorkingWeekdayHour=$WorkHours && $IsWeekday;
$TargetDedicated=$IsWorkingWeekdayHour?20:10;
```

Эта формула сначала получает значение текущего времени. В рабочие дни (1–5) и часы (8:00–18:00) целевой размер пула равен 20 узлам. В противном случае для пула устанавливается целевой размер 10 узлов.

### Пример 2. Изменение с учетом задачи

В этом примере размер пула настраивается в зависимости от количества задач в очереди. Обратите внимание, что в строках формул допускаются комментарии и разрывы строк.

```
// Get pending tasks for the past 15 minutes.
$Samples = $ActiveTasks.GetSamplePercent(TimeInterval_Minute * 15);
// If we have fewer than 70 percent data points, we use the last sample point, otherwise we use the maximum of
// last sample point and the history average.
$Tasks = $Samples < 70 ? max(0,$ActiveTasks.GetSample(1)) : max( $ActiveTasks.GetSample(1), avg($ActiveTasks.GetSample(TimeInterval_Minute * 15)));
// If number of pending tasks is not 0, set targetVM to pending tasks, otherwise half of current dedicated.
$TargetVMs = $Tasks > 0? $Tasks:max(0, $TargetDedicated/2);
// The pool size is capped at 20, if target VM value is more than that, set it to 20. This value
// should be adjusted according to your use case.
$TargetDedicated = max(0,min($TargetVMs,20));
// Set node deallocation mode - keep nodes active only until tasks finish
$NodeDeallocationOption = taskcompletion;
```

### Пример 3. Параллельные задачи

Вот еще один пример, который изменяет размер пула на основе числа задач. В этой формуле также учитывается значение [MaxTasksPerComputeNode][net_maxtasks], которое было задано для пула. Это особенно полезно, если в пуле поддерживается [параллельное выполнение задач](batch-parallel-node-tasks.md).

```
// Determine whether 70 percent of the samples have been recorded in the past 15 minutes; if not, use last sample
$Samples = $ActiveTasks.GetSamplePercent(TimeInterval_Minute * 15);
$Tasks = $Samples < 70 ? max(0,$ActiveTasks.GetSample(1)) : max( $ActiveTasks.GetSample(1),avg($ActiveTasks.GetSample(TimeInterval_Minute * 15)));
// Set the number of nodes to add to one-fourth the number of active tasks (the MaxTasksPerComputeNode
// property on this pool is set to 4, adjust this number for your use case)
$Cores = $TargetDedicated * 4;
$ExtraVMs = (($Tasks - $Cores) + 3) / 4;
$TargetVMs = ($TargetDedicated+$ExtraVMs);
// Attempt to grow the number of compute nodes to match the number of active tasks, with a maximum of 3
$TargetDedicated = max(0,min($TargetVMs,3));
// Keep the nodes active until the tasks finish
$NodeDeallocationOption = taskcompletion;
```

### Пример 4. Настройка исходного размера пула

В этом примере показан фрагмент кода C# с помощью формулы автоматического масштабирования, которая задает размер пула в определенное число узлов на начальный период времени. Затем он корректирует размер пула на основе количества запущенных и активных задач по истечению начального периода времени.

```
string now = DateTime.UtcNow.ToString("r");
string formula = string.Format(@"

	$TargetDedicated = {1};
	lifespan         = time() - time(""{0}"");
	span             = TimeInterval_Minute * 60;
	startup          = TimeInterval_Minute * 10;
	ratio            = 50;

	$TargetDedicated = (lifespan > startup ? (max($RunningTasks.GetSample(span, ratio), $ActiveTasks.GetSample(span, ratio)) == 0 ? 0 : $TargetDedicated) : {1});
	", now, 4);
```

Формула в предыдущем фрагменте кода:

- Она задает исходный размер пула в 4 узла.
- Не изменяет размер пула в течение первых 10 минут его жизненного цикла.
- После первых 10 минут она получает максимальное количество запущенных и активных задач за последние 60 минут.
  - Если оба значения равны 0 (то есть за 60 минут не было ни активных, ни запущенных задач), то размер пула устанавливается в 0.
  - Если любое из значений больше нуля, изменений не производится.

## Дальнейшие действия

* Статья [Повышение эффективности вычислительных ресурсов в пакетной службе Azure благодаря параллельному выполнению задач на узлах](batch-parallel-node-tasks.md) содержит сведения о том, как можно одновременно выполнять несколько задач на вычислительных узлах пула. Помимо автоматического масштабирования, эта функция позволяет уменьшить длительность выполнения заданий для некоторых рабочих нагрузок, тем самым обеспечивая сокращение затрат.

* Еще одна возможность повысить эффективность — гарантировать, что приложение пакетной службы отправляет запросы в пакетную службу наиболее оптимальным способом. Из статьи [Эффективные запросы к пакетной службе Azure](batch-efficient-list-queries.md) вы узнаете, как ограничить объем данных, передаваемых по сети при потенциальном запросе состояния тысяч вычислительных узлов или задач.

[net_api]: https://msdn.microsoft.com/library/azure/mt348682.aspx
[net_batchclient]: http://msdn.microsoft.com/library/azure/microsoft.azure.batch.batchclient.aspx
[net_cloudpool]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.aspx
[net_cloudpool_autoscaleformula]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleformula.aspx
[net_cloudpool_autoscaleevalinterval]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.autoscaleevaluationinterval.aspx
[net_enableautoscale]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.enableautoscale.aspx
[net_maxtasks]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.maxtaskspercomputenode.aspx
[net_poolops_resizepool]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.resizepool.aspx

[rest_api]: https://msdn.microsoft.com/library/azure/dn820158.aspx
[rest_autoscaleformula]: https://msdn.microsoft.com/library/azure/dn820173.aspx
[rest_autoscaleinterval]: https://msdn.microsoft.com/ru-RU/library/azure/dn820173.aspx
[rest_enableautoscale]: https://msdn.microsoft.com/library/azure/dn820173.aspx

<!---HONumber=AcomDC_0928_2016-->