<properties
    pageTitle="Включение автономной синхронизации для мобильного приложения (Xamarin iOS)"
    description="Использование мобильного приложения службы приложений для кэширования и синхронизации автономных данных в приложении Xamarin iOS"
    documentationCenter="xamarin"
    authors="lindydonna"
    manager="dwrede"
    editor=""
    services="app-service\mobile"/>

<tags
    ms.service="app-service-mobile"
    ms.workload="mobile"
    ms.tgt_pltfrm="xamarin-ios"
    ms.devlang="dotnet"
    ms.topic="article"
    ms.date="03/26/2015"
    ms.author="donnam"/>

# Включение автономной синхронизации для мобильного приложения Xamarin iOS

[AZURE.INCLUDE [app-service-mobile-selector-offline-preview](../../includes/app-service-mobile-selector-offline-preview.md)]

В этом учебнике рассматривается функция автономной синхронизации мобильных приложений для iOS. Автономная синхронизация позволяет конечным пользователям взаимодействовать с мобильным приложением — просматривать, добавлять или изменять данные — даже при отсутствии подключения к сети. Изменения сохраняются в локальной базе данных; как только устройство возвращается в режим подключения к сети, эти изменения синхронизируются с удаленной службой.

Автономная синхронизация может применяться в следующих случаях:

* Повышение скорости реагирования приложений путем локального кэширования данных сервера в устройстве
* Защита приложений от потери сетевой связности
* Предоставление конечным пользователям возможности создания и изменения данных даже в том случае, когда отсутствует сетевой доступ, поддерживая сценарии с минимальной связностью или при отсутствии связности
* Синхронизация данных между несколькими устройствами и обнаружение конфликтов, когда два устройства изменяют одну и ту же запись

Если вы впервые работаете с мобильными приложениями, сначала пройдите учебник [Создание приложения Xamarin iOS].

Для работы с данным учебником требуется следующее:

* Visual Studio 2013
* [Расширение Xamarin] Visual Studio **или** [Xamarin Studio] на OS X

## Обзор кода синхронизации мобильных приложений

Автономная синхронизация мобильных приложений позволяет конечным пользователям взаимодействовать с локальной базой данных, если сеть недоступна. Для использования этих возможностей в приложении вы инициализируете `MobileServiceClient.SyncContext` в локальное хранилище. Затем ссылаетесь на таблицу с помощью интерфейса `IMobileServiceSyncTable`. В этом разделе подробно рассматривается код, связанный с автономной синхронизацией, в `QSTodoService.cs`.

1. В Visual Studio откройте проект, созданный в учебнике [Начало работы с мобильными приложениями]. Откройте файл `QSTodoService.cs`.

2. Обратите внимание, что этот член `todoTable` имеет тип `IMobileServiceSyncTable`. Автономная синхронизация использует этот интерфейс таблицы синхронизации вместо `IMobileServiceTable`. При использовании таблицы синхронизации все операции направляются в локальное хранилище и синхронизируются с удаленной службой только по явным операциям принудительной отправки и принудительного получения.

    Для получения ссылки на таблицу синхронизации используется метод `GetSyncTable()`. Чтобы удалить функцию автономной синхронизации, можно использовать `GetTable()`.

3. Прежде чем можно будет выполнить операции с таблицами, необходимо инициализировать локальное хранилище. Это делается в методе `InitializeStoreAsync`:

        public async Task InitializeStoreAsync()
        {
            var store = new MobileServiceSQLiteStore(localDbPath);
            store.DefineTable<ToDoItem>();

            // Uses the default conflict handler, which fails on conflict
            await client.SyncContext.InitializeAsync(store);
        }

    При этом создается локальное хранилище, использующее класс `MobileServiceSQLiteStore`, который предоставляется в пакете SDK для мобильного приложения. Вы также можете предоставить другую реализацию локального хранилища, реализовав `IMobileServiceLocalStore`.

    Метод `DefineTable` создает в локальном хранилище таблицу, соответствующую полям в указанном типе, в данном случае это `ToDoItem`. Тип необязательно должен включать в себя все столбцы, которые находятся в удаленной базе данных, так как можно хранить и подмножество столбцов.

<!--     This overload of `InitializeAsync` uses the default conflict handler, which fails whenever there is a conflict. To provide a custom conflict handler, see the tutorial [Handling conflicts with offline support for Mobile Services].
 -->
4. Метод `SyncAsync` запускает операцию фактической синхронизации:

        public async Task SyncAsync()
        {
            try
            {
                await client.SyncContext.PushAsync();
                await todoTable.PullAsync("allTodoItems", todoTable.CreateQuery()); // query ID is used for incremental sync
            }

            catch (MobileServiceInvalidOperationException e)
            {
                Console.Error.WriteLine(@"Sync Failed: {0}", e.Message);
            }
        }

    Во-первых, это вызов `IMobileServiceSyncContext.PushAsync()`. Этот метод является членом `IMobileServicesSyncContext` вместо таблицы синхронизации, поскольку он будет передавать изменения во все таблицы. Только те записи, которые были каким-либо образом локально изменены (с помощью операций CUD), будут отправлены на сервер.

    Затем метод вызывает `IMobileServiceSyncTable.PullAsync()` для извлечения данных из таблицы на сервере в приложение. Обратите внимание, что если в контексте синхронизации имеются ожидающие изменения, то операция принудительного получения всегда предварительно выполняет операцию принудительной отправки. Это позволяет обеспечить согласованность всех таблиц в локальном хранилище, а также связей между ними. В этом случае мы вызвали операцию принудительной отправки явным образом.

    В этом примере мы получаем все записи из удаленной таблицы `TodoItem`, однако их можно также отфильтровать путем передачи запроса. Первым параметром для `PullAsync()` является идентификатор запроса, используемый для добавочной синхронизации, в рамках которой используется метка времени `UpdatedAt`, чтобы получить только записи, измененные с момента последней синхронизации. Идентификатор запроса должен быть описательной строкой, уникальной для каждого логического запроса в приложении. Чтобы явно отказаться от добавочной синхронизации, передайте `null` в качестве идентификатора запроса. В этом случае команда получает все записи по каждой операции принудительного извлечения, которая потенциально неэффективна.

<!--     >[AZURE.NOTE] To remove records from the device local store when they have been deleted in your mobile service database, you should enable [Soft Delete]. Otherwise, your app should periodically call `IMobileServiceSyncTable.PurgeAsync()` to purge the local store.

    Note that the `MobileServicePushFailedException` can occur for both a push and a pull operation. The next tutorial, [Handling conflicts with offline support for Mobile Services], shows how to handle these sync related exceptions.
-->

5. В классе `QSTodoService` метод `SyncAsync()` вызывается после операций, которые изменяют данные, — `InsertTodoItemAsync()` и `CompleteItemAsync`. Он также вызывается из `RefreshDataAsync()`, поэтому пользователь получает последние данные при каждом выполнении жеста обновления. Приложение также выполняет синхронизацию при запуске, поскольку `QSTodoListViewController.ViewDidLoad()` вызывает `RefreshDataAsync()`.

    Поскольку `SyncAsync()` вызывается при каждом изменении данных, это приложение предполагает, что пользователь находится в сети каждый раз, когда вносит изменения в данные. В следующем разделе мы обновим приложение, чтобы пользователи могли изменять данные, даже работая в автономном режиме.

## Обновление режима синхронизации приложения

В этом разделе вы измените приложение, чтобы оно не синхронизировалось при запуске или операциях вставки и изменения и синхронизировалось только при выполнении жеста обновления. Затем вы разорвете связь приложения с мобильным внутренним сервером для имитации автономного сценария. При добавлении элементов данных они будут храниться в локальном хранилище, но не будут синхронизированы с хранилищем данных мобильного внутреннего сервера немедленно.

1. Откройте `QSTodoService.cs`. Закомментируйте вызовы `SyncAsync()` в следующих методах:

    - `InsertTodoItemAsync`
    - `CompleteItemAsync`
    - `RefreshAsync`

    Теперь `RefreshAsync()` будет загружать только данные из локального хранилища, но не будет подключаться к внутреннему серверу приложений.

2. В `QSTodoService.cs` измените определение `applicationURL`, чтобы оно указывало на недопустимый URI мобильного приложения:

        const string applicationURL = @"https://your-service.azurewebsites.xxx/"; // invalid URI

3. Чтобы обеспечить синхронизацию данных при выполнении обновления, измените метод `QSTodoListViewController.RefreshAsync()`. Добавьте вызов `SyncAsync()` перед вызовом `RefreshDataAsync()`:

        private async Task RefreshAsync ()
        {
            RefreshControl.BeginRefreshing ();

            await todoService.SyncAsync();
            await todoService.RefreshDataAsync (); // add this line

            RefreshControl.EndRefreshing ();

            TableView.ReloadData ();
        }

4. Выполните сборку и запустите приложение. Добавьте несколько новых элементов списка дел. Эти новые элементы существуют только в локальном хранилище, пока не будут принудительно переданы на мобильный внутренний сервер. Клиентское приложение ведет себя так, как если бы оно было подключено к внутреннему серверу, поддерживающему все операции создания, чтения, обновления и удаления (CRUD).

5. Закройте приложение и перезапустите его, чтобы убедиться, что новые элементы сохранены в локальном хранилище.

## Обновление приложения для повторного подключения мобильного внутреннего сервера

В этом разделе вы повторно подключите приложение к мобильному внутреннему серверу, имитирующему приложение, подключающееся к сети. При выполнении жеста обновления данные будут синхронизированы с мобильным внутренним сервером.

1. Откройте `QSTodoService.cs`. Удалите недопустимый URL-адрес мобильного приложения и верните правильный URL-адрес и ключ приложения.

2. Повторно выполните сборку и запустите приложение. Обратите внимание, что данные не изменились несмотря на то, что приложение теперь подключено к мобильному внутреннему серверу. Это вызвано тем, что данное приложение всегда использует `IMobileServiceSyncTable`, который указывает на локальное хранилище.

3. Подключитесь к базе данных SQL внутреннего сервера, чтобы просмотреть сохраненные данные. В Visual Studio последовательно выберите пункты **Обозреватель серверов** -> **Azure** -> **Базы данных SQL**. Щелкните правой кнопкой мыши базу данных и выберите **Открыть в обозревателе объектов SQL Server**.

    Обратите внимание, что данные* не* синхронизированы между базой данных и локальным хранилищем.

4. Находясь в приложении, сделайте жест обновления, потянув список элементов вниз. После этого приложение вызывает `RefreshDataAsync()`, который, в свою очередь, вызывает `SyncAsync()`. Это приведет к отправке push-уведомлений и выполнению операций получения: сначала элементы локального хранилища отправляются на мобильный внутренний сервер, а затем из мобильного внутреннего сервера извлекаются новые данные.

5. Обновите представление базы данных и подтвердите, что изменения были синхронизированы.

<!-- ##Summary

[AZURE.INCLUDE [mobile-services-offline-summary-csharp](../../includes/mobile-services-offline-summary-csharp.md)]

## Next steps

* [Handling conflicts with offline support for Mobile Services]

* [How to use the Xamarin Component client for Azure Mobile Services]
 -->

<!-- Images -->

<!-- URLs. -->
[Создание приложения Xamarin iOS]: ../app-service-mobile-dotnet-backend-xamarin-ios-get-started.md

[How to use the Xamarin Component client for Azure Mobile Services]: ../partner-xamarin-mobile-services-how-to-use-client-library.md

[Xamarin Studio]: http://xamarin.com/download
[Расширение Xamarin]: http://xamarin.com/visual-studio
 

<!---HONumber=62-->