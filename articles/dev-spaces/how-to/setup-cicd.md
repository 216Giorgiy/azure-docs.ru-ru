---
title: Использование CI/CD в Azure Dev Spaces | Документация Майкрософт
titleSuffix: Azure Dev Spaces
services: azure-dev-spaces
ms.service: azure-dev-spaces
ms.subservice: azds-kubernetes
author: DrEsteban
ms.author: stevenry
ms.date: 12/17/2018
ms.topic: article
manager: yuvalm
description: Быстрая разработка в Kubernetes с использованием контейнеров и микрослужб в Azure
keywords: Docker, Kubernetes, Azure, AKS, Azure Container Service, containers
ms.openlocfilehash: 0abe2902248c8203046cfe891d136ca7d5d0a75b
ms.sourcegitcommit: de32e8825542b91f02da9e5d899d29bcc2c37f28
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/02/2019
ms.locfileid: "55665975"
---
# <a name="use-cicd-with-azure-dev-spaces"></a>Использование CI/CD в Azure Dev Spaces

Из этой статьи вы узнаете, как настроить непрерывную интеграцию и непрерывное развертывание (CI/CD) для Службы Azure Kubernetes (AKS) с поддержкой Azure Dev Spaces. CI/CD для AKS позволяет автоматически развертывать обновления приложений при каждой отправке зафиксированного кода в исходный репозиторий. Благодаря CI/CD и поддержке Dev Spaces кластер сохраняет актуальность базовых показателей приложения, чтобы разработчики могли работать с ними.

![Пример схемы CI/CD](../media/common/ci-cd-simple.png)

В этой статье описывается использование Azure DevOps, но те же принципы применяются и к другим системам непрерывной интеграции и непрерывного развертывания, таким как Jenkins, TeamCity и т. д.

## <a name="prerequisites"></a>Предварительные требования
* [Кластер Службы Azure Kubernetes (AKS) с поддержкой Azure Dev Spaces](../get-started-netcore.md).
* [Установленный интерфейс командной строки Azure Dev Spaces](upgrade-tools.md).
* [Организация Azure DevOps с проектом](https://docs.microsoft.com/azure/devops/user-guide/sign-up-invite-teammates?view=vsts).
* [Реестр контейнеров Azure (ACR)](../../container-registry/container-registry-get-started-azure-cli.md).
    * Доступные данные [учетной записи администратора](../../container-registry/container-registry-authentication.md#admin-account) Реестра контейнеров Azure.
* [Кластер AKS с разрешениями на извлечение данных из Реестра контейнеров Azure](../../container-registry/container-registry-auth-aks.md).

## <a name="download-sample-code"></a>Скачивание примера кода
Ради экономии времени создадим вилку примера кода из репозитория GitHub. Перейдите на страницу https://github.com/Azure/dev-spaces и щелкните **Fork** (Вилка). После создания вилки **клонируйте** версию вилки репозитория локально. По умолчанию будет извлечена ветвь _master_, но мы включили несколько изменений в ветвь _azds_updates_, которую также следует перенести во время создания вилки. Эти изменения позволят сэкономить время. Ветвь _azds_updates_ содержит обновления, которые следует внести вручную, как описано в разделах руководства по Dev Spaces, а также некоторые готовые файлы YAML и JSON для оптимизации развертывания системы CI/CD. С помощью команды `git checkout -b azds_updates origin/azds_updates` можно извлечь ветвь _azds_updates_ в локальном репозитории.

## <a name="dev-spaces-setup"></a>Настройка Dev Spaces
Создайте новое пространство с именем _dev_ с помощью команды `azds space select`. Ваш конвейер CI/CD будет использовать пространство _dev_ для передачи изменений кода. Также оно будет использоваться для создания _дочерних пространств_ на основе _dev_.

```cmd
azds space select -n dev
```

При появлении запроса на выбор родительского пространства выберите _\<none\>_.

Пространство _dev_ всегда будет содержать последнее состояние репозитория — базовое значение. Таким образом, разработчики могут создавать _дочерние пространства_ на основе _dev_ для тестирования отдельных изменений в контексте приложения большего размера. Эта концепция более подробно описана в руководствах по Dev Spaces.

## <a name="creating-the-build-definition"></a>Создание определения сборки
Откройте командный проект Azure DevOps в веб-браузере и перейдите в раздел _Pipelines_ (Конвейеры). Сначала щелкните фотографию профиля в правом верхнем углу на сайте Azure DevOps, откройте панель предварительной версии функций и отключите параметр _Новый интерфейс для создания конвейеров YAML_:

![Панель предварительной версии функций](../media/common/preview-feature-open.png)

Отключение параметра:

![Параметр "Новый интерфейс для создания конвейеров YAML"](../media/common/yaml-pipeline-preview-feature.png)

> [!Note]
> Сейчас предварительная версия функции Azure DevOps _Новый интерфейс для создания конвейеров YAML_ конфликтует с созданием предварительно определенных конвейеров сборки. Прежде чем развернуть предварительно определенный конвейер сборки, необходимо отключить эту функцию.

Мы включили в ветвь _azds_updates_ простую схему [YAML конвейеров Azure](https://docs.microsoft.com/azure/devops/pipelines/yaml-schema?view=vsts&tabs=schema), которая определяет необходимые шаги для сборки *mywebapi* и *webfrontend*.

В зависимости от выбранного языка схема YAML конвейера извлекается в путь, схожий со следующим: `samples/dotnetcore/getting-started/azure-pipelines.dotnetcore.yml`

Чтобы создать конвейер из этого файла, сделайте следующее:
1. На главной странице проекта DevOps последовательно выберите Pipelines (Конвейеры) > Builds (Сборки).
1. Выберите параметр, чтобы создать **новый** конвейер сборки.
1. Выберите **GitHub** в качестве источника, при необходимости авторизуйтесь с помощью учетной записи GitHub и выберите ветвь _azds_updates_ из ответвленной версии репозитория sampleapp в Dev Spaces.
1. Выберите шаблон **Настройка в качестве кода** или **YAML**.
1. Теперь появится страница конфигурации для конвейера сборки. Как упоминалось выше, введите путь для конкретного языка в поле **Путь к файлу YAML**. Например `samples/dotnetcore/getting-started/azure-pipelines.dotnetcore.yml`.
1. Перейдите на вкладку "Переменные".
1. Вручную добавьте _dockerId_ в качестве переменной, которая является именем пользователя вашей [учетной записи администратора для Реестра контейнеров Azure](../../container-registry/container-registry-authentication.md#admin-account) (см. предварительные требования в начале статьи).
1. Вручную добавьте _dockerPassword_ в качестве переменной, которая является паролем вашей [учетной записи администратора для Реестра контейнеров Azure](../../container-registry/container-registry-authentication.md#admin-account). Не забудьте указать _dockerPassword_ в качестве секрета (щелкнув значок замка) в целях безопасности.
1. Щелкните **Сохранить и поместить в очередь**.

Теперь у вас есть решение непрерывной интеграции, которое автоматически выполняет сборку *mywebapi* и *webfrontend* для любого обновления, отправленного в ветвь _azds_updates_ вилки GitHub. Можно проверить отправку образов Docker: перейдите на портал Azure, выберите "Реестр контейнеров Azure" и перейдите на вкладку _Репозитории_.

![Репозитории Реестра контейнеров Azure](../media/common/ci-cd-images-verify.png)

## <a name="creating-the-release-definition"></a>Создание определения выпуска

1. На главной странице проекта DevOps последовательно выберите Pipelines (Конвейеры) > Releases (Выпуски).
1. Если вы работаете в новом проекте DevOps, который еще не содержит определение выпуска, необходимо сначала создать пустое определение выпуска. Параметр "Импорт" не отображается в пользовательском интерфейсе, пока не появится существующее определение выпуска.
1. С левой стороны экрана щелкните **+ Создать**, а затем — **Импорт конвейера**.
1. Выберите файл JSON в папке `samples/release.json`.
1. Нажмите кнопку "ОК". Обратите внимание, что панель конвейера загрузилась со страницей редактирования определения выпуска. Также обратите внимание на красные значки предупреждения, указывающие на связанные с кластером сведения, которые должны быть настроены.
1. В левой части панели конвейера щелкните кружок **Добавить артефакт**.
1. В раскрывающемся списке **Источник** выберите конвейер сборки, который мы создали ранее в этом документе.
1. В **версии по умолчанию** рекомендуется выбрать **Latest from the build pipeline default branch** (Последнее из ветви по умолчанию конвейера сборки). Теги указывать не нужно.
1. Для параметра **Псевдоним источника** укажите `drop`. Предопределенные задачи выпуска используют **псевдоним источника**, поэтому его нужно задать.
1. Щелкните **Добавить**.
1. Теперь щелкните значок молнии на только что созданном источнике артефакта `drop`, как показано ниже:

    ![Настройка непрерывного развертывания артефакта выпуска](../media/common/release-artifact-cd-setup.png)
1. Включите **триггер непрерывного развертывания**.
1. Теперь перейдите в область задач. Следует выбрать рабочую область _dev_. Отобразятся три красных элемента управления с раскрывающимся списком, как показано ниже:

    ![Настройка определения выпуска](../media/common/release-setup-tasks.png)
1. Укажите подписку Azure, группу ресурсов и кластер, который вы используете в Azure Dev Spaces.
1. На этом этапе должен быть только один дополнительный раздел, выделенный красным, — раздел **Задание агента**. Перейдите туда и в качестве пула агентов укажите **Hosted Ubuntu 1604** (Размещение в Ubuntu 1604) для данного этапа.
1. Наведите указатель мыши на селектор задач в верхней части страницы и выберите _prod_.
1. Укажите подписку Azure, группу ресурсов и кластер, который вы используете в Azure Dev Spaces.
1. В разделе **Задание агента** настройте **Hosted Ubuntu 1604** (Размещение в Ubuntu 1604) в качестве пула агентов.
1. Нажмите кнопку **Сохранить** в правом верхнем углу и кнопку **ОК**.
1. Щелкните **+ Выпуск** (рядом с кнопкой "Сохранить") и **Создать выпуск**.
1. Убедитесь, что в разделе "Артефакты" выбрана последняя сборка из конвейера сборки, и щелкните **Создать**.

Теперь начнется процесс автоматического выпуска и развертывание диаграмм *mywebapi* и *webfrontend* в кластер Kubernetes в пространстве верхнего уровня _dev_. Ход выполнения выпуска можно отслеживать на веб-портале Azure DevOps.

> [!TIP]
> Если выпуск завершается сбоем с сообщением об ошибке, например *UPGRADE FAILED: timed out waiting for the condition* (НЕ УДАЛОСЬ ОБНОВИТЬ: истекло время ожидания условия), проверьте объекты pod в кластере [с помощью панели мониторинга Kubernetes](../../aks/kubernetes-dashboard.md). Если возникают ошибки при запуске объектов pod, такие как *Failed to pull image "azdsexample.azurecr.io/mywebapi:122": rpc error: code = Unknown desc = Error response from daemon: Get https://azdsexample.azurecr.io/v2/mywebapi/manifests/122: unauthorized: authentication required*, возможно, ваш кластер не авторизован для извлечения данных из Реестра контейнеров Azure. Убедитесь, что предварительное требование о наличии [кластера AKS с разрешениями на извлечение данных из Реестра контейнеров Azure](../../container-registry/container-registry-auth-aks.md) выполнено.

Теперь у вас есть полностью автоматизированный конвейер CI/CD для вилки GitHub примеров приложений Dev Spaces. Каждый раз при фиксации и отправке кода конвейер сборки будет создавать и отправлять образы *mywebapi* и *webfrontend* в ваш экземпляр ACR. Затем конвейер выпуска будет развертывать диаграмму Helm для каждого приложения в пространстве _dev_ кластера с поддержкой Dev Spaces.

## <a name="accessing-your-dev-services"></a>Доступ к службе _dev_
После развертывания доступ к _dev_-версии *webfrontend* может осуществляться с общедоступного URL-адреса, например `http://dev.webfrontend.<hash>.<region>.aksapp.io`.

Этот URL-адрес можно найти с помощью интерфейса командной строки *kubectl*:
```cmd
kubectl get ingress -n dev webfrontend -o=jsonpath="{.spec.rules[0].host}"
```

## <a name="deploying-to-production"></a>Развертывание в рабочей среде
Щелкните **Изменить** в определении выпуска и обратите внимание на определение рабочей области _prod_:

![Этап рабочего развертывания](../media/common/prod-env.png)

Чтобы вручную повысить уровень определенного выпуска до _prod_ в системе CI/CD, созданной в этом руководстве, выполните следующие действия:
1. Откройте успешно выполненный ранее выпуск на портале DevOps.
1. Наведите указатель мыши на этап "prod".
1. Выберите Deploy (Развернуть).

![Повышение уровня до рабочей среды](../media/common/prod-promote.png)

Наш пример конвейера CI/CD использует переменные, чтобы изменить префикс DNS для *webfrontend* в зависимости от развертываемой среды. Поэтому, чтобы получить доступ к службам "prod", можно использовать такие URL-адреса, как `http://prod.webfrontend.<hash>.<region>.aksapp.io`.

После развертывания этот URL-адрес можно найти с помощью интерфейса командной строки *kubectl*: <!-- TODO update below to use list-uris when the product has been updated to list non-azds ingresses #769297 -->

```cmd
kubectl get ingress -n prod webfrontend -o=jsonpath="{.spec.rules[0].host}"
```

## <a name="dev-spaces-instrumentation-in-production"></a>Инструментирование Dev Spaces в рабочей среде
Хотя инструментирование Dev Spaces создавалось, чтобы _не_ препятствовать нормальной работе вашего приложения, мы рекомендуем запускать рабочие нагрузки для рабочих сред в пространстве имен Kubernetes, которое не поддерживает Dev Spaces. С этим типом пространства имен Kubernetes вам следует либо создать пространство имен для рабочей среды с помощью интерфейса командной строки `kubectl`, либо разрешить системе CI/CD создать его при первом развертывании Helm. _Выбрав_ или создав пространство с помощью инструментов Dev Spaces, вы таким образом добавите инструментирование Dev Spaces в это пространство имен.

Ниже приведен пример структуры пространства имен, которая поддерживает разработку функций, среду "dev" _и_ рабочую среду в одном кластере Kubernetes:

![Пример структуры пространства имен](../media/common/cicd-namespaces.png)

> [!Tip]
> Если вы уже создали пространство `prod` и хотите исключить его из инструментирования Dev Spaces (но не удалять!), это можно сделать с помощью приведенной ниже команды в интерфейсе командной строки Dev Spaces:
>
> `azds space remove -n prod --no-delete`
>
> После этого может потребоваться удалить все объекты pod в пространстве имен `prod`, чтобы их можно было воссоздать без инструментирования Dev Spaces.

## <a name="next-steps"></a>Дополнительная информация

> [!div class="nextstepaction"]
> [Сведения о коллективной разработке с помощью Azure Dev Spaces](../team-development-netcore.md)