---
title: "Выполнение конвейера и триггеры в фабрике данных Azure | Документация Майкрософт"
description: "В этой статье объясняется, как выполнить конвейер в фабрике данных Azure по запросу или путем создания триггера."
services: data-factory
documentationcenter: 
author: sharonlo101
manager: jhubbard
editor: spelluru
ms.service: data-factory
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: get-started-article
ms.date: 01/03/2018
ms.author: shlo
ms.openlocfilehash: fc34cfbab796c6e1e4cd25ce13dcc63c39c6699d
ms.sourcegitcommit: 79683e67911c3ab14bcae668f7551e57f3095425
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/25/2018
---
# <a name="pipeline-execution-and-triggers-in-azure-data-factory"></a>Выполнение конвейера и триггеры в фабрике данных Azure
> [!div class="op_single_selector" title1="Select the version of the Data Factory service that you're using:"]
> * [Версия 1 — общедоступная](v1/data-factory-scheduling-and-execution.md)
> * [Версия 2 — предварительная](concepts-pipeline-execution-triggers.md)

Термин _выполнение конвейера_ во второй версии фабрики данных Azure обозначает отдельный экземпляр выполнения конвейера. Например, у вас есть конвейер, который выполняется в 8:00, 09:00 и 10:00. В этом случае выполняются три отдельных запуска конвейера. Каждый запуск конвейера имеет уникальный идентификатор запуска конвейера, однозначно его определяющий. Запуск конвейера обычно создается путем передачи аргументов в параметры, определенные в конвейерах. Конвейер можно выполнить двумя способами: вручную или с помощью _триггера_. Эта статья подробно описывает оба способа.

> [!NOTE]
> Эта статья относится к фабрике данных Azure версии 2, которая в настоящее время доступна в предварительной версии. Если вы используете фабрику данных Azure версии 1, которая является общедоступной версией (GA), ознакомьтесь со статьей [Планирование и исполнение с использованием фабрики данных](v1/data-factory-scheduling-and-execution.md).

## <a name="manual-execution-on-demand"></a>Выполнение вручную (по запросу)
Выполнение конвейера вручную также называется выполнением _по требованию_.

Предположим, у вас есть простой конвейер с именем **copyPipeline**, который вы хотите выполнить. Это конвейер с одним действием, которое копирует данные из папки источника, расположенной в хранилище BLOB-объектов Azure, в папку приемника в том же хранилище. В следующем определении JSON показан этот пример конвейера:

```json
{
  "name": "copyPipeline",
  "properties": {
    "activities": [
      {
        "type": "Copy",
        "typeProperties": {
          "source": {
            "type": "BlobSource"
          },
          "sink": {
            "type": "BlobSink"
          }
        },
        "name": "CopyBlobtoBlob",
        "inputs": [
          {
            "referenceName": "sourceBlobDataset",
            "type": "DatasetReference"
          }
        ],
        "outputs": [
          {
            "referenceName": "sinkBlobDataset",
            "type": "DatasetReference"
          }
        ]
      }
    ],
    "parameters": {
      "sourceBlobContainer": {
        "type": "String"
      },
      "sinkBlobContainer": {
        "type": "String"
      }
    }
  }
}
```

В определении JSON этот конвейер принимает два параметра: **sourceBlobContainer** и **sinkBlobContainer**. Значения этих параметров передаются во время выполнения.

Вы можете вручную запустить свой конвейер, используя следующие методы:
- пакет SDK для .NET;
- модуль Azure PowerShell;
- REST API;
- пакет SDK для Python.

### <a name="the-rest-api"></a>Вызов REST API
В следующем примере команды показано, как запустить конвейер вручную с помощью REST API:  

```
POST
https://management.azure.com/subscriptions/mySubId/resourceGroups/myResourceGroup/providers/Microsoft.DataFactory/factories/myDataFactory/pipelines/copyPipeline/createRun?api-version=2017-03-01-preview
```

Полный пример см. в статье [Создание фабрики данных Azure и конвейера с помощью REST API](quickstart-create-data-factory-rest-api.md).

### <a name="azure-powershell"></a>Azure PowerShell
В следующем примере команды показано, как запустить конвейер вручную с помощью Azure PowerShell:

```powershell
Invoke-AzureRmDataFactoryV2Pipeline -DataFactory $df -PipelineName "Adfv2QuickStartPipeline" -ParameterFile .\PipelineParameters.json
```

Параметры передаются в тексте полезных данных запроса. В пакетах SDK для .NET, Azure Powershell и Python можно передавать значения в словарь, который передается в качестве аргумента вызова:

```json
{
  “sourceBlobContainer”: “MySourceFolder”,
  “sinkBlobCountainer”: “MySinkFolder”
}
```

Полезные данные ответа содержат уникальный идентификатор запуска конвейера.

```json
{
  "runId": "0448d45a-a0bd-23f3-90a5-bfeea9264aed"
}
```

Полный пример см. в статье [Создание фабрики данных Azure с помощью PowerShell](quickstart-create-data-factory-powershell.md).

### <a name="the-net-sdk"></a>Пакет SDK для .NET
В следующем примере вызова показано, как запустить конвейер вручную с помощью .NET SDK:

```csharp
client.Pipelines.CreateRunWithHttpMessagesAsync(resourceGroup, dataFactoryName, pipelineName, parameters)
```

Полный пример см. в статье [Создание фабрики данных и конвейера с помощью пакета SDK .NET](quickstart-create-data-factory-dot-net.md).

> [!NOTE]
> Пакет SDK .NET можно использовать для вызова конвейеров фабрики Azure данных из решения "Функции Azure", собственных веб-служб и т. д.

<h2 id="triggers">Выполнение триггера</h2>
Вторым способом запуска конвейера являются триггеры. Триггеры обозначает единицу обработки, которая определяет время запуска для выполнения конвейера. В настоящее время фабрика данных Azure поддерживает два типа триггеров:
- Триггер планировщика. Триггер, который запускает конвейер в определенное время по расписанию.
- Триггер "переворачивающегося" окна. Триггер, который работает на основе периодических интервалов, сохраняя состояние. Фабрика данных Azure в настоящее время не поддерживает триггеры на основе событий, например, триггер для запуска конвейера, реагирующий на событие получения файла.

Конвейеры и триггеры имеют связь "многие ко многим". Несколько триггеров могут запускать один конвейер, а один триггер может запускать несколько конвейеров. В следующем определении триггера свойство **конвейеры** ссылается на список конвейеров, запускаемых определенным триггером. Определение свойства содержит значения для параметров конвейера.

### <a name="basic-trigger-definition"></a>Базовое определение триггера

```json
    "properties": {
        "name": "MyTrigger",
        "type": "<type of trigger>",
        "typeProperties": {
            …
        },
        "pipelines": [
            {
                "pipelineReference": {
                    "type": "PipelineReference",
                    "referenceName": "<Name of your pipeline>"
                },
                "parameters": {
                    "<parameter 1 Name>": {
                        "type": "Expression",
                          "value": "<parameter 1 Value>"
                    },
                    "<parameter 2 Name>" : "<parameter 2 Value>"
                }
            }
        ]
    }
```

## <a name="schedule-trigger"></a>Триггер планировщика
Триггер планировщика запускает конвейер в определенное время по расписанию. Этот триггер поддерживает периодичность и расширенные возможности календаря. Например, триггер поддерживает такие интервалы, как "еженедельно" или "каждую неделю, в 17:00 по понедельникам и в 21:00 по четвергам". Триггер планировщика гибкий, так как шаблон набора данных не важен, а триггер не различает данные временных рядов и данные, не относящиеся к временным рядам.

Дополнительные сведения о триггерах планировщика и примеры см. в руководстве по [созданию триггера расписания](how-to-create-schedule-trigger.md).

## <a name="tumbling-window-trigger"></a>Триггер "переворачивающегося" окна
Триггер "переворачивающегося" окна — это тип триггера, который активируется с определенным интервалом начиная с указанного времени запуска, сохраняя состояние. "Переворачивающиеся" окна — это ряд неперекрывающихся и несоприкасающихся интервалов времени фиксированного размера. Дополнительные сведения об этом типе триггеров и примеры см. в статье, объясняющей, [как создать триггер "переворачивающегося" окна](how-to-create-tumbling-window-trigger.md).

## <a name="schedule-trigger-definition"></a>Определение триггера планировщика
При создании триггера планировщика нужно указать расписание и повторения с помощью определения JSON. 

Чтобы триггер планировщика выполнял конвейер, включите в определении триггера ссылку на нужный конвейер. Конвейеры и триггеры имеют связь "многие ко многим". Несколько триггеров могут запускать один конвейер. Один триггер может запускать несколько конвейеров.

```json
{
  "properties": {
    "type": "ScheduleTrigger",
    "typeProperties": {
      "recurrence": {
        "frequency": <<Minute, Hour, Day, Week, Year>>,
        "interval": <<int>>,             // How often to fire
        "startTime": <<datetime>>,
        "endTime": <<datetime>>,
        "timeZone": "UTC"
        "schedule": {                    // Optional (advanced scheduling specifics)
          "hours": [<<0-24>>],
          "weekDays": ": [<<Monday-Sunday>>],
          "minutes": [<<0-60>>],
          "monthDays": [<<1-31>>],
          "monthlyOccurences": [
               {
                    "day": <<Monday-Sunday>>,
                    "occurrence": <<1-5>>
               }
           ] 
        }
      }
    },
   "pipelines": [
            {
                "pipelineReference": {
                    "type": "PipelineReference",
                    "referenceName": "<Name of your pipeline>"
                },
                "parameters": {
                    "<parameter 1 Name>": {
                        "type": "Expression",
                        "value": "<parameter 1 Value>"
                    },
                    "<parameter 2 Name>" : "<parameter 2 Value>"
                }
           }
      ]
  }
}
```

> [!IMPORTANT]
> Свойство **parameters** является обязательным свойством для элемента **pipelines**. Если конвейер не принимает никаких параметров, необходимо включить пустое определение JSON для свойства **parameters**.

### <a name="schema-overview"></a>Общее представление схемы
Таблица ниже содержит обзор основных элементов схемы, связанных с периодичностью выполнения и расписанием триггера:

| Свойство JSON | ОПИСАНИЕ |
|:--- |:--- |
| **startTime** | Значение даты и времени. Для простых расписаний значение свойства **startTime** применяется к первому вхождению. В сложных расписаниях триггер не запускается раньше, чем определяется значением **startTime**. |
| **endTime** | Дата и время завершения триггера. После указанной даты и времени триггер перестает выполняться. Значение свойства не может быть в прошлом. <!-- This property is optional. --> |
| **timeZone** | Часовой пояс. В настоящее время поддерживается только часовой пояс UTC. |
| **recurrence** | Объект recurrence указывает правила повторения для триггера. Этот объект поддерживает следующие элементы: **frequency**, **interval**, **endTime**, **count** и **schedule**. Если определен объект recurrence, элемент **frequency** является обязательным. Другие элементы объекта recurrence являются необязательными. |
| **frequency** | Единица частоты, с которой выполняется триггер. Поддерживаются следующие значения: "минута", "час", "день", "неделя" и "месяц". |
| **interval** | Положительное целое число, указывающее интервал для значения **frequency**, которое определяет, как часто выполняется триггер. Например, если **interval** имеет значение 3, а для элемента **frequency** выбран вариант "неделя", триггер выполняется один раз каждые 3 недели. |
| **schedule** | Расписание повторения для триггера. Триггер с указанным значением **частоты** выполняется по расписанию. Свойство **schedule** содержит изменения для повторения, основанного на минутах, часах, неделях, днях месяца и номере недели.

### <a name="schedule-trigger-example"></a>Пример триггера расписания

```json
{
    "properties": {
        "name": "MyTrigger",
        "type": "ScheduleTrigger",
        "typeProperties": {
            "recurrence": {
                "frequency": "Hour",
                "interval": 1,
                "startTime": "2017-11-01T09:00:00-08:00",
                "endTime": "2017-11-02T22:00:00-08:00"
            }
        },
        "pipelines": [{
                "pipelineReference": {
                    "type": "PipelineReference",
                    "referenceName": "SQLServerToBlobPipeline"
                },
                "parameters": {}
            },
            {
                "pipelineReference": {
                    "type": "PipelineReference",
                    "referenceName": "SQLServerToAzureSQLPipeline"
                },
                "parameters": {}
            }
        ]
    }
}
```

### <a name="schema-defaults-limits-and-examples"></a>Параметры схемы по умолчанию, ограничения и примеры

| Свойство JSON | type | Обязательно | Значение по умолчанию | Допустимые значения | Пример |
|:--- |:--- |:--- |:--- |:--- |:--- |
| **startTime** | Строка | Yes | Нет | Дата и время по спецификации ISO-8601 | `"startTime" : "2013-01-09T09:30:00-08:00"` |
| **recurrence** | Объект. | Yes | Нет | Объект recurrence | `"recurrence" : { "frequency" : "monthly", "interval" : 1 }` |
| **interval** | Number | Нет  | 1 | 1–1000 | `"interval":10` |
| **endTime** | Строка | Yes | Нет | Значение даты и времени, представляющее время в будущем. | `"endTime" : "2013-02-09T09:30:00-08:00"` |
| **schedule** | Объект. | Нет  | Нет | Объект schedule | `"schedule" : { "minute" : [30], "hour" : [8,17] }` |

### <a name="starttime-property"></a>Свойство startTime
В следующей таблице показано, как свойство **startTime** управляет запуском триггера:

| Значение startTime | Повторение без расписания | Повторение с расписанием |
|:--- |:--- |:--- |
| Время начала в прошлом | Вычисляется время первого выполнения, относящееся к будущему времени, после указанного времени начала.<br/><br/>Последующие выполнения вычисляются с учетом времени предыдущего выполнения.<br/><br/>Пример представлен после этой таблицы. | Триггер выполняется _не раньше_ указанного времени начала. Первое выполнение производится по расписанию, которое отсчитывается от времени начала.<br/><br/>Последующие выполнения производятся по расписанию повторов. |
| Время начала в будущем или в настоящем | Выполняется первый раз в указанное время начала.<br/><br/>Последующие выполнения вычисляются с учетом времени предыдущего выполнения. | Триггер выполняется _не раньше_ указанного времени начала. Первое выполнение производится по расписанию, которое отсчитывается от времени начала.<br/><br/>Последующие выполнения производятся по расписанию повторов. |

Рассмотрим, как работает триггер, для которого время начала установлено в прошлом, указан параметр recurrence и отсутствует параметр schedule. Предположим, что текущее время — `2017-04-08 13:00`, время начала — `2017-04-07 14:00`, а повторение — каждые два дня. (Значение **recurrence** определяется путем указания для свойства **frequency** значения "день", а для свойства **interval** значение 2.) Обратите внимание, что значение **startTime** находится в прошлом, то есть наступает раньше текущего времени.

В этих условиях первое выполнение происходит `2017-04-09 at 14:00`. От времени начала ядро планировщика отсчитывает время повторных выполнений. Выполнения, которые приходятся на прошлое, игнорируются. Ядро берет очередной случай выполнения, который приходится на будущее. В данном сценарии время начала имеет значение `2017-04-07 at 2:00pm`, поэтому следующее выполнение состоится через 2 дня от этого времени начала, то есть `2017-04-09 at 2:00pm`.

Время первого выполнения останется тем же, даже если **startTime** имеет значение `2017-04-05 14:00` или `2017-04-01 14:00`. Все последующие выполнения после первого вычисляются по расписанию schedule. Таким образом, последующие выполнения проходят в `2017-04-11 at 2:00pm`, затем в `2017-04-13 at 2:00pm`, затем в `2017-04-15 at 2:00pm` и т. д.

Наконец, когда часы или минуты не установлены в расписании триггера, часы или минуты первого выполнения используются как значения по умолчанию.

### <a name="schedule-property"></a>Свойства schedule
С одной стороны, использование параметра schedule может ограничивать число выполнений триггера. Например, если триггеру назначена ежемесячная частота и параметр schedule, который запускает триггер только в 31-й день месяца, он будет выполняться только в те месяцы, в которых есть 31 день.

Обратите внимание, что параметр schedule может увеличивать число выполнений триггера. Например, триггер с ежемесячной частотой и параметром schedule, который запускает триггер в 1 и 2 день месяца, будет выполняться в первый и второй дни месяца, а не раз в месяц.

При наличии нескольких указанных элементов **schedule** порядок вычисляется от наибольшего параметра расписания к меньшему. Оценка начинается с номера недели, а затем месяца, дня недели, часа и, наконец, минут.

В следующей таблице элементы параметра **schedule** описаны подробно:

| Элемент JSON | ОПИСАНИЕ | Допустимые значения |
|:--- |:--- |:--- |
| **minutes** | Минуты часа, в которые будет выполняться триггер. | <ul><li>Целое число </li><li>массив целых чисел</li></ul>
| **hours** | Часы дня, в которые будет выполняться триггер. | <ul><li>Целое число </li><li>массив целых чисел</li></ul> |
| **weekDays** | Дни недели, по которым выполняется триггер. Значение можно указать только с еженедельной частотой. | <ul><li>Понедельник, вторник, среда, четверг, пятница, суббота, воскресенье</li><li>Массив значений дня (максимальный размер массива — 7)</li><li>Значения дня можно вводить в любом регистре.</li></ul> |
| **monthlyOccurrences** | Дни месяца, по которым выполняется триггер. Значение можно указать только с ежемесячной частотой. | <ul><li>Массив объектов **monthlyOccurence**: `{ "day": day,  "occurrence": occurence }`.</li><li>Атрибут **day** является днем недели, в который выполняется триггер. Например, свойство **monthlyOccurrences** со значением **day** равным `{Sunday}` означает каждое воскресенье месяца. Атрибут **day** является обязательным.</li><li>Атрибут **occurrence** является частотой появления определенного **дня** на протяжении месяца. Например, свойство **monthlyOccurrences** со значениями **day** и **occurrence** равными `{Sunday, -1}` означает последнее воскресенье месяца. Атрибут **occurrence** не является обязательным.</li></ul> |
| **monthDays** | Дни месяца, по которым выполняется триггер. Значение можно указать только с ежемесячной частотой. | <ul><li>Любое значение <= -1 и >= -31</li><li>Любое значение >= 1 и <= 31</li><li>Массив значений</li></ul> |

## <a name="examples-of-trigger-recurrence-schedules"></a>Примеры расписаний повторения триггеров
Этот раздел содержит примеры расписания повторений с применением объекта **schedule** и его элементов.

В примерах предполагается, что **interval** имеет значение равное 1, а значение **frequency** является правильным согласно определению расписания. Например, у вас не может быть значения **frequency** "день" и изменение monthDays в объекте **schedule**. Такие ограничения указаны в таблице в предыдущем разделе.

| Пример | ОПИСАНИЕ |
|:--- |:--- |
| `{"hours":[5]}` | Задание выполняется каждый день в 5:00. |
| `{"minutes":[15], "hours":[5]}` | Задание выполняется каждый день в 5:15. |
| `{"minutes":[15], "hours":[5,17]}` | Задание выполняется каждый день в 5:15 и 16:15. |
| `{"minutes":[15,45], "hours":[5,17]}` | Задание выполняется каждый день в 5:15, 5:45, 16:15 и 16:45. |
| `{"minutes":[0,15,30,45]}` | Выполнение каждые 15 минут. |
| `{hours":[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]}` | Выполнение каждый час. Этот триггер запускается каждый час. Минуты управляются значением **startTime**, когда оно указано. Если значение не указано, управление минутами осуществляется в соответствии с временем создания. Например, если триггер запущен или создан (в зависимости от ситуации) в 12:25, он будет запускаться в 00:25, 01:25, 02:25 и т. д. и 23:25.<br/><br/>Это расписание работает так же, как триггер с **частотой** "час", значением 1 для параметра **interval** и без параметра **schedule**. Это расписание можно использовать с различными значениями **частот** и **интервалов** для создания других триггеров. Например, если значение **частоты** — "месяц", расписание выполняется один раз в месяц, а не каждый день, когда **частота** имеет значение "день". |
| `{"minutes":[0]}` | Задание выполняется с наступлением каждого часа. Этот триггер выполняется с наступлением каждого часа, начиная с 12:00, 13:00, 14:00 и т. д.<br/><br/>Это расписание является эквивалентом триггера со значением **частоты** равным "час" и значением **startTime** без минут или без **расписания**, но со значением **частоты** "день". Если значение **частоты** равно "неделя" или "месяц", расписание выполняется только один раз в неделю или один раз в месяц соответственно. |
| `{"minutes":[15]}` | Задание выполняется через 15 минут после наступления каждого часа. Этот триггер выполняется через 15 минут после наступления каждого часа, начиная с 00:15, 1:15, 2:15 и т. д. и заканчивается в 23:15. |
| `{"hours":[17], "weekDays":["saturday"]}` | Задание выполняется в 17:00 каждую субботу. |
| `{"hours":[17], "weekDays":["monday", "wednesday", "friday"]}` | Задание выполняется в 17:00 в каждые понедельник, среду и пятницу. |
| `{"minutes":[15,45], "hours":[17], "weekDays":["monday", "wednesday", "friday"]}` | Задание выполняется в 17:15 и 17:45 в каждые понедельник, среду и пятницу. |
| `{"minutes":[0,15,30,45], "weekDays":["monday", "tuesday", "wednesday", "thursday", "friday"]}` | Задание выполняется каждые 15 минут в каждый рабочий день. |
| `{"minutes":[0,15,30,45], "hours": [9, 10, 11, 12, 13, 14, 15, 16] "weekDays":["monday", "tuesday", "wednesday", "thursday", "friday"]}` | Задание выполняется каждые 15 минут в период с 09:00 до 16:45 в каждый рабочий день. |
| `{"weekDays":["tuesday", "thursday"]}` | Задание выполняется по вторникам и четвергам в указанное время начала. |
| `{"minutes":[0], "hours":[6], "monthDays":[28]}` | Задание выполняется в 6:00 28 числа каждого месяца (при условии, что значение **частоты** — месяц). |
| `{"minutes":[0], "hours":[6], "monthDays":[-1]}` | Задание выполняется в 06:00 в последний день месяца. Чтобы триггер запускался в последний день месяца, используйте –1 вместо значения 28, 29, 30 или 31. |
| `{"minutes":[0], "hours":[6], "monthDays":[1,-1]}` | Задание выполняется в 06:00 в первый и последний день каждого месяца. |
| `{monthDays":[1,14]}` | Задание выполняется в первый и 14-й день каждого месяца в указанное время начала. |
| `{"minutes":[0], "hours":[5], "monthlyOccurrences":[{"day":"friday", "occurrence":1}]}` | Задание выполняется в первую пятницу каждого месяца в 05:00. |
| `{"monthlyOccurrences":[{"day":"friday", "occurrence":1}]}` | Задание выполняется в первую пятницу каждого месяца в указанное время начала. |
| `{"monthlyOccurrences":[{"day":"friday", "occurrence":-3}]}` | Задание выполняется в третью пятницу с конца каждого месяца в указанное время начала. |
| `{"minutes":[15], "hours":[5], "monthlyOccurrences":[{"day":"friday", "occurrence":1},{"day":"friday", "occurrence":-1}]}` | Задание выполняется первую и последнюю пятницу каждого месяца в 05:15. |
| `{"monthlyOccurrences":[{"day":"friday", "occurrence":1},{"day":"friday", "occurrence":-1}]}` | Задание выполняется в первую и последнюю пятницу каждого месяца в указанное время начала. |
| `{"monthlyOccurrences":[{"day":"friday", "occurrence":5}]}` | Задание выполняется в пятую пятницу каждого месяца в указанное время начала. Если пятой пятницы в месяце нет, конвейер не выполняется, так как по расписанию он должен выполняться только по пятым пятницам. Чтобы триггер выполнялся в последнюю пятницу месяца, используйте вместо значения **повторения** 5 значение –1. |
| `{"minutes":[0,15,30,45], "monthlyOccurrences":[{"day":"friday", "occurrence":-1}]}` | Задание выполняется каждые 15 минут в последнюю пятницу месяца. |
| `{"minutes":[15,45], "hours":[5,17], "monthlyOccurrences":[{"day":"wednesday", "occurrence":3}]}` | Задание выполняется в 5:15, 5:45, 17:15, 17:45 в третью среду каждого месяца. |

## <a name="trigger-type-comparison"></a>Сравнение типов триггеров
Если триггер "переворачивающегося" окна и триггер расписания работают с одинаковыми интервалами времени, чем они отличаются?

В следующей таблице представлено сравнение триггера "переворачивающегося" окна и триггера расписания:

|  | Триггер&nbsp;"переворачивающегося"&nbsp;окна | Триггер&nbsp;расписания |
|:--- |:--- |:--- |
| **Сценарии&nbsp; с задним числом** | Поддерживается. Выполнения конвейера можно запланировать для окон в прошлом. | Не поддерживается. Конвейер можно выполнить только в периоды времени в настоящем и будущем. |
| **Надежность** | 100 % надежность. Запуск конвейеров можно запланировать для всех окон с заданной датой начала без пробелов. | Меньшая надежность. |
| **Повторные&nbsp;попытки** | Поддерживается. При сбое запуска конвейера по умолчанию политика повторного запуска настроена на 0 повторных попыток. Или пользователь может указать количество повторных попыток в определении триггера. Автоматически выполняет повтор при сбое из-за ограничений параллелизма, сервера и регулирования (т. е. коды состояния "400: ошибка пользователя", "429: слишком много запросов" и "500: внутренняя ошибка сервера"). | Не поддерживается. |
| **Параллелизм** | Поддерживается. Пользователи могут явно задавать ограничения параллелизма для триггера. Позволяет от 1 до максимум 50 одновременных активированных выполнений конвейера. | Не поддерживается. |
| **Системные&nbsp;переменные** | Поддерживают использование системных переменных **WindowStart** и **WindowEnd**. Пользователи могут получить доступ к `triggerOutputs().windowStartTime` и `triggerOutputs().windowEndTime` как к системным переменным триггера в определении триггера. Значения используются как время начала и окончания окна соответственно. Например, для триггера "переворачивающегося" окна, выполняющегося каждый час, в окне от 1:00 до 2:00 определением является `triggerOutputs().WindowStartTime = 2017-09-01T01:00:00Z` и `triggerOutputs().WindowEndTime = 2017-09-01T02:00:00Z`. | Не поддерживается. |
| **Связь триггера и конвейера** | Поддерживает связь "один к одному". Вы можете активировать только один конвейер. | Поддерживает связи "многие ко многим" Несколько триггеров могут запускать один конвейер. Один триггер может запускать несколько конвейеров. | 

## <a name="next-steps"></a>Дополнительная информация
Ознакомьтесь со следующими руководствами:

- [Создание фабрики данных и конвейера с помощью пакета SDK .NET](quickstart-create-data-factory-dot-net.md)
- [Create a trigger that runs a pipeline on a schedule](how-to-create-schedule-trigger.md) (Создание триггера, запускающего конвейер по расписанию)
- [Create a trigger that runs a pipeline on a tumbling window](how-to-create-tumbling-window-trigger.md) (Создание триггера, который запускает конвейер в "переворачивающемся" окне)
