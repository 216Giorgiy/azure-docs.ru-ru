---
title: Триггеры и действия для рабочих процессов в Azure Logic Apps | Документация Майкрософт
description: Сведения о триггерах и действиях для создания автоматизированных рабочих процессов и процессов с помощью приложений логики.
services: logic-apps
author: divyaswarnkar
manager: anneta
editor: ''
documentationcenter: ''
ms.assetid: 86a53bb3-01ba-4e83-89b7-c9a7074cb159
ms.service: logic-apps
ms.workload: integration
ms.tgt_pltfrm: na
ms.devlang: multiple
ms.topic: article
ms.date: 10/13/2017
ms.author: klam; LADocs
ms.openlocfilehash: 28d28888ce66c354da39dc636579655aadbb9e51
ms.sourcegitcommit: 59914a06e1f337399e4db3c6f3bc15c573079832
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/20/2018
---
# <a name="triggers-and-actions-for-logic-app-workflows"></a>Триггеры и действия для рабочих процессов приложений логики

Все приложения логики запускаются триггером с последующими действиями. В этой статье описываются типы триггеров и действий, которые можно использовать для создания интеграции систем и автоматизации бизнес-процессов с помощью приложений логики. 
  
## <a name="triggers-overview"></a>Общие сведения о триггерах 

Все приложения логики запускаются триггером, который указывает вызовы, способные запускать выполнение приложения логики. Ниже приведены типы триггеров, которые можно использовать:

* *Опрашивающий триггер*, который проверяет конечную точку службы HTTP через равные промежутки времени.
* *Извещающий триггер*, который вызывает [REST API службы рабочих процессов](https://docs.microsoft.com/rest/api/logic/workflows).
  
Все триггеры содержат следующие элементы верхнего уровня:  
  
```json
"<myTriggerName>": {
    "type": "<triggerType>",
    "inputs": { <callSettings> },
    "recurrence": {  
        "frequency": "Second | Minute | Hour | Day | Week | Month | Year",
        "interval": "<recurrence-interval-based-on-frequency>"
    },
    "conditions": [ <array-with-required-conditions> ],
    "splitOn": "<property-used-for-creating-runs>",
    "operationOptions": "<options-for-operations-on-the-trigger>"
}
```

## <a name="trigger-types-and-inputs"></a>Типы и входные данные триггеров  

Каждый тип триггера имеет свой интерфейс и свои *входные данные*, которые определяют его поведение. 

| Тип триггера | ОПИСАНИЕ | 
| ------------ | ----------- | 
| **Периодичность** | Активируется на основе определенного расписания. Можно задать дату и время в будущем для срабатывания триггера. Основываясь на частоте, можно также указать время и дни, когда должен запускаться рабочий процесс. | 
| **Запрос**  | Превращает приложение логики в конечную точку, которую можно вызвать, Также называется "ручным" триггером. | 
| **HTTP** | Проверяет или *опрашивает* конечную веб-точку HTTP. Конечная точка HTTP должна соответствовать определенному условию триггера — используя шаблон асинхронных операций 202 или возвращая массив. | 
| **ApiConnection** | Опрашивает, как и триггер HTTP, но использует [интерфейсы API, управляемые Майкрософт](../connectors/apis-list.md). | 
| **HTTPWebhook** | Превращает приложение логики в вызываемую конечную точку, как и триггер **запросов**, но вызывает определенный URL-адрес для регистрации и отмены регистрации. |
| **ApiConnectionWebhook** | Работает по принципу триггера **HTTPWebhook**, но использует интерфейсы API, управляемые Майкрософт. | 
||| 

См. дополнительные сведения о [языке определения рабочего процесса](../logic-apps/logic-apps-workflow-definition-language.md). 

<a name="recurrence-trigger"></a>

## <a name="recurrence-trigger"></a>Триггер повторения  

Этот триггер выполняется на основе указанных вами параметров повторения и расписания и предоставляет простой способ регулярного запуска рабочего процесса. 

Ниже приведен пример простого триггера повторения, который запускается ежедневно:

```json
"myRecurrenceTrigger": {
    "type": "Recurrence",
    "recurrence": {
        "frequency": "Day",
        "interval": 1
    }
}
```

Вы также можете запланировать дату и время, когда триггер будет срабатывать. Например, чтобы еженедельный отчет запускался каждый понедельник, можно запланировать запуск приложения логики на определенный понедельник, как в этом примере: 

```json
"myRecurrenceTrigger": {
    "type": "Recurrence",
    "recurrence": {
        "frequency": "Week",
        "interval": "1",
        "startTime": "2017-09-18T00:00:00Z"
    }
}
```

Ниже приведено определение для этого триггера:

```json
"myRecurrenceTrigger": {
    "type": "Recurrence",
    "recurrence": {
        "frequency": "second|minute|hour|day|week|month",
        "interval": <recurrence-interval-based-on-frequency>,
        "schedule": {
            // Applies only when frequency is Day or Week. Separate values with commas.
            "hours": [ <one-or-more-hour-marks> ], 
            // Applies only when frequency is Day or Week. Separate values with commas.
            "minutes": [ <one-or-more-minute-marks> ], 
            // Applies only when frequency is Week. Separate values with commas.
            "weekDays": [ "Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday" ] 
        },
        "startTime": "<start-date-time-with-format-YYYY-MM-DDThh:mm:ss>",
        "timeZone": "<specify-time-zone>"
    }
}
```

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- | 
| frequency | Yes | Строка | Единица времени для указания частоты срабатывания триггера. Используйте только одно из этих значений: second (секунда), minute (минута), hour (час), day (день), week (неделя) или month (месяц). | 
| interval | Yes | Целое число  | Положительное целое число, которое описывает, как часто выполняется рабочий процесс с учетом заданной частоты. <p>Ниже приведены минимальный и максимальный интервалы. <p>— Месяц: 1–16 месяцев; </br>— День: 1–500 дней; </br>— Час: 1–12 000 часов; </br>— Минута: 1–72 000 минут; </br>- Second: 1–9 999 999 секунд.<p>Например, если интервал равен 6, а значение частоты — month, то повтор будет происходить каждые 6 месяцев. | 
| timeZone | Нет  | Строка | Применяется только при указании времени начала, так как этот триггер не принимает [смещение от UTC](https://en.wikipedia.org/wiki/UTC_offset). Укажите часовой пояс, который необходимо применить. | 
| startTime | Нет  | Строка | Укажите дату и время начала в таком формате: <p>ГГГГ-ММ-ДДTчч:мм:сс, если указан часовой пояс, <p>-или- <p>ГГГГ-ММ-ДДTчч:мм:ссZ, если часовой пояс не указан. <p>Например, если требуется указать 18 сентября 2017 г. в 14:00, то используйте 2017-09-18T14:00:00 и укажите часовой пояс, такой как "Стандартное тихоокеанское время". Или укажите 2017-09-18T14:00:00Z без часового пояса. <p>**Примечание.** Это время начала должно соответствовать [спецификации даты и времени ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) в [формате UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time), но без [смещения от UTC](https://en.wikipedia.org/wiki/UTC_offset). Если не указать часовой пояс, то необходимо в конце добавить букву Z без пробелов. Эта буква Z ссылается на соответствующее [судовое время](https://en.wikipedia.org/wiki/Nautical_time). <p>В простых расписаниях время начала определяет первый случай выполнения задания, а в сложных расписаниях триггер срабатывает не раньше, чем наступит время начала. Дополнительные сведения о дате и времени начала см. в статье [Начало работы с триггером повторения](../connectors/connectors-native-recurrence.md). | 
| weekDays | Нет  | Строка или массив строк | Если для параметра `frequency` задать значение Week, то можно указать один или несколько дней, разделенных запятыми. В эти дни будет запускаться рабочий процесс: Monday (Понедельник), Tuesday (Вторник), Wednesday (Среда), Thursday (Четверг), Friday (Пятница), Saturday (Суббота) и Sunday (Воскресенье). | 
| hours | Нет  | Целое число или массив целых чисел | Если для параметра `frequency` задать значение Day или Week, то можно указать одно или несколько целых чисел от 0 до 23, разделенных запятыми. В эти часы будет запускаться рабочий процесс. <p>Например, если указать 10, 12 и 14, вы получите часовые метки 10:00, 12:00 и 14:00. | 
| minutes | Нет  | Целое число или массив целых чисел | Если для параметра `frequency` задать значение Day или Week, то можно указать одно или несколько целых чисел от 0 до 59, разделенных запятыми. В эти минуты часа будет запускаться рабочий процесс. <p>Например, если указать 30 минут и использовать предыдущий пример для часов, то вы получите 10:30, 12:30 и 14:30. | 
||||| 

Например, в этом триггере повторения указано, что приложение логики должно выполняться еженедельно каждый понедельник в 10:30, 12:30 и 14:30 по стандартному тихоокеанскому времени, начиная не ранее 9 сентября 2017 г. с 14:00:

``` json
"myRecurrenceTrigger": {
    "type": "Recurrence",
    "recurrence": {
        "frequency": "Week",
        "interval": 1,
        "schedule": {
            "hours": [
                10,
                12,
                14
            ],
            "minutes": [
                30
            ],
            "weekDays": [
                "Monday"
            ]
        },
       "startTime": "2017-09-07T14:00:00",
       "timeZone": "Pacific Standard Time"
    }
}
```

Дополнительные сведения, а также примеры повторений и времени начала см. в статье [Начало работы с триггером повторения](../connectors/connectors-native-recurrence.md).

## <a name="request-trigger"></a>Триггер запросов

Этот триггер служит в качестве конечной точки, которую можно использовать для вызова приложения логики с помощью HTTP-запроса. Триггер запроса выглядит следующим образом:  
  
```json
"myRequestTrigger": {
    "type": "Request",
    "kind": "Http",
    "inputs": {
        "schema": {
            "type": "Object",
            "properties": {
                "myInputProperty1": { "type" : "string" },
                "myInputProperty2": { "type" : "number" }
            },
            "required": [ "myInputProperty1" ]
        }
    }
} 
```

Этот триггер также содержит необязательное свойство, которое называется `schema`:
  
| Имя элемента | Обязательно | type | ОПИСАНИЕ |
| ------------ | -------- | ---- | ----------- |
| schema | Нет  | Объект. | Схема JSON, которая проверяет входящий запрос. Используется, чтобы указать, на какие свойства ссылаться последующим действиям рабочего процесса. | 
||||| 

Для вызова этого триггера в качестве конечной точки необходимо вызвать API `listCallbackUrl`. См. сведения в статье [Рабочие процессы](https://docs.microsoft.com/rest/api/logic/workflows).

## <a name="http-trigger"></a>Триггер HTTP  

Этот триггер опрашивает указанную конечную точку и проверяет ответ, чтобы определить, следует ли выполнять рабочий процесс. Объект `inputs` принимает следующие параметры, необходимые для создания HTTP-вызова: 

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- | 
| метод | Yes | Строка | Использует один из этих методов HTTP: GET, POST, PUT, DELETE, PATCH или HEAD. | 
| uri | Yes| Строка | Конечная точка HTTP или HTTPS, которую проверяет триггер. Максимальный размер строки: 2 КБ. | 
| Запросы | Нет  | Объект. | Представляет любые параметры запроса, которые необходимо включить в URL-адрес. <p>Например, `"queries": { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес. | 
| Заголовки | Нет  | Объект. | Представляет каждый заголовок, который отправляется в запросе. <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` | 
| текст | Нет  | Объект. | Представляет полезные данные, отправляемые конечной точке. | 
| retryPolicy | Нет  | Объект. | Используйте этот объект, чтобы настроить поведение повтора при возникновении ошибок 4xx или 5xx. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md). | 
| authentication | Нет  | Объект. | Представляет метод, который должен использоваться запросом для аутентификации. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](../scheduler/scheduler-outbound-authentication.md). <p>Помимо планировщика, имеется еще одно поддерживаемое свойство: `authority`. По умолчанию его значение равно `https://login.windows.net`, если не указано другое. Также можно использовать другое значение, например `https://login.windows\-ppe.net`. | 
||||| 

Помимо исключений при подключении, *политика повтора* применяется к периодическим сбоям, классифицируемым как коды состояния HTTP 408, 429 и 5xx. Эту политику можно определить с помощью объекта `retryPolicy`, как показано ниже:
  
```json
"retryPolicy": {
    "type": "<retry-policy-type>",
    "interval": <retry-interval>,
    "count": <number-of-retry-attempts>
}
```

Для эффективной работы с приложением логики триггеру HTTP требуется, чтобы API HTTP соответствовал определенному шаблону. Триггер распознает следующие свойства:  
  
| Ответ | Обязательно | ОПИСАНИЕ | 
| -------- | -------- | ----------- |  
| Код состояния | Yes | Код состояния 200 (ОК) инициирует запуск. Другие коды состояния не вызывают запуск. | 
| Заголовок retry-after | Нет  | Количество секунд перед повторным опросом конечной точки приложением логики. | 
| Заголовок Location | Нет  | URL-адрес для вызова во время следующего интервала опроса. Если не указан, используется исходный URL-адрес. | 
|||| 

Ниже приведены некоторые примеры поведений для различных типов запросов.
  
| Код ответа | Повтор через | Поведение | 
| ------------- | ----------- | -------- | 
| 200 | {нет} | Выполняется рабочий процесс, затем после определенного количества повторений снова проверяется, не добавились ли данные. | 
| 200 | 10 с | Выполняется рабочий процесс, затем через 10 секунд снова проверяется, не добавились ли данные. |  
| 202 | 60 секунд | Рабочий процесс не запускается. Следующая попытка происходит через одну минуту с учетом определенного повторения. Если определенное повторение составляет менее минуты, то приоритет имеет заголовок retry-after. В противном случае используется определенное повторение. | 
| 400 | {нет} | Недопустимый запрос, рабочий процесс не запускается. Если параметр `retryPolicy` не задан, то используется политика по умолчанию. После достижения количества попыток триггер снова проверяет наличие данных после определенного числа повторений. | 
| 500 | {нет}| Ошибка сервера, рабочий процесс не запускается. Если параметр `retryPolicy` не задан, то используется политика по умолчанию. После достижения количества попыток триггер снова проверяет наличие данных после определенного числа повторений. | 
|||| 

Ниже приведены выходные данные триггера HTTP. 
  
| Имя элемента | type | ОПИСАНИЕ |
| ------------ | ---- | ----------- |
| Заголовки | Объект. | Заголовки HTTP-ответа. | 
| текст | Объект. | Текст HTTP-ответа. | 
|||| 

<a name="apiconnection-trigger"></a>

## <a name="apiconnection-trigger"></a>Триггер APIConnection  

Базовые функции этого триггера такие же, как у триггера HTTP. Однако параметры для определения действия различаются. Вот пример:    
  
```json
"myDailyReportTrigger": {
    "type": "ApiConnection",
    "inputs": {
        "host": {
            "api": {
                "runtimeUrl": "https://myarticles.example.com/"
            }
        },
        "connection": {
            "name": "@parameters('$connections')['myconnection'].name"
        }
    },  
    "method": "POST",
    "body": {
        "category": "myCategory"
    }
}
```

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- | 
| host | Yes | Объект. | Шлюз, где размещено приложение API, и его идентификатор. | 
| метод | Yes | Строка | Использует один из этих методов HTTP: GET, POST, PUT, DELETE, PATCH или HEAD. | 
| Запросы | Нет  | Объект. | Представляет любые параметры запроса, которые необходимо включить в URL-адрес. <p>Например, `"queries": { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес. | 
| Заголовки | Нет  | Объект. | Представляет каждый заголовок, который отправляется в запросе. <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` | 
| текст | Нет  | Объект. | Представляет полезные данные, отправляемые конечной точке. | 
| retryPolicy | Нет  | Объект. | Используйте этот объект, чтобы настроить поведение повтора при возникновении ошибок 4xx или 5xx. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md). | 
| authentication | Нет  | Объект. | Представляет метод, который должен использоваться запросом для аутентификации. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](../scheduler/scheduler-outbound-authentication.md). | 
||||| 

Ниже приведены свойства для объекта `host`.  
  
| Имя элемента | Обязательно | ОПИСАНИЕ | 
| ------------ | -------- | ----------- | 
| api runtimeUrl | Yes | Конечная точка для управляемого API. | 
| connection name |  | Имя подключения управляемого API, которое использует рабочий процесс. Должно быть ссылкой на параметр с именем `$connection`. |
|||| 

Помимо исключений при подключении, *политика повтора* применяется к периодическим сбоям, классифицируемым как коды состояния HTTP 408, 429 и 5xx. Эту политику можно определить с помощью объекта `retryPolicy`, как показано ниже:
  
```json
"retryPolicy": {
    "type": "<retry-policy-type>",
    "interval": <retry-interval>,
    "count": <number-of-retry-attempts>
}
```

Ниже приведены выходные данные для триггера подключения API.
  
| Имя элемента | type | ОПИСАНИЕ |
| ------------ | ---- | ----------- |
| Заголовки | Объект. | Заголовки HTTP-ответа. | 
| текст | Объект. | Текст HTTP-ответа. | 
|||| 

См. дополнительные сведения о [ценах на триггеры API подключения](../logic-apps/logic-apps-pricing.md#triggers).

## <a name="httpwebhook-trigger"></a>Триггер httpWebhook  

Этот триггер предоставляет конечную точку аналогично триггеру `Request`, но также вызывает указанный URL-адрес для регистрации и отмены регистрации. Триггер HTTPWebhook может выглядеть так:

```json
"myAppsSpotTrigger": {
    "type": "HttpWebhook",
    "inputs": {
        "subscribe": {
            "method": "POST",
            "uri": "https://pubsubhubbub.appspot.com/subscribe",
            "headers": {},
            "body": {
                "hub.callback": "@{listCallbackUrl()}",
                "hub.mode": "subscribe",
                "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
            },
            "authentication": {},
            "retryPolicy": {}
        },
        "unsubscribe": {
            "method": "POST",
            "url": "https://pubsubhubbub.appspot.com/subscribe",
            "body": {
                "hub.callback": "@{workflow().endpoint}@{listCallbackUrl()}",
                "hub.mode": "unsubscribe",
                "hub.topic": "https://pubsubhubbub.appspot.com/articleCategories/technology"
            },
            "authentication": {}
        }
    },
    "conditions": []
}
```

Многие из этих разделов являются необязательными, и поведение триггера HTTPWebhook зависит от того, какие разделы предоставлены или опущены. Ниже приведены свойства триггера HTTPWebhook.
  
| Имя элемента | Обязательно | ОПИСАНИЕ | 
| ------------ | -------- | ----------- |  
| subscribe | Нет  | Указывает исходящий запрос, который вызывается, когда триггер создается и выполняет первоначальную регистрацию. | 
| unsubscribe | Нет  | Указывает исходящий запрос, который вызывается при удалении триггера. | 
|||| 

Вы можете указать ограничения для триггера веб-перехватчика так же, как и [ограничения для асинхронной модели HTTP](#asynchronous-limits). Ниже приведены дополнительные сведения о действиях `subscribe` и `unsubscribe`:

* `subscribe` вызывается, чтобы триггер начал ожидать передачи данных событий. Этот исходящий вызов запускается с теми же параметрами, что и стандартные действия HTTP. Этот вызов выполняется при любом изменении рабочего процесса, например когда происходит отзыв учетных данных или изменяются входные параметры триггера. 
  
  Для поддержки этого вызова функция `@listCallbackUrl()` возвращает уникальный URL-адрес для конкретного триггера в рабочем процессе. Этот URL-адрес представляет собой уникальный идентификатор для конечных точек, использующих REST API службы.
  
* `unsubscribe` вызывается автоматически, когда операция делает этот триггер недействительным, включая такие операции:

  * удаление или отключение триггера; 
  * удаление или отключение рабочего процесса; 
  * удаление или отключение подписки. 
  
  Параметры этой функции совпадают с параметрами триггера HTTP.

Ниже приведены выходные данные триггера HTTPWebhook и содержимое входящего запроса.
  
| Имя элемента | type | ОПИСАНИЕ |
| ------------ | ---- | ----------- |
| Заголовки | Объект. | Заголовки HTTP-ответа. | 
| текст | Объект. | Текст HTTP-ответа. | 
|||| 

## <a name="triggers-conditions"></a>Триггеры: условия

Для любого триггера можно задать одно или несколько условий, определяющих, должен ли выполняться рабочий процесс. В этом примере отчет активируется, если для параметра рабочего процесса `sendReports` установлено значение true. 

```json
"myDailyReportTrigger": {
    "type": "Recurrence",
    "conditions": [ 
        {
            "expression": "@parameters('sendReports')"
        } 
    ],
    "recurrence": {
        "frequency": "Day",
        "interval": 1
    }
}
```

Условия могут ссылаться на код состояния триггера. Например, можно запускать рабочий процесс, если веб-сайт возвращает код состояния 500:
  
``` json
"conditions": [ 
    {  
      "expression": "@equals(triggers().code, 'InternalServerError')"  
    }  
]  
```  

> [!NOTE]
> По умолчанию триггер срабатывает только при получении ответа "200 ОК". Если выражение ссылается на код состояния триггера каким-либо образом, стандартное поведение триггера изменяется. Если нужно, чтобы триггер срабатывал на основе нескольких кодов состояния, например 200 и 201, включите следующее выражение в качестве условия: 
>
> `@or(equals(triggers().code, 200),equals(triggers().code, 201))` 

<a name="split-on-debatch"></a>

## <a name="triggers-process-an-array-with-multiple-runs"></a>Триггеры: обработка массива за несколько выполнений

Если триггер возвращает массив для обработки приложением логики, цикл for each может занять слишком много времени для обработки каждого элемента массива. Вместо этого можно использовать свойство **SplitOn** в триггере, чтобы выполнить *индивидуальную обработку* массива. 

При индивидуальной обработке массив разделяется на элементы и для каждого элемента запускается новый экземпляр приложения логики. Такой подход является эффективным, например, если нужно опросить конечную точку, которая может вернуть несколько новых элементов между интервалами опроса.
Максимальное число элементов массива, которое свойство **SplitOn** позволяет обработать в одном приложении логики, см. в статье [Ограничения и настройка Logic Apps](../logic-apps/logic-apps-limits-and-config.md). 

> [!NOTE]
> Свойство **SplitOn** можно добавить в триггеры, только вручную определив или переопределив в представлении кода для определения JSON приложения логики. Вы не можете использовать **SplitOn**, если нужно реализовать шаблон синхронных ответов. Любой рабочий процесс, который использует свойство **SplitOn** и содержит действие ответа, выполняется асинхронно и сразу же отправляет ответ `202 ACCEPTED`.

Если в файле триггера Swagger описаны полезные данные, составляющие массив, **SplitOn** автоматически добавляется в триггер. В противном случае добавьте это свойство в полезные данные ответа, содержащий массив, который нужно обработать индивидуально. 

Допустим, что у вас есть API, который возвращает такой ответ: 
  
```json
{
    "Status": "Succeeded",
    "Rows": [ 
        { 
            "id": 938109380,
            "name": "customer-name-one"
        },
        {
            "id": 938109381,
            "name": "customer-name-two"
        }
    ]
}
```
  
Приложению логики требуется только содержимое свойства `Rows`, поэтому можно создать триггер, как в следующем примере.

``` json
"myDebatchTrigger": {
    "type": "Http",
    "recurrence": {
        "frequency": "Second",
        "interval": "1"
    },
    "inputs": {
        "uri": "https://mydomain.com/myAPI",
        "method": "GET"
    },
    "splitOn": "@triggerBody()?.Rows"
}
```

> [!NOTE]
> Если используется команда `SplitOn`, получить свойства, которые находятся за пределами массива, невозможно. В нашем примере получить свойство `status` в ответе, возвращенном из API, невозможно.
> 
> Чтобы избежать ошибок, если отсутствует свойство `Rows`, в этом примере используется оператор `?`.

Теперь в определении рабочего процесса можно использовать `@triggerBody().name`, чтобы получить `customer-name-one` при первом выполнении и `customer-name-two` при втором выполнении. Выходные данные триггера выглядят так:

```json
{
    "body": {
        "id": 938109380,
        "name": "customer-name-one"
    }
}
```

```json
{
    "body": {
        "id": 938109381,
        "name": "customer-name-two"
    }
}
```
  
## <a name="triggers-fire-only-after-all-active-runs-finish"></a>Триггеры: срабатывание только после завершения всех активных выполнений

Триггеры повторения можно настроить таким образом, чтобы они срабатывали, только когда завершены все активные выполнения. Чтобы настроить этот параметр, задайте для `operationOptions` значение `singleInstance`:

```json
"myTrigger": {
    "type": "Http",
    "inputs": { },
    "recurrence": { },
    "operationOptions": "singleInstance"
}
```

Если запланированное повторение случается во время выполнения экземпляра рабочего процесса, триггер не срабатывает и ожидает следующего запланированного интервала повторения, чтобы сделать повторную проверку.

## <a name="actions-overview"></a>Общие сведения о действиях

Существует много типов действий, каждое из которых имеет уникальное поведение. Каждый тип действия имеет различные входные данные, определяющие его поведение. Действия коллекций могут содержать множество других вложенных действий. 

### <a name="standard-actions"></a>Стандартные действия  

| Тип действия | ОПИСАНИЕ | 
| ----------- | ----------- | 
| **HTTP** | Вызывает конечную веб-точку HTTP. | 
| **ApiConnection**  | Работает по принципу действия HTTP, но использует [интерфейсы API, управляемые Майкрософт](https://docs.microsoft.com/azure/connectors/apis-list). | 
| **ApiConnectionWebhook** | Работает по принципу HTTPWebhook, но использует интерфейсы API, управляемые Майкрософт. | 
| **Ответ** | Определяет ответ для входящего вызова. | 
| **Действие создания** | Создает произвольный объект из входных данных действия. | 
| **Function** | Представляет функцию Azure. | 
| **Wait** | Ожидает фиксированное количество времени или до определенного времени. | 
| **Workflow** | Представляет вложенный рабочий процесс. | 
| **Действие создания** | Создает произвольный объект из входных данных действия. | 
| **Запрос** | Фильтрует массив по условию. | 
| **Select** | Проецирует каждый элемент массива на новое значение. Например, можно преобразовать массив чисел в массив объектов. | 
| **Таблица** | Преобразовывает массив элементов в таблицу CSV или HTML. | 
| **Terminate** | Останавливает выполнение рабочего процесса. | 
| **Wait** | Ожидает фиксированное количество времени или до определенного времени. | 
| **Workflow** | Представляет вложенный рабочий процесс. | 
||| 

### <a name="collection-actions"></a>Действия коллекций

| Тип действия | ОПИСАНИЕ | 
| ----------- | ----------- | 
| **If** | Вычисляет выражение и в зависимости от результата выполняет соответствующую ветвь. | 
| **Switch** | Выполняет различные действия в зависимости от определенных значений объекта. | 
| **ForEach** | Это циклическое действие выполняет итерацию по массиву и внутренние действия для каждого элемента массива. | 
| **Until** | Это циклическое действие выполняет внутренние действия, пока для условия не возвращается значение true. | 
| **Область** | Используется для логического группирования других действий. | 
|||  

## <a name="http-action"></a>Действие HTTP  

Действие HTTP вызывает указанную конечную точку и проверяет ответ, чтобы определить, следует ли запускать рабочий процесс. Например: 
  
```json
"myLatestNewsAction": {
    "type": "Http",
    "inputs": {
        "method": "GET",
        "uri": "https://mynews.example.com/latest"
    }
}
```

Объект `inputs` принимает следующие параметры, необходимые для создания HTTP-вызова: 

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- | 
| метод | Yes | Строка | Использует один из этих методов HTTP: GET, POST, PUT, DELETE, PATCH или HEAD. | 
| uri | Yes| Строка | Конечная точка HTTP или HTTPS, которую проверяет триггер. Максимальный размер строки: 2 КБ. | 
| Запросы | Нет  | Объект. | Представляет любые параметры запроса, которые необходимо включить в URL-адрес. <p>Например, `"queries": { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес. | 
| Заголовки | Нет  | Объект. | Представляет каждый заголовок, который отправляется в запросе. <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` | 
| текст | Нет  | Объект. | Представляет полезные данные, отправляемые конечной точке. | 
| retryPolicy | Нет  | Объект. | Используйте этот объект, чтобы настроить поведение повтора при возникновении ошибок 4xx или 5xx. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md). | 
| operationsOptions | Нет  | Строка | Определяет набор особого поведения для переопределения. | 
| authentication | Нет  | Объект. | Представляет метод, который должен использоваться запросом для аутентификации. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](../scheduler/scheduler-outbound-authentication.md). <p>Помимо планировщика, имеется еще одно поддерживаемое свойство: `authority`. По умолчанию его значение равно `https://login.windows.net`, если не указано другое. Также можно использовать другое значение, например `https://login.windows\-ppe.net`. | 
||||| 

Действия HTTP и APIConnection поддерживают *политики повтора*. Помимо исключений при подключении, политика повтора применяется к периодическим сбоям, классифицируемым как коды состояния HTTP 408, 429 и 5xx. Эту политику можно определить с помощью объекта `retryPolicy`, как показано ниже:
  
```json
"retryPolicy": {
    "type": "<retry-policy-type>",
    "interval": <retry-interval>,
    "count": <number-of-retry-attempts>
}
```

В этом примере при возникновении временных сбоев действие HTTP от двух до трех раз пытается получить последние новости с 30-секундной задержкой между попытками:
  
```json
"myLatestNewsAction": {
    "type": "Http",
    "inputs": {
        "method": "GET",
        "uri": "https://mynews.example.com/latest",
        "retryPolicy": {
            "type": "fixed",
            "interval": "PT30S",
            "count": 2
        }
    }
}
```

Интервал повторных попыток указывается в [формате ISO 8601](https://en.wikipedia.org/wiki/ISO_8601). Минимальное значение по умолчанию для этого интервала составляет 20 секунд, а максимальное — один час. Максимальное число повторных попыток по умолчанию составляет четыре часа. Если определение политики повтора не указано, используется стратегия `fixed` со значениями числа и интервала повтора по умолчанию. Чтобы отключить политику повтора, задайте для нее тип `None`.

### <a name="asynchronous-patterns"></a>Модель асинхронных операций

По умолчанию все действия на основе HTTP поддерживают стандартную модель асинхронных операций. Таким образом, если удаленный сервер указывает, что запрос принят для обработки с ответом "202 ACCEPTED", то ядро Logic Apps продолжает опрашивать URL-адрес, указанный в заголовке расположения ответа, пока не получит конечного ответа, отличного от ответа 202.
  
Чтобы отключить описанное выше асинхронное поведение, задайте параметру `operationOptions` значение `DisableAsyncPattern` во входных данных действия. В таком случае выходные данные действия будут основаны на первоначальном ответе 202 от сервера. Например: 
  
```json
"invokeLongRunningOperationAction": {
    "type": "Http",
    "inputs": {
        "method": "POST",
        "uri": "https://host.example.com/resources"
    },
    "operationOptions": "DisableAsyncPattern"
}
```

<a name="asynchronous-limits"></a>

#### <a name="asynchronous-limits"></a>Ограничения асинхронных операций

Вы можете ограничить длительность асинхронных операций, задав определенный период времени. Если интервал времени истекает без достижения конечного состояния, состояние действия помечается как `Cancelled` с помощью кода `ActionTimedOut`. Ограничение времени ожидания указывается в формате ISO 8601. В этом примере показано, как можно указать ограничения:


``` json
"<action-name>": {
    "type": "Workflow|Webhook|Http|ApiConnectionWebhook|ApiConnection",
    "inputs": { },
    "limit": {
        "timeout": "PT10S"
    }
}
```
  
## <a name="apiconnection-action"></a>Действие APIConnection

Это действие ссылается на соединитель, управляемый Майкрософт. Для него также требуется ссылка на допустимое подключение и сведения об API и параметрах. Ниже приведен пример действия APIConnection.

```json
"Send_Email": {
    "type": "ApiConnection",
    "inputs": {
        "host": {
            "api": {
                "runtimeUrl": "https://logic-apis-df.azure-apim.net/apim/office365"
            },
            "connection": {
                "name": "@parameters('$connections')['office365']['connectionId']"
            }
        },
        "method": "POST",
        "body": {
            "Subject": "New tweet from @{triggerBody()['TweetedBy']}",
            "Body": "@{triggerBody()['TweetText']}",
            "To": "me@example.com"
        },
        "path": "/Mail"
    },
    "runAfter": {}
}
```

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- | 
| host | Yes | Объект. | Представляет сведения о соединителе, например `runtimeUrl`, и ссылку на объект подключения. | 
| метод | Yes | Строка | Использует один из этих методов HTTP: GET, POST, PUT, DELETE, PATCH или HEAD. | 
| path | Yes | Строка | Путь к операции API. | 
| Запросы | Нет  | Объект. | Представляет любые параметры запроса, которые необходимо включить в URL-адрес. <p>Например, `"queries": { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес. | 
| Заголовки | Нет  | Объект. | Представляет каждый заголовок, который отправляется в запросе. <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` | 
| текст | Нет  | Объект. | Представляет полезные данные, отправляемые конечной точке. | 
| retryPolicy | Нет  | Объект. | Используйте этот объект, чтобы настроить поведение повтора при возникновении ошибок 4xx или 5xx. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md). | 
| operationsOptions | Нет  | Строка | Определяет набор особого поведения для переопределения. | 
| authentication | Нет  | Объект. | Представляет метод, который должен использоваться запросом для аутентификации. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](../scheduler/scheduler-outbound-authentication.md). |
||||| 

Помимо исключений при подключении, политика повтора применяется к периодическим сбоям, классифицируемым как коды состояния HTTP 408, 429 и 5xx. Эту политику можно определить с помощью объекта `retryPolicy`, как показано ниже:

```json
"retryPolicy": {
    "type": "<retry-policy-type>",
    "interval": <retry-interval>,
    "count": <number-of-retry-attempts>
}
```

## <a name="apiconnection-webhook-action"></a>Действие APIConnectionWebhook

Действие APIConnectionWebhook ссылается на соединитель, управляемый Майкрософт. Для этого действия требуется ссылка на допустимое подключение и сведения об API и параметрах. Вы можете указать ограничения для действий webhook так же, как [ограничения для асинхронной модели HTTP](#asynchronous-limits).

```json
"Send_approval_email": {
    "type": "ApiConnectionWebhook",
    "inputs": {
        "host": {
            "api": {
                "runtimeUrl": "https://logic-apis-df.azure-apim.net/apim/office365"
            },
            "connection": {
                "name": "@parameters('$connections')['office365']['connectionId']"
            }
        },
        "body": {
            "Message": {
                "Subject": "Approval Request",
                "Options": "Approve, Reject",
                "Importance": "Normal",
                "To": "me@email.com"
            }
        },
        "path": "/approvalmail",
        "authentication": "@parameters('$authentication')"
    },
    "runAfter": {}
}
```

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- | 
| host | Yes | Объект. | Представляет сведения о соединителе, например `runtimeUrl`, и ссылку на объект подключения. | 
| path | Yes | Строка | Путь к операции API. | 
| Запросы | Нет  | Объект. | Представляет любые параметры запроса, которые необходимо включить в URL-адрес. <p>Например, `"queries": { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес. | 
| Заголовки | Нет  | Объект. | Представляет каждый заголовок, который отправляется в запросе. <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` | 
| текст | Нет  | Объект. | Представляет полезные данные, отправляемые конечной точке. | 
| retryPolicy | Нет  | Объект. | Используйте этот объект, чтобы настроить поведение повтора при возникновении ошибок 4xx или 5xx. Дополнительные сведения см. в разделе [Политики повтора](../logic-apps/logic-apps-exception-handling.md). | 
| operationsOptions | Нет  | Строка | Определяет набор особого поведения для переопределения. | 
| authentication | Нет  | Объект. | Представляет метод, который должен использоваться запросом для аутентификации. Дополнительные сведения см. в статье [Исходящая проверка подлинности планировщика](../scheduler/scheduler-outbound-authentication.md). |
||||| 

## <a name="response-action"></a>Действие ответа  

Это действие содержит все полезные данные ответа из HTTP-запроса и включает в себя `statusCode`, `body` и `headers`:
  
```json
"myResponseAction": {
    "type": "Response",
    "inputs": {
        "statusCode": 200,
        "body": {
            "contentFieldOne": "value100",
            "anotherField": 10.001
        },
        "headers": {
            "x-ms-date": "@utcnow()",
            "Content-type": "application/json"
        }
    },
    "runAfter": {}
}
```

Действие response имеет специальные ограничения, которые не применяются к другим действиям, а именно:  
  
* Действия response не могут быть в параллельных ветвях в определении приложения логики, так как для входящего запроса требуется детерминированный ответ.
  
* Если рабочий процесс достигает действия response после получения ответа входящим запросом, то действие response считается неудачным или в состоянии конфликта. В результате запуск приложения логики помечается как `Failed`.
  
* Рабочий процесс с действиями response не может использовать команду `splitOn` в определении триггера, так как вызов создает несколько запусков. В результате при проверке этого случая, если операция рабочего процесса — PUT, возвращается ответ "Недопустимый запрос".

## <a name="compose-action"></a>Действие compose

Это действие позволяет создать произвольный объект, а выходные данные являются результатом вычисления входных данных действия. 

> [!NOTE]
> Действие `Compose` можно использовать для создания выходных данных, включая объекты, массивы и любой другой тип, изначально поддерживаемый приложениями логики (XML и двоичный тип).

Например, действие `Compose` можно использовать для объединения выходных данных нескольких действий:

```json
"composeUserRecordAction": {
    "type": "Compose",
    "inputs": {
        "firstName": "@actions('getUser').firstName",
        "alias": "@actions('getUser').alias",
        "thumbnailLink": "@actions('lookupThumbnail').url"
    }
}
```

## <a name="function-action"></a>Действие функции

Это действие позволяет представить и вызвать [функцию Azure](../azure-functions/functions-overview.md), например:

```json
"<my-Azure-Function-name>": {
   "type": "Function",
    "inputs": {
        "function": {
            "id": "/subscriptions/<Azure-subscription-ID>/resourceGroups/<Azure-resource-group-name>/providers/Microsoft.Web/sites/<your-Azure-function-app-name>/functions/<your-Azure-function-name>"
        },
        "queries": {
            "extrafield": "specialValue"
        },  
        "headers": {
            "x-ms-date": "@utcnow()"
        },
        "method": "POST",
        "body": {
            "contentFieldOne": "value100",
            "anotherField": 10.001
        }
    },
    "runAfter": {}
}
```

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- |  
| ИД функции | Yes | Строка | Идентификатор ресурса для функции Azure, которую требуется вызвать. | 
| метод | Нет  | Строка | Метод HTTP, используемый для вызова функции. Если метод не указан, то по умолчанию используется POST. | 
| Запросы | Нет  | Объект. | Представляет любые параметры запроса, которые необходимо включить в URL-адрес. <p>Например, `"queries": { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес. | 
| Заголовки | Нет  | Объект. | Представляет каждый заголовок, который отправляется в запросе. <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` | 
| текст | Нет  | Объект. | Представляет полезные данные, отправляемые конечной точке. | 
|||||

При сохранении приложения логики обработчик Logic Apps выполняет проверки указанной функции:

* У вас должен быть доступ к функции.
* Можно использовать только стандартный триггер HTTP или универсальный триггер веб-перехватчика в формате JSON.
* В функции не должен быть определен какой-либо маршрут.
* Можно использовать только авторизацию с помощью функции и анонимную авторизацию.

> [!NOTE]
> Обработчик Logic Apps получает и кэширует URL-адрес триггера, используемый во время выполнения. Поэтому, если какая-либо операция делает недействительным кэшированный URL-адрес, то во время выполнения действие заканчивается сбоем. Чтобы обойти эту проблему, еще раз сохраните приложение логики — оно повторно получит и поместит в кэш URL-адрес триггера.

## <a name="select-action"></a>Выбор действия

Это действие позволяет проецировать каждый элемент массива на новое значение. В этом примере массив чисел преобразовывается в массив объектов:

```json
"selectNumbersAction": {
    "type": "Select",
    "inputs": {
        "from": [ 1, 3, 0, 5, 4, 2 ],
        "select": { "number": "@item()" }
    }
}
```

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- | 
| from | Yes | Массив, | Исходный массив. |
| select | Yes | Любой | Проекция, применяемая к каждому элементу в исходном массиве. |
||||| 

Выходные данные действия `select` — это массив с таким же количеством элементов, как и во входном массиве. Каждый его элемент преобразован так, как предписывает свойство `select`. Если вход — это пустой массив, выходные данные также будут пустым массивом.

## <a name="terminate-action"></a>Действие terminate

Это действие останавливает рабочий процесс, отменяя выполняющиеся действия и пропуская все оставшиеся действия. Действие terminate не влияет на завершенные действия.

Например, чтобы остановить выполнение в состоянии `Failed`, используйте следующий код:

```json
"HandleUnexpectedResponse": {
    "type": "Terminate",
    "inputs": {
        "runStatus": "Failed",
        "runError": {
            "code": "UnexpectedResponse",
            "message": "Received an unexpected response",
        }
    }
}
```

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- | 
| runStatus | Yes | Строка | Состояние целевого выполнения (`Failed` или `Cancelled`). |
| runError | Нет  | Объект. | Сведения об ошибке. Поддерживается, только если `runStatus` имеет значение `Failed`. |
| runError code | Нет  | Строка | Код ошибки выполнения. |
| runError message | Нет  | Строка | Сообщение об ошибке выполнения. | 
||||| 

## <a name="query-action"></a>Действие запроса

Это действие позволяет фильтровать массив на основе условия. 

> [!NOTE]
> Вы можете использовать действие compose для создания выходных данных, включая объекты, массивы и другие типы, изначально поддерживаемые приложениями логики (XML и двоичный тип).

Например, чтобы выбрать числа больше 2, используйте следующий код:

```json
"filterNumbersAction": {
    "type": "Query",
    "inputs": {
        "from": [ 1, 3, 0, 5, 4, 2 ],
        "where": "@greater(item(), 2)"
    }
}
```

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- | 
| from | Yes | Массив, | Исходный массив. |
| где: | Yes | Строка | Условие, которое применяется к каждому элементу исходного массива. Если значений, соответствующих условию `where`, нет, результатом будет пустой массив. |
||||| 

Выходные данные действия `query` представлены в виде массива, содержащего элементы из массива входных данных, которые соответствуют условию.

## <a name="table-action"></a>Действие таблицы

Это действие позволяет преобразовать массив в таблицу CSV или HTML. 

```json
"ConvertToTable": {
    "type": "Table",
    "inputs": {
        "from": "<source-array>",
        "format": "CSV | HTML"
    }
}
```

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- | 
| from | Yes | Массив, | Исходный массив. Если значение свойства `from` — это пустой массив, выходные данные будут пустой таблицей. | 
| свойства | Yes | Строка | Необходимый формат таблицы — CSV или HTML. | 
| columns | Нет  | Массив, | Необходимые столбцы таблицы. Используйте, чтобы переопределить форму таблицы по умолчанию. | 
| column header | Нет  | Строка | Заголовок столбца. | 
| column value | Yes | Строка | Значение столбца. | 
||||| 

Предположим, вы определяете действие table, как в следующем примере:

```json
"convertToTableAction": {
    "type": "Table",
    "inputs": {
        "from": "@triggerBody()",
        "format": "HTML"
    }
}
```

И используете этот массив для `@triggerBody()`:

```json
[ {"ID": 0, "Name": "apples"},{"ID": 1, "Name": "oranges"} ]
```

Вот результат из этого примера:

<table><thead><tr><th>ИД</th><th>ИМЯ</th></tr></thead><tbody><tr><td>0</td><td>apples</td></tr><tr><td>1</td><td>oranges</td></tr></tbody></table>

Чтобы настроить эту таблицу, можно явно указать столбцы, например:

```json
"ConvertToTableAction": {
    "type": "Table",
    "inputs": {
        "from": "@triggerBody()",
        "format": "html",
        "columns": [ 
            {
                "header": "Produce ID",
                "value": "@item().id"
            },
            {
              "header": "Description",
              "value": "@concat('fresh ', item().name)"
            }
        ]
    }
}
```

Вот результат из этого примера:

<table><thead><tr><th>Код результата</th><th>ОПИСАНИЕ</th></tr></thead><tbody><tr><td>0</td><td>fresh apples</td></tr><tr><td>1</td><td>fresh oranges</td></tr></tbody></table>

## <a name="wait-action"></a>Действие wait  

Это действие приостанавливает выполнение рабочего процесса на указанный период времени. В этом примере задается ожидание рабочего процесса длительностью 15 минут:
  
```json
"waitForFifteenMinutesAction": {
    "type": "Wait",
    "inputs": {
        "interval": {
            "unit": "minute",
            "count": 15
        }
    }
}
```
  
Кроме того, чтобы задать ожидание до определенного момента времени, можно использовать такой пример:
  
```json
"waitUntilOctoberAction": {
    "type": "Wait",
    "inputs": {
        "until": {
            "timestamp": "2017-10-01T00:00:00Z"
        }
    }
}
```
  
> [!NOTE]  
> Вы можете задать длительность ожидания с помощью только одного из объектов — `interval` или `until`.

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- | 
| until | Нет  | Объект. | Длительность ожидания на основе точки на момент времени. | 
| until timestamp | Yes | Строка | Точка во времени ([дата и время в формате UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time)), когда истекает время ожидания. | 
| interval | Нет  | Объект. | Длительность ожидания на основе единицы интервала и числа интервалов. | 
| interval unit | Yes | Строка | Единица времени. Используйте только одно из этих значений: second (секунда), minute (минута), hour (час), day (день), week (неделя) или month (месяц). | 
| interval count | Yes | Целое число  | Положительное целое число, представляющее число единиц интервала, которые используются для длительности ожидания. | 
||||| 

## <a name="workflow-action"></a>Действие workflow

Это действие позволяет вложить рабочий процесс. Обработчик Logic Apps проверяет доступ в дочернем рабочем процессе, точнее в триггере. Это означает, что требуется доступ к дочернему рабочему процессу. Например: 

```json
"<my-nested-workflow-action-name>": {
    "type": "Workflow",
    "inputs": {
        "host": {
            "id": "/subscriptions/<my-subscription-ID>/resourceGroups/<my-resource-group-name>/providers/Microsoft.Logic/<my-nested-workflow-action-name>",
            "triggerName": "mytrigger001"
        },
        "queries": {
            "extrafield": "specialValue"
        },  
        "headers": {
            "x-ms-date": "@utcnow()",
            "Content-type": "application/json"
        },
        "body": {
            "contentFieldOne": "value100",
            "anotherField": 10.001
        }
    },
    "runAfter": {}
}
```

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- |  
| host id | Yes | Строка| Идентификатор ресурса для рабочего процесса, который требуется вызвать. | 
| host triggerName | Yes | Строка | Имя триггера, который необходимо вызвать. | 
| Запросы | Нет  | Объект. | Представляет любые параметры запроса, которые необходимо включить в URL-адрес. <p>Например, `"queries": { "api-version": "2015-02-01" }` добавляет `?api-version=2015-02-01` в URL-адрес. | 
| Заголовки | Нет  | Объект. | Представляет каждый заголовок, который отправляется в запросе. <p>Например, чтобы задать язык и тип запроса: <p>`"headers": { "Accept-Language": "en-us", "Content-Type": "application/json" }` | 
| текст | Нет  | Объект. | Представляет полезные данные, отправляемые конечной точке. | 
||||| 

Выходные данные этого действия основаны на заданном в действии `Response` для дочернего рабочего процесса. Если дочерний рабочий процесс не определяет действие `Response`, выходные данные будут пустыми.

## <a name="collection-actions-overview"></a>Общие сведения о действиях коллекций

Действия коллекций могут содержать другие действия, и это помогает управлять выполнением рабочего процесса. На ссылочные действия в коллекции можно ссылаться непосредственно за пределами коллекции. Например, если вы определили действие `Http` в области, элемент `@body('http')` действителен в любой точке рабочего процесса. Также действия в коллекции могут выполняться только после других действий в этой коллекции.

## <a name="if-action"></a>Действие If

Это действие, которое является условным оператором, позволяет вычислить условие и выполнить ветвь в зависимости от того, получает ли выражение значение true. Если условие выполняется успешно (возвращает значение true), его состояние будет "Succeeded". Действия в объектах `actions` или `else` получают следующие значения:

* "Succeeded", если они запускаются и выполняются успешно;
* "Failed", если они запускаются, но завершаются ошибкой;
* "Skipped", если не запускается соответствующая ветвь.

См. дополнительные сведения об [условных операторах в приложениях логики](../logic-apps/logic-apps-control-flow-conditional-statement.md).

``` json
"<my-condition-name>": {
  "type": "If",
  "expression": "<condition>",
  "actions": {
    "if-true-run-this-action": {
      "type": <action-type>,
      "inputs": {},
      "runAfter": {}
    }
  },
  "else": {
    "actions": {
        "if-false-run-this-action": {
            "type": <action-type>,
            "inputs": {},
            "runAfter": {}
        }
    }
  },
  "runAfter": {}
}
```

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- | 
| actions | Yes | Объект. | Внутренние действия, которые необходимо выполнить, когда `expression` получает значение `true`. | 
| expression | Yes | Строка | Выражение для вычисления. |
| else | Нет  | Объект. | Внутренние действия, которые необходимо выполнить, когда `expression` получает значение `false`. |
||||| 

Например: 

```json
"myCondition": {
    "type": "If",
    "actions": {
        "if-true-check-this-website": {
            "type": "Http",
            "inputs": {
                "method": "GET",
                "uri": "http://this-url"
            },
            "runAfter": {}
        }
    },
    "else": {
        "actions": {
            "if-false-check-this-other-website": {
                "type": "Http",
                "inputs": {
                    "method": "GET",
                    "uri": "http://this-other-url"
                },
                "runAfter": {}
            }
        }
    }
}
```  

### <a name="how-conditions-can-use-expressions-in-actions"></a>Как условия могут использовать выражения и действия

Ниже приведены некоторые примеры, показывающие, как можно использовать выражения в условиях.
  
| Выражение JSON | Результат | 
| --------------- | ------ | 
| `"expression": "@parameters('hasSpecialAction')"` | Условие выполняется при наличии какого-либо значения, которое возвращает значение true для выражения. Поддерживаются только логические выражения. Чтобы преобразовать другие типы в логический, используйте следующие функции: `empty` или `equals`. | 
| `"expression": "@greater(actions('action1').output.value, parameters('threshold'))"` | Поддерживает функции сравнения. В этом примере действие выполняется, только если выходные данные action1 превышают пороговое значение. | 
| `"expression": "@or(greater(actions('action1').output.value, parameters('threshold')), less(actions('action1').output.value, 100))"` | Поддерживает функции логики для создания вложенных логических выражений. В этом примере действие выполняется, если выходные данные action1 превышают пороговое значение или не превышают 100. | 
| `"expression": "@equals(length(actions('action1').outputs.errors), 0))"` | Чтобы проверить, содержит ли массив элементы, можно использовать функции массива. В этом примере действие выполняется, если массив ошибок пустой. | 
| `"expression": "parameters('hasSpecialAction')"` | Это выражение вызывает ошибку и не является допустимым условием. Условия должны использовать символ @. | 
||| 

## <a name="switch-action"></a>Действие switch

Это действие, являющееся инструкцией switch, выполняет различные действия в зависимости от определенных значений объекта, выражения или маркера. Это действие оценивает объект, выражение или маркер, выбирает вариант, который соответствует результату, и выполняет действия только для этого варианта. Если ни один вариант не совпадает с результатом, выполняется действие по умолчанию. При выполнении оператора switch результат должен совпадать только с одним вариантом. См. дополнительные сведения об [операторах switch в приложениях логики](../logic-apps/logic-apps-control-flow-switch-statement.md).

``` json
"<my-switch-statement-name>": {
   "type": "Switch",
   "expression": "<evaluate-this-object-expression-token>",
   "cases": {
      "myCase1" : {
         "actions" : {
           "myAction1": {}
         },
         "case": "<result1>"
      },
      "myCase2": {
         "actions" : {
           "myAction2": {}
         },
         "case": "<result2>"
      }
   },
   "default": {
      "actions": {
          "myDefaultAction": {}
      }
   },
   "runAfter": {}
}
```

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- | 
| expression | Yes | Строка | Объект, выражение или маркер для оценки | 
| cases | Yes | Объект. | Содержит наборы внутренних действий, которые выполняются на основе результата выражения. | 
| case | Yes | Строка | Значение, которое должно соответствовать результату. | 
| actions | Yes | Объект. | Внутренние действия, которые выполняются для варианта, соответствующего результату выражения. | 
| по умолчанию | Нет  | Объект. | Внутренние действия, которые выполняются при отсутствии вариантов, соответствующих результату. | 
||||| 

Например: 

``` json
"myApprovalEmailAction": {
   "type": "Switch",
   "expression": "@body('Send_approval_email')?['SelectedOption']",
   "cases": {
      "Case": {
         "actions" : {
           "Send_an_email": {...}
         },
         "case": "Approve"
      },
      "Case_2": {
         "actions" : {
           "Send_an_email_2": {...}
         },
         "case": "Reject"
      }
   },
   "default": {
      "actions": {}
   },
   "runAfter": {
      "Send_approval_email": [
         "Succeeded"
      ]
   }
}
```

## <a name="foreach-action"></a>Действие foreach

Это циклическое действие выполняет итерацию по массиву и внутренние действия для каждого элемента массива. По умолчанию цикл foreach выполняется параллельно. Максимальное число параллельных циклов, которые может запустить foreach, см. в статье [Ограничения и настройка Logic Apps](../logic-apps/logic-apps-limits-and-config.md). Чтобы каждый цикл выполнялся последовательно, укажите для параметра `operationOptions` значение `Sequential`. См. дополнительные сведения о [циклах foreach в приложениях логики](../logic-apps/logic-apps-control-flow-loops.md#foreach-loop).

```json
"<my-forEach-loop-name>": {
    "type": "Foreach",
    "actions": {
        "myInnerAction1": {
            "type": "<action-type>",
            "inputs": {}
        },
        "myInnerAction2": {
            "type": "<action-type>",
            "inputs": {}
        }
    },
    "foreach": "<array>",
    "runAfter": {}
}
```

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- | 
| actions | Yes | Объект. | Внутренние действия, которые необходимо выполнить внутри цикла. | 
| foreach | Yes | Строка | Массив для итерации. | 
| operationOptions | Нет  | Строка | Указывает любые параметры операций для настройки поведения. В данный момент поддерживается только значение `Sequential` для последовательного выполнения итераций, где поведение по умолчанию — параллельное выполнение. |
||||| 

Например: 

```json
"forEach_EmailAction": {
    "type": "Foreach",
    "foreach": "@body('email_filter')",
    "actions": {
        "Send_email": {
            "type": "ApiConnection",
            "inputs": {
                "body": {
                    "to": "@item()",
                    "from": "me@contoso.com",
                    "message": "Hello, thank you for ordering"
                },
                "host": {
                    "connection": {
                        "id": "@parameters('$connections')['office365']['connection']['id']"
                    }
                }
            }
        }
    },
    "foreach": "@body('email_filter')",
    "runAfter": {
        "email_filter": [ "Succeeded" ]
    }
}
```

## <a name="until-action"></a>Действие Until

Это циклическое действие выполняет внутренние действия, пока для условия не возвращается значение true. См. дополнительные сведения о [циклах until в приложениях логики](../logic-apps/logic-apps-control-flow-loops.md#until-loop).

```json
 "<my-Until-loop-name>": {
    "type": "Until",
    "actions": {
        "myActionName": {
            "type": "<action-type>",
            "inputs": {},
            "runAfter": {}
        }
    },
    "expression": "<myCondition>",
    "limit": {
        "count": 1000,
        "timeout": "PT1H"
    },
    "runAfter": {}
}
```

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- | 
| actions | Yes | Объект. | Внутренние действия, которые необходимо выполнить внутри цикла. | 
| expression | Yes | Строка | Выражение, вычисляемое после каждой итерации. | 
| ограничение | Yes | Объект. | Ограничения для цикла. Необходимо определить по крайней мере одно ограничение. | 
| count | Нет  | Целое число  | Ограничение на число итераций, которые необходимо выполнить. | 
| timeout | Нет  | Строка | Ограничение времени ожидания в [формате ISO 8601](https://en.wikipedia.org/wiki/ISO_8601), которое определяет, как долго будет выполняться цикл. |
||||| 

Например: 

```json
 "runUntilSucceededAction": {
    "type": "Until",
    "actions": {
        "Http": {
            "type": "Http",
            "inputs": {
                "method": "GET",
                "uri": "http://myurl"
            },
            "runAfter": {}
        }
    },
    "expression": "@equals(outputs('Http')['statusCode', 200)",
    "limit": {
        "count": 100,
        "timeout": "PT1H"
    },
    "runAfter": {}
}
```

## <a name="scope-action"></a>Действие scope

Это действие позволяет логически группировать действия в рабочем процессе. Когда все действия в области завершаются, такая область также получает собственное состояние. См. дополнительные сведения об [областях](../logic-apps/logic-apps-control-flow-run-steps-group-scopes.md).

```json
"<my-scope-action-name>": {
    "type": "Scope",
    "actions": {
        "myInnerAction1": {
            "type": "<action-type>",
            "inputs": {}
        },
        "myInnerAction2": {
            "type": "<action-type>",
            "inputs": {}
        }
    }
}
```

| ИМЯ | Обязательно | type | ОПИСАНИЕ | 
| ---- | -------- | ---- | ----------- |  
| actions | Yes | Объект. | Внутренние действия, которые необходимо выполнить внутри области. |
||||| 

## <a name="next-steps"></a>Дополнительная информация

* См. дополнительные сведения о [языке определения рабочего процесса](../logic-apps/logic-apps-workflow-definition-language.md)
* См. дополнительные сведения о [REST API рабочих процессов](https://docs.microsoft.com/rest/api/logic/workflows)