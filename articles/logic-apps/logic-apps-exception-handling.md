---
title: Обработка ошибок и исключений в Azure Logic Apps | Документация Майкрософт
description: Шаблоны обработки ошибок и исключений в Azure Logic Apps
services: logic-apps
ms.service: logic-apps
author: dereklee
ms.author: deli
manager: jeconnoc
ms.date: 01/31/2018
ms.topic: article
ms.reviewer: klam, LADocs
ms.suite: integration
ms.openlocfilehash: 7ce5c7007414bfe8e17727c25de9712e7993dc1e
ms.sourcegitcommit: a5eb246d79a462519775a9705ebf562f0444e4ec
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/26/2018
ms.locfileid: "39263758"
---
# <a name="handle-errors-and-exceptions-in-azure-logic-apps"></a>Обработка ошибок и исключений в Azure Logic Apps

Способ, которым любая архитектура интеграции должным образом обрабатывает время простоя или проблемы, вызванные зависимыми системами, может создать проблему. Чтобы помочь вам создать надежную и устойчивую интеграцию, корректно обрабатывающую проблемы и сбои, Logic Apps предоставляет эффективные возможности обработки ошибок и исключений. 

<a name="retry-policies"></a>

## <a name="retry-policies"></a>Политики повтора

Для самой простой обработки исключений и ошибок можно использовать *политику повторов* для любого действия или триггера, в котором она поддерживается. Политика повторов указывает, каким образом и повторяет ли действие или триггер запрос, когда истекает время ожидания первоначального запроса или запрос завершается ошибкой, т.е. на запрос дается ответ 408, 429 или 5xx. Если политика повтора не задана, используется политика по умолчанию. 

Ниже приведены типы политик повтора. 

| type | ОПИСАНИЕ | 
|------|-------------| 
| [**По умолчанию**](#default-retry) | Эта политика отправляет до четырех повторных попыток в [*экспоненциально увеличивающихся*](#exponential-retry) интервалах, которые масштабируются с шагом в 7,5 секунд, но ограничены между 5 и 45 секундами. | 
| [**Экспоненциальный интервал**](#exponential-retry)  | Перед отправкой следующего запроса эта политика ожидает случайного интервала, выбранного из экспоненциально растущего диапазона. | 
| [**Фиксированный интервал**](#fixed-retry)  | Эта политика ожидает определенный интервал времени перед отправкой следующего запроса. | 
| [**Отсутствует**](#no-retry)  | Повторная отправка запроса не происходит. | 
||| 

Дополнительные сведения об ограничениях политики повтора см. в статье [Ограничения и настройка Logic Apps](../logic-apps/logic-apps-limits-and-config.md#request-limits). 

### <a name="change-retry-policy"></a>Изменение политики повтора

Чтобы выбрать другую политику повтора, выполните следующие действия. 

1. Создание приложения логики в Конструкторе приложений логики. 

2. Откройте **Параметры** для действия или триггера.

3. Если действие или триггер поддерживает политику повтора, в разделе **Политика повтора**, выберите нужный тип. 

Или можно вручную задать политику повтора в разделе `inputs` для действия или триггера, который поддерживает политику повтора. Если не указать политику повтора, действие использует политику по умолчанию.

```json
"<action-name>": {
   "type": "<action-type>", 
   "inputs": {
      "<action-specific-inputs>",
      "retryPolicy": {
         "type": "<retry-policy-type>",
         "interval": "<retry-interval>",
         "count": <retry-attempts>,
         "minimumInterval": "<minimum-interval>",
         "maximumInterval": "<maximun-interval>"
      },
      "<other-action-specific-inputs>"
   },
   "runAfter": {}
}
```

*Обязательный*

| Значение | type | ОПИСАНИЕ |
|-------|------|-------------|
| <*retry-policy-type*> | Строка | Тип политики повторных попыток, которые необходимо использовать: "по умолчанию", "отсутствует", "фиксированный" или "экспоненциальный" | 
| <*retry-interval*> | Строка | Интервал повторных попыток, значение которого используется в [формате ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations). Минимальный интервал по умолчанию составляет `PT5S`, а максимальный интервал — `PT1D`. При использовании политики экспоненциального интервала можно указать разные минимальное и максимальное значения. | 
| <*retry-attempts*> | Целое число  | Количество повторных попыток. Значение должно находиться в диапазоне от 1 до 90. | 
||||

*Необязательно.*

| Значение | type | ОПИСАНИЕ |
|-------|------|-------------|
| <*minimum-interval*> | Строка | Минимальный интервал политики экспоненциального интервала для случайно выбранного интервала в [ формате ISO 8601 ](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) | 
| <*maximum-interval*> | Строка | Максимальный интервал политики экспоненциального интервала для случайно выбранного интервала в [ формате ISO 8601 ](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) | 
|||| 

Ниже приведены дополнительные сведения о различных типах политик.

<a name="default-retry"></a>

### <a name="default"></a>значение по умолчанию

Если не будет указана политика повтора, действие использует политику по умолчанию, которая на самом деле представляет собой [политику экспоненциального интервала](#exponential-interval), которая отправляет до четырех повторных попыток с экспоненциально растущим интервалом с шагом в 7,5 секунд. Диапазон составляет от 5 до 45 секунд. 

Хотя это явно не определено в действии или триггере, ниже представлена политика по умолчанию на примере действия HTTP.

```json
"HTTP": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "http://myAPIendpoint/api/action",
      "retryPolicy" : {
         "type": "exponential",
         "interval": "PT7S",
         "count": 4,
         "minimumInterval": "PT5S",
         "maximumInterval": "PT1H"
      }
   },
   "runAfter": {}
}
```

### <a name="none"></a>None

Чтобы указать, что действие или триггер не повторяет неудавшиеся запросы, задайте параметру <*retry-policy-type*> значение `none`.

### <a name="fixed-interval"></a>Фиксированный интервал

Чтобы указать, что действие или триггер ждет указанного интервала перед отправкой следующего запроса, задайте параметру <*retry-policy-type*> значение `fixed`.

*Пример*

Эта политика повтора пытается два раза получить последние новости после первого сбоя запроса с 30-секундной задержкой между попытками.

```json
"Get_latest_news": {
   "type": "Http",
   "inputs": {
      "method": "GET",
      "uri": "https://mynews.example.com/latest",
      "retryPolicy": {
         "type": "fixed",
         "interval": "PT30S",
         "count": 2
      }
   }
}
```

<a name="exponential-interval"></a>

### <a name="exponential-interval"></a>Экспоненциальный интервал

Чтобы указать, что действие или триггер ждет случайного интервала перед отправкой следующего запроса, задайте параметру <*retry-policy-type*> значение `exponential`. Случайный интервал выбирается из экспоненциально растущего диапазона. Минимальный и максимальный интервалы по умолчанию также можно переопределить, указав собственные минимальный и максимальный интервалы.

**Диапазон случайных переменных**

В этой таблице показано, как Logic Apps создает универсальную случайную переменную в указанном диапазоне для каждой попытки повтора, включая число повторных попыток.

| Число повторных попыток | Минимальный интервал | Максимальный интервал |
|--------------|------------------|------------------|
| 1 | max(0, <*minimum-interval*>) | min(interval, <*maximum-interval*>) |
| 2 | max(interval, <*minimum-interval*>) | min(2 * interval, <*maximum-interval*>) |
| 3 | max(2 * interval, <*minimum-interval*>) | min(4 * interval, <*maximum-interval*>) |
| 4. | max(4 * interval, <*minimum-interval*>) | min(8 * interval, <*maximum-interval*>) |
| .... | .... | .... | 
|||| 

## <a name="catch-and-handle-failures-with-the-runafter-property"></a>Перехват и обработка ошибок с помощью свойства RunAfter

Каждое действие приложения логики объявляет действия, которые должны завершаться перед началом этого действия. Это похоже на упорядочение действий рабочего процесса. В определении действия этот порядок определяет свойство **runAfter**, которое является объектом, описывающим, какие действия и состояния действий необходимы для выполнения определенного действия.

По умолчанию все действия, добавленные в конструктор приложений логики, выполняются после предыдущего шага, если тот завершился **успешно**. Однако значение **runAfter** можно изменить таким образом, чтобы действия срабатывали, если предыдущие действия получали состояния **Failed** (Сбой), **Skipped** (Пропущено) или оба. Например, чтобы добавить элемент в указанный раздел служебной шины после сбоя определенного действия **Insert_Row**, можно использовать следующий пример определения **runAfter**:

```json
"Send_message": {
    "inputs": {
        "body": {
            "ContentData": "@{encodeBase64(body('Insert_Row'))}",
            "ContentType": "{ \"content-type\" : \"application/json\" }"
        },
        "host": {
            "api": {
                "runtimeUrl": "https://logic-apis-westus.azure-apim.net/apim/servicebus"
            },
            "connection": {
                "name": "@parameters('$connections')['servicebus']['connectionId']"
            }
        },
        "method": "post",
        "path": "/@{encodeURIComponent('failures')}/messages"
    },
    "runAfter": {
        "Insert_Row": [
            "Failed"
        ]
    }
}
```

Свойство **runAfter** выполняется, если состояние действия **Insert_Row** — **Failed** (Сбой). Чтобы выполнить действие, если состояние действия **Succeeded**, **Failed** или **Skipped**, используйте такой синтаксис:

```json
"runAfter": {
        "Insert_Row": [
            "Failed", "Succeeded", "Skipped"
        ]
    }
```

> [!TIP]
> Действия, успешно завершенные после сбоя предыдущего действия, будут помечены как **Succeeded** (Успешно). Таким образом, если перехватить все ошибки в рабочем процессе, само выполнение помечается как **Succeeded** (Успешно).

<a name="scopes"></a>

## <a name="evaluate-actions-with-scopes-and-their-results"></a>Оценка действия с помощью областей и их результатов

Вы можете сгруппировать действия внутри [области](../logic-apps/logic-apps-control-flow-run-steps-group-scopes.md), аналогично тому, как выполняются отдельные действия с помощью свойства **runAfter**. Области позволяют логически группировать действия, получать доступ к общему состоянию области и выполнять действия на основе состояния. После завершения выполнения всех действий в области, она получает собственное состояние. 

Чтобы проверить состояние области, можно использовать те же критерии, что и для проверки состояния выполнения приложения логики, например **Succeeded** (Успешно), **Failed** (Сбой) и т. д. 

По умолчанию, когда все действия области будут выполнены, для состояния области устанавливается значение **Succeeded** (Успешно). Если состояние последнего действия в области — **Failed** (Сбой) или **Aborted** (Прервано), для состояния области устанавливается значение **Failed** (Сбой). 

Для перехвата исключений в области с состоянием **Failed** (Сбой) и выполнения действий, которые обрабатывают эти ошибки, можно использовать свойство **runAfter** для области с состоянием **Failed** (Сбой). Таким образом можно создать отдельное действие для перехвата ошибок, в случае если *какое-либо* действие в области завершилось сбоем и для этой области используется свойство **runAfter**.

Сведения об ограничениях в областях см. в статье [Ограничения и настройка Logic Apps](../logic-apps/logic-apps-limits-and-config.md).

### <a name="get-context-and-results-for-failures"></a>Получение контекста и результатов ошибок

Хотя перехват ошибок в области очень эффективен, вам также может понадобиться контекст, чтобы понять, какие действия завершились сбоем, и узнать возвращенные ошибки и коды состояния. Выражение "@result()" предоставляет контекст о результатах всех действий в области.

Выражение "@result()"принимает единственный параметр (имя области) и возвращает массив всех результатов действия из этой области. Объекты действия включают в себя те же атрибуты, что и объект **@actions()**, например время начала и окончания действия, его состояние, входные и выходные данные, а также идентификаторы корреляции. Чтобы отправить контекст любых действий, завершившихся сбоем в области, вы можете легко связать функцию **@result()** со свойством **runAfter**.

Чтобы выполнить действие для каждого действия в области, имеющей результат **Failed** (Сбой), и для фильтрации массива результатов до неудачных действий, можно сопоставить **@result()** с действием **[Фильтрация массива](../connectors/connectors-native-query.md)** и циклом [**Foreach**](../logic-apps/logic-apps-control-flow-loops.md). Можно настроить выполнение действия для каждой ошибки в отфильтрованном массиве результатов, используя цикл **Foreach**. 

Вот пример с подробным объяснением, которое отправляет HTTP-запрос POST, для которого будут возвращены завершившиеся сбоем действия в области My_Scope.

```json
"Filter_array": {
   "type": "Query",
   "inputs": {
      "from": "@result('My_Scope')",
      "where": "@equals(item()['status'], 'Failed')"
   },
   "runAfter": {
      "My_Scope": [
         "Failed"
      ]
    }
},
"For_each": {
   "type": "foreach",
   "actions": {
      "Log_exception": {
         "type": "Http",
         "inputs": {
            "method": "POST",
            "body": "@item()['outputs']['body']",
            "headers": {
               "x-failed-action-name": "@item()['name']",
               "x-failed-tracking-id": "@item()['clientTrackingId']"
            },
            "uri": "http://requestb.in/"
         },
         "runAfter": {}
      }
   },
   "foreach": "@body('Filter_array')",
   "runAfter": {
      "Filter_array": [
         "Succeeded"
      ]
   }
}
```

Подробно рассмотрим приведенный выше пример.

1. Для получения результатов из всех действий внутри области My_Scope, действие **Фильтрация массива** использует выражение фильтра @result('My_Scope').

2. Условие для **Фильтр массива** — это любой элемент @result(), который имеет статус, равный состоянию **Failed** (Сбой). Это условие фильтрует массив, который имеет все результаты действия от My_Scope до массива только с неудачными результатами.

3. Выполните действия цикла**Foreach** на выходных данных *фильтра массива*. Этот шаг выполняет действие для каждого неудавшегося результата действия, который был ранее отфильтрован.

   Если определенное действие в области завершилось сбоем, действия в цикле **Foreach** выполняются только один раз. 
   Многие завершившиеся сбоем действия приведут к выполнению только одного действия на сбой.

4. Отправьте HTTP-запрос POST для текста ответа элемента **Foreach**, который является выражением @item()['outputs']['body']. 

   Формат элемента @result() совпадает с форматом @actions() и может быть проанализирован одинаково.

5. Включите два пользовательских заголовка с именем неудавшегося действия (@item()['name']) и идентификатор отслеживания клиента с ошибкой (@item()['clientTrackingId']).

Для справки: вот пример одного элемента "@result()", отображающего свойства **имени**, **текста** и **clientTrackingId**, которые проанализированы в примере выше. За пределами цикла **Foreach** действие @result() возвращает массив этих объектов.

```json
{
   "name": "Example_Action_That_Failed",
   "inputs": {
      "uri": "https://myfailedaction.azurewebsites.net",
      "method": "POST"
   },
   "outputs": {
      "statusCode": 404,
      "headers": {
         "Date": "Thu, 11 Aug 2016 03:18:18 GMT",
         "Server": "Microsoft-IIS/8.0",
         "X-Powered-By": "ASP.NET",
         "Content-Length": "68",
         "Content-Type": "application/json"
      },
      "body": {
         "code": "ResourceNotFound",
         "message": "/docs/folder-name/resource-name does not exist"
      }
   },
   "startTime": "2016-08-11T03:18:19.7755341Z",
   "endTime": "2016-08-11T03:18:20.2598835Z",
   "trackingId": "bdd82e28-ba2c-4160-a700-e3a8f1a38e22",
   "clientTrackingId": "08587307213861835591296330354",
   "code": "NotFound",
   "status": "Failed"
}
```

Выражения, описанные в этой статье, можно использовать для выполнения различных шаблонов обработки исключений. Вы можете настроить выполнение одного действия обработки исключений вне области, которое принимает весь отфильтрованный массив сбоев, и удалить действие **Foreach**. Кроме того, можно включить другие полезные свойства из ответа **@result()**, как описано выше.

## <a name="azure-diagnostics-and-metrics"></a>Система диагностики и метрики Azure

Приведенные выше шаблоны — эффективный способ обработки ошибок и исключений в выполнении. Однако можно также обнаруживать отдельные ошибки и реагировать на них независимо от выполнения. 
[Система диагностики Azure](../logic-apps/logic-apps-monitor-your-logic-apps.md) предоставляет простой способ отправки всех событий рабочего процесса, включая все состояния выполнений и действий, в учетную запись хранения Azure или в концентратор событий, созданный в службе "Концентраторы событий Azure". 

Вы можете отслеживать журналы и метрики или публиковать их в любом средстве мониторинга для оценки состояния выполнения. К примеру, можно направлять поток всех событий через концентратор событий в [Azure Stream Analytics](https://azure.microsoft.com/services/stream-analytics/). В Stream Analytics можно написать активные запросы для получения сведений об отклонении на основе средних показателей или сбоев из журналов диагностики. Stream Analytics можно использовать для отправки информации в другие источники данных, такие как очереди, разделы, SQL, Azure Cosmos DB или Power BI.

## <a name="next-steps"></a>Дополнительная информация

* [Сценарий обработки исключений и ведения журнала ошибок для приложений логики](../logic-apps/logic-apps-scenario-error-and-exception-handling.md)
* [Примеры использования Logic Apps и распространенные сценарии](../logic-apps/logic-apps-examples-and-scenarios.md)

<!-- References -->
[retryPolicyMSDN]: https://docs.microsoft.com/rest/api/logic/actions-and-triggers#Anchor_9