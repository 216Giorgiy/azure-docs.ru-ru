---
title: Обработка ошибок и исключений в Logic Apps в Azure | Документация Майкрософт
description: Сведения об обработке ошибок и исключений в Logic Apps.
services: logic-apps
documentationcenter: ''
author: dereklee
manager: anneta
editor: ''
ms.assetid: e50ab2f2-1fdc-4d2a-be40-995a6cc5a0d4
ms.service: logic-apps
ms.devlang: ''
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: logic-apps
ms.date: 01/31/2018
ms.author: deli; LADocs
ms.openlocfilehash: 2ae4f0ae9782ada23089d364e8a1700144ef5ff7
ms.sourcegitcommit: 8aab1aab0135fad24987a311b42a1c25a839e9f3
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/16/2018
---
# <a name="handle-errors-and-exceptions-in-logic-apps"></a>Обработка ошибок и исключений в Logic Apps

Сложности, связанные с соответствующей обработкой простоя или устранением неполадок, вызванных зависимыми системами, возникают при использовании любой архитектуры интеграции. Чтобы создать надежную интеграцию, защищенную от проблем и сбоев, Logic Apps предоставляет эффективные возможности для обработки ошибок и исключений. 

## <a name="retry-policies"></a>Политики повтора

Для обработки самых простых исключений и ошибок можно использовать политику повтора. Эта политика определяет, следует ли отправлять запрос повторно и как это можно сделать, если время ожидания первоначального запроса истекло или он завершился сбоем (любой запрос с ответом 429 или 5xx). 

Есть четыре типа политик повтора: по умолчанию, none (нет), fixed (с фиксированным интервалом) и exponential (с экспоненциальным интервалом). Если в определении рабочего процесса не указана политика повтора, то вместо нее используется политика по умолчанию в соответствии с определением службы.

Чтобы настроить политики повтора, если это применимо, откройте конструктор приложений логики и перейдите к **параметрам** конкретного действия в приложении логики. Кроме того, вы можете определить политики повтора в разделе **inputs** определенного действия или триггера, если они предусматривают повтор, в определении рабочего процесса. Ниже приведен общий синтаксис.

```json
"retryPolicy": {
    "type": "<retry-policy-type>",
    "interval": <retry-interval>,
    "count": <number-of-retry-attempts>
}
```

Дополнительные сведения о синтаксисе и разделе **inputs** см. в статье [Триггеры и действия для рабочих процессов приложений логики][retryPolicyMSDN]. Дополнительные сведения об ограничениях политики повтора см. в статье [Ограничения и настройка Logic Apps](../logic-apps/logic-apps-limits-and-config.md). 

### <a name="default"></a>значение по умолчанию

Если вы не определили политику повтора в разделе **retryPolicy**, приложение логики использует политику по умолчанию. Это [политика с экспоненциальным интервалом](#exponential-interval), которая отправляет до четырех повторных попыток с экспоненциально растущим интервалом с шагом в 7,5 секунд. Диапазон составляет от 5 до 45 секунд. Эта политика эквивалентна политике в приведенном ниже примере определения рабочего процесса HTTP:

```json
"HTTP": {
    "type": "Http",
    "inputs": {
        "method": "GET",
        "uri": "http://myAPIendpoint/api/action",
        "retryPolicy" : {
            "type": "exponential",
            "count": 4,
            "interval": "PT7.5S",
            "minimumInterval": "PT5S",
            "maximumInterval": "PT45S"
        }
    },
    "runAfter": {}
}
```

### <a name="none"></a>Нет

Если для **retryPolicy** задать значение **none**, эта политика не выполняет повторно неудачный запрос.

| Имя элемента | Обязательно | type | ОПИСАНИЕ | 
| ------------ | -------- | ---- | ----------- | 
| Тип | Yes | Строка | **Нет** | 
||||| 

### <a name="fixed-interval"></a>Фиксированный интервал

Если для **retryPolicy** задано значение **fixed**, эта политика будет повторять невыполненный запрос, ожидая указанный интервал времени перед отправкой следующего запроса.

| Имя элемента | Обязательно | type | ОПИСАНИЕ |
| ------------ | -------- | ---- | ----------- |
| Тип | Yes | Строка | **fixed** |
| count | Yes | Целое число  | Количество повторных попыток. Значение должно находиться в диапазоне от 1 до 90. | 
| interval | Yes | Строка | Интервал повтора в [формате ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations). Должен быть в диапазоне от PT5S до PT1D. | 
||||| 

<a name="exponential-interval"></a>

### <a name="exponential-interval"></a>Экспоненциальный интервал

Если для **retryPolicy** задано значение **exponential**, эта политика повторяет невыполненный запрос через произвольный интервал времени, выбранный в экспоненциально растущем диапазоне. Политика также гарантирует, что каждой повторной попытке предоставляется произвольный интервал времени в диапазоне от **minimumInterval** до **maximumInterval**. Для экспоненциальных политик необходимо указать значения **count** и **interval**. Значения для **minimumInterval** и **maximumInterval** указывать необязательно. Если вы хотите переопределить значения по умолчанию для PT5S и PT1D соответственно, можно добавить эти значения.

| Имя элемента | Обязательно | type | ОПИСАНИЕ |
| ------------ | -------- | ---- | ----------- |
| Тип | Yes | Строка | **exponential** |
| count | Yes | Целое число  | Количество повторных попыток. Значение должно находиться в диапазоне от 1 до 90.  |
| interval | Yes | Строка | Интервал повтора в [формате ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations). Должен быть в диапазоне от PT5S до PT1D. |
| minimumInterval | Нет  | Строка | Минимальный интервал повтора в [формате ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations). Должен быть в диапазоне от PT5S до **interval**. |
| maximumInterval | Нет  | Строка | Минимальный интервал повтора в [формате ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations). Должен быть в диапазоне от **interval** до PT1D. | 
||||| 

В приведенной ниже таблице показано, как универсальная случайная переменная в указанном диапазоне, будет создаваться для каждой попытки повтора, пока их количество не достигнет значения **count**:

**Диапазон случайных переменных**

| Число повторных попыток | Минимальный интервал | Максимальный интервал |
| ------------ | ---------------- | ---------------- |
| 1 | Max(0, **minimumInterval**) | Min(interval, **maximumInterval**) |
| 2 | Max(interval, **minimumInterval**) | Min(2 * interval, **maximumInterval**) |
| 3 | Max(2 * interval, **minimumInterval**) | Min(4 * interval, **maximumInterval**) |
| 4. | Max(4 * interval, **minimumInterval**) | Min(8 * interval, **maximumInterval**) |
| .... | | | 
|||| 

## <a name="catch-and-handle-failures-with-the-runafter-property"></a>Перехват и обработка ошибок с помощью свойства RunAfter

Каждое действие приложения логики объявляет действия, которые должны завершаться перед началом этого действия. Это похоже на упорядочение действий рабочего процесса. В определении действия этот порядок определяет свойство **runAfter**, которое является объектом, описывающим, какие действия и состояния действий необходимы для выполнения определенного действия.

По умолчанию все действия, добавленные в конструктор приложений логики, выполняются после предыдущего шага, если тот завершился **успешно**. Однако значение **runAfter** можно изменить таким образом, чтобы действия срабатывали, если предыдущие действия получали состояния **Failed** (Сбой), **Skipped** (Пропущено) или оба. Например, чтобы добавить элемент в указанный раздел служебной шины после сбоя определенного действия **Insert_Row**, можно использовать следующий пример определения **runAfter**:

```json
"Send_message": {
    "inputs": {
        "body": {
            "ContentData": "@{encodeBase64(body('Insert_Row'))}",
            "ContentType": "{ \"content-type\" : \"application/json\" }"
        },
        "host": {
            "api": {
                "runtimeUrl": "https://logic-apis-westus.azure-apim.net/apim/servicebus"
            },
            "connection": {
                "name": "@parameters('$connections')['servicebus']['connectionId']"
            }
        },
        "method": "post",
        "path": "/@{encodeURIComponent('failures')}/messages"
    },
    "runAfter": {
        "Insert_Row": [
            "Failed"
        ]
    }
}
```

Свойство **runAfter** выполняется, если состояние действия **Insert_Row** — **Failed** (Сбой). Чтобы выполнить действие, если состояние действия **Succeeded**, **Failed** или **Skipped**, используйте такой синтаксис:

```json
"runAfter": {
        "Insert_Row": [
            "Failed", "Succeeded", "Skipped"
        ]
    }
```

> [!TIP]
> Действия, успешно завершенные после сбоя предыдущего действия, будут помечены как **Succeeded** (Успешно). Таким образом, если перехватить все ошибки в рабочем процессе, само выполнение помечается как **Succeeded** (Успешно).

<a name="scopes"></a>

## <a name="evaluate-actions-with-scopes-and-their-results"></a>Оценка действия с помощью областей и их результатов

Вы можете сгруппировать действия внутри [области](../logic-apps/logic-apps-control-flow-run-steps-group-scopes.md), аналогично тому, как выполняются отдельные действия с помощью свойства **runAfter**. Области позволяют логически группировать действия, получать доступ к общему состоянию области и выполнять действия на основе состояния. После завершения выполнения всех действий в области, она получает собственное состояние. 

Чтобы проверить состояние области, можно использовать те же критерии, что и для проверки состояния выполнения приложения логики, например **Succeeded** (Успешно), **Failed** (Сбой) и т. д. 

По умолчанию, когда все действия области будут выполнены, для состояния области устанавливается значение **Succeeded** (Успешно). Если состояние последнего действия в области — **Failed** (Сбой) или **Aborted** (Прервано), для состояния области устанавливается значение **Failed** (Сбой). 

Для перехвата исключений в области с состоянием **Failed** (Сбой) и выполнения действий, которые обрабатывают эти ошибки, можно использовать свойство **runAfter** для области с состоянием **Failed** (Сбой). Таким образом можно создать отдельное действие для перехвата ошибок, в случае если *какое-либо* действие в области завершилось сбоем и для этой области используется свойство **runAfter**.

Сведения об ограничениях в областях см. в статье [Ограничения и настройка Logic Apps](../logic-apps/logic-apps-limits-and-config.md).

### <a name="get-context-and-results-for-failures"></a>Получение контекста и результатов ошибок

Хотя перехват ошибок в области очень эффективен, вам также может понадобиться контекст, чтобы понять, какие действия завершились сбоем, и узнать возвращенные ошибки и коды состояния. Функция рабочего процесса **@result()** выводит контекст о результате всех действий в области.

Функция **@result()** принимает один параметр (имя области) и возвращает массив результатов всех действий в этой области. Объекты действия включают в себя те же атрибуты, что и объект **@actions()**, например время начала и окончания действия, его состояние, входные и выходные данные, а также идентификаторы корреляции. Чтобы отправить контекст любых действий, завершившихся сбоем в области, вы можете легко связать функцию **@result()** со свойством **runAfter**.

Чтобы выполнять действие *для каждого* действия в области с состоянием **Failed** (Сбой), выполните фильтрацию массива результатов по действиям, которые завершились сбоем, что позволит вам связать **@result()** с действием **[Filter Array](../connectors/connectors-native-query.md)** (Фильтрация массива) и циклом **[ForEach](../logic-apps/logic-apps-control-flow-loops.md)**. Можно настроить выполнение действия для каждой ошибки в отфильтрованном массиве результатов с помощью цикла **ForEach** . 

Ниже представлен пример с подробным описанием под ним. В этом примере отправляется запрос HTTP POST, для которого будут возвращены завершившиеся сбоем действия в области My_Scope.

```json
"Filter_array": {
    "inputs": {
        "from": "@result('My_Scope')",
        "where": "@equals(item()['status'], 'Failed')"
    },
    "runAfter": {
        "My_Scope": [
            "Failed"
        ]
    },
    "type": "Query"
},
"For_each": {
    "actions": {
        "Log_Exception": {
            "inputs": {
                "body": "@item()['outputs']['body']",
                "method": "POST",
                "headers": {
                    "x-failed-action-name": "@item()['name']",
                    "x-failed-tracking-id": "@item()['clientTrackingId']"
                },
                "uri": "http://requestb.in/"
            },
            "runAfter": {},
            "type": "Http"
        }
    },
    "foreach": "@body('Filter_array')",
    "runAfter": {
        "Filter_array": [
            "Succeeded"
        ]
    },
    "type": "Foreach"
}
```

Подробно рассмотрим приведенный выше пример.

1. Чтобы получить результат всех действий в области My_Scope, действие **Filter_array** выполняет фильтрацию **@result('My_Scope')**.

2. Условием отбора для действия **Filter_array** является любой элемент **@result()** с состоянием **Failed** (Сбой). Это условие фильтрует массив всех действий, полученных из области My_Scope, и массив с результатами действий, завершившихся сбоем.

3. Затем выполняется действие цикла **For Each** для данных, полученных в результате выполнения действия *фильтрации массива*. При этом выполняется действие *для каждого* ранее отфильтрованного результата действия, завершившегося сбоем.

   Если определенное действие в области завершилось сбоем, действия в цикле **foreach** выполняются не более одного раза. 
   Многие завершившиеся сбоем действия приведут к выполнению только одного действия на сбой.

4. Затем отправляется запрос HTTP POST для текста ответа элемента **foreach** — **@item()['outputs']['body']**. Форматы элемента **@result()** и **@actions()** совпадают, поэтому они могут быть проанализированы одинаковым образом.

5. В код выше включены два пользовательских заголовка с именем завершившегося сбоем действия **@item()['name']** и идентификатором отслеживания клиента выполнения со сбоем **@item()['clientTrackingId']**.

Ниже приведен пример (для справочных целей) отдельного элемента **@result()** с отображением свойств **name**, **body** и **clientTrackingId**, проанализированных в примере выше. Вне действия **foreach** **@result()** возвращает массив этих объектов.

```json
{
    "name": "Example_Action_That_Failed",
    "inputs": {
        "uri": "https://myfailedaction.azurewebsites.net",
        "method": "POST"
    },
    "outputs": {
        "statusCode": 404,
        "headers": {
            "Date": "Thu, 11 Aug 2016 03:18:18 GMT",
            "Server": "Microsoft-IIS/8.0",
            "X-Powered-By": "ASP.NET",
            "Content-Length": "68",
            "Content-Type": "application/json"
        },
        "body": {
            "code": "ResourceNotFound",
            "message": "/docs/folder-name/resource-name does not exist"
        }
    },
    "startTime": "2016-08-11T03:18:19.7755341Z",
    "endTime": "2016-08-11T03:18:20.2598835Z",
    "trackingId": "bdd82e28-ba2c-4160-a700-e3a8f1a38e22",
    "clientTrackingId": "08587307213861835591296330354",
    "code": "NotFound",
    "status": "Failed"
}
```

Выражения, описанные в этой статье, можно использовать для выполнения различных шаблонов обработки исключений. Вы можете настроить выполнение одного действия обработки исключений вне области, которое принимает весь отфильтрованный массив сбоев, и удалить действие **foreach**. Кроме того, можно включить другие полезные свойства из ответа **@result()**, как описано выше.

## <a name="azure-diagnostics-and-telemetry"></a>Система диагностики и телеметрия Azure

Приведенные выше шаблоны — эффективный способ обработки ошибок и исключений в выполнении. Однако можно также обнаруживать отдельные ошибки и реагировать на них независимо от выполнения. 
[Система диагностики Azure](../logic-apps/logic-apps-monitor-your-logic-apps.md) предоставляет простой способ отправки всех событий рабочего процесса, включая все состояния выполнений и действий, в учетную запись хранения Azure или в концентратор событий, созданный в службе "Концентраторы событий Azure". 

Вы можете отслеживать журналы и метрики или публиковать их в любом средстве мониторинга для оценки состояния выполнения. К примеру, можно направлять поток всех событий через концентратор событий в [Azure Stream Analytics](https://azure.microsoft.com/services/stream-analytics/). В Stream Analytics можно написать активные запросы для получения сведений об отклонении на основе средних показателей или сбоев из журналов диагностики. Stream Analytics можно использовать для отправки информации в другие источники данных, такие как очереди, разделы, SQL, Azure Cosmos DB или Power BI.

## <a name="next-steps"></a>Дополнительная информация

* [Сценарий обработки исключений и ведения журнала ошибок для приложений логики](../logic-apps/logic-apps-scenario-error-and-exception-handling.md)
* [Примеры использования Logic Apps и распространенные сценарии](../logic-apps/logic-apps-examples-and-scenarios.md)

<!-- References -->
[retryPolicyMSDN]: https://docs.microsoft.com/rest/api/logic/actions-and-triggers#Anchor_9