---
title: "Использование приложений логики в качестве вызываемых конечных точек | Документация Майкрософт"
description: "Как создать и настроить конечные точки триггера и использовать их в приложении логики Azure"
services: logic-apps
documentationcenter: .net,nodejs,java
author: jeffhollan
manager: anneta
editor: 
ms.assetid: 73ba2a70-03e9-4982-bfc8-ebfaad798bc2
ms.service: logic-apps
ms.devlang: multiple
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: integration
ms.date: 10/18/2016
ms.author: jehollan
translationtype: Human Translation
ms.sourcegitcommit: d7144208fc3e6eb1f8d3c43d8b4a5e2bcb225e58
ms.openlocfilehash: ac0c200abd110262badd04212c82be45cb0f8bfc
ms.lasthandoff: 02/22/2017


---
# <a name="logic-apps-as-callable-endpoints"></a>Приложения логики как вызываемые конечные точки
В приложениях логики встроена возможность предоставлять синхронную конечную точку HTTP в качестве триггера.  Можно также использовать схему вызываемых конечных точек для вызова приложений логики в качестве вложенного рабочего процесса с помощью действия "рабочего процесса" в приложении логики.

Существует три типа триггеров, которые могут получать запросы:

* Запрос
* apiConnectionWebhook,
* httpWebhook.

В этой статье для примера используется триггер **request**. Все описанные принципы точно так же применяются и к двум остальным типам триггеров.

## <a name="adding-a-trigger-to-your-definition"></a>Добавление триггера в определение
Первый шаг — это добавить триггер в определение приложения логики, способное принимать входящие запросы.  Можно выполнить поиск "HTTP Request" в конструкторе, чтобы добавить карту триггера. Вы можете определить схему JSON текста запроса, а конструктор создаст маркеры для анализа и передачи данных из триггера manual посредством рабочего процесса.  Я рекомендую использовать такой инструмент, как [jsonschema.net](http://jsonschema.net) , для создания схемы JSON из примера полезных данных текста.

![Карта триггера запросов][2]

После сохранения определения приложения логики будет создан URL-адрес обратного вызова следующим образом.

``` text
https://prod-03.eastus.logic.azure.com:443/workflows/080cb66c52ea4e9cabe0abf4e197deff/triggers/myendpointtrigger?*signature*...
```

Этот URL-адрес содержит ключ SAS в параметрах запроса, используемого для аутентификации.

Эту конечную точку также можно получить на портале Azure.

![][1]

Также можно вызвать следующий метод:

``` text
POST https://management.azure.com/{resourceID of your logic app}/triggers/myendpointtrigger/listCallbackURL?api-version=2015-08-01-preview
```

### <a name="changing-http-method-of-the-trigger"></a>Изменение метода HTTP триггера
По умолчанию триггер запросов в Logic Apps ожидает HTTP-запроса POST. Но метод HTTP можно настроить в разделе `Show advanced options`.

 > [!NOTE]
 > Допускается только один тип метода.

### <a name="relative-trigger-url"></a>Относительный URL-адрес триггера
Чтобы принимать параметры, можно также настроить относительный путь URL-адреса запроса.

1. Разверните раздел `Show advanced options` триггера **Request**.
 - В поле `Relative path` введите `customer/{customerId}`.

  ![Относительный URL-адрес триггера](./media/logic-apps-http-endpoint/relativeurl.png)

2. Обновите действие **Respond**, чтобы создать пользователя параметра.
 - В средстве выбора маркеров должен отобразиться вариант `customerId`.
 - Обновите текст ответа, чтобы он возвращал `Hello {customerId}`.

  ![Относительный URL-адрес ответа](./media/logic-apps-http-endpoint/relativeurlresponse.png)

3. Сохраните приложение логики. Вы заметите, что URL-адрес запроса обновился и содержит относительный путь.

4. Скопируйте новый URL-адрес запроса и вставьте его в новое окно браузера. Замените `{customerId}` на `123` и нажмите клавишу ВВОД.
 - Должен вернуться ответ `Your customer Id is 123`.

### <a name="security-for-the-trigger-url"></a>Безопасность URL-адреса триггера
URL-адреса обратного вызова приложений логики создаются безопасным способом на основе подписанного URL-адреса.  Подпись передается как параметр запроса и должна быть проверена перед запуском приложения логики.  Она создается с помощью уникального сочетания секретного ключа каждого приложения логики, имени триггера и выполняемой операции.  Не имея доступа к секретному ключу приложения логики, невозможно создать действительную подпись.

## <a name="calling-the-logic-app-triggers-endpoint"></a>Вызов конечной точки триггера для приложения логики
Созданную конечную точку триггера можно и вызывать с помощью метода `POST` по полному URL-адресу. В текст можно включать дополнительные заголовки и любое другое содержимое.

Тип содержимого `application/json` позволяет ссылаться на свойства из самого запроса. При использовании других типов содержимого запрос считается отдельной двоичной единицей, которая может передаваться в другие API, но недоступна для ссылок внутри рабочего процесса без преобразования содержимого.  Например, чтобы передать содержимое `application/xml`, можно использовать `@xpath()` для извлечения XPath или `@json()` для преобразования XML в JSON.  Дополнительные сведения о работе с типами содержимого [можно найти здесь](../logic-apps/logic-apps-content-type.md)

Кроме того, в определении можно указать схему JSON. Тогда конструктор создаст маркеры, которые затем можно будет передать в действия.  Например, следующий код делает маркеры `title` и `name` доступными в конструкторе.

```
{
    "properties":{
        "title": {
            "type": "string"
        },
        "name": {
            "type": "string"
        }
    },
    "required": [
        "title",
        "name"
    ],
    "type": "object"
}
```

## <a name="referencing-the-content-of-the-incoming-request"></a>Ссылка на содержимое входящего запроса
Функция `@triggerOutputs()` выводит содержимое входящего запроса. Это может выглядеть следующим образом:

```
{
    "headers" : {
        "content-type" : "application/json"
    },
    "body" : {
        "myprop" : "a value"
    }
}
```

Для доступа непосредственно к свойству `body` можно использовать сокращенный вариант `@triggerBody()`. 

## <a name="responding-to-the-request"></a>Ответ на запрос
Некоторые запросы, запускающие приложение логики, подразумевают определенный ответ. Для составления кода состояния, текста и заголовков ответа можно использовать новый тип действия под названием **response** . Обратите внимание, что если фигура **response** отсутствует, то конечная точка приложения логики *немедленно* вернет ответ **202 Accepted** (202 — запрос принят).

![Действие ответа HTTP][3]

``` json
"Response": {
            "conditions": [],
            "inputs": {
                "body": {
                    "name": "@{triggerBody()['name']}",
                    "title": "@{triggerBody()['title']}"
                },
                "headers": {
                    "content-type": "application/json"
                },
                "statusCode": 200
            },
            "type": "Response"
        }
```

Ответы содержат следующее:

| Свойство | Описание |
| --- | --- |
| statusCode |Код состояния HTTP для ответа на входящий запрос. Это может быть любой допустимый код состояния, который начинается с 2xx, 4xx или 5xx. Коды состояния&3;xx не допускаются. |
| текст |Тело ответа. Это может быть строка, объект JSON и даже двоичное содержимое из предыдущего шага. |
| headers |В ответ можно включить любое число заголовков. |

Чтобы исходный запрос получил ответ, все необходимые для этого действия в приложении логики должны быть выполнены в течение *60 секунд* , **если только рабочий процесс не вызывается как вложенное приложение логики**. Если в течение 60 секунд действие response выполнено не будет, срок действия входящего запроса истечет и будет получен ответ HTTP **408 время ожидания клиента истекло** .  Для вложенных приложений логики родительское приложение логики будет продолжать ожидать ответ до конца, независимо от того, сколько это потребует времени.

## <a name="advanced-endpoint-configuration"></a>Расширенная настройка конечной точки
Приложения логики имеют встроенную поддержку конечной точки прямого доступа и для запуска выполнения приложения логики всегда используют метод `POST` . Ранее приложение API **Прослушиватель HTTP** также поддерживало изменение сегментов URL-адреса и метода HTTP. Можно даже настроить дополнительную защиту или пользовательский домен, добавив его в узел приложения API (веб-приложение, в котором находится приложения API). 

Эти функции доступны через **управление API**.

* [Изменение метода запроса](https://msdn.microsoft.com/library/azure/dn894085.aspx#SetRequestMethod)
* [Изменение сегментов URL-адреса запроса](https://msdn.microsoft.com/library/azure/7406a8ce-5f9c-4fae-9b0f-e574befb2ee9#RewriteURL)
* Настройка доменов управления API на вкладке **Настройка** классического портала Azure
* Настройка политики для применения обычной проверки подлинности (**требуется ссылка**)

## <a name="summary-of-migration-from-2014-12-01-preview"></a>Отличия от версии 2014-12-01-preview
| 2014-12-01-preview | 2016-06-01 |
| --- | --- |
| Щелкните приложение API **Прослушиватель HTTP** . |Щелкните параметр **Активация вручную** (приложение API не требуется). |
| Параметр прослушивателя HTTP*Sends response automatically*(Отправляет ответ автоматически). |Добавьте действие **response** в определение рабочего процесса или не делайте этого. |
| Настройка базовой проверки подлинности или OAuth |через управление API |
| Настройка метода HTTP |через управление API |
| Настройка относительного пути |через управление API |
| Ссылка на текст входящего ответа через `@triggerOutputs().body.Content` |Ссылка через `@triggerOutputs().body` |
| **Отправка HTTP-ответа** для прослушивателя HTTP. |Щелкните **Respond to HTTP request** (Ответить на HTTP-запрос) (приложение API не требуется). |

[1]: ./media/logic-apps-http-endpoint/manualtriggerurl.png
[2]: ./media/logic-apps-http-endpoint/manualtrigger.png
[3]: ./media/logic-apps-http-endpoint/response.png

