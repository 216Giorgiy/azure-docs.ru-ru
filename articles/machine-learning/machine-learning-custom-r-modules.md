<properties 
	pageTitle="Создание пользовательских R-модулей в Машинном обучении Azure | Azure" 
	description="Краткое руководство по созданию пользовательских R-модулей в Машинном обучении Azure." 
	services="machine-learning" 
	documentationCenter="" 
	authors="bradsev"  
	manager="paulettm" 
	editor="cgronlun" />

<tags 
	ms.service="machine-learning" 
	ms.devlang="na" 
	ms.topic="article" 
	ms.tgt_pltfrm="na" 
	ms.workload="tbd" 
	ms.date="02/04/2015" 
	ms.author="bradsev" />


# Создание пользовательских R-модулей в Машинном обучении Azure

В этом разделе описывается процедура создания пользовательского R-модуля в Машинном обучении Azure. Здесь рассказывается о том, что такое пользовательский R-модуль и какие файлы используются для его создания. В этом разделе также описан способ создания этих файлов и регистрации модуля для его развертывания в рабочей области Машинного обучения. Затем более подробно описываются элементы и атрибуты, используемые в определении пользовательского модуля. Кроме этого, здесь рассматриваются способы использования дополнительных функций, файлов и нескольких наборов выходных данных. 

## Что такое пользовательский R-модуль?
Пользовательский модуль - это определяемый пользователем модуль, который можно передать в рабочую область пользователя и выполнить как часть эксперимента Машинного обучения Azure. Пользовательский R-модуль представляет собой настраиваемый модуль, который выполняет определяемую пользователем R-функцию в машинном обучении. R - это язык программирования, предназначенный для статистических вычислений и работы с графикой, который широко используют специалисты по статистике и обработке данных для реализации алгоритмов. В параметрах языковой поддержки Машинного обучения для пользовательских модулей по умолчанию задано использование языка R.

Пользовательские модули принадлежат к группе первоклассных модулей в Машинном обучении Azure в том смысле, что их можно использовать наравне с любым другим модулем. Их можно выполнять с другими модулями, включенными в опубликованный эксперимент или визуализированными. Пользователи могут управлять алгоритмом, который реализует модуль, используемыми портами ввода и вывода, параметрами моделирования и другими параметрами, определяющими поведение во время выполнения.


## Файлы в пользовательском R-модуле
Пользовательский R-модуль создается на основе ZIP-файла, содержащего как минимум два файла:

* файл, который реализует R-функцию, предоставляемую модулем;
* XML-файл определения, описывающий пользовательский модуль.

В ZIP-файл также можно включить дополнительные вспомогательные файлы, обеспечивающие функциональные возможности, доступ к которым можно получить из пользовательского модуля. Эта процедура подробно описана ниже.

## Пример быстрого запуска
В этом примере показано, как создать файлы, необходимые для пользовательского R-модуля, упаковать их в ZIP-файл и затем зарегистрировать модуль в рабочей области Машинного обучения.

Рассмотрим пример пользовательского модуля "Добавление моих строк", который изменяет стандартную реализацию модуля "Добавление строк", используемого для объединения строк (наблюдений) из двух наборов данных (кадров данных). Модуль "Добавление строк" добавляет строки второго входного набора данных в конец первого входного набора данных, используя алгоритм rbind. Настраиваемая функция `myAddRows` подобным образом принимает в качестве входных данных два набора данных, а также дополнительный логический параметр переноса значений. Если для параметра переноса задано значение **FALSE**, он возвращает тот же набор данных, что и при стандартной реализации. Если же для параметра переноса задано значение **TRUE**, он добавляет строки из первого входного набора данных в конец второго набора данных. Файл, который реализует R-функцию myAddRows, предоставляемую модулем "Добавление моих строк", содержит следующий код на языке R.

	myAddRows <- function(Dataset1, Dataset2, swap=FALSE) {
	if (swap) { 
		dataset <- rbind(Dataset2, Dataset1))
	 } else { 
	  	dataset <- rbind(Dataset1, Dataset2)) 
	 } 
	return (dataset)
	}

Чтобы предоставить функцию `myAddRows` как модуль Машинного обучения Azure, необходимо создать XML-файл определения, чтобы задать вид и поведение модуля "Добавление моих строк". 

	<Module Version="v0.00.1" type="Public" insync="false" Owner="myName">
	  <GUID>{1CE529D1-B9D2-496F-AB42-8DBA60DE8279}</GUID>
	  <ID>myAddRows</ID>
	  <Name>My Add Rows</Name>	
	  <State>Custom</State>
	  <Description>This is my module description. </Description>
	  <Language Name="R" EntryPointFile="myAddRows.R" EntryPoint="myAddRows" />  
	    <Ports>
	      <output id="dataset" display="dataset" type="DataTable">
	        <Description>Combined Data</Description>
	      </output>
	      <input id="Dataset1" display="Dataset1" type="DataTable">
		    <Description>Input dataset 1</Description>
	      </input>
	      <input id="Dataset2" display="Dataset2" type="DataTable">
		    <Description>Input dataset 2</Description>
	      </input>
	    </Ports>
	    <Arguments>
	      <arg id="swap" display="swap" type="bool" >
	        <Description>Swaps inputs</Description>
	      </arg>
	    </Arguments>
	  <Category>My Category</Category>
	</Module>

 
При этом очень важно, чтобы содержимое элемента идентификатора в XML-файле точно совпадало с именем функции. 

Сохраните эти два файла под именами *myAddRows.R* и *myAddRows.xml*, а затем запакуйте их вместе в ZIP-файл *myAddRows.zip*.

Чтобы зарегистрировать их в рабочей области машинного обучения, перейдите в свою рабочую область в Студии машинного обучения, нажмите кнопку **+СОЗДАТЬ** в нижней части страницы и выберите **МОДУЛЬ -> ИЗ ZIP-ПАКЕТА**, чтобы передать новый пользовательский модуль "Добавление моих строк".

![](http://i.imgur.com/RFJhCls.png)

Теперь модуль "Добавление моих строк" доступен из экспериментов Машинного обучения.

## Элементы в XML-файле определения

### Порты ввода и вывода
Порты ввода и вывода для пользовательского модуля указываются в дочерних элементах раздела Ports в XML-файле определения. От того, в каком порядке заданы эти входные и выходные элементы, зависит структура (UX), которая будет отображаться для пользователей. Первым дочерним элементом в списке элементов в разделе Ports  XML-файла будет крайний левый порт ввода в UX машинного обучения. Ниже приведены типы данных, которые поддерживаются для портов ввода и вывода. 

**DataTable** - этот тип передается R-функции в формате data.frame. Фактически, все типы (например, CSV-файлы или ARFF-файлы), которые поддерживаются  в машинном обучении и совместимы с типом DataTable, автоматически преобразуются в формат data.frame. 

       <input id="dataset1" display="Input 1" type="DataTable" IsOptional="false">
           <Description>Input Dataset 1</Description>
       </input>

**Zip** - пользовательские модули могут принимать в качестве входных данных ZIP-файл. Эти входные данные распаковываются в каталог выполнения функции.

       <input id="zippedData" display="Zip Input" type="Zip" IsOptional="false">
           <Description>Zip Input for port</Description>
       </input>

У атрибутов идентификатора, связанных с каждым из портов ввода и вывода, обязательно должны быть уникальные значения, соответствующие именованным параметрам в R-функции. Кроме того, если для атрибутов необязательно задавать порты ввода, необходимо задать значение по умолчанию. Атрибут IsOptional необязательный для типов DataTable и Zip, и для него по умолчанию задано значение False. Это значение по умолчанию указывает, что тип входных данных обязательный.


### Параметры
Параметры для пользовательского модуля указываются в дочерних элементах в разделе Arguments XML-файла определения. Как и в случае с дочерними элементами в разделе Ports, от порядка параметров в разделе Arguments зависит схема размещения элементов в UX. Первый параметр в списке считается первым параметром функции. Ниже перечислены типы, поддерживаемые для параметров в машинном обучении. Для необязательных атрибутов в XML-файле определения должны быть заданы значения по умолчанию. Это значения, которые используются, если значение параметра не указано при использовании функции. Для каждого типа указано, какие атрибуты являются необязательными.


**int** - параметр целочисленного типа (32-разрядная версия).

       <arg id="intValue1" display="My int Param" type="int" IsOptional="false" MinValue="0" MaxValue="100">
           <Description>Integer Parameter 1</Description>
       </arg>

Необязательные атрибуты для этого типа - IsOptional, MaxValue и MinValue.

**double** - параметр типа double.

       <arg id="doubleValue1" display="My double Param" type="double" IsOptional="false" min="0.000" max="0.999" default="0.3">
           <Description>Double Parameter 1</Description>
       </arg>
Необязательные атрибуты для этого типа - IsOptional, min, max и default.

**bool** - логический параметр, который представлен в UX в виде флажка.

       <arg id="boolValue1" display="My boolean Param" type="bool" default="true">
           <Description>Boolean Parameter 1 </Description>
       </arg>

Необязательный атрибут для этого типа - default.

**string** - стандартная строка.

        <arg id="stringValue1" display="My string Param" type="string" default="default value" IsOptional="true">
           <Description>String Parameter 1</Description>
        </arg>

Необязательные атрибуты для этого типа - default и IsOptional.

**ColumnPickerFor** - параметр выбора столбца. Этот тип воспроизводится в UX в виде средства выбора столбца. Идентификатор объекта DataTable, из которого выбираются столбцы, должен заменить часть таблицы в значении атрибута типа. Переменная будет передана в функцию в виде списка строк. 

        <arg id="columnSelection1" display="My Column Param" type="ColumnPickerFor:table">
           <Description>My column selector Param 1</Description>		
        </arg>

Если бы у нас, например, был объект DataTable с идентификатором dataset1, у типа было бы значение 

		type="ColumnPickerFor:dataset1" 
                            
**enum:<ИД_типа_раскрывающегося_списка>** - (раскрывающийся) список перечисляемых значений. Выбранное значение передается в R-функцию в виде строки. Для этого типа требуется, чтобы в разделе Arguments сначала были определены допустимые перечисляемые значения.

       <DropDownType id="myDropDown1">
           <o id="red" display="Red"/>
           <o id="yellow" display="Yellow"/>
           <o id="blue" display="Blue"/>
       </DropDownType>
       <arg id="enum1" display="My Enum Param" default="red" type="enum:myDropDown1">
           <Description>My Enum Param 1</Description>
       </arg>

Как и в случае с портами ввода и вывода, крайне важно, чтобы с каждым параметром было связано уникальное значение идентификатора. Кроме того, значения идентификаторов должны соответствовать именованным параметрам в R-функции. В нашем примере быстрого запуска связанный идентификатор или параметр - *swap*.

### Определение языка
Элемент Language в XML-файле определения задает функциональные возможности, зависящие от языка. Обычно, для R-модулей это 

	<Language Name="R" EntryPointFile="myFunc.R" EntryPoint="myFunc" AddDisplayOutputPort="false"/>

В этом элементе задается язык, файл, в котором определена функция, и точка входа в этом определении. Необязательный атрибут для элемента Language - AddDisplayOutputPort. Если как и в модуле "Выполнение R-сценария" (ссылка будет добавлена позже) нужно добавить порт вывода, который можно использовать для визуализации диаграмм и графиков, выберите *true* для тега AddDisplayOutputPort. В результате отобразится дополнительный порт вывода. 

### Вспомогательные функции

Для создания пользовательских модулей можно использовать не только атрибуты, задействованные в этом примере, но и многие другие. Например, поведение модуля может быть детерминированным или недетерминированным. Детерминированный модуль не сработает во второй раз при поступлении тех же входных данных с той же конфигурацией параметров. Вместо этого будут использоваться кэшированные результаты, которые распространятся по всем подчиненным модулям. Примером детерминированного модуля в Машинном обучении Azure может служить модуль "Добавление строк". Примером недетерминированного модуля может служить модуль "Средство чтения". Чтобы сделать свой пользовательский модуль недетерминированным, измените параметр по умолчанию, добавив к определению следующий атрибут:

	<IsDeterministic>false</IsDeterministic>

### Вспомогательные файлы

Любой файл, помещенный в ZIP-файл пользовательского модуля, будет доступен для использования во время выполнения. При наличии структуры каталогов эта структура сохраняется. Это означает, что вызов файлов так же будет работать как локально, так и при выполнении в Машинном обучении Azure. 

Предположим, например, что из набора данных необходимо удалить все повторяющиеся строки и строки, в которых частично отсутствуют данные, перед выводом в функцию myAddRows, и вы уже написали R-функцию, которая выполняет это действие в файле removeDupNARows.R:

	removeDupNARows <- function(dataFrame) {
		#Remove Duplicate Rows:
		dataFrame <- unique(dataFrame)
		#Remove Rows with NAs:
		finalDataFrame <- dataFrame[complete.cases(dataFrame),]
		return(finalDataFrame)
	}
Вы можете вызвать вспомогательный файл removeDupNARows.R из функции myAddRows:

	myAddRows <- function(Dataset1, Dataset2, swap=FALSE) {
		source("removeDupNARows.R")
	if (swap) { 
		dataset <- rbind(Dataset2, Dataset1))
	 } else { 
	  	dataset <- rbind(Dataset1, Dataset2)) 
	 } 
	dataset <- removeDupNARows(dataset)
	return (dataset)
	}

Затем передать ZIP-файл, содержащий myAddRows.R, myAddRows.xml и removeDupNARows.R, в качестве пользовательского R-модуля.

### Несколько портов вывода

Для вывода нескольких объектов поддерживаемого типа данных необходимо указать соответствующие порты в XML-файле определения, а объекты необходимо возвратить в виде списка. Выходные объекты будут назначаться портам вывода слева направо, в том порядке, в котором объекты размещены в возвращенном списке.
 
Например, для вывода наборов данных Dataset1 и Dataset2 для портов вывода dataset, dataset1 и dataset2 слева направо, определите, соответственно, порты вывода в файле myAddRows.xml следующим образом:

	<Ports>
	    <output id="dataset" display="dataset" type="DataTable">
	        <Description>Combined Data</Description>
	    </output>
		<output id="Dataset1" display="dataset1" type="DataTable">
	        <Description>Combined Data</Description>
	    </output>
		<output id="Dataset2" display="dataset2" type="DataTable">
	        <Description>Combined Data</Description>
	    </output>
	    <input id="Dataset1" display="Dataset1" type="DataTable">
		    <Description>Input dataset 1</Description>
	    </input>
	    <input id="Dataset2" display="Dataset2" type="DataTable">
		    <Description>Input dataset 2</Description>
	    </input>
	</Ports>

Затем возвратите список объектов в виде списка с правильным порядком в файле myAddRows.R:

	myAddRows <- function(Dataset1, Dataset2, swap=FALSE) {
	if (swap) { 
		dataset <- rbind(Dataset2, Dataset1))
	 } else { 
	  	dataset <- rbind(Dataset1, Dataset2)) 
	 } 
	return (list(dataset, Dataset1, Dataset2))
	}

## Среда выполнения

ПОДЛЕЖИТ УТОЧНЕНИЮ

## Дальнейшие действия

ПОДЛЕЖИТ УТОЧНЕНИЮ

<!--HONumber=49--> 