---
title: "Конкретные рекомендации по использованию механизма повторов | Документация Майкрософт"
description: "Конкретные рекомендации по настройке механизма повторов."
services: 
documentationcenter: na
author: dragon119
manager: christb
editor: 
tags: 
ms.assetid: 159d6a0b-b929-4e7f-b297-f89b4af8a940
ms.service: best-practice
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 07/13/2016
ms.author: masashin
translationtype: Human Translation
ms.sourcegitcommit: f5bdbd801107650f87993b395338adfb1b26d17e
ms.openlocfilehash: 28f0a833ca410a518291c99b308ac52a1318761e


---
# <a name="retry-service-specific-guidance"></a>Конкретные рекомендации по использованию механизма повторов
[!INCLUDE [pnp-header](../includes/guidance-pnp-header-include.md)]

## <a name="overview"></a>Обзор
Большинство служб Azure и клиентских пакетов SDK содержат механизм повтора. В то же время они отличаются, поскольку каждая служба имеет разные характеристики и требования, поэтому каждый механизм повтора настроен для конкретной службы. В этом руководстве представлены возможности механизма повтора для большинства служб Azure, а также сведения, помогающие использовать, адаптировать или расширять механизм повтора для такой службы.

Для получения общих рекомендаций по обработке временных сбоев и выполнения повторных попыток подключения и операций со службами и ресурсами обратитесь к разделу [Руководство по повторам](best-practices-retry-general.md).

В следующей таблице перечислены функции механизма повтора для служб Azure, описанных в этом руководстве.

| **Служба** | **Ключевые возможности** | **Настройки политики** | **Область** | **Функции телеметрии** |
| --- | --- | --- | --- | --- |
| **[Служба хранилища Azure](#azure-storage-retry-guidelines)** |Машинный код в клиенте |Программный |Клиентские и индивидуальные операции |TraceSource |
| **[База данных SQL с Entity Framework](#sql-database-using-entity-framework-6-retry-guidelines)** |Машинный код в клиенте |Программный |Глобальные каждого домена приложения |None |
| **[База данных SQL с ADO.NET](#azure-storage-retry-guidelines)** |Topaz* |Декларативные и программные |Единые инструкции или блоки кода |Пользовательская |
| **[Служебная шина](#service-bus-retry-guidelines)** |Машинный код в клиенте |Программный |Диспетчер пространств имен, фабрика сообщений и клиент |Трассировка событий Windows |
| **[Кэш Redis для Azure](#azure-redis-cache-retry-guidelines)** |Машинный код в клиенте |Программный |Клиент |TextWriter |
| **[DocumentDB](#documentdb-retry-guidelines)** |Машинный код в службе |Ненастраиваемые |Глобальные |TraceSource |
| **[Поиск Azure](#azure-storage-retry-guidelines)** |Машинный код в клиенте |Программный |Клиент |Трассировка событий Windows или пользовательская |
| **[Active Directory](#azure-active-directory-retry-guidelines)** |Topaz* (с пользовательской стратегией определения) |Декларативные и программные |Блоки кода |Пользовательская |

* Topaz — это понятное имя блока приложения для обработки временной ошибки, включенного в [Enterprise Library 6.0][entlib]. Можно использовать пользовательскую стратегию определения с Topaz для большинства типов служб, как описано в этом руководстве. Стратегии Topaz по умолчанию указаны в разделе [Стратегии блока приложения для обработки временной ошибки (Topaz)](#transient-fault-handling-application-block-topaz-strategies) в конце этого руководства. Обратите внимание, что блок теперь является объектом с открытым кодом и напрямую не поддерживается корпорацией Майкрософт.

> [!NOTE]
> Для большинства встроенных механизмов повтора Azure в данный момент невозможно применить различную политику повтора для различных типов ошибок или исключений за пределами функционала, включенного в политику повтора. Таким образом наилучшей рекомендацией на момент написания статьи будет являться настройка политики, которая обеспечит оптимальный средний уровень производительности и доступности. Одним из способов настройки политики является анализ файлов журнала для определения типа возникающих временных сбоев. Например, если большая часть ошибок связана с проблемами с сетевым подключением, вы можете попробовать настроить немедленный повтор вместо ожидания перед первой попыткой.
>
>

## <a name="azure-storage-retry-guidelines"></a>Рекомендации по использованию механизма повторов для службы хранилища Azure
Службы хранилища Azure включают таблицы и BLOB-хранилища, файлы и очереди хранилища.

### <a name="retry-mechanism"></a>Механизм повтора
Повторы выполняются на уровне отдельных операции REST и являются неотъемлемой частью реализации API клиента. Клиентский пакет SDK службы хранилища использует классы, реализующие [Интерфейс IExtendedRetryPolicy](http://msdn.microsoft.com/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.aspx).

Существуют различные реализации этого интерфейса. Клиенты службы хранилища могут выбирать политики специально для доступа к таблицам, BLOB-объектам и очередям. Каждая реализация использует различные стратегии повтора, фактически определяя интервал повторных попыток и другие параметры.

Встроенные классы обеспечивают поддержку для линейных (постоянная задержка) и экспоненциальных со случайными параметрами интервалов повтора. Здесь также нет политики повторов для случаев, когда другой процесс обрабатывает повторы на более высоком уровне. Тем не менее если имеются особые требования, не предоставляемые встроенными классами, то можно реализовать собственные классы для обработки повторов.

Альтернативные повторы переключаются между первичным и вторичным расположением службы хранилища при использовании геоизбыточного хранилища с доступом на чтение (RA-GRS) и если результатом запроса стала ошибка. Дополнительные сведения см. в статье [Варианты избыточности хранилища Azure](http://msdn.microsoft.com/library/azure/dn727290.aspx).

### <a name="policy-configuration"></a>Настройки политики
Политики повтора настраиваются программным способом. Типичная процедура состоит в создании и заполнении экземпляров **TableRequestOptions**, **BlobRequestOptions**, **FileRequestOptions** или **QueueRequestOptions**.

```csharp
TableRequestOptions interactiveRequestOption = new TableRequestOptions()
{
  RetryPolicy = new LinearRetry(TimeSpan.FromMilliseconds(500), 3),
  // For Read-access geo-redundant storage, use PrimaryThenSecondary.
  // Otherwise set this to PrimaryOnly.
  LocationMode = LocationMode.PrimaryThenSecondary,
  // Maximum execution time based on the business use case. Maximum value up to 10 seconds.
  MaximumExecutionTime = TimeSpan.FromSeconds(2)
};
```

Затем можно задать параметры экземпляра запроса на клиенте, и все операции с клиентом будут использовать указанные параметры запроса.

```csharp
client.DefaultRequestOptions = interactiveRequestOption;
var stats = await client.GetServiceStatsAsync();
```

Можно переопределить параметры запроса клиента путем передачи заполненного экземпляра класса параметров запроса в качестве параметра метода.

```csharp
var stats = await client.GetServiceStatsAsync(interactiveRequestOption, operationContext: null);
```

Можно использовать экземпляр **OperationContext** , чтобы указать код, выполняемый при возникновении повтора и после завершения операции. Этот код может собирать сведения об операции для последующего использования в результатах телеметрии и журналах.

    // Set up notifications for an operation
    var context = new OperationContext();
    context.ClientRequestID = "some request id";
    context.Retrying += (sender, args) =>
    {
      /* Collect retry information */
    };
    context.RequestCompleted += (sender, args) =>
    {
      /* Collect operation completion information */
    };
    var stats = await client.GetServiceStatsAsync(null, context);

Кроме определения, подходит ли сбой для повторных попыток, расширенные политики повтора возвращают объект **RetryContext**, который указывает число повторных попыток, результаты последнего запроса, произойдет ли следующая попытка в первичном или вторичном расположении (дополнительные сведения см. в таблице ниже). Свойства объекта **RetryContext** позволяют принять решение о необходимости и времени выполнения повтора. Дополнительные сведения см. в статье [Метод IExtendedRetryPolicy.Evaluate](http://msdn.microsoft.com/library/microsoft.windowsazure.storage.retrypolicies.iextendedretrypolicy.evaluate.aspx).

Следующая таблица показывает значения по умолчанию для встроенной политики повторов.

| **Контекст** | **Параметр** | **Значение по умолчанию** | **Значение** |
| --- | --- | --- | --- |
| Таблицы, BLOB-объекты или File<br />QueueRequestOptions |MaximumExecutionTime<br /><br />ServerTimeOut<br /><br /><br /><br /><br />LocationMode<br /><br /><br /><br /><br /><br /><br />политика RetryPolicy |120 секунд<br /><br />None<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />ExponentialPolicy |Максимальное время выполнения запроса, включая все потенциальные повторные попытки.<br />Интервал времени ожидания сервера для запроса (значение округляется до секунд). Если не указан, он будет использовать значение по умолчанию для всех запросов к серверу. Как правило, лучше всего опустить этот параметр, чтобы использовать значение сервера по умолчанию.<br />Если учетная запись хранения создается с вариантом репликации на географически избыточном хранилище с доступом для чтения (RA-GRS), то можно использовать режим расположения, чтобы указать расположение, где запрос должен быть получен. Например, если указано **PrimaryThenSecondary**, запросы всегда будут отправляться сначала в основное расположение. Если запрос завершается ошибкой, он направляется во вторичное расположение.<br />Сведения о каждом параметре смотрите далее. |
| Экспоненциальная политика |maxAttempt<br />deltaBackoff<br /><br /><br />MinBackoff<br /><br />MaxBackoff |3<br />4 секунды<br /><br /><br />3 секунды<br /><br />30 секунд |Количество повторных попыток.<br />Интервал отсрочки между повторными попытками. Кратное timespan, включая элемент случая, который будет использоваться для последующих попыток.<br />Добавить ко всем интервалам повтора, вычисленным по deltaBackoff. Это значение не может быть изменено.<br />MaxBackoff используется в том случае, если расчетный интервал повторных попыток оказывается больше, чем MaxBackoff. Это значение не может быть изменено. |
| Линейная политика |maxAttempt<br />deltaBackoff |3<br />30 секунд |Количество повторных попыток.<br />Интервал отсрочки между повторными попытками. |

### <a name="retry-usage-guidance"></a>Руководство по использованию механизма повторов
При доступе к службам хранилища Azure с помощью API клиентской службы хранилища, придерживайтесь следующих рекомендаций.

* Используйте встроенные политики повтора из пространства имен Microsoft.WindowsAzure.Storage.RetryPolicies, которые соответствуют требованиям. В большинстве случаев использования этих политик будет достаточно.
* Используйте политику **ExponentialRetry** для пакетных операций, фоновых задач или неинтерактивных сценариев. В этих сценариях обычно имеется больше времени для восстановления службы — таким образом повышается успешного выполнения операции.
* Следует указать свойства **MaximumExecutionTime** параметра **RequestOptions** для ограничения общего времени выполнения, а также принять во внимание тип и размер операции при выборе значения времени ожидания.
* Если необходимо реализовать пользовательский повтор, избегайте создания оболочек клиентских классов хранения. Вместо этого используйте возможности для расширения существующих политик с помощью интерфейса **IExtendedRetryPolicy** .
* Если вы используете геоизбыточное хранилище с доступом на чтение (RA-GRS), можно использовать **LocationMode** для указания, что повторные попытки должны будут выполняться для вторичной копии хранилища в случае сбоя доступа к первичному хранилищу. Однако при использовании этого параметра необходимо убедиться, что ваше приложение может успешно работать с данными, которые могут устаревать, если процедура репликации с основным хранилищем еще не завершена.

Начните с использования следующих параметров для операции повтора. Это параметры общего назначения, и вам будет необходимо отслеживать операции и проводить тонкую настройку параметров в соответствии с конкретной ситуацией.  

| **Контекст** | **Максимальная задержка<br />примера целевого E2E** | **Политика повтора** | **Параметры** | **Значения** | **Принцип работы** |
| --- | --- | --- | --- | --- | --- |
| Интерактивный, пользовательский интерфейс<br />или передний план |2 секунды |Линейная |maxAttempt<br />deltaBackoff |3<br />500 мс |Попытка 1 — задержка 500 мс<br />Попытка 2 — задержка 500 мс<br />попытка 3 — задержка 500 мс |
| Фоновый<br />или пакетный |30 секунд |Экспоненциальная |maxAttempt<br />deltaBackoff |5<br />4 секунды |Попытка 1 — задержка ~ 3 с<br />Попытка 2 — задержка 7 с<br />Попытка 3 — задержка ~ 15 с |

### <a name="telemetry"></a>Телеметрия
Количество попыток входа регистрируется в **TraceSource**. Необходимо настроить **TraceListener** для сбора данных о событиях и записи этих данных в журнал с подходящим назначением. Можно использовать **TextWriterTraceListener** или **XmlWriterTraceListener** для записи данных в файл журнала, **EventLogTraceListener** для записи в журнал событий Windows или **EventProviderTraceListener** для записи данных трассировки в подсистеме трассировки событий Windows. Можно также настроить автоматическую очистку буфера и уровень детализации регистрируемых событий (например, Ошибка, Предупреждение, Информационное событие и Подробное протоколирование). Дополнительные сведения см. в статье [Вход в клиентскую библиотеку хранилища .NET на стороне клиента](http://msdn.microsoft.com/library/azure/dn782839.aspx).

Операции могут получать экземпляр **OperationContext**, предоставляющий событие **Повтор**, которое может использоваться для присоединения телеметрии пользовательской логики. Дополнительные сведения см. в статье [Событие OperationContext.Retrying](http://msdn.microsoft.com/library/microsoft.windowsazure.storage.operationcontext.retrying.aspx).

### <a name="examples"></a>Примеры
В следующем примере кода показано, как создать два экземпляра **TableRequestOptions** с различными параметрами, один для интерактивных запросов и один для фоновых запросов. Пример затем устанавливает эти две политики повторов на клиентском компьютере, чтобы они применялись для всех запросов, а также задает интерактивную стратегию на конкретный запрос, чтобы он переопределял параметры по умолчанию, применяемые к клиенту.

```csharp
using System;
using System.Threading.Tasks;
using Microsoft.WindowsAzure.Storage;
using Microsoft.WindowsAzure.Storage.RetryPolicies;
using Microsoft.WindowsAzure.Storage.Table;

namespace RetryCodeSamples
{
    class AzureStorageCodeSamples
    {
        private const string connectionString = "UseDevelopmentStorage=true";

        public async static Task Samples()
        {
            var storageAccount = CloudStorageAccount.Parse(connectionString);

            TableRequestOptions interactiveRequestOption = new TableRequestOptions()
            {
                RetryPolicy = new LinearRetry(TimeSpan.FromMilliseconds(500), 3),
                // For Read-access geo-redundant storage, use PrimaryThenSecondary.
                // Otherwise set this to PrimaryOnly.
                LocationMode = LocationMode.PrimaryThenSecondary,
                // Maximum execution time based on the business use case. Maximum value up to 10 seconds.
                MaximumExecutionTime = TimeSpan.FromSeconds(2)
            };

            TableRequestOptions backgroundRequestOption = new TableRequestOptions()
            {
                // Client has a default exponential retry policy with 4 sec delay and 3 retry attempts
                // Retry delays will be approximately 3 sec, 7 sec, and 15 sec
                MaximumExecutionTime = TimeSpan.FromSeconds(30),
                // PrimaryThenSecondary in case of Read-access geo-redundant storage, else set this to PrimaryOnly
                LocationMode = LocationMode.PrimaryThenSecondary
            };

            var client = storageAccount.CreateCloudTableClient();
            // Client has a default exponential retry policy with 4 sec delay and 3 retry attempts
            // Retry delays will be approximately 3 sec, 7 sec, and 15 sec
            // ServerTimeout and MaximumExecutionTime are not set

            {
                // Set properties for the client (used on all requests unless overridden)
                // Different exponential policy parameters for background scenarios
                client.DefaultRequestOptions = backgroundRequestOption;
                // Linear policy for interactive scenarios
                client.DefaultRequestOptions = interactiveRequestOption;
            }

            {
                // set properties for a specific request
                var stats = await client.GetServiceStatsAsync(interactiveRequestOption, operationContext: null);
            }

            {
                // Set up notifications for an operation
                var context = new OperationContext();
                context.ClientRequestID = "some request id";
                context.Retrying += (sender, args) =>
                {
                    /* Collect retry information */
                };
                context.RequestCompleted += (sender, args) =>
                {
                    /* Collect operation completion information */
                };
                var stats = await client.GetServiceStatsAsync(null, context);
            }
        }
    }
}
```

### <a name="more-information"></a>Дополнительные сведения
* [Рекомендации по настройке политики повтора для клиентской библиотеки службы хранилища Azure](https://azure.microsoft.com/blog/2014/05/22/azure-storage-client-library-retry-policy-recommendations/)
* [Клиентская библиотека службы хранилища 2.0: реализация политики повтора](http://gauravmantri.com/2012/12/30/storage-client-library-2-0-implementing-retry-policies/)

## <a name="sql-database-using-entity-framework-6-retry-guidelines"></a>Руководство по использованию механизма повторов для базы данных SQL с помощью инструкций Entity Framework 6
База данных SQL является размещенной базой данных SQL различных размеров и является как стандартной (общей), так и премиальной (частной) службой. Механизм Entity Framework является модулем объектно-реляционного сопоставления, который позволяет разработчикам .NET работать с реляционными данными с помощью специфических для домена объектов. Это исключает необходимость в большинстве кодов доступа к данным, которые обычно требуется писать разработчикам.

### <a name="retry-mechanism"></a>Механизм повтора
Поддержка повторных попыток при доступе к базе данных SQL с помощью Entity Framework 6.0 и выше предоставляется через механизм, называемый [Устойчивость соединения и логика повтора](http://msdn.microsoft.com/data/dn456835.aspx). Полная спецификация доступна на [Вики-сайте .NET Entity Framework](https://entityframework.codeplex.com/wikipage?title=Connection%20Resiliency%20Spec) на Codeplex. Ниже перечислены основные возможности механизма повтора.

* Интерфейс **IDbExecutionStrategy** является основной абстракцией. Этот интерфейс
  * Определяет синхронные и асинхронные методы **Execute***.
  * Определяет классы для непосредственного использования, или которые могут быть настроены на контекст базы данных как стратегию по умолчанию, с сопоставленным именем поставщика или сопоставленным именем поставщика и именем сервера. При настройке на контекст повторы происходят на уровне операций с отдельными базами данных, из которых несколько может соответствовать заданному контексту операции.
  * Определяет, когда и каким образом следует выполнить повтор при ошибке соединения.
* Включает несколько встроенных реализаций интерфейса **IDbExecutionStrategy** .
  * Значение по умолчанию — не повторять.
  * По умолчанию для базы данных SQL (автоматический режим) — не повторять, но проверять исключения и завершать их с предложением использовать стратегию базы данных SQL.
  * По умолчанию для базы данных SQL — экспоненциальный повтор (наследуется от базового класса) плюс логика обнаружения базы данных SQL.
* Это реализует стратегию экспоненциальной отсрочки, которая также включает случайный выбор.
* Встроенные классы повтора включают отслеживание состояния и не являются потокобезопасными. Однако они могут использоваться повторно после завершения текущей операции.
* В случае превышения заданного счетчика повторов результаты помещаются в новое исключение. Это не вызывает перенаправления текущего исключения.

### <a name="policy-configuration"></a>Настройки политики
Поддержка повторных попыток предоставляется при доступе к базе данных SQL с помощью Entity Framework 6.0 и более поздних версий. Политики повтора настраиваются программным способом. Нельзя изменить конфигурацию для каждой операции.

При настройке стратегии в контексте по умолчанию, необходимо указать функцию, которая создает новые стратегии по требованию. В следующем коде показано, как можно создать класс конфигурации повтора, который расширяет базовый класс **DbConfiguration** .

```csharp
public class BloggingContextConfiguration : DbConfiguration
{
  public BlogConfiguration()
  {
    // Set up the execution strategy for SQL Database (exponential) with 5 retries and 4 sec delay
    this.SetExecutionStrategy(
         "System.Data.SqlClient", () => new SqlAzureExecutionStrategy(5, TimeSpan.FromSeconds(4)));
  }
}
```

Затем можно указать это в качестве стратегии повторных попыток по умолчанию для всех операций с помощью метода **SetConfiguration** экземпляра **DbConfiguration** при запуске приложения. По умолчанию EF будет автоматически обнаруживать и использовать класс конфигурации.

    DbConfiguration.SetConfiguration(new BloggingContextConfiguration());

Класс конфигурации повторных попыток для контекста задается дополнением контекста класса атрибутом **DbConfigurationType** . Однако при наличии только одного класса конфигурации EF будет использовать его без необходимости дополнения контекста.

    [DbConfigurationType(typeof(BloggingContextConfiguration))]
    public class BloggingContext : DbContext
    { ...

Если необходимо использовать различные стратегии для конкретных операций или отключить повторы для определенных операций, то можно создать класс конфигурации, который позволяет приостановить или заменить стратегии, установив флаг **CallContext**. Класс конфигурации может использовать этот флаг для переключения стратегии или отключения стратегии, предоставленной вами, с последующим использованием стратегии по умолчанию. Дополнительные сведения см. в разделе [Приостановка выполнения стратегии](http://msdn.microsoft.com/dn307226#transactions_workarounds) на странице "Ограничения стратегий выполнения повторов (для EF6 и выше)".

Иным способом использования стратегий повторов, определенных для отдельных операций, является создание экземпляра класса требуемой стратегии и передача ему нужных параметров. Затем можно вызвать его метод **ExecuteAsync** .

    var executionStrategy = new SqlAzureExecutionStrategy(5, TimeSpan.FromSeconds(4));
    var blogs = await executionStrategy.ExecuteAsync(
        async () =>
        {
            using (var db = new BloggingContext("Blogs"))
            {
                // Acquire some values asynchronously and return them
            }
        },
        new CancellationToken()
    );

Самый простой способ использовать класс **DbConfiguration** — это обнаружить его в той же сборке, что и класс **DbContext**. Однако этот способ не подходит в случае, когда тот же контекст требуется в различных сценариях, таких как различные интерактивные и фоновые стратегии повторов. Если разные контексты выполняются в отдельных доменах приложений, можно использовать встроенную поддержку для указания классов конфигурации в файле конфигурации или задать ее явным образом с помощью кода. Если различные контексты должны выполняться в том же домене приложения, потребуется создание пользовательского решения.

Дополнительные сведения см. в статье [Конфигурация на основе кода (для EF6 и выше)](http://msdn.microsoft.com/data/jj680699.aspx).

Следующая таблица показывает значения по умолчанию для встроенной политики повторов при использовании EF6.

![](media/best-practices-retry-service-specific/RetryServiceSpecificGuidanceTable4.png)

### <a name="retry-usage-guidance"></a>Руководство по использованию механизма повторов
При доступе к базе данных SQL с помощью EF6, придерживайтесь следующих рекомендаций.

* Выберите соответствующую службу (общую или премиальную). Общий экземпляр может испытывать большие задержки подключения и регулирования чем обычно из-за использования другими клиентами общего сервера. Если требуется выполнение надежных операций с низкой задержкой и прогнозируемая производительность, попробуйте выбрать премиальный вариант.
* Стратегия фиксированного интервала не рекомендуется для использования с базой данных SQL Azure. Вместо этого используйте стратегию экспоненциальной отсрочки, так как служба может быть перегружена и большее время задержки обеспечит большее время для ее восстановления.
* Выберите подходящее значение для времени ожидания подключения и команды при определении подключения. Выберите значение времени ожидания на основе логики вашей работы и на основе испытаний. Может потребоваться изменить это значение по мере изменения объемов данных или бизнес-процессов. Слишком короткое время ожидания может привести к преждевременным сбоям подключений, когда база данных занята. Слишком длинное время ожидания может помешать правильной работе логики повторов из-за слишком долгого ожидания до обнаружения ошибки соединения. Значение времени ожидания — это компонент сквозной задержки, несмотря на это вы не можете легко определить, сколько команд будет выполнено при сохранении контекста. Время ожидания по умолчанию можно изменить, задав свойство **CommandTimeout** экземпляра **DbContext**.
* Платформа Entity Framework поддерживает конфигурации повторов, определенные в файлах конфигурации. Однако для максимальной гибкости в Azure необходимо создать конфигурацию программным способом в приложении. Определенные параметры политик повторов, например количество повторных попыток и интервалы повтора, можно сохранить в файле конфигурации службы и использовать во время выполнения для создания соответствующих политик. Это позволяет изменять параметры перезапуска приложения при необходимости.

Начните с использования следующих параметров для операции повтора. Нельзя указать задержку между попытками повтора (она является фиксированной и генерируется в виде экспоненциальной последовательности). Максимальные значения можно указать, как показано ниже, если только вы не создаете пользовательскую стратегию. Это параметры общего назначения, и вам будет необходимо отслеживать операции и проводить тонкую настройку параметров в соответствии с конкретной ситуацией.

| **Контекст** | **Максимальная задержка<br />примера целевого E2E** | **Политика повтора** | **Параметры** | **Значения** | **Принцип работы** |
| --- | --- | --- | --- | --- | --- |
| Интерактивный, пользовательский интерфейс<br />или передний план |2 секунды |Экспоненциальная |MaxRetryCount<br />MaxDelay |3<br />750 мс |Попытка 1 — задержка 0 с<br />Попытка 2 — задержка 750 мс<br />Попытка 3 – задержка 750 мс |
| Фоновый<br /> или пакетный |30 секунд |Экспоненциальная |MaxRetryCount<br />MaxDelay |5<br />12 секунд |Попытка 1 — задержка 0 с<br />Попытка 2 — задержка 1 с<br />Попытка 3 — задержка 3 с<br />Попытка 4 — задержка 7 с<br />Попытка 5 — задержка 12 с |

> [!NOTE]
> Целевые значения сквозной задержки подразумевают время ожидания по умолчанию для подключения к службе. При указании более длинного времени ожидания подключения величина сквозной задержки будет увеличена путем добавления этого дополнительного времени для каждой попытки повтора.
>
>

### <a name="examples"></a>Примеры
В следующем примере кода определяется простое решение доступа к данным, использующее Entity Framework. Программа определяет конкретную стратегию путем определения класса с именем экземпляра **BlogConfiguration**, который расширяет **DbConfiguration**.

```csharp
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.SqlServer;
using System.Threading.Tasks;

namespace RetryCodeSamples
{
    public class BlogConfiguration : DbConfiguration
    {
        public BlogConfiguration()
        {
            // Set up the execution strategy for SQL Database (exponential) with 5 retries and 12 sec delay.
            // These values could be loaded from configuration rather than being hard-coded.
            this.SetExecutionStrategy(
                    "System.Data.SqlClient", () => new SqlAzureExecutionStrategy(5, TimeSpan.FromSeconds(12)));
        }
    }

    // Specify the configuration type if more than one has been defined.
    // [DbConfigurationType(typeof(BlogConfiguration))]
    public class BloggingContext : DbContext
    {
        // Definition of content goes here.
    }

    class EF6CodeSamples
    {
        public async static Task Samples()
        {
            // Execution strategy configured by DbConfiguration subclass, discovered automatically or
            // or explicitly indicated through configuration or with an attribute. Default is no retries.
            using (var db = new BloggingContext("Blogs"))
            {
                // Add, edit, delete blog items here, then:
                await db.SaveChangesAsync();
            }
        }
    }
}
```

Дополнительные примеры использования механизма повтора Entity Framework можно найти в разделе [Устойчивость соединения и логика повтора](http://msdn.microsoft.com/data/dn456835.aspx).

### <a name="more-information"></a>Дополнительные сведения
* [Руководство по эластичности и производительности базы данных SQL Azure](http://social.technet.microsoft.com/wiki/contents/articles/3507.windows-azure-sql-database-performance-and-elasticity-guide.aspx)

## <a name="sql-database-using-adonet-retry-guidelines"></a>Руководство по использованию механизма повторов с базой данных SQL с использованием ADO.NET
База данных SQL является размещенной базой данных SQL различных размеров и является как стандартной (общей), так и премиальной (частной) службой.

### <a name="retry-mechanism"></a>Механизм повтора
База данных SQL не имеет встроенной поддержки выполнения повторных попыток, если доступ осуществляется с помощью ADO.NET. Однако коды возврата от запросов могут быть использованы для определения причины сбоя запроса. Страница [Регулирование базы данных SQL Azure](http://msdn.microsoft.com/library/dn338079.aspx) объясняет, как с помощью регулирования можно запретить подключения, коды возврата для определенных ситуаций и как обрабатывать эти операции и операции повтора.

Блок приложения для обработки временной ошибки (Topaz) можно использовать с пакетом Nuget EnterpriseLibrary.TransientFaultHandling.Data (класс **SqlAzureTransientErrorDetectionStrategy**) для реализации механизма повтора для базы данных SQL.

Блок также предоставляет класс **ReliableSqlConnection**, который реализует старый API 1.0 ADO.NET (**IDbConnection** вместо **DbConnection**) и осуществляет повторные попытки и управление подключениями изнутри. Хотя механизм является удобным, необходимо использовать другой набор методов для вызова операций при выполнении повторных попыток, и поэтому он не является простой прямой заменой. Он не поддерживает асинхронное выполнение, что рекомендуется использовать при реализации и использовании служб Azure. Кроме того, так как этот класс использует ADO.NET 1.0, он не может воспользоваться преимуществами последних улучшений и обновлений для ADO.NET.

### <a name="policy-configuration-sql-database-using-adonet"></a>Настройка политики (база данных SQL с помощью ADO.NET)
Блок приложения для обработки временной ошибки поддерживает конфигурирование как на основе файла, так и программным методом. В общем случае следует использовать программную конфигурацию для обеспечения максимальной гибкости (см. примечания ниже для получения дополнительных сведений). Следующий код, который будет выполняться один раз при запуске приложения, создает и заполняет **RetryManager** списком из четырех стратегий повтора, подходящих для использования с Базой данных SQL Azure. Программа также задает стратегии по умолчанию для **RetryManager**. Это стратегии будут использоваться для подключения и выдачи команд, если альтернативная стратегия не будет указана при создании соединения или команды.

```csharp
RetryManager.SetDefault(new RetryManager(
    new List<RetryStrategy> { new ExponentialBackoff(name: "default", retryCount: 3,
                                                    minBackoff:     TimeSpan.FromMilliseconds(100),
                                                    maxBackoff:     TimeSpan.FromSeconds(30),
                                                    deltaBackoff:     TimeSpan.FromSeconds(1),
                                                    firstFastRetry: true),
                            new ExponentialBackoff(name: "default sql connection", retryCount: 3,
                                                    minBackoff:     TimeSpan.FromMilliseconds(100),
                                                    maxBackoff:     TimeSpan.FromSeconds(30),
                                                    deltaBackoff:     TimeSpan.FromSeconds(1),
                                                    firstFastRetry: true),
                            new ExponentialBackoff(name: "default sql command", retryCount: 3,
                                                    minBackoff:     TimeSpan.FromMilliseconds(100),
                                                    maxBackoff:     TimeSpan.FromSeconds(30),
                                                    deltaBackoff:     TimeSpan.FromSeconds(1),
                                                    firstFastRetry: true),
                            new ExponentialBackoff(name: "alt sql", retryCount: 5,
                                                    minBackoff:     TimeSpan.FromMilliseconds(100),
                                                    maxBackoff:     TimeSpan.FromSeconds(30),
                                                    deltaBackoff:     TimeSpan.FromSeconds(1),
                                                    firstFastRetry: true), },
    "default",
    new Dictionary<string, string> {
        {
        RetryManagerSqlExtensions.DefaultStrategyConnectionTechnologyName, "default sql connection"
        },
        {
        RetryManagerSqlExtensions.DefaultStrategyCommandTechnologyName, "default sql command"}
        }));
```

Дополнительные сведения об использовании политик повторных попыток, настроенных для доступа к Базе данных SQL Azure, см. в разделе [Примеры](#examples) ниже.

Стратегии блока приложения для обработки временной ошибки по умолчанию указаны в разделе [Стратегии блока приложения для обработки временной ошибки (Topaz)](#transient-fault-handling-application-block-topaz-strategies) в конце этого руководства.

### <a name="retry-usage-guidance"></a>Руководство по использованию механизма повторов
При доступе к базе данных SQL с помощью ADO.NET придерживайтесь следующих рекомендаций.

* Выберите соответствующую службу (общую или премиальную). Общий экземпляр может испытывать большие задержки подключения и регулирования чем обычно из-за использования другими клиентами общего сервера. Если требуется более прогнозируемая производительность и выполнение надежных операций с низкой задержкой, попробуйте выбрать премиальный вариант.
* Убедитесь, что выполнение повторов происходит на соответствующем уровне или области во избежание операций, не являющихся идемпотентными, что может вызвать несоответствие в данных. В идеальном случае все операции должны быть идемпотентными таким образом, чтобы их можно было повторить без возникновения несоответствия. Если это не так, повтор следует производить на уровне или в области, которая позволяет отменить все связанные изменения, если одна операция завершится ошибкой. Например, в области транзакций. Для получения дополнительных сведений обратитесь к разделу [Основы облачной службы. Уровень доступа к данным: обработка временных ошибок](http://social.technet.microsoft.com/wiki/contents/articles/18665.cloud-service-fundamentals-data-access-layer-transient-fault-handling.aspx#Idempotent_Guarantee).
* Не рекомендуется использование стратегии с фиксированным интервалом при работе с базой данных SQL Azure, кроме интерактивных сценариев при наличии нескольких попыток повтора с очень короткими интервалами. Вместо этого рекомендуется использовать стратегию экспоненциальной отсрочки для большинства сценариев.
* Выберите подходящее значение для времени ожидания подключения и команды при определении подключения. Слишком короткое время ожидания может привести к преждевременным сбоям подключений, когда база данных занята. Слишком длинное время ожидания может помешать правильной работе логики повторов из-за слишком долгого ожидания до обнаружения ошибки соединения. Значение времени ожидания — это компонент сквозной задержки; фактически это значение добавляется к величине задержки повтора, указанной в политике повтора для каждой попытки.
* Закройте соединение после определенного числа повторных попыток, даже если используется экспоненциальная логика повторных попыток, и повторите операцию с новым подключением. Повторение одной и той же операции несколько раз для одного соединения может стать фактором возникновения проблем с подключением. Пример использования этой технологии см. в статье [Основы облачной службы. Уровень доступа к данным: обработка временных ошибок](http://social.technet.microsoft.com/wiki/contents/articles/18665.cloud-service-fundamentals-data-access-layer-transient-fault-handling.aspx).
* Когда используется пул подключений (по умолчанию), существует вероятность того, что будет выбрано то же подключение из пула, даже после закрытия и повторного открытия соединения. Если это так, способом устранения подобной ситуации является вызов метода **ClearPool** класса **SqlConnection**, чтобы отметить подключение как не используемое повторно. Тем не менее это следует делать только после сбоя нескольких попыток соединения и только при обнаружении определенного класса временных ошибок, таких как время ожидания SQL (код ошибки -2), связанных со сбоями в подключениях.
* Если код доступа к данным использует транзакции, инициируемые как экземпляры **TransactionScope** , то логика повторных попыток должна включать повторное открытие подключения и инициацию новой области транзакции. По этой причине блок кода повторной попытки должен охватывать всю область транзакции.
* Блок приложения для обработки временной ошибки поддерживает конфигурации повторных попыток, полностью определенные в файлах конфигурации. Однако для максимальной гибкости в Azure необходимо создать конфигурацию программным способом в приложении. Определенные параметры политик повторов, например количество повторных попыток и интервалы повтора, можно сохранить в файле конфигурации службы и использовать во время выполнения для создания соответствующих политик. Это позволяет изменять параметры перезапуска приложения при необходимости.

Начните с использования следующих параметров для операции повтора. Это параметры общего назначения, и вам будет необходимо отслеживать операции и проводить тонкую настройку параметров в соответствии с конкретной ситуацией.

| **Контекст** | **Максимальная задержка<br />примера целевого E2E** | **Стратегия повторов** | **Параметры** | **Значения** | **Принцип работы** |
| --- | --- | --- | --- | --- | --- |
| Интерактивный, пользовательский интерфейс<br />или передний план |2 с |FixedInterval |Число повторных попыток<br />Интервал попытки<br />Первый быстрый повтор |3<br />500 мс<br />true |Попытка 1 — задержка 0 с<br />Попытка 2 — задержка 500 мс<br />попытка 3 — задержка 500 мс |
| Фоновый<br />или пакетный |30 с |ExponentialBackoff |Число повторных попыток<br />Минимальная задержка<br />Максимальная задержка<br />Разностная задержка<br />Первый быстрый повтор |5<br />0 с<br />60 с<br />2 с<br />false |Попытка 1 — задержка 0 с<br />Попытка 2 — задержка 2 с<br />Попытка 3 — задержка 6 с<br />Попытка 4 — задержка 14 с<br />Попытка 5 — задержка 30 с |

> [!NOTE]
> Целевые значения сквозной задержки подразумевают время ожидания по умолчанию для подключения к службе. При указании более длинного времени ожидания подключения величина сквозной задержки будет увеличена путем добавления этого дополнительного времени для каждой попытки повтора.
>
>

### <a name="examples"></a>Примеры
В этом разделе описывается возможность использования блока приложения для обработки временной ошибки для доступа к Базе данных SQL Azure с помощью набора политик повторных попыток, настроенных в **RetryManager** (как показано в предыдущем разделе [Конфигурации политики](#policy-configuration)). Простой подход к применению блока осуществляется через класс **ReliableSqlConnection** или путем вызова методов расширения, таких как **OpenWithRetry**, для соединения (дополнительные сведения см. в статье [Блок приложения для обработки временной ошибки](http://msdn.microsoft.com/library/hh680934.aspx)).

Однако в текущей версии блока приложения для обработки временной ошибки такие подходы по умолчанию не поддерживают асинхронные операции с базой данных SQL. Нормальная практика подразумевает использование только асинхронных методов для доступа к службам Azure, таких как база данных SQL, и поэтому следует рассмотреть следующие технические приемы использования блока приложения для обработки временной ошибки с базой данных SQL.

Можно использовать упрощенную поддержку асинхронных операций в языке C# версии 5 для создания асинхронных версий методов, предоставляемых блоком. Например, в следующем коде показано, как можно создать асинхронную версию метода расширения **ExecuteReaderWithRetry** . Изменения и дополнения к исходному коду выделены. Исходный код для Topaz доступен на Codeplex в разделе [Transient Fault Handling Application Block ("Topaz")](http://topaz.codeplex.com/SourceControl/latest)(Блок приложения для обработки временной ошибки (Topaz)).

```csharp
public async static Task<SqlDataReader> ExecuteReaderWithRetryAsync(this SqlCommand command, RetryPolicy cmdRetryPolicy,
RetryPolicy conRetryPolicy)
{
    GuardConnectionIsNotNull(command);

    // Check if retry policy was specified, if not, use the default retry policy.
    return await (cmdRetryPolicy ?? RetryPolicy.NoRetry).ExecuteAsync(async () =>
    {
        var hasOpenConnection = await EnsureValidConnectionAsync(command, conRetryPolicy).ConfigureAwait(false);

        try
        {
            return await command.ExecuteReaderAsync().ConfigureAwait(false);
        }
        catch (Exception)
        {
            if (hasOpenConnection && command.Connection != null && command.Connection.State == ConnectionState.Open)
            {
                command.Connection.Close();
            }

            throw;
        }
    }).ConfigureAwait(false);
}
```

Этот новый асинхронный метод расширения может использоваться таким же образом, как и синхронные версии методов в блоке.

```csharp
var sqlCommand = sqlConnection.CreateCommand();
sqlCommand.CommandText = "[some query]";

var retryPolicy =
    RetryManager.Instance.GetRetryPolicy<SqlDatabaseTransientErrorDetectionStrategy>("alt sql");
using (var reader = await sqlCommand.ExecuteReaderWithRetryAsync(retryPolicy))
{
    // Do something with the values
}
```

Однако этот подход работает только с отдельными операциями или командами, а не с блоками инструкций, где могут быть правильно определенные границы транзакций. Кроме того, этот механизм не предусматривает возможность удаления ошибочных подключений из пула подключений, чтобы они не выбирались для последующих попыток. Пример разрешения этих проблем синхронным методом можно найти в разделе [Основы облачной службы. Уровень доступа к данным: обработка временных ошибок](http://social.technet.microsoft.com/wiki/contents/articles/18665.cloud-service-fundamentals-data-access-layer-transient-fault-handling.aspx#Timeouts_amp_Connection_Management). Помимо повтора выполнения произвольной последовательности инструкций базы данных, он очищает пул подключений, чтобы удалить недопустимые подключения, и реализует весь процесс. Код, приведенный в этом примере, является синхронным, однако его относительно легко преобразовать в асинхронный код.

### <a name="more-information"></a>Дополнительные сведения
Подробные сведения об использовании блока приложения для обработки временной ошибки см. в разделах

* [Использование блока приложения для обработки временной ошибки с SQL Azure](http://msdn.microsoft.com/library/hh680899.aspx)
* [Настойчивость — секрет всех побед: использование блока приложения для обработки временной ошибки](http://msdn.microsoft.com/library/dn440719.aspx)
* [Основы облачной службы. Уровень доступа к данным: обработка временных ошибок](http://social.technet.microsoft.com/wiki/contents/articles/18665.cloud-service-fundamentals-data-access-layer-transient-fault-handling.aspx)

Для получения общих рекомендаций по использованию базы данных SQL обратитесь к

* [Руководство по эластичности и производительности базы данных SQL Azure](http://social.technet.microsoft.com/wiki/contents/articles/3507.windows-azure-sql-database-performance-and-elasticity-guide.aspx)
* [Минимизация ошибок пула соединений в SQL Azure](http://blogs.msdn.com/b/adonet/archive/2011/11/05/minimizing-connection-pool-errors-in-sql-azure.aspx)

## <a name="service-bus-retry-guidelines"></a>Руководство по использованию механизма повторов для служебной шины
Служебная шина является облачной платформой обмена сообщениями, которая предоставляет слабосвязанный обмен сообщениями с улучшенным масштабированием и устойчивостью для компонентов приложения, размещенных в облаке или локально.

### <a name="retry-mechanism"></a>Механизм повтора
Служебная шина реализует повторы с помощью реализации базового класса [RetryPolicy](http://msdn.microsoft.com/library/microsoft.servicebus.retrypolicy.aspx) . Все клиенты служебной шины предоставляют свойство **RetryPolicy**, которое может быть присвоено одной из реализаций базового класса **RetryPolicy**. Встроенные реализации

* [Класс RetryExponential](http://msdn.microsoft.com/library/microsoft.servicebus.retryexponential.aspx). Этот класс предоставляет свойства, управляющие интервалом отсрочки, числом попыток и свойством **TerminationTimeBuffer** , используемым для ограничения общего времени завершения операции.
* [Класс NoRetry](http://msdn.microsoft.com/library/microsoft.servicebus.noretry.aspx). Используется, когда повторы на уровне API служебной шины не требуются, например, если повторные попытки управляются другим процессом в рамках пакета операций либо многоэтапной операции.

Действия служебной шины могут вызвать ряд исключений, как указано в документе [Приложение: исключения при передаче сообщений](http://msdn.microsoft.com/library/hh418082.aspx). Список предоставляет сведения о том, какие из исключений указывают, что повторение операции является целесообразным. Например [ServerBusyException](http://msdn.microsoft.com/library/microsoft.servicebus.messaging.serverbusyexception.aspx) указывает, что клиенту следует подождать некоторое время и затем повторить операцию. Появление исключения **ServerBusyException** также вынуждает служебную шину переключиться в другой режим, в котором добавляется дополнительная 10-секундная задержка к вычисляемому времени задержки повтора операции. Этот режим сбрасывается после короткого времени.

Исключения, возвращаемые служебной шиной, предоставляют свойство **IsTransient** , указывающее, что клиент должен повторить операцию. Встроенная политика **RetryExponential** зависит от свойства **IsTransient** класса **MessagingException**, который является базовым классом для всех исключений служебной шины. Если создать пользовательские реализации базового класса **RetryPolicy**, то можно будет использовать сочетание типа исключения и свойство **IsTransient**, чтобы организовать более точное управление повторами. Например, можно обнаружить исключение **QuotaExceededException** и принять меры по очистке очереди, прежде чем повторить отправку сообщения в очередь.

### <a name="policy-configuration"></a>Настройки политики
Политики повтора настраиваются программно и могут быть установлены в качестве политики по умолчанию для **NamespaceManager** и **MessagingFactory** или по отдельности для каждого клиента обмена сообщениями. Чтобы задать политику повтора по умолчанию для сеанса обмена сообщениями, можно установить свойство **RetryPolicy** класса **NamespaceManager**.

    namespaceManager.Settings.RetryPolicy = new RetryExponential(minBackoff: TimeSpan.FromSeconds(0.1),
                                                                 maxBackoff: TimeSpan.FromSeconds(30),
                                                                 maxRetryCount: 3);

Обратите внимание, что этот код использует именованные параметры для ясности. Также можно опустить имена, так как ни один из параметров не является необязательным.

    namespaceManager.Settings.RetryPolicy = new RetryExponential(TimeSpan.FromSeconds(0.1),
                     TimeSpan.FromSeconds(30), TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(5), 3);

Чтобы задать политику повторов по умолчанию для всех клиентов, созданных из фабрики обмена сообщениями, установите свойство **RetryPolicy** класса **MessagingFactory**.

    messagingFactory.RetryPolicy = new RetryExponential(minBackoff: TimeSpan.FromSeconds(0.1),
                                                        maxBackoff: TimeSpan.FromSeconds(30),
                                                        maxRetryCount: 3);

Чтобы задать политику повтора для клиента обмена сообщениями или переопределить политику по умолчанию, задайте свойство **RetryPolicy** с помощью экземпляра класса требуемой политики:

```csharp
client.RetryPolicy = new RetryExponential(minBackoff: TimeSpan.FromSeconds(0.1),
                                            maxBackoff: TimeSpan.FromSeconds(30),
                                            maxRetryCount: 3);
```

Нельзя задать политику повтора на уровне отдельных операций. Она применяется для всех операций для клиента обмена сообщениями.
Следующая таблица показывает значения по умолчанию для встроенной политики повторов.

![](media/best-practices-retry-service-specific/RetryServiceSpecificGuidanceTable7.png)

### <a name="retry-usage-guidance"></a>Руководство по использованию механизма повторов
При использовании служебной шины придерживайтесь следующих рекомендаций.

* При использовании встроенной реализации **RetryExponential** не реализуйте операции резервирования, поскольку политика реагирует на исключения типа «Сервер занят» и автоматически переключается в режим повтора.
* Server Bus поддерживает функцию, называемую Сопряженные пространства имен, которая реализует автоматическое переключение на очередь резервного копирования в отдельном пространстве имен, если очередь в первичном пространстве имен дает сбой. Сообщения из вторичной очереди могут отправляться обратно в основную очередь после ее восстановления. Эта функция позволяет справиться с временными сбоями. Для получения дополнительных сведений обратитесь к разделу [Асинхронные шаблоны обмена сообщениями и высокий уровень доступности](http://msdn.microsoft.com/library/azure/dn292562.aspx).

Начните с использования следующих параметров для операции повтора. Это параметры общего назначения, и вам будет необходимо отслеживать операции и проводить тонкую настройку параметров в соответствии с конкретной ситуацией.

![](media/best-practices-retry-service-specific/RetryServiceSpecificGuidanceTable8.png)

### <a name="telemetry"></a>Телеметрия
Служебная шина регистрирует повторные попытки как события ETW с помощью **EventSource**. Необходимо присоединить службу **EventListener** к источнику события, чтобы зарегистрировать события и просмотреть в средстве просмотра производительности или записать данные о них в журнале с подходящим назначением. Чтобы это сделать, можно использовать [Блок приложения семантического ведения журнала](http://msdn.microsoft.com/library/dn775006.aspx) . События повтора операций отображаются в следующей форме:

```text
Microsoft-ServiceBus-Client/RetryPolicyIteration
ThreadID="14,500"
FormattedMessage="[TrackingId:] RetryExponential: Operation Get:https://retry-guidance-tests.servicebus.windows.net/TestQueue/?api-version=2014-05 at iteration 0 is retrying after 00:00:00.1000000 sleep because of Microsoft.ServiceBus.Messaging.MessagingCommunicationException: The remote name could not be resolved: 'retry-guidance-tests.servicebus.windows.net'.TrackingId:6a26f99c-dc6d-422e-8565-f89fdd0d4fe3, TimeStamp:9/5/2014 10:00:13 PM."
trackingId=""
policyType="RetryExponential"
operation="Get:https://retry-guidance-tests.servicebus.windows.net/TestQueue/?api-version=2014-05"
iteration="0"
iterationSleep="00:00:00.1000000"
lastExceptionType="Microsoft.ServiceBus.Messaging.MessagingCommunicationException"
exceptionMessage="The remote name could not be resolved: 'retry-guidance-tests.servicebus.windows.net'.TrackingId:6a26f99c-dc6d-422e-8565-f89fdd0d4fe3,TimeStamp:9/5/2014 10:00:13 PM"
```

### <a name="examples"></a>Примеры
В следующем примере кода показано, как задать политику повтора для

* Диспетчера пространства имен. Политика применяется ко всем операциям диспетчера и не может быть переопределена для отдельных операций.
* Фабрики сообщений. Политика применяется ко всем клиентам, созданным из этой фабрики, и не может быть переопределена при создании отдельных клиентов.
* Отдельных клиентов обмена сообщениями. После создания клиента можно задать политику повтора для этого клиента. Политика применяется ко всем операциям на этом клиенте.

```csharp
using System;
using System.Threading.Tasks;
using Microsoft.ServiceBus;
using Microsoft.ServiceBus.Messaging;

namespace RetryCodeSamples
{
    class ServiceBusCodeSamples
    {
        private const string connectionString =
            @"Endpoint=sb://[my-namespace].servicebus.windows.net/;
                SharedAccessKeyName=RootManageSharedAccessKey;
                SharedAccessKey=C99..........Mk=";

        public async static Task Samples()
        {
            const string QueueName = "TestQueue";

            ServiceBusEnvironment.SystemConnectivity.Mode = ConnectivityMode.Http;

            var namespaceManager = NamespaceManager.CreateFromConnectionString(connectionString);

            // The namespace manager will have a default exponential policy with 10 retry attempts
            // and a 3 second delay delta.
            // Retry delays will be approximately 0 sec, 3 sec, 9 sec, 25 sec and the fixed 30 sec,
            // with an extra 10 sec added when receiving a ServiceBusyException.

            {
                // Set different values for the retry policy, used for all operations on the namespace manager.
                namespaceManager.Settings.RetryPolicy =
                    new RetryExponential(
                        minBackoff: TimeSpan.FromSeconds(0),
                        maxBackoff: TimeSpan.FromSeconds(30),
                        maxRetryCount: 3);

                // Policies cannot be specified on a per-operation basis.
                if (!await namespaceManager.QueueExistsAsync(QueueName))
                {
                    await namespaceManager.CreateQueueAsync(QueueName);
                }
            }


            var messagingFactory = MessagingFactory.Create(
                namespaceManager.Address, namespaceManager.Settings.TokenProvider);
            // The messaging factory will have a default exponential policy with 10 retry attempts
            // and a 3 second delay delta.
            // Retry delays will be approximately 0 sec, 3 sec, 9 sec, 25 sec and the fixed 30 sec,
            // with an extra 10 sec added when receiving a ServiceBusyException.

            {
                // Set different values for the retry policy, used for clients created from it.
                messagingFactory.RetryPolicy =
                    new RetryExponential(
                        minBackoff: TimeSpan.FromSeconds(1),
                        maxBackoff: TimeSpan.FromSeconds(30),
                        maxRetryCount: 3);


                // Policies cannot be specified on a per-operation basis.
                var session = await messagingFactory.AcceptMessageSessionAsync();
            }


            {
                var client = messagingFactory.CreateQueueClient(QueueName);
                // The client inherits the policy from the factory that created it.


                // Set different values for the retry policy on the client.
                client.RetryPolicy =
                    new RetryExponential(
                        minBackoff: TimeSpan.FromSeconds(0.1),
                        maxBackoff: TimeSpan.FromSeconds(30),
                        maxRetryCount: 3);


                // Policies cannot be specified on a per-operation basis.
                var session = await client.AcceptMessageSessionAsync();
            }
        }
    }
}
```

### <a name="more-information"></a>Дополнительные сведения
* [Шаблоны асинхронного обмена сообщениями и высокий уровень доступности](http://msdn.microsoft.com/library/azure/dn292562.aspx)

## <a name="azure-redis-cache-retry-guidelines"></a>Руководство по использованию механизма повторов для кэша Redis для Azure
Кэш Redis для Azure является средством быстрого доступа к данным и службой кэша с низкой задержкой, созданной на основе кэша с открытым исходным кодом Redis. Он является безопасным, управляется Майкрософт и доступен из любого приложения в Azure.

Рекомендации в этом разделе основаны на использовании клиента StackExchange.Redis для доступа к кэшу. Список других подходящих клиентов можно найти на [веб-сайте Redis](http://redis.io/clients), и они могут применять различные механизмы.

Обратите внимание, что клиент StackExchange.Redis использует мультиплексирование через одно подключение. Рекомендуется создавать экземпляр клиента при запуске приложения и использовать этот экземпляр для всех операций в кэше. По этой причине подключение к кэшу происходит только один раз, и поэтому все инструкции в этом разделе относятся к политике повтора для этого исходного соединения, а не для каждой операции, которая обращается к кэшу.

### <a name="retry-mechanism"></a>Механизм повтора
Клиент StackExchange.Redis использует класс диспетчера соединений, который настраивается с помощью набора параметров. Эти параметры включают свойство **ConnectRetry** , которое указывает, сколько раз неудачное подключение к кэшу будет повторено. Однако политика повтора используется только для первоначального подключения и не выполняет ожидания между повторными попытками.

### <a name="policy-configuration"></a>Настройки политики
Политики повтора настраиваются программным способом с помощью параметров клиента перед подключением к кэшу. Для этого нужно создать экземпляр класса **ConfigurationOptions**, заполнить его свойства и передать ему метод **Connect**.

```csharp
var options = new ConfigurationOptions { EndPoints = { "localhost" },
                                            ConnectRetry = 3,
                                            ConnectTimeout = 2000 };
ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(options, writer);
```

Обратите внимание, что свойство **ConnectTimeout** задает максимальное время ожидания в миллисекундах), а не задержку между повторными попытками.

Кроме того, можно указать параметры в виде строки и передать эти данные методу **Connect** .

```csharp
    var options = "localhost,connectRetry=3,connectTimeout=2000";
    ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(options, writer);
```

Можно также указать параметры непосредственно при подключении к кэшу.

```csharp
var conn = ConnectionMultiplexer.Connect("redis0:6380,redis1:6380,connectRetry=3");
```

Следующая таблица показывает значения по умолчанию для встроенной политики повторов.

| **Контекст** | **Параметр** | **Значение по умолчанию**<br />(версия 1.0.331) | **Значение** |
| --- | --- | --- | --- |
| Параметры конфигурации |ConnectRetry<br /><br />ConnectTimeout<br /><br />SyncTimeout |3<br /><br />Максимально 5000 мс плюс SyncTimeout<br />1000 |Количество попыток повторов подключения во время начального подключения.<br />Время ожидания (мс) для операций подключения. Без задержки между повторными попытками.<br />Время (мс) для синхронных операций. |

> [!NOTE]
> Величина SyncTimeout добавляется к величине сквозной задержки операции. Однако в общем случае использование синхронных операций не рекомендуется. Дополнительные сведения см. в статье [Конвейеры и мультиплексоры](http://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/PipelinesMultiplexers.md).
>
>

### <a name="retry-usage-guidance"></a>Руководство по использованию механизма повторов
При использовании кэша Redis для Azure, придерживайтесь следующих рекомендаций.

* Клиент StackExchange Redis управляет собственными операциями повтора, но только при установлении соединения с кэшем при первом запуске приложения. Можно настроить время ожидания подключения и количество повторных попыток установления подключения, но политика повторов не применяется к операциям с кэшем.
* Механизм повторов не подразумевает задержки между повторными попытками. Происходит повторная попытка подключения после истечения указанного времени ожидания соединения и указанного числа попыток.
* Вместо использования большого числа повторных попыток рассмотрите возможность возврата к исходному источнику данных.

### <a name="telemetry"></a>Телеметрия
Можно собирать сведения о подключении (но не о других операциях) с помощью **TextWriter**.

```csharp
var writer = new StringWriter();
...
ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(options, writer);
```

Ниже показан пример генерируемых выходных данных.

```text
localhost:6379,connectTimeout=2000,connectRetry=3
1 unique nodes specified
Requesting tie-break from localhost:6379 > __Booksleeve_TieBreak...
Allowing endpoints 00:00:02 to respond...
localhost:6379 faulted: SocketFailure on PING
localhost:6379 failed to nominate (Faulted)
> UnableToResolvePhysicalConnection on GET
No masters detected
localhost:6379: Standalone v2.0.0, master; keep-alive: 00:01:00; int: Connecting; sub: Connecting; not in use: DidNotRespond
localhost:6379: int ops=0, qu=0, qs=0, qc=1, wr=0, sync=1, socks=2; sub ops=0, qu=0, qs=0, qc=0, wr=0, socks=2
Circular op-count snapshot; int: 0 (0.00 ops/s; spans 10s); sub: 0 (0.00 ops/s; spans 10s)
Sync timeouts: 0; fire and forget: 0; last heartbeat: -1s ago
resetting failing connections to retry...
retrying; attempts left: 2...
...
```

### <a name="examples"></a>Примеры
В следующем примере кода показано, как можно настроить время ожидания подключения и количество повторных попыток при инициализации клиента StackExchange.Redis, чтобы получить доступ к кэшу Redis для Azure при запуске приложения. Обратите внимание, что время ожидания соединения является периодом времени, который требуется для соединения с кэшем. Это не задержка между попытками повтора.

В этом примере показано, как настроить конфигурацию, используя экземпляр **ConfigurationOptions**.

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using StackExchange.Redis;

namespace RetryCodeSamples
{
    class CacheRedisCodeSamples
    {
        public async static Task Samples()
        {
            var writer = new StringWriter();

            {
                try
                {
                    // Using object-based configuration.
                    var options = new ConfigurationOptions
                                        {
                                            EndPoints = { "localhost" },
                                            ConnectRetry = 3,
                                            ConnectTimeout = 2000  // The maximum waiting time (ms), not the delay for retries.
                                        };
                    ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(options, writer);

                    // Store a reference to the multiplexer for use in the application.
                }
                catch
                {
                    Console.WriteLine(writer.ToString());
                    throw;
                }
            }
        }
    }
}
```

В этом примере показано, как настроить конфигурацию путем указания параметров в виде строки.

```csharp
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using StackExchange.Redis;

namespace RetryCodeSamples
{
    class CacheRedisCodeSamples
    {
        public async static Task Samples()
        {
            var writer = new StringWriter();

            {
                try
                {
                    // Using string-based configuration.
                    var options = "localhost,connectRetry=3,connectTimeout=2000";
                    ConnectionMultiplexer redis = ConnectionMultiplexer.Connect(options, writer);

                    // Store a reference to the multiplexer for use in the application.
                }
                catch
                {
                    Console.WriteLine(writer.ToString());
                    throw;
                }
            }
        }
    }
}
```

Дополнительные примеры см. в разделе [Конфигурация](http://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Configuration.md#configuration) на веб-сайте проекта.

### <a name="more-information"></a>Дополнительные сведения
* [Веб-сайт Redis](http://redis.io/)

## <a name="documentdb-retry-guidelines"></a>Рекомендации по использованию механизма повторов для DocumentDB
DocumentDB является полностью управляемой документоориентированной облачной базой данных с широкими возможностями выполнения запросов и индексирования на основе безсхемной модели данных JSON. Она обеспечивает настраиваемую и надежную производительность, собственную обработку транзакций на основе JavaScript и разработана для облачной службы с гибким масштабированием.

### <a name="retry-mechanism"></a>Механизм повтора
Класс `DocumentClient` автоматически осуществляет новую попытку после сбоя. Чтобы задать количество повторных попыток и максимальное время ожидания, настройте свойство [ConnectionPolicy.RetryOptions]. Исключения клиента находятся за пределами действия политики повтора или не являются временными ошибками.

Если DocumentDB регулирует клиент, он возвращает ошибку HTTP 429. Проверьте код состояния в `DocumentClientException`.

### <a name="policy-configuration"></a>Настройки политики
В следующей таблице показаны значения по умолчанию для класса `RetryOptions`.

| Настройка | Значение по умолчанию | Description (Описание) |
| --- | --- | --- |
| MaxRetryAttemptsOnThrottledRequests |9 |Максимальное число повторных попыток при сбое запроса, так как DocumentDB применяет ограничение частоты запросов к клиенту. |
| MaxRetryWaitTimeInSeconds |30 |Максимальное время повтора в секундах. |

### <a name="example"></a>Пример
```csharp
DocumentClient client = new DocumentClient(new Uri(endpoint), authKey); ;
var options = client.ConnectionPolicy.RetryOptions;
options.MaxRetryAttemptsOnThrottledRequests = 5;
options.MaxRetryWaitTimeInSeconds = 15;
```

### <a name="telemetry"></a>Телеметрия
Повторные попытки регистрируются как неструктурированные сообщения трассировки в .NET **TraceSource**. Необходимо настроить **TraceListener** для сбора данных о событиях и записи этих данных в журнал с подходящим назначением.

Например, если добавить в файл App.config следующий фрагмент кода, трассировка будет создаваться в текстовом файле в том же расположении, что и исполняемый файл:

```
<configuration>
  <system.diagnostics>
    <switches>
      <add name="SourceSwitch" value="Verbose"/>
    </switches>
    <sources>
      <source name="DocDBTrace" switchName="SourceSwitch" switchType="System.Diagnostics.SourceSwitch" >
        <listeners>
          <add name="MyTextListener" type="System.Diagnostics.TextWriterTraceListener" traceOutputOptions="DateTime,ProcessId,ThreadId" initializeData="DocumentDBTrace.txt"></add>
        </listeners>
      </source>
    </sources>
  </system.diagnostics>
</configuration>
```


## <a name="azure-search-retry-guidelines"></a>Рекомендации по использованию механизма повторов для Поиска Azure
Поиск Azure является мощным и сложным инструментом поиска для сайта или приложения с возможностями быстрой и простой настройки результатов поиска и построения информативных и точных моделей ранжирования.

### <a name="retry-mechanism"></a>Механизм повтора
Поведение повтора в пакете SDK для Поиска Azure контролируется в методе `SetRetryPolicy` класса [SearchServiceClient] и [SearchIndexClient]. Повтор политики по умолчанию осуществляется с экспоненциальной задержкой, если Поиск Azure возвращает ответ с кодом 5xx или 408 (истекло время ожидания запроса).

### <a name="telemetry"></a>Телеметрия
Используйте трассировку событий Windows или осуществляйте трассировку путем регистрации пользовательского поставщика трассировки. Дополнительные сведения см. в статье [Tracing][autorest-tracing] (Трассировка) в документации по AutoRest.

### <a name="more-information"></a>Дополнительные сведения
* [Automatic Retries][autorest-retry] (Автоматические повторы) в документации по AutoRest.

## <a name="azure-active-directory-retry-guidelines"></a>Руководство по использованию механизма повторов для Azure Active Directory
Azure Active Directory (AD) представляет собой комплексное решение по управлению идентификацией и доступом к облаку, которое включает в себя службы основных каталогов, расширенное управление удостоверениями, службы безопасности и управления доступом приложений. Azure AD также предлагает разработчикам платформу управления удостоверениями для доставки элементов контроля доступа к приложениям на основе централизованной политики и правил.

### <a name="retry-mechanism"></a>Механизм повтора
Служба Azure Active Directory библиотеки проверки подлинности Azure Active Directory (ADAL) не имеет встроенного механизма повторов. Блок приложения для обработки временной ошибки позволяет реализовать стратегию повторов, которая содержит механизм определения исключений, возвращаемых службой каталогов Active Directory.

### <a name="policy-configuration-azure-active-directory"></a>Настройка политики (Azure Active Directory)
При использовании блока приложения для обработки временной ошибки с Azure Active Directory вы создаете экземпляр **RetryPolicy** на основе класса, определяющего необходимую стратегию обнаружения.

```csharp
var policy = new RetryPolicy<AdalDetectionStrategy>(new ExponentialBackoff(retryCount: 5,
                                                                     minBackoff: TimeSpan.FromSeconds(0),
                                                                     maxBackoff: TimeSpan.FromSeconds(60),
                                                                     deltaBackoff: TimeSpan.FromSeconds(2)));
```

Затем вызовите метод **ExecuteAction** или **ExecuteAsync** политики повтора, передав операцию, которую требуется выполнить.

```csharp
var result = await policy.ExecuteAsync(() => authContext.AcquireTokenAsync(resourceId, clientId, uc));
```

Класс определения стратегии получает исключения при возникновении сбоя и определяет, является ли этот сбой временной ошибкой или постоянной. Обычно он сделает это путем проверки типа и кода состояния исключения. Например, ответ «Служба недоступна» ( Service Unavailable) указывает на необходимость попытки повтора. Блок приложения для обработки временной ошибки не включает класс стратегии обнаружения, который подходит для использования с клиентом ADAL. В то же время пример стратегии определения приведен в разделе [Примеры](#examples) ниже. Использование персональной стратегии определения ничем не отличается от использования стратегии, содержащейся в блоке.

Стратегии блока приложения для обработки временной ошибки по умолчанию указаны в разделе [Стратегии блока приложения для обработки временной ошибки (Topaz)](#transient-fault-handling-application-block-topaz-strategies) в конце этого руководства.

### <a name="retry-usage-guidance"></a>Руководство по использованию механизма повторов
При использовании Azure Active Directory придерживайтесь следующих рекомендаций.

* При использовании интерфейса API REST для Azure Active Directory следует повторить операцию только в том случае, если происходит ошибка в диапазоне 5xx (500 — Внутренняя ошибка сервера, 502 — Ошибочный шлюз, 503 — Служба недоступна и 504 — Истекло время ожидания шлюза). Не следует выполнять повтор при возникновении других ошибок.
* При использовании библиотеки проверки подлинности Active Directory (ADAL) коды HTTP доступны не явно. Необходимо будет создать стратегию определения, выполняющую логику для проверки свойств исключений, специфичных для ADAL. Обратитесь к разделу [Примеры](#examples) ниже.
* В пакетных сценариях с Azure Active Directory рекомендуется использование экспоненциальных политик отсрочки.

Начните с использования следующих параметров для операции повтора. Это параметры общего назначения, и вам будет необходимо отслеживать операции и проводить тонкую настройку параметров в соответствии с конкретной ситуацией.

| **Контекст** | **Максимальная задержка<br />примера целевого E2E** | **Стратегия повторов** | **Параметры** | **Значения** | **Принцип работы** |
| --- | --- | --- | --- | --- | --- |
| Интерактивный, пользовательский интерфейс<br />или передний план |2 с |FixedInterval |Число повторных попыток<br />Интервал попытки<br />Первый быстрый повтор |3<br />500 мс<br />true |Попытка 1 — задержка 0 с<br />Попытка 2 — задержка 500 мс<br />попытка 3 — задержка 500 мс |
| Фоновый<br /> или пакетный |60 с |ExponentialBackoff |Число повторных попыток<br />Минимальная задержка<br />Максимальная задержка<br />Разностная задержка<br />Первый быстрый повтор |5<br />0 с<br />60 с<br />2 с<br />false |Попытка 1 — задержка 0 с<br />Попытка 2 — задержка 2 с<br />Попытка 3 — задержка 6 с<br />Попытка 4 — задержка 14 с<br />Попытка 5 — задержка 30 с |

### <a name="examples"></a>Примеры
В следующем примере кода показано, как можно использовать блок приложения для обработки временной ошибки (Topaz) для задания стратегии определения пользовательских временных ошибок для использования с клиентом ADAL. Код создает экземпляр **RetryPolicy** по стратегии определения типа **AdalDetectionStrategy**, как определено в примере кода ниже. Настраиваемые стратегии определения для блока Topaz применяют интерфейс **ITransientErrorDetectionStrategy** и возвращают значение true, если следует предпринять повторную попытку, или **false**, если сбой не временный и повтор не должен выполняться.

    using System;
    using System.Linq;
    using System.Net;
    using System.Threading.Tasks;
    using Microsoft.Practices.TransientFaultHandling;
    using Microsoft.IdentityModel.Clients.ActiveDirectory;

    namespace RetryCodeSamples
    {
        class ActiveDirectoryCodeSamples
        {
            public async static Task Samples()
            {
                var authority = "[some authority]";
                var resourceId = “[some resource id]”;
                var clientId = “[some client id]”;

                var authContext = new AuthenticationContext(authority);

                var uc = new UserCredential(“[user]", "[password]");

                // Use Topaz with a custom detection strategy to manage retries.
                var policy =
                    new RetryPolicy<AdalDetectionStrategy>(
                        new ExponentialBackoff(
                            retryCount: 5,
                            minBackoff: TimeSpan.FromSeconds(0),
                            maxBackoff: TimeSpan.FromSeconds(60),
                            deltaBackoff: TimeSpan.FromSeconds(2)));

                var result = await policy.ExecuteAsync(() => authContext.AcquireTokenAsync(resourceId, clientId, uc));

                // Get the access token
                var accessToken = result.AccessToken;

                // Use the result, probably to authorize an API call.
            }
        }

        // TODO: This is sample code that needs validation from the WAAD team!
        // based on existing detection strategies
        public class AdalDetectionStrategy : ITransientErrorDetectionStrategy
        {
            private static readonly WebExceptionStatus[] webExceptionStatus =
                new[]
                {
                    WebExceptionStatus.ConnectionClosed,
                    WebExceptionStatus.Timeout,
                    WebExceptionStatus.RequestCanceled
                };

            private static readonly HttpStatusCode[] httpStatusCodes =
                new[]
                {
                    HttpStatusCode.InternalServerError,
                    HttpStatusCode.GatewayTimeout,
                    HttpStatusCode.ServiceUnavailable,
                    HttpStatusCode.RequestTimeout
                };

            public bool IsTransient(Exception ex)
            {
                var adalException = ex as AdalException;
                if (adalException == null)
                {
                    return false;
                }

                if (adalException.ErrorCode == AdalError.ServiceUnavailable)
                {
                    return true;
                }

                var innerWebException = adalException.InnerException as WebException;
                if (innerWebException != null)
                {
                    if (webExceptionStatus.Contains(innerWebException.Status))
                    {
                        return true;
                    }

                    if (innerWebException.Status == WebExceptionStatus.ProtocolError)
                    {
                        var response = innerWebException.Response as HttpWebResponse;
                        return response != null && httpStatusCodes.Contains(response.StatusCode);
                    }
                }

                return false;
            }
        }
    }

Сведения о восстановлении операций Active Directory API Graph и ошибки возвращаемых кодов

* [Пример кода: Логика повторов](http://msdn.microsoft.com/library/azure/dn448547.aspx)
* [Коды ошибок Azure AD Graph](http://msdn.microsoft.com/library/azure/hh974480.aspx)

### <a name="more-information"></a>Дополнительные сведения
* [Реализация пользовательской стратегии определения](http://msdn.microsoft.com/library/hh680940.aspx) (Topaz)
* [Реализация пользовательской стратегии повторов](http://msdn.microsoft.com/library/hh680943.aspx) (Topaz)
* [Рекомендации по использованию механизма повторов и выдаче маркера](http://msdn.microsoft.com/library/azure/dn168916.aspx)

## <a name="general-rest-and-retry-guidelines"></a>Общие рекомендации по использованию REST и механизма повторов
При обращении к службам Azure или службам сторонних производителей учитывайте следующее.

* Используйте систематический подход к управлению механизмом повторов, возможно в виде повторно используемого кода, что таким образом дает возможность применения согласованной методологии ко всем клиентам и всем решениям.
* Рассмотрите возможность использования платформы повторов, например блока приложения для обработки временной ошибки, для управления механизмом повторов, если целевая служба или клиент не имеет встроенного механизма повторов. Это поможет реализовать согласованный механизм повтора и может предоставить подходящую стратегию повторов по умолчанию для целевой службы. Тем не менее необходимо создать пользовательский код механизма повторов для служб, имеющих нестандартное поведение, которые не полагаются на исключения для определения временных сбоев, или если вы хотите использовать ответ **Retry-Response** для управления поведением механизма повторов.
* Логика обнаружения временных сбоев будет зависеть от фактического клиентского API, который используется для вызова REST. Некоторые клиенты, например новый класс **HttpClient** , не создают исключения для запросов, завершенных с неуспешным кодом состояния HTTP. Это улучшает производительность, но предотвращает использование блока приложения для обработки временной ошибки. В этом случае можно поместить вызов API REST с кодом, который создает исключения для неуспешных кодов состояния HTTP, которые затем могут быть обработаны в блоке. Также можно использовать другой механизм для запуска повторов.
* Код состояния HTTP, возвращаемый службой, позволяет указать, является ли ошибка временной. Необходимо изучить исключения, генерируемые клиентом, или механизм повторов для доступа к коду состояния для определения эквивалентного типа исключения. Следующие коды HTTP обычно показывают, что повтор может быть выполнен.
  * 408 — Истекло время ожидания запроса
  * 500 — Внутренняя ошибка сервера
  * 502 — Недопустимый шлюз
  * 503 — Служба недоступна
  * 504 — Истекло время ожидания шлюза
* Если логика повторов основана на исключениях, следующие параметры обычно указывают, что произошел временный сбой где не удалось создать подключение.
  * WebExceptionStatus.ConnectionClosed
  * WebExceptionStatus.ConnectFailure
  * WebExceptionStatus.Timeout
  * WebExceptionStatus.RequestCanceled
* В случае недоступности службы, служба может определить соответствующую задержку перед повтором в заголовке ответа **Retry-After** или в другом пользовательском заголовке (как в случае службы DocumentDB). Службы также отправляют дополнительную информацию в виде пользовательских заголовков или внедренной в содержимое ответа. Блок приложения для обработки временной ошибки не может использовать стандартные или пользовательские заголовки retry-after.
* Не выполняйте повторы для кодов состояния, представляющих клиентские ошибки (ошибки в диапазоне 4xx) за исключением ошибки «408 — Истекло время ожидания запроса».
* Тщательно протестируйте свои стратегии и механизмы повторов для различных условий, например, указав другую сеть и с различными нагрузками системы.

### <a name="retry-strategies"></a>Стратегия повторов
Ниже приведены типичные виды интервалов стратегий повтора.

* **Экспоненциальный**: политика повторов, основанная на выполнении указанного числа повторных попыток, используя случайный экспоненциальный пассивный метод для определения интервала между повторными попытками. Например:

        var random = new Random();

        var delta = (int)((Math.Pow(2.0, currentRetryCount) - 1.0) *
                    random.Next((int)(this.deltaBackoff.TotalMilliseconds * 0.8),
                    (int)(this.deltaBackoff.TotalMilliseconds * 1.2)));
        var interval = (int)Math.Min(checked(this.minBackoff.TotalMilliseconds + delta),
                       this.maxBackoff.TotalMilliseconds);
        retryInterval = TimeSpan.FromMilliseconds(interval);
* **Добавочный**: стратегия повторов с указанным количеством повторных попыток и добавочным интервалом между повторными попытками. Например:

        retryInterval = TimeSpan.FromMilliseconds(this.initialInterval.TotalMilliseconds +
                       (this.increment.TotalMilliseconds * currentRetryCount));
* **Линейный повтор**: политика повторов, которая выполняет указанное число повторных попыток, используя указанный фиксированный интервал времени между повторными попытками. Например:

        retryInterval = this.deltaBackoff;

### <a name="more-information"></a>Дополнительные сведения
* [Стратегии выключателя](http://msdn.microsoft.com/library/dn589784.aspx)

## <a name="transient-fault-handling-application-block-topaz-strategies"></a>Стратегии блока приложения для обработки временной ошибки (Topaz)
Блок приложения для обработки временной ошибки содержит следующие стратегии по умолчанию.

| **Стратегия** | **Параметр** | **Значение по умолчанию** | **Значение** |
| --- | --- | --- | --- |
| **Экспоненциальное** |retryCount<br />minBackoff<br /><br />MaxBackoff<br /><br />deltaBackoff<br /><br />fastFirstRetry |10<br />1 с<br /><br />30 секунд<br /><br />10 с<br /><br />Да |Количество повторных попыток.<br />Минимальное время отсрочки. Большее из этого значения или вычисляемого значения отсрочки будет использоваться в качестве задержки повтора.<br />Минимальное время отсрочки. Меньшее из этого значения или вычисляемого значения отсрочки будет использоваться в качестве задержки повтора.<br />Значение, используемое для вычисления случайных изменений экспоненциальной задержки между повторными попытками.<br />Будет ли первая попытка повтора выполнена немедленно. |
| **Добавочное** |retryCount<br />initialInterval<br />increment<br /><br />fastFirstRetry<br /> |10<br />1 с<br />1 с<br /><br />Да |Количество повторных попыток.<br />Начальный интервал, который будет применяться для первой попытки.<br />Значение добавочного времени, которое будет использоваться для вычисления последовательной задержки между повторными попытками.<br />Будет ли первая попытка повтора выполнена немедленно. |
| **Линейный (фиксированный интервал)** |retryCount<br />retryInterval<br />fastFirstRetry<br /> |10<br />1 с<br />Да |Количество повторных попыток.<br />Задержка между повторными попытками.<br />Будет ли первая попытка повтора выполнена немедленно. |

Примеры использования блока приложения для обработки временной ошибки смотрите в разделах Примеры, приведенные ранее в этом руководстве для базы данных SQL Azure с помощью ADO.NET и Azure Active Directory.

<!-- links -->

[autorest-retry]: https://github.com/Azure/autorest/blob/master/Documentation/clients-retry.md
[autorest-tracing]: https://github.com/Azure/autorest/blob/master/Documentation/clients-tracing.md
[ConnectionPolicy.RetryOptions]: https://msdn.microsoft.com/library/azure/microsoft.azure.documents.client.connectionpolicy.retryoptions.aspx
[entlib]: http://msdn.microsoft.com/library/dn440719.aspx
[SearchIndexClient]: https://msdn.microsoft.com/library/azure/microsoft.azure.search.searchindexclient.aspx
[SearchServiceClient]: https://msdn.microsoft.com/library/microsoft.azure.search.searchserviceclient.aspx



<!--HONumber=Nov16_HO3-->


