<properties pageTitle="Использование синхронизации с автономными данными в мобильных службах (iOS) | Центр разработчиков для мобильных устройств" description="Узнайте, как использовать мобильные службы Azure для кэширования и синхронизации автономных данных в приложении iOS" documentationCenter="ios" authors="krisragh" manager="dwrede" editor="" services=""/>

<tags ms.service="mobile-services" ms.workload="mobile" ms.tgt_pltfrm="mobile-ios" ms.devlang="objective-c" ms.topic="article" ms.date="01/16/2015" ms.author="krisragh,donnam"/>

# Приступая к работе с синхронизацией автономных данных в мобильных службах

[AZURE.INCLUDE [mobile-services-selector-offline](../includes/mobile-services-selector-offline.md)]

В этом учебнике рассматривается функция автономной синхронизации мобильных служб в iOS. Автономная синхронизация позволяет конечным пользователям взаимодействовать с мобильным приложением - просматривать, добавлять или изменять данные - даже при отсутствии подключения к сети. Изменения сохраняются в локальной базе данных; как только устройство возвращается в режим подключения к сети, эти изменения синхронизируются с удаленной службой.

Автономная синхронизация может применяться в следующих случаях:

* Повышение скорости реагирования приложений путем локального кэширования данных сервера в устройстве
* Защита приложений от потери сетевой связности
* Предоставление конечным пользователям возможности создания и изменения данных даже в том случае, когда отсутствует сетевой доступ, поддерживая сценарии с минимальной связностью или при отсутствии связности
* Синхронизация данных между несколькими устройствами и обнаружение конфликтов, когда два устройства изменяют одну и ту же запись

>[AZURE.NOTE] Для работы с этим учебником требуется учетная запись Azure. Если у вас нет учетной записи, можно зарегистрироваться для получения бесплатной пробной версии Azure и получить до 10 бесплатных мобильных служб, которые можно использовать и после окончания пробного периода. Дополнительные сведения см. в разделе <a href="http://www.windowsazure.com/ru-ru/pricing/free-trial/?WT.mc_id=AE564AB28" target="_blank">Бесплатная пробная версия Azure</a>.

Если это ваш первый опыт работы с мобильными службами, сначала ознакомьтесь с учебником [Приступая к работе с мобильными службами]

В этом учебнике рассматриваются следующие основные действия:

1. [Получение примера приложения]
2. [Обзор кода синхронизации мобильных служб]
3. [Обзор модели Core Data]
4. [Изменение режима синхронизации приложения]
5. [Тестирование приложения]

## <a name="get-app"></a>Получение примера автономного приложения списка дел

В [репозитории образцов для мобильных служб Github] клонируйте репозиторий и откройте проект [Offline iOS Sample] в Xcode.

### Бета-версия пакета SDK
Чтобы добавить поддержку автономной работы в существующее приложение, получите последнюю версию [бета-версии пакета SDK для iOS](http://aka.ms/gc6fex).

## <a name="review-sync"></a>Обзор кода синхронизации мобильных служб

Автономная синхронизация мобильных служб Azure позволяет взаимодействовать с локальной базой данных без доступа к сети. Для использования этих возможностей в приложении необходимо инициализировать контекст синхронизации `MSClient` и указать ссылку на локальное хранилище. Затем укажите ссылку на таблицу с помощью интерфейса `MSSyncTable`.

В этом разделе рассматривается представленный в примере код автономной синхронизации.

1. Обратите внимание, что в **QSTodoService.m** элемент `syncTable` имеет тип `MSSyncTable`. Автономная синхронизация использует этот интерфейс таблицы синхронизации вместо `MSTable`. При использовании таблицы синхронизации все операции направляются в локальное хранилище и синхронизируются с удаленной службой только по явным операциям принудительной отправки и принудительного получения.

    Для получения ссылки на таблицу синхронизации используйте метод `syncTableWithName`. Чтобы удалить функцию автономной синхронизации, воспользуйтесь `tableWithName`.

3. Прежде чем можно будет выполнить операции с таблицами, необходимо инициализировать локальное хранилище. Это соответствующий код в методе `QSTodoService.init`:

        MSCoreDataStore *store = [[MSCoreDataStore alloc] initWithManagedObjectContext:context];
        
        self.client.syncContext = [[MSSyncContext alloc] initWithDelegate:nil dataSource:store callback:nil];

    При этом создается локальное хранилище с использованием интерфейса `MSCoreDataStore`, предоставляемого в пакете SDK для мобильных служб. Можно также предоставить другую реализацию локального хранилища, внедрив протокол `MSSyncContextDataSource`.

    Первый параметр `initWithDelegate` используется для указания обработчика конфликтов. Поскольку мы передали `nil`, используется обработчик конфликтов по умолчанию, который завершается с ошибкой всякий раз, когда возникает конфликт. Сведения о реализации пользовательского обработчика конфликтов см. в учебнике [Обработка конфликтов с автономной поддержкой мобильных служб].

4. Методы `pullData` и `syncData` выполняют операцию фактической синхронизации: `syncData` сначала передает новые изменения, а затем вызывает `pullData` для получения данных из удаленной службы.

        -(void)syncData:(QSCompletionBlock)completion
        {
            // push all changes in the sync context, then pull new data
            [self.client.syncContext pushWithCompletion:^(NSError *error) {
                [self logErrorIfNotNil:error];
                [self pullData:completion];
            }];
        }

    В свою очередь, метод `pullData` получает новые данные, удовлетворяющие запросу:

        -(void)pullData:(QSCompletionBlock)completion
        {
            MSQuery *query = [self.syncTable query];
            
            // Pulls data from the remote server into the local table.
            // We're pulling all items and filtering in the view
            // query ID is used for incremental sync
            [self.syncTable pullWithQuery:query queryId:@"allTodoItems" completion:^(NSError *error) {
                [self logErrorIfNotNil:error];
                
                // Let the caller know that we have finished
                if (completion != nil) {
                    dispatch_async(dispatch_get_main_queue(), completion);
                }
            }];
        }   

    В `syncData` мы сначала вызываем `pushWithCompletion` в для контекста синхронизации. Этот метод является участником `MSSyncContext` (а не таблицы синхронизации), поэтому изменения будут переданы во все таблицы. Только те записи, которые были каким-либо образом локально изменены (с помощью операций CUD), будут отправлены на сервер. Затем вызывается вспомогательный метод `pullData`, который вызывает "MSSyncTable.pullWithQuery" для получения удаленных данных и их сохранения в локальной базе данных. 

    Обратите внимание, что в этом примере операция принудительной отправки не является обязательной. Если в контексте синхронизации для таблице, осуществляющей операцию принудительной отправки, имеются ожидающие изменения, то операция принудительного получения всегда предварительно выполняет операцию принудительной отправки. Однако при наличии нескольких таблиц синхронизации, рекомендуется явно вызывать операцию принудительной отправки, чтобы обеспечить согласованность для связанных таблиц.

    Метод `pullWithQuery` позволяет указать запрос для фильтрации извлекаемых получаемых записей. В этом примере запрос просто извлекает все записи в удаленной таблице `TodoItem`.

    Второй параметр для `pullWithQuery` - это идентификатор запроса, который используется для *добавочной синхронизации*. Добавочная синхронизация извлекает только те записи, которые были изменены с момента последней синхронизации, используя для этого метку времени записи `UpdatedAt` (в локальном хранилище это называется `ms_updatedAt`). Идентификатор запроса должен быть описательной строкой, уникальной для каждого логического запроса в приложении. Чтобы явно отказаться от добавочной синхронизации, передайте в качестве ИД запроса значение `nil`. Помните, что это может привести к снижению производительности, поскольку при каждой операции принудительного получения будут извлекаться все записи.

    >[AZURE.NOTE] Для удаления записей из локального хранилища устройства, если они были удалены в базе данных мобильной службы, следует включить [обратимое удаление]. В противном случае приложение должно периодически вызывать `MSSyncTable.purgeWithQuery` для очистки локального хранилища.

5. В классе `QSTodoService` метод `syncData` вызывается после операций, которые изменяют данные - `addItem` и `completeItem`. Он также вызывается из `QSTodoListViewController.refresh`, поэтому пользователь получает последние данные при каждом выполнении жеста обновления. Приложение также выполняет синхронизацию при запуске, поскольку `QSTodoListViewController.init` вызывает `refresh`.

    Поскольку `syncData` вызывается при каждом изменении данных, это приложение предполагает, что пользователь находится в сети каждый раз, когда вносит изменения в данные. В другом разделе мы обновим приложение, чтобы пользователи могли изменять данные, даже работая в автономном режиме.

## <a name="review-core-data"></a>Обзор модели Core Data

При использовании автономного хранилища Core Data необходимо определить конкретные таблицы и поля в модели данных. Пример приложения уже содержит модель данных с подходящим форматом. В этом разделе мы рассмотрим эти таблицы и их использование.

- Откройте **QSDataModel.xcdatamodeld**. Определено четыре таблицы - три используются пакетом SDK и одна предназначена для самих элементов списка дел.
      * MS_TableOperations: для отслеживания элементов, которые должны быть синхронизированы с сервером.
      * MS_TableOperationErrors: для отслеживания ошибок, возникающих во время автономной синхронизации. 
      * MS_TableConfig: для отслеживания времени последнего обновления у последней операции синхронизации для всех операций принудительного получения.
      * TodoItem: для хранения элементов списка дел. Системные столбцы **ms_createdAt**, **ms_updatedAt** и **ms_version** - представляют собой необязательные системные свойства. 

>[AZURE.NOTE] Пакет SDK для мобильных служб резервирует имена столбцов, начинающиеся с "**`ms_`**". Не следует использовать этот префикс где-либо, кроме системных столбцов, в противном случае при использовании удаленной службы имена таких столбцов будут изменены.

- При использовании функции автономной синхронизации необходимо определить системные таблицы, как показано ниже.

    ### Системные таблицы

    **MS_TableOperations**

    ![][defining-core-data-tableoperations-entity]

    | Атрибут  |    Тип     |
    |----------- |   ------    |
    | id         | Integer 64  |
    | itemId     | String      |
    | properties | Binary Data |
    | table      | String      |
    | tableKind  | Integer 16  |

    <br>**MS_TableOperationErrors**

    ![][defining-core-data-tableoperationerrors-entity]

    | Атрибут  |    Тип     |
    |----------- |   ------    |
    | id         | String      |
    | operationID | Integer 64 |
    | properties | Binary Data |
    | tableKind  | Integer 16  |

    <br>**MS_TableConfig**

    ![][defining-core-data-tableconfig-entity]

    | Атрибут  |    Тип     |
    |----------- |   ------    |
    | id         | Integer 64  |
    | key        | String      |
    | keyType    | Integer 64  |
    | table      | String      |
    | value      | String      |

    ### Таблица данных

    ![][defining-core-data-todoitem-entity]

    **TodoItem**

    | Атрибут    |  Тип   | Примечание                                                       | 
    |-----------   |  ------ | -----------------------------------------------------------|
    | id           | String  | первичный ключ в удаленном хранилище                                |
    | complete     | Boolean | поле элемента списка дел                                            |
    | text         | String  | поле элемента списка дел                                            |
    | ms_createdAt | Date    | *(необязательно)* сопоставляется с системным свойством "__createdAt"         |
    | ms_updatedAt | Date    | *(необязательно)* сопоставляется с системным свойством "__updatedAt"         |
    | ms_version   | String  | *(необязательно)* используется для обнаружения конфликтов, сопоставляется с "__version" |


## <a name="setup-sync"></a>Изменение режима синхронизации приложения

В этом разделе вы измените приложение, чтобы оно не синхронизировалось при запуске и при вставке или изменении элементов, а синхронизировалось только при выполнении жеста обновления. 

1. В **QSTodoListViewController.m** измените метод **viewDidLoad**, чтобы удалить вызов "[самостоятельного обновления]" в конце метода. Теперь данные не будут синхронизироваться с сервером при запуске приложения, а будут находиться в локальном хранилище.

2. В **QSTodoService.m** измените определение `addItem` , чтобы запретить синхронизацию после вставки элемента. Удалите блок `self syncData` и замените его следующим:

            if (completion != nil) {
                dispatch_async(dispatch_get_main_queue(), completion);
            }

3. Измените определение `completeItem`, как указано выше; удалите блок для `self syncData` и замените его следующим:

            if (completion != nil) {
                dispatch_async(dispatch_get_main_queue(), completion);
            }

## <a name="test-app"></a>Тестирование приложения

В этом разделе вы отключите функцию Wi-Fi в имитаторе, чтобы создать сценарий автономной работы. При добавлении элементов данных они будут находиться в локальном хранилище Core Data, но не будут синхронизированы с мобильной службой.

1. Отключите функцию Wi-Fi в имитаторе iOS.

2. Добавьте несколько элементов списка дел или завершите некоторые элементы. Выполните выход из имитатора (или принудительно закройте приложения) и перезапустите его. Убедитесь, что изменения были сохранены.

3. Просмотрите содержимое удаленной таблицы TodoItem:
   - Для серверной части JavaScript перейдите на портал управления и откройте вкладку "Данные", чтобы просмотреть содержимое таблицы `TodoItem`.
   - Для серверной части .NET просмотрите содержимое таблицы либо с помощью средства SQL, например SQL Server Management Studio, или с помощью клиента REST, например Fiddler или Postman.

    Убедитесь, что новые элементы *не* были синхронизированы с сервером:

4. Включите Wi-Fi в симуляторе iOS, а затем сделайте жест обновления, потянув список элементов вниз. Появится индикатор хода выполнения и текст "Синхронизация...".

5. Снова просмотрите данные таблиц TodoItem. Должны отображаться как новые, так и измененные TodoItem.

## Сводка

Для поддержки автономных функций мобильных служб мы использовали интерфейс `MSSyncTable` и инициализировали `MSClient.syncContext` с локальным хранилищем. В этом случае локальным хранилищем была база данных Core Data. 

При использовании локального хранилища Core Data необходимо определить несколько таблиц с помощью подходящих системных свойств [исправить системные свойства][Обзор модели Core Data].

Обычные операции CRUD для мобильных служб работают так, как если бы приложение по-прежнему подключено, но все операции выполняются с локальным хранилищем.

Когда мы хотели синхронизировать локальное хранилище с сервером, то использовали методы `MSSyncTable.pullWithQuery` и `MSClient.syncContext.pushWithCompletion`.

*  Для принудительной отправки изменений на сервер мы вызвали `Обзор модели Core Data`. Этот метод является участником `MSSyncContext`, а не таблицы синхронизации, поэтому изменения будут переданы во все таблицы.

    Только те записи, которые были каким-либо образом локально изменены (с помощью операций CUD), будут отправлены на сервер.
   
* Для извлечения данных из таблицы на сервере в приложение мы вызвали метод `MSSyncTable.pullWithQuery`.

    Операции извлечения всегда предшествует операция передачи. Это позволяет обеспечить согласованность всех таблиц в локальном хранилище, а также связей между ними.

    Обратите внимание, что `pullWithQuery` можно использовать для фильтрации данных, хранящихся на клиенте, для этого достаточно изменить параметр `query`. 

* Чтобы включить добавочную синхронизацию, передайте идентификатор запроса в `pullWithQuery`. Идентификатор запроса используется для хранения метки времени последнего обновления из результатов последней операции принудительной отправки. Идентификатор запроса должен быть описательной строкой, уникальной для каждого логического запроса в приложении. Если запрос содержит параметр, то аналогичное значение параметра должно быть частью идентификатора запроса.

    Если вы хотите явно отказаться от добавочной синхронизации, передайте `nill` в качестве идентификатора запроса. В этом случае при каждом вызове `pullWithQuery` будут извлекаться все записи, что может снижать уровень производительности.

* Для удаления записей из локального хранилища устройства, если они были удалены в базе данных мобильной службы, следует включить [обратимое удаление]. В противном случае приложение должно периодически вызывать `MSSyncTable.purgeWithQuery` для удаления записей из локальной базы данных, если они были удалены в удаленной службы.


## Дальнейшие действия

* [Обработка конфликтов с автономной поддержкой мобильных служб]

* [Использование обратимого удаления в мобильных службах][Обратимое удаление]

## Дополнительные ресурсы

* [Облачное покрытие: автономная синхронизация в мобильных службах Azure]

* [Azure Friday: приложения с поддержкой автономной работы в мобильных службах Azure] \ (Примечание. Демонстрации предназначены для операционной системы  Windows, однако обсуждение функций справедливо для всех платформ\)

<!-- URLs. -->

[Получение примера приложения]: #get-app
[Обзор модели Core Data]: #review-core-data
[Обзор кода синхронизации мобильных служб]: #review-sync
[Изменение режима синхронизации приложения]: #setup-sync
[Тестирование приложения]: #test-app

[core-data-1]: ./media/mobile-services-ios-get-started-offline-data/core-data-1.png
[core-data-2]: ./media/mobile-services-ios-get-started-offline-data/core-data-2.png
[core-data-3]: ./media/mobile-services-ios-get-started-offline-data/core-data-3.png
[defining-core-data-main-screen]: ./media/mobile-services-ios-get-started-offline-data/defining-core-data-main-screen.png
[defining-core-data-model-editor]: ./media/mobile-services-ios-get-started-offline-data/defining-core-data-model-editor.png
[defining-core-data-tableoperationerrors-entity]: ./media/mobile-services-ios-get-started-offline-data/defining-core-data-tableoperationerrors-entity.png
[defining-core-data-tableoperations-entity]: ./media/mobile-services-ios-get-started-offline-data/defining-core-data-tableoperations-entity.png
[defining-core-data-tableconfig-entity]: ./media/mobile-services-ios-get-started-offline-data/defining-core-data-tableconfig-entity.png
[defining-core-data-todoitem-entity]: ./media/mobile-services-ios-get-started-offline-data/defining-core-data-todoitem-entity.png
[update-framework-1]: ./media/mobile-services-ios-get-started-offline-data/update-framework-1.png
[update-framework-2]: ./media/mobile-services-ios-get-started-offline-data/update-framework-2.png

[Справка редактора моделей Core Data]: https://developer.apple.com/library/mac/recipes/xcode_help-core_data_modeling_tool/Articles/about_cd_modeling_tool.html
[Создание связи с выходом]: https://developer.apple.com/library/mac/recipes/xcode_help-interface_builder/articles-connections_bindings/CreatingOutlet.html
[Создание пользовательского интерфейса]: https://developer.apple.com/library/mac/documentation/ToolsLanguages/Conceptual/Xcode_Overview/Edit_User_Interfaces/edit_user_interface.html
[Добавление перехода между сценами в раскадровке]: https://developer.apple.com/library/ios/recipes/xcode_help-IB_storyboard/chapters/StoryboardSegue.html#//apple_ref/doc/uid/TP40014225-CH25-SW1
[Добавление сцены в раскадровку]: https://developer.apple.com/library/ios/recipes/xcode_help-IB_storyboard/chapters/StoryboardScene.html

[Core Data]: https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/cdProgrammingGuide.html
[Загрузка предварительной версии пакета SDK]: http://aka.ms/Gc6fex
[Использование клиентской библиотеки мобильных служб для iOS]: /ru-ru/documentation/articles/mobile-services-ios-how-to-use-client-library/
[Автономный образец для iOS]: https://github.com/Azure/mobile-services-samples/tree/master/TodoOffline/iOS/blog20140611
[Репозиторий образцов для мобильных служб Github]: https://github.com/Azure/mobile-services-samples

[Приступая к работе с мобильными службами]: /ru-ru/documentation/articles/mobile-services-ios-get-started/
[Приступая к работе с данными]: /ru-ru/documentation/articles/mobile-services-ios-get-started-data/
[Обработка конфликтов с автономной поддержкой мобильных служб]: /ru-ru/documentation/articles/mobile-services-ios-handling-conflicts-offline-data/
[Обратимое удаление]: /ru-ru/documentation/articles/mobile-services-using-soft-delete/

[Облачное покрытие: автономная синхронизация в мобильных службах Azure]: http://channel9.msdn.com/Shows/Cloud+Cover/Episode-155-Offline-Storage-with-Donna-Malayeri
[Azure Friday: приложения с поддержкой автономной работы в мобильных службах Azure]: http://azure.microsoft.com/ru-ru/documentation/videos/azure-mobile-services-offline-enabled-apps-with-donna-malayeri/


<!--HONumber=42-->
