<properties pageTitle="Работа с серверной мобильной службой JavaScript" metaKeywords="server scripts, mobile devices, Azure, scheduler" description="Содержит примеры того, как определить, зарегистрировать и использовать серверные сценарии в мобильных службах Azure." metaCanonical="" services="mobile-services" documentationCenter="Mobile" title="Work with server scripts in Mobile Services" authors="ricksal" solutions="" manager="dwrede" editor="" />

<tags ms.service="mobile-services" ms.workload="mobile" ms.tgt_pltfrm="mobile-multiple" ms.devlang="multiple" ms.topic="article" ms.date="01/01/1900" ms.author="ricksal" />


# Работа с серверной мобильной службой JavaScript

<div class="dev-center-tutorial-subselector"><a href="/ru-ru/documentation/articles/mobile-services-dotnet-backend-how-to-use/" title=".NET backend">Серверная часть .NET</a> | <a href="/ru-ru/documentation/articles/mobile-services-how-to-use-server-scripts/"  title="JavaScript backend" class="current">Серверная часть JavaScript</a></div>
 
В этой статье содержится подробная информация о программировании серверной части на языке JavaScript в мобильных службах Azure и соответствующие примеры. Этот раздел состоит из следующих подразделов:

+ [Введение]
+ [Операции с таблицами]
	+ [Практическое руководство. Регистрация для операций с таблицами]
	+ [Практическое руководство. Переопределение ответа по умолчанию]
	+ [Практическое руководство. Переопределение успешного выполнения]
	+ [Практическое руководство. Переопределение обработки ошибок по умолчанию]
	+ [Практическое руководство. Добавление пользовательских параметров].
	+ [Практическое руководство. Работа с пользователями таблиц][Практическое руководство. Работа с пользователями]
+ [Настраиваемый интерфейс API][Привязка настраиваемого API]
	+ [Практическое руководство. Определение настраиваемого интерфейса API]
	+ [Практическое руководство. Реализация методов HTTP]
	+ [Практическое руководство. Отправка и получение данных в формате XML]
	+ [Практическое руководство. Работа с пользователями и заголовками в настраиваемом интерфейсе API]
	+ [Практическое руководство. Определение нескольких маршрутов настраиваемого интерфейса API]
+ [Планировщик заданий]
	+ [Практическое руководство. Определение сценариев запланированных заданий]
+ [Система управления версиями, общий код и вспомогательные функции]
	+ [Практическое руководство. Загрузка модулей Node.js]
	+ [Практическое руководство. Использование вспомогательных функций]
	+ [Практическое руководство. Совместное использование кода с помощью системы управления версиями]
	+ [Практическое руководство. Работа с параметрами приложения] 
+ [Использование программы командной строки]
+ [Работа с таблицами]
	+ [Практическое руководство. Доступ к таблицам из сценариев]
	+ [Практическое руководство. Выполнение массовой вставки]
	+ [Практическое руководство. Сопоставление типов JSON с типами баз данных]
	+ [Использование языка Transact-SQL для доступа к таблицам]
+ [Отладка и устранение неполадок]
	+ [Практическое руководство. Запись выходных данных в журналы мобильной службы]

##<a name="intro"></a>Введение

В серверной части мобильной службы JavaScript можно определить настраиваемую бизнес-логику в коде JavaScript, который хранится и выполняется на сервере. Этот код серверного скрипта назначается одной из следующих функций сервера.

+ [Операции вставки, чтения, обновления и удаления в данной таблице][Операции с таблицей].
+ [Запланированные задания][Планировщик заданий].
+ [HTTP-методы, определенные настраиваемом интерфейсе API][Привязка настраиваемого интерфейса API]. 

Подпись основной функции в серверном скрипте зависит от контекста использования скрипта. Можно также определить общий код скрипта как модули nodes.js, которые являются общими для скриптов. Дополнительные сведения см. разделе [Контроль версий и общий код][Контроль версий, общий код и вспомогательные функции.].

Описания отдельных объектов и функций серверных скриптов см. в разделе [Справочник по серверным скриптам мобильных служб]. 


##<a name="table-scripts"></a>Операции с таблицами

Скрипт операций с таблицами - это серверный скрипт, который зарегистрирован на операцию вставки, чтения, обновления или удаления таблицы (*del*). Имя скрипта должно совпадать с типом операции, для которой он зарегистрирован. Для данной операции с таблицей может быть зарегистрирован только один скрипт. Скрипт выполняется каждый раз при вызове данной операции запросом REST, например при получении запроса POST для вставки элемента в таблицу. Мобильные службы не сохраняют состояния между выполнениями скриптов. Так как каждый раз, когда запускается скрипт, создается новый глобальный контекст, снова инициализируются все состояния переменных, определенных в скрипте. Если требуется сохранять состояние от одного запроса к другому, создайте в своей мобильной службе таблицу, а затем читайте и записывайте состояние в таблицу. Дополнительные сведения см. в разделе [Практическое руководство. Доступ к таблицам из скриптов].

Скрипты операций с таблицами пишут, когда необходимо применять настраиваемую бизнес-логику при выполнении операции. Например, приведенный ниже скрипт отклоняет операции вставки в таблицу, если длина строки поля `text` больше десяти символов. 

	function insert(item, user, request) {
	    if (item.text.length > 10) {
	        request.respond(statusCodes.BAD_REQUEST, 
				'Text length must be less than 10 characters');
	    } else {
	        request.execute();
	    }
	}

Функция скрипта таблицы всегда принимает три аргумента.

- Первый аргумент зависит от операции с таблицей. 

	- Для вставок и обновлений это объект **item**, который является JSON-представлением строки, задействованной в операции. Это позволяет получить доступ к значениям столбцов по имени, например *элемент.Владелец*, где *Владелец* является одним из имен в JSON-представлении.
	- Для удаления это идентификатор записи, которую требуется удалить. 
	- Для чтения это [объект запроса], задающий набор строк для возврата.

- Вторым аргументом всегда является [объект пользователя][Объект пользователя], который представляет пользователя, отправившего запрос. 

- Третьим аргументом всегда является [объект запроса][Объект запроса], с помощью которого можно контролировать выполнение запрошенной операции и отправляемый клиенту ответ.

Ниже приведены канонические подписи функций main для операций с таблицей. 

+ [Insert][insert function]: `function insert (item, user, request) { ... }`
+ [Update][update function]: `function update (item, user, request) { ... }`
+ [Delete][delete function]: `function del (id, user, request) { ... }`
+ [Read][read function]: `function read (query, user, request) { ... }`

>[WACOM.NOTE]"delete" является зарезервированным ключевым словом в языке JavaScript, поэтому функция, зарегистрированная для операции удаления, должна иметь имя _del_. 

Каждый серверный скрипт имеет основную функцию и может иметь дополнительные вспомогательные функции. Даже если серверный скрипт был создан для определенной таблицы, он может также ссылаться на другие таблицы в той же базе данных. Можно также определить общие функции как модули, которые могут быть общими для скриптов. Дополнительные сведения см. разделе [Контроль версий и общий код][Контроль версий, общий код и вспомогательные функции.].

###<a name="register-table-scripts"></a>Практическое руководство. Регистрация сценариев таблиц

Серверные скрипты, которые зарегистрированы для операции с таблицей, можно определить одним из следующих способов:

+ На [портале управления Azure][Портал управления]. Доступ к скриптам для операций с таблицами осуществляется на вкладке **Scripts** для данной таблицы. Ниже показан код по умолчанию, зарегистрированный для сценария вставки для таблицы `TodoItem`. Этот код можно переопределить с помощью собственной настраиваемой бизнес-логики.

	![1][1]
	
	Чтобы узнать, как это сделать, см. раздел [Проверка и изменение данных в мобильных службах с помощью серверных скриптов].  

+ С помощью системы управления версиями. При включенной системе управления версиями просто создайте файл с именем <em>`<table>`</em>.<em>`<operation>`</em>.js во вложенной папке .\service\table репозитория git, где <em>`<table>`</em> - имя таблицы, а <em>`<operation>`</em> - операция с таблицей, которая регистрируется. Дополнительные сведения см. разделе [Контроль версий и общий код][Контроль версий, общий код и вспомогательные функции.].

+ В командной строке с помощью средства командной строки Azure. Дополнительные сведения см. в разделе [Использование программы командной строки].


Скрипт операции с таблицей должен вызывать по крайней мере одну из следующих функций [объекта запроса], чтобы гарантировать получение ответа клиентом. 
 
+ **Функцию execute**. Запрошенная операция выполняется, возвращается стандартный ответ.
 
+ **Функцию respond**. Возвращается настраиваемый ответ.

<div class="dev-callout"><strong>Важно!</strong>
<p>Когда скрипт имеет путь кода, в котором не вызывается ни <b>execute</b>, ни <b>ответ</b>, операция может не реагировать.</p></div>

Следующий скрипт вызывает функцию **execute** для завершения операции с данными, запрошенной клиентом. 

	function insert(item, user, request) { 
	    request.execute(); 
	}

В этом примере элемент вставляется в базу данных, а пользователю возвращается код соответствующего состояния. 

При вызове функции **execute** значение `item`, [query][query object] или `id` передается в качестве первого аргумента в функцию скрипта, используемую для выполнения операции. Для операции вставки, обновления или запроса можно изменить значение item или query перед вызовом функции **execute**. 

	function insert(item, user, request) { 
	    item.scriptComment =
			'this was added by a script and will be saved to the database'; 
	    request.execute(); 
	} 
 
	function update(item, user, request) { 
	    item.scriptComment = 
			'this was added by a script and will be saved to the database'; 
	    request.execute(); 
	} 

	function read(query, user, request) { 
		// Only return records for the current user 	    
		query.where({ userid: user.userId}); 
	    request.execute(); 
	}
 
>[WACOM.NOTE]В скрипте удаления изменение значения предоставляемой переменной userId не влияет на то, какая запись удаляется.

Дополнительные примеры см. в разделах [Чтение и запись данных], [Изменение запроса] и [Проверка данных].


###<a name="override-response"></a>Практическое руководство. Переопределение ответа по умолчанию

Скрипт также можно использовать в логике проверки, чтобы переопределить отклик по умолчанию. Если проверка не пройдена, просто вызовите функцию **respond** вместо функции **execute** и запишите ответ клиенту. 

	function insert(item, user, request) {
	    if (item.userId !== user.userId) {
	        request.respond(statusCodes.FORBIDDEN, 
	        'You may only insert records with your userId.');
	    } else {
	        request.execute();
	    }
	}

В этом примере запрос отклоняется, если вставляемый элемент не имеет свойства `userId`, которое соответствует свойству `userId` [объекта пользователя], предоставляемому прошедшему проверку подлинности клиенту. В данном случае операции с базой данных (*insert*) не производится и клиенту возвращается ответ с настраиваемым сообщением об ошибке и кодом состояния HTTP 403. Дополнительные примеры см. в разделе [Изменение отклика].

###<a name="override-success"></a>Практическое руководство. Переопределение успешного выполнения

По умолчанию в операции с таблицей функция **execute** автоматически записывает ответы. Тем не менее, в функцию execute можно передать два необязательных параметра, которые переопределят ее поведение в случае успеха или ошибки.

Передавая обработчик **success** при вызове функции execute, можно изменить результаты запроса до их записи в ответ. В следующем примере вызывается функция `execute({ success: function(results) { ... })`. Она выполняет дополнительные действия после чтения данных из базы данных, но перед записью отклика.

	function read(query, user, request) {
	    request.execute({
	        success: function(results) {
	            results.forEach(function(r) {
	                r.scriptComment = 
	                'this was added by a script after querying the database';
	            });
	            request.respond();
	        }
	    });
	}

При вводе обработчика **success** для функции **execute** необходимо также вызвать функцию **respond** как часть обработчика **success**, чтобы поставить среду выполнения в известность, что скрипт завершен и можно записать ответ. При вызове функции **respond** без передачи каких-либо аргументов мобильные службы создают ответ по умолчанию. 

>[WACOM.NOTE]Функцию **respond** без аргументов для получения ответа по умолчанию можно вызвать только в том случае, если вначале вызвать функцию **execute**.
 
###<a name="override-error"></a>Практическое руководство. Переопределение обработки ошибок по умолчанию

Функция **execute** может завершиться ошибкой в случае потери подключения к базе данных, недопустимого объекта или неверного запроса. По умолчанию при возникновении ошибки серверные скрипты записывают ошибку в журнал и записывают ошибочный результат в ответ. Мобильные службы обеспечивают обработку ошибок по умолчанию, поэтому нет необходимости обрабатывать ошибки, возникающие в службе. 

Если нужно произвести определенное компенсирующее действие или использовать глобальный консольный объект для записи в журнал более подробных сведений, то обработку ошибок по умолчанию можно переопределить путем реализации явной обработки ошибок. Это можно сделать, указав обработчик **error** для функции **execute**.

	function update(item, user, request) { 
	  request.execute({ 
	    error: function(err) { 
	      // Do some custom logging, then call respond. 
	      request.respond(); 
	    } 
	  }); 
	}
 

Если имеется обработчик ошибок, то мобильные службы возвращают клиенту результат ошибки при вызове функции **respond**.

При необходимости можно указать как обработчик **success**, так и обработчик **error**.

###<a name="access-headers"></a>Практическое руководство. Доступ к настраиваемым параметрам

При отправке запроса к мобильной службе можно добавить настраиваемые параметры в URI запроса, чтобы указать скриптам операций с таблицей, как обращаться с данным запросом. Измените скрипт для проверки параметра, чтобы определить путь обработки.

Например, следующий URI для запроса POST сообщает службе не допускать вставки нового элемента *TodoItem*, который имеет то же текстовое значение.

		https://todolist.azure-mobile.net/tables/TodoItem?duplicateText=false

Доступ к этим настраиваемым параметрам запроса осуществляется как к JSON-значениям из свойства **параметры** [объекта запроса]. Мобильные службы предоставляют объект **запрос** для любой функции, зарегистрированной для операции с таблицей. Следующий серверный скрипт для операции вставки проверяет значение параметра `duplicateText`, прежде чем выполнить операцию вставки.

		function insert(item, user, request) {
		    var todoItemTable = tables.getTable('TodoItem');
		    // Check the supplied custom parameter to see if
		    // we should allow duplicate text items to be inserted.		   
		    if (request.parameters.duplicateText === 'false') {
		        // Find all existing items with the same text
		        // and that are not marked 'complete'. 
		        todoItemTable.where({
		            text: item.text,
		            complete: false
		        }).read({
		            success: insertItemIfNotComplete
		        });
		    } else {
		        request.execute();
		    }

		    function insertItemIfNotComplete(existingItems) {
		        if (existingItems.length > 0) {
		            request.respond(statusCodes.CONFLICT, 
                        "Duplicate items are not allowed.");
		        } else {
		            // Insert the item as normal. 
		            request.execute();
		        }
		    }
		}

Обратите внимание, что в **insertItemIfNotComplete** функция **execute** [объекта запроса] вызывается для вставки элемента при отсутствии повторяющегося текста; в противном случае вызывается функция **respond**, которая уведомляет клиента о повторе. 

Обратите внимание на синтаксис вызова функции **success** в приведенном выше коде.

 		        }).read({
		            success: insertItemIfNotComplete
		        });

В JavaScript это компактная версия более длинного эквивалента: 

		success: function(results) 
		{ 
			insertItemIfNotComplete(results); 
		}


###<a name="work-with-users"></a>Практическое руководство. Работа с пользователями

В мобильных службах Azure можно использовать поставщика удостоверений для проверки подлинности пользователей. Дополнительные сведения см. в разделе [Приступая к работе с аутентификацией]. Когда прошедший проверку пользователь вызывает операцию с таблицей, мобильные службы используют [объект пользователя] для предоставления сведений о пользователе зарегистрированной функции скрипта. Свойство **userId** можно использовать для хранения и извлечения данных конкретного пользователя. В следующем примере устанавливается свойство владельца элемента на основе идентификатора (userId) прошедшего проверку пользователя.

	function insert(item, user, request) {
	    item.owner = user.userId;
	    request.execute();
	}

В следующем примере добавляется дополнительный фильтр запроса на основе **userId** прошедшего проверку пользователя. Этот фильтр ограничивает результаты только теми элементами, которые принадлежат текущему пользователю.  

	function read(query, user, request) {
	    query.where({
	        owner: user.userId
	    });
	    request.execute();
	}

##<a name="custom-api"></a>Настраиваемая служба API

Настраиваемый интерфейс API является конечной точкой в мобильной службе, доступной через стандартные методы HTTP: GET, POST, PUT, PATCH и DELETE. Для каждого метода HTTP, который поддерживает настраиваемый интерфейс API, можно определить отдельную функцию экспорта в одном и том же файле скрипта. Зарегистрированный скрипт вызывается при получении запроса настраиваемого интерфейса API с помощью данного метода. Дополнительные сведения см. в разделе [Настраиваемый интерфейс API].

При вызове функций настраиваемого интерфейса API средой выполнения мобильных служб поставляются объект [запрос][объект запроса] и объект [ответ][объекта ответа]. Эти объекты предоставляют функциональные возможности [библиотеки express.js], которыми можно управлять с помощью скриптов. Следующий настраиваемый интерфейс API с именем **hello** - очень простой пример, который возвращает _Hello, world! _ в ответ на запрос POST.

		exports.post = function(request, response) {
		    response.send(200, "{ message: 'Hello, world!' }");
		} 

Функция **send** [объекта ответа] возвращает нужный ответ клиенту. Этот код вызывается отправлением запроса POST по следующему URL-адресу:

		https://todolist.azure-mobile.net/api/hello  

Глобальное состояние сохраняется между выполнениями. 

###<a name="define-custom-api"></a>Практическое руководство. Определение настраиваемого интерфейса API

Серверные скрипты, которые зарегистрированы для методов HTTP в конечной точке настраиваемого интерфейса API, можно определить одним из следующих способов:

+ На [портале управления Azure][Портал управления]. Скрипты настраиваемого интерфейса API создаются и изменяются во вкладке **API**. Код серверного скрипта находится во вкладке **Скрипты** данного настраиваемого интерфейса API. Ниже приведен скрипт, который вызывается по запросу POST к конечной точке `CompleteAll` настраиваемого интерфейса API. 

	![2][2]
	
	На вкладке "Разрешения" назначаются разрешения доступа для методов настраиваемого интерфейса API. Как был создан этот настраиваемый интерфейс API, см. в разделе [Вызов настраиваемого API из клиента].  

+ С помощью системы управления версиями. При включенной системе управления версиями просто создайте файл с названием <em>`<custom_api>`</em>.js во вложенной папке .\service\api репозитория git, где <em>`<custom_api>`</em> - имя настраиваемого интерфейса API, который регистрируется. Этот файл скрипта содержит функцию _exported_ для каждого метода HTTP, предоставляемого настраиваемым API. Разрешения определены в файле-компаньоне .json. Дополнительные сведения см. разделе [Контроль версий и общий код][Контроль версий, общий код и вспомогательные функции.].

+ В командной строке с помощью средства командной строки Azure. Дополнительные сведения см. в разделе [Использование программы командной строки].

###<a name="handle-methods"></a>Практическое руководство. Реализация методов HTTP

Настраиваемый интерфейс API может обрабатывать один или несколько методов HTTP: GET, POST, PUT, PATCH и DELETE. Для каждого HTTP-метода, который обрабатывает настраиваемый интерфейс API, определяется экспортированная функция. Один файл кода настраиваемого API может экспортировать одну или все из следующих функций:

		exports.get = function(request, response) { ... };
		exports.post = function(request, response) { ... };
		exports.patch = function(request, response) { ... };
		exports.put = function(request, response) { ... };
		exports.delete = function(request, response) { ... };

Конечную точку настраиваемого интерфейса API нельзя вызвать с помощью HTTP-метода, который не был реализован в серверном скрипте, и возвращается сообщение об ошибке 405 (недопустимый метод). Для каждого HTTP-метода поддержки можно назначить отдельные уровни разрешения.

###<a name="api-return-xml"></a>Практическое руководство. Отправка и получение данных в формате XML

Когда клиенты хранят и извлекают данные, мобильные службы используют JavaScript Object Notation (JSON) для представления данных в тексте сообщения. Однако существуют скрипты, где вместо этого требуется использовать полезные данные формата XML. Например, приложения для магазина Windows имеют встроенные возможности периодических уведомлений, для которых требуется, чтобы служба выдавала XML. Дополнительные сведения содержатся в разделе [Определение настраиваемого интерфейса API с поддержкой периодических уведомлений].

Следующая функция настраиваемого API-интерфейса **OrderPizza** возвращает простой XML-документ как полезные данные ответа.

		exports.get = function(request, response) {
		  response.set('content-type', 'application/xml');
		  var xml = '<?xml version="1.0"?><PizzaOrderForm><PizzaOrderForm/>';
		  response.send(200, xml);
		};

Эта функция настраиваемого API вызывается с помощью запроса HTTP GET к следующей конечной точке:

		https://todolist.azure-mobile.net/api/orderpizza

###<a name="get-api-user"></a>Практическое руководство. Работа с пользователями и заголовками в настраиваемом интерфейсе API

В мобильных службах Azure можно использовать поставщика удостоверений для проверки подлинности пользователей. Дополнительные сведения см. в разделе [Приступая к работе с аутентификацией]. Когда пользователь с подтвержденной подлинностью запрашивает настраиваемый интерфейс API, мобильные службы используют [объект пользователя], чтобы предоставить сведения о пользователе для кода настраиваемого API. Доступ к [объекту пользователя] осуществляется через свойство пользователя [объекта запроса]. Свойство **userId** можно использовать для хранения и извлечения данных конкретного пользователя. 

Следующая функция настраиваемого API-интерфейса **OrderPizza** задает свойство владельца элемента на основе идентификатора пользователя (userId), прошедшего проверку подлинности.

		exports.post = function(request, response) {
			var userTable = request.service.tables.getTable('user');
			userTable.lookup(request.user.userId, {
				success: function(userRecord) {
					callPizzaAPI(userRecord, request.body, function(orderResult) {
						response.send(201, orderResult);
					});
				}
			});
		
		};

Эта функция настраиваемого API вызывается с помощью запроса HTTP POST к следующей конечной точке:

		https://<service>.azure-mobile.net/api/orderpizza

Доступ к конкретному заголовку HTTP можно также получить из [объекта запроса], как показано в следующем коде:

		exports.get = function(request, response) {    
    		var header = request.header('my-custom-header');
    		response.send(200, "You sent: " + header);
		};

В этом простом примере считывается настраиваемый заголовок с именем `my-custom-header`, а затем возвращается значение в ответе.

###<a name="api-routes"></a>Практическое руководство. Определение нескольких маршрутов настраиваемого интерфейса API

Мобильные службы позволяют определить несколько путей или маршрутов в настраиваемом интерфейсе API. Например, HTTP-запрос GET на следующий URL-адрес в настраиваемом интерфейсе API **калькулятор** custom API будет вызывать функцию **add** или **subtract** соответственно: 

+ `https://<service>.azure-mobile.net/api/calculator/add`
+ `https://<service>.azure-mobile.net/api/calculator/sub`

Несколько маршрутов определяются путем экспорта функции **register**, которая передает объект **api** object (подобно [объекту express в express.js]), используемый для регистрации маршрутов в конечной точке настраиваемого API. В следующем примере реализуются методы **add** и **sub** в настраиваемом интерфейсе API **калькулятор**: 

		exports.register = function (api) {
		    api.get('add', add);
		    api.get('sub', subtract);
		}
		
		function add(req, res) {
		    var result = parseInt(req.query.a) + parseInt(req.query.b);
		    res.send(200, { result: result });
		}
		
		function subtract(req, res) {
		    var result = parseInt(req.query.a) - parseInt(req.query.b);
		    res.send(200, { result: result });
		}

**Api** объекта, переданного функции **register**, предоставляет функцию для каждого метода HTTP (**get**, **post**, **put**, **patch**, **delete**). Эти функции регистрируют маршрут к определенной функции для конкретного метода HTTP. Каждая функция принимает два параметра: первый - имя маршрута, а второй - функция, зарегистрированная для маршрута. 

Два маршрута в приведенном выше примере настраиваемого API могут вызываться HTTP-запросами GET (показаны с ответом) следующим образом:

+ `https://<service>.azure-mobile.net/api/calculator/add?a=1&b=2`

		{"result":3}

+ `https://<service>.azure-mobile.net/api/calculator/sub?a=3&b=5`

		{"result":-2}

##<a name="scheduler-scripts"></a>Планировщик заданий

Мобильные службы позволяют определить серверные скрипты, которые выполняются как задания по фиксированному расписанию, либо по требованию с портала управления. Запланированные задания можно использовать для выполнения периодических задач, таких как очистка данных таблицы и пакетная обработка. Дополнительные сведения см. в разделе [Расписание заданий].

Скрипты, зарегистрированные для запланированных заданий, имеют основную функцию с тем же именем, что и запланированное задание. Поскольку запланированный скрипт не вызывается с помощью запроса HTTP, не существует контекста, который может быть передан средой выполнения сервера, и функция не принимает параметров. Как и для других видов скриптов, у вас могут быть функции подпрограмм и требование общих модулей. Дополнительные сведения см. в разделе [Система управления версиями, общий код и вспомогательные функции].

###<a name="scheduler-scripts"></a>Практическое руководство. Определение сценариев запланированных заданий

Серверные скрипты могут назначаться заданию, определенному в планировщике мобильных служб. Эти скрипты относятся к заданию и выполняются согласно расписания заданий. (Можно также использовать [портал управления] для выполнения заданий по запросу). Определяющий запланированное задание скрипт не имеет параметров, так как мобильные службы не передают ему никаких данных; он выполняется как регулярная функция JavaScript и непосредственно не взаимодействует с мобильными службами. 

Запланированные задания определяются одним из следующих способов: 

+ В портале управления [Портал управления Azure][ ] на вкладке **Скрипт** в планировщике:

	![3][3]

	Дополнительные сведения о том, как это сделать, см. в разделе [Планирование заданий сервера в мобильных службах]. 

+ В командной строке с помощью средства командной строки Azure. Дополнительные сведения см. в разделе [Использование программы командной строки].

>[WACOM.NOTE]Если система управления версиями включена, можно редактировать файлы скриптов запланированных заданий непосредственно во вложенной папке .\service\scheduler в репозитории git. Дополнительные сведения см. в разделе [Практическое руководство. Совместное использование кода с помощью системы управления версиями].

##<a name="shared-code"></a>Система управления версиями, общий код и вспомогательные функции

Так как Node.js используется мобильными службами на сервере, скрипты уже имеют доступ к встроенным модулям Node.js. Также можно использовать систему управления версиями для определения собственных модулей или добавления других модулей Node.js к службе.

Ниже представлены лишь некоторые полезные модули, которые можно использовать в скриптах с помощью глобальной функции **require**:

+ **azure**: Предоставляет функциональные возможности пакета Azure SDK для Node.js. Дополнительные сведения см. в разделе [Пакет Azure SDK для Node.js]. 
+ **crypto**: обеспечивает функциональные возможности шифрования OpenSSL. Дополнительные сведения см. в разделе [Документация по Node.js][шифрование API].
+ **path**: содержит служебные программы для работы с путями файлов. Дополнительные сведения см. в разделе [Документация по Node.js][путь API].
+ **querystring**: содержит служебные программы для работы со строками запросов. Дополнительные сведения см. в разделе [Документация по Node.js][строка запроса API].
+ **request**: отправляет HTTP-запросы к внешним службам REST, таким как Twitter и Facebook. Дополнительные сведения см. в разделе [Отправка HTTP-запроса].
+ **sendgrid**: отправляет электронную почту с помощью службы электронной почты Sendgrid в Azure. Дополнительные сведения содержатся в разделе [Отправка электронной почты с мобильных служб с помощью SendGrid].
+ **url**: содержит служебные программы для анализа и разрешения URL-адресов. Дополнительные сведения см. в разделе [Документация по Node.js][url API].
+ **util**: содержит различные служебные программы, такие как функции форматирования строк и проверки типов объектов. Дополнительные сведения см. в разделе [Документация по Node.js][util API]. 
+ **zlib**: предоставляет функциональные возможности сжатия, например gzip и deflate. Дополнительные сведения см. в разделе [Документация по Node.js][zlib API]. 

###<a name="modules-helper-functions"></a>Практическое руководство. Использование модулей

Мобильные службы предоставляют набор модулей, загружаемых скриптами с помощью глобальной функции **require**. Например, для скрипта может требоваться функция **request**, чтобы выполнять HTTP-запросы: 

	function update(item, user, request) { 
	    var httpRequest = require('request'); 
	    httpRequest('http://www.google.com', function(err, response, body) { 
	    	... 
	    }); 
	} 


###<a name="shared-code-source-control"></a>Практическое руководство. Совместное использование кода с помощью системы управления версиями

Система управления версиями с диспетчером пакетов Node.js (npm) позволяет указать модули, доступные для вашей мобильной службы. Это можно осуществить двумя способами.

+ Для модулей, которые опубликованы и установлены с помощью npm, используйте файл package.json, чтобы заявить, какие пакеты должна устанавливать ваша мобильная служба. Таким образом служба всегда имеет доступ к последней версии необходимых пакетов. Файл package.json находится в каталоге `.\service`. Дополнительные сведения содержатся в разделе [Поддержка package.json в мобильных службах Azure].

+ Для закрытых или настраиваемых модулей можно использовать npm, чтобы вручную установить модуль в каталог модулей `.\service\node_modules`. Пример ручной загрузки модуля см. в разделе [Использование общего кода и модулей Node.js в серверных скриптах].

	>[WACOM.NOTE]Если `node_modules` уже существует в иерархии каталогов, NPM создает там подкаталог `\node-uuid`, вместо того чтобы создать новый каталог `node_modules` в репозитории. В этом случае удалите существующий каталог `node_modules`.

После применения файла package.json или настраиваемых модулей к репозиторию для мобильной службы используйте функцию **require** для ссылки на модули по имени.   

>[WACOM.NOTE]  Модули, которые вы указали в package.json или загрузили в свою мобильную службу, используются только в коде серверного скрипта. Эти модули не используются средой выполнения мобильных служб.

###<a name="helper-functions"></a>Практическое руководство. Использование вспомогательных функций

Помимо запрашивания модулей, отдельные серверные скрипты могут включать вспомогательные функции. Это функции независимы от основной функции, их можно использовать для разделения кода в скрипте. 

В следующем примере регистрируется скрипт таблицы для операции вставки, которая включает вспомогательную функцию **handleUnapprovedItem**:


	function insert(item, user, request) {
	    if (!item.approved) {
	        handleUnapprovedItem(item, user, request);
	    } else {
	        request.execute();
	    }
	}
	
	function handleUnapprovedItem(item, user, request) {
	    // Do something with the supplied item, user, or request objects.
	}
 
В скрипте вспомогательные функции должны быть объявлены после основной функции. В скрипте необходимо объявить все переменные. Необъявленные переменные приводят к ошибке.

Определенные один раз вспомогательные функции также могут совместно использоваться серверными скриптами. Чтобы функция могла совместно использоваться скриптами, функции необходимо экспортировать, а файл скрипта должен существовать в каталоге `.\service\shared\`. Ниже приведен шаблон для экспорта общей функции в файле `.\services\shared\helpers.js`:

		exports.handleUnapprovedItem = function (tables, user, callback) {
		    
		    // Do something with the supplied tables or user objects and 
			// return a value to the callback function.
		};
 
You can then use a function like this in a table operation script:

		function insert(item, user, request) {
		    var helper = require('../shared/helper');
		    helper.handleUnapprovedItem(tables, user, function(result) {
		        	
					// Do something based on the result.
		            request.execute();
		        }
		    }
		}

В этом примере необходимо передать общей функции [объект таблиц] и [объект пользователя]. Это связано с тем, что для общих скриптов недоступен глобальный [объект таблицы], а [объект пользователя] существует только в контексте запроса.

Файлы скриптов передаются в общий каталог с помощью [системы управления версиями][Практическое руководство. Совместное использование кода с помощью системы управления версиями] или с помощью [средства командной строки][Использование программы командной строки].

###<a name="app-settings"></a>Практическое руководство. Работа с параметрами приложения

Мобильные службы позволяют безопасно хранить значения как параметры приложения, к которым можно получить доступ с помощью серверных скриптов во время выполнения.  При добавлении данных к параметрам приложения мобильной службы пары имя/значение хранятся в зашифрованном виде, и они будут доступны в серверных скриптах без жесткого кодирования их в файле скрипта. Дополнительные сведения см. в разделе [Параметры приложения].

В следующем примере настраиваемый интерфейс API использует предоставленный [объект службы] для извлечения значения параметра приложения.  

		exports.get = function(request, response) {
		
			// Get the MY_CUSTOM_SETTING value from app settings.
		    var customSetting = 
		        request.service.config.appSettings.my_custom_setting;
				
			// Do something and then send a response.

		}

Следующий код использует модуль настройки для получения значения маркера доступа к Twitter, который хранится в параметрах приложения, используемых в скрипте запланированных заданий:

		// Get the service configuration module.
		var config = require('mobileservice-config');

		// Get the stored Twitter consumer key and secret. 
		var consumerKey = config.twitterConsumerKey,
		    consumerSecret = config.twitterConsumerSecret
		// Get the Twitter access token from app settings.    
		var accessToken= config.appSettings.TWITTER_ACCESS_TOKEN,
		    accessTokenSecret = config.appSettings.TWITTER_ACCESS_TOKEN_SECRET;

Обратите внимание, что этот код также извлекает значения ключа пользователя Twitter, хранящиеся во вкладке **Удостоверение** на портале. Поскольку функция **config object** недоступна в скриптах операции с таблицами и запланированных заданий, для доступа к параметрам приложения необходимо использовать модуль конфигурации. Полный пример см. в разделе [Планирование серверных заданий в мобильных службах].

<h2><a name="command-prompt"></a>Использование программы командной строки</h2>

В мобильных службах можно создавать, изменять и удалять серверные скрипты с помощью средства командной строки Azure. Перед отправкой скриптов убедитесь, что используется следующая структура каталогов.

![4][4]

Обратите внимание, что эта структура каталогов такая же, как и репозиторий git при использовании системы управления версиями. 

При отправке файлов скрипта из средства командной строки необходимо сначала перейти в каталог `.\services\`. Следующая команда отправляет скрипт с именем `todoitem.insert.js` из подкаталога `table`:

		~$azure mobile script upload todolist table/todoitem.insert.js
		info:    Executing command mobile script upload
		info:    mobile script upload command OK

Следующая команда возвращает сведения о каждом файле скрипта, размещенном в вашей мобильной службе:

		~$ azure mobile script list todolist
		info:    Executing command mobile script list
		+ Retrieving script information
		info:    Table scripts
		data:    Name                       Size
		data:    -------------------------  ----
		data:    table/channels.insert      1980
		data:    table/TodoItem.insert      5504
		data:    table/TodoItem.read        64
		info:    Shared scripts
		data:    Name              Size
		data:    ----------------  ----
		data:    shared/helper.js  62
		data:    shared/uuid.js    7452
		info:    Scheduled job scripts
		data:    Job name    Script name           Status    Interval     Last run  Next run
		data:    ----------  --------------------  --------  -----------  --------  --------
		data:    getUpdates  scheduler/getUpdates  disabled  15 [minute]  N/A       N/A
		info:    Custom API scripts
		data:    Name                    Get          Put          Post         Patch        Delete
		data:    ----------------------  -----------  -----------  -----------  -----------  -----------
		data:    completeall             application  application  application  application  application
		data:    register_notifications  application  application  user         application  application
		info:    mobile script list command OK

Дополнительные сведения см. в разделе [Команды для управления мобильными службами Azure]. 

##<a name="working-with-tables"></a>Работа с таблицами

Для многих скриптов мобильных служб требуются серверные скрипты для доступа к таблицам базы данных. К примеру, поскольку мобильные службы не сохраняют состояния между выполнениями скрипта, любые данные, которые должны сохраняться между выполнениями скрипта, должны храниться в таблицах. Можно также просмотреть записи в таблице разрешений или хранения данных аудита, а не просто записать их в журнал, где данные хранятся ограниченное время и недоступны программно. 

Мобильные службы могут обращаться к таблицам двумя способами: с помощью прокси [объект таблицы] или путем составления запросов Transact-SQL с помощью [объекта mssql]. [Объект таблицы] упрощает доступ к данным таблицы из кода серверного скрипта, но [объект mssql] поддерживает более сложные операции с данными и обеспечивает наибольшую гибкость. 

###<a name="access-tables"></a>Практическое руководство. Доступ к таблицам из сценариев

Наиболее простой способ доступа к таблицам из скрипта - использовать [объект таблиц]. Функция **GetTable** возвращает экземпляр [объекта таблицы], который является прокси для доступа к запрашиваемой таблице. Затем можно вызвать функции прокси для доступа к данным и их изменения. 

Скрипты, зарегистрированные для операций с таблицей и запланированных заданий, могут получить доступ к [объекту таблиц] как глобальному объекту. Эта строка кода получает прокси для таблицы *TodoItems* из глобального [объекта таблиц]: :

		var todoItemsTable = tables.getTable('TodoItems');

Скрипты настраиваемого API могут получить доступ к [объекту таблиц] из свойства <strong>службы</strong> предоставляемого [объекта запроса]. Эта строка кода получает [объект таблиц] из запроса:

		var todoItemsTable = request.service.tables.getTable('TodoItem');

<div class="dev-callout"><strong>Примечание.</strong>
<p>Общие функции не могут получить доступ к объекту <strong>таблиц</strong> напрямую. В случае общей функции необходимо передать функции объект таблицы.</p></div>

Имея [объект таблицы], можно вызвать одну или несколько функций операций с таблицами: вставки, обновления, удаления или чтения. В этом примере считываются разрешения пользователей из таблицы разрешений:

	function insert(item, user, request) {
		var permissionsTable = tables.getTable('permissions');
	
		permissionsTable
			.where({ userId: user.userId, permission: 'submit order'})
			.read({ success: checkPermissions });
			
		function checkPermissions(results) {
			if(results.length > 0) {
				// Permission record was found. Continue normal execution.
				request.execute();
			} else {
				console.log('User %s attempted to submit an order without permissions.', user.userId);
				request.respond(statusCodes.FORBIDDEN, 'You do not have permission to submit orders.');
			}
		}
	}

В следующем примере записываются данные аудита в таблицу **audit**:

	function update(item, user, request) {
		request.execute({ success: insertAuditEntry });
		
		function insertAuditEntry() {
			var auditTable = tables.getTable('audit');
			var audit = {
				record: 'checkins',
				recordId: item.id,
				timestamp: new Date(),
				values: JSON.stringify(item)
			};
			auditTable.insert(audit, {
				success: function() {
					// Write to the response now that all data operations are complete
					request.respond();
				}
			});
		}
	}

Заключительный образец кода: [Практическое руководство. Доступ к настраиваемым параметрам][Практическое руководство. Добавление пользовательских параметров].

###<a name="bulk-inserts"></a>Практическое руководство. Выполнение массовой вставки

При использовании цикла **for** или **while** для непосредственной вставки в таблицу большого количества элементов (например, 1000)   могут возникнуть ограничения на число подключений SQL, которые приведут к сбою некоторых вставок. Запрос может не завершиться или вернуть ошибку: HTTP 500 Внутренняя ошибка сервера.  Чтобы избежать этой проблемы, можно вставлять элементы партиями примерно по 10. После вставки первой партии отправьте следующую и т. д.

С помощью следующего скрипта можно установить размер партии записей для вставки в параллельном режиме. Рекомендуется устанавливать небольшое количество записей. Функция **insertItems** вызывает себя рекурсивно при завершении асинхронной пакетной вставки. Цикл "for" в конце вставляет одну запись за один раз и вызывает **insertComplete** в случае успеха и **errorHandler** при ошибке. Функция **insertComplete**  определяет, будет ли **insertItems** вызываться рекурсивно для следующего пакета или задание выполнено и следует выйти из скрипта.

		var todoTable = tables.getTable('TodoItem');
		var recordsToInsert = 1000;
		var batchSize = 10; 
		var totalCount = 0;
		var errorCount = 0; 
		
		function insertItems() {        
		    var batchCompletedCount = 0;  
		
		    var insertComplete = function() { 
		        batchCompletedCount++; 
		        totalCount++; 
		        if(batchCompletedCount === batchSize || totalCount === recordsToInsert) {                        
		            if(totalCount < recordsToInsert) {
		                // kick off the next batch 
		                insertItems(); 
		            } else { 
		                // or we are done, report the status of the job 
		                // to the log and don't do any more processing 
		                console.log("Insert complete. %d Records processed. There were %d errors.", totalCount, errorCount); 
		            } 
		        } 
		    }; 
		
		    var errorHandler = function(err) { 
		        errorCount++; 
		        console.warn("Ignoring insert failure as part of batch.", err); 
		        insertComplete(); 
		    };
		
		    for(var i = 0; i < batchSize; i++) { 
		        var item = { text: "This is item number: " + totalCount + i }; 
		        todoTable.insert(item, { 
		            success: insertComplete, 
		            error: errorHandler 
		        }); 
		    } 
		} 
		
		insertItems(); 


Полный образец кода и сопутствующие обсуждение можно найти в этом [блоге](http://blogs.msdn.com/b/jpsanders/archive/2013/03/20/server-script-to-insert-table-items-in-windows-azure-mobile-services.aspx). Если вы используете этот код, можно адаптировать его к конкретной ситуации и тщательно протестировать.

###<a name="JSON-types"></a>Практическое руководство. Сопоставление типов JSON с типами баз данных

Коллекции типов данных на стороне клиента и в таблице базы данных мобильных служб различаются. Иногда их удается легко сопоставить друг с другом, а иногда не удается. Мобильные службы выполняют ряд преобразований типа при сопоставлении:

- Для типов в клиентах, реализованных на разных языках, выполняется сериализация в JSON.
- Прежде чем появиться в серверном сценарии, представление JSON преобразуется в JavaScript.
- Типы данных JavaScript преобразуются в типы базы данных SQL при сохранении с использованием [объекта таблиц].

Преобразование из схемы клиента в JSON зависит от платформы.  Клиенты магазина Windows и Windows Phone используют JSON.NET. Клиент Android использует библиотеку gson.  Клиент iOS использует класс NSJSONSerialization. Используется сериализация по умолчанию каждой из этих библиотек за исключением того, что объекты даты преобразуются в строки JSON, содержащие даты, закодированные по стандарту ISO 8601.

При написании серверных скриптов, использующих функции [insert], [update], [read] и [delete], можно получить доступ к представлению данных в JavaScript. Мобильные службы используют функцию десериализации Node.js ([JSON.parse](http://es5.github.io/#x15.12)) для преобразования объектов JSON при передаче в объекты JavaScript. Однако мобильные службы выполняют   преобразование для извлечения объектов **Дата** из строк ISO 8601.

Если вы используете [объект таблиц] или [объект mssql] либо просто позволяете выполниться скриптам таблицы, десериализованные объекты JavaScript вставляются в базу данных SQL. В этом процессе свойства объекта сопоставляются с типами T-SQL:

<table border="1">
<tr>
<td>Свойство JavaScript</td>
<td>Тип T-SQL</td>
</tr><tr>
<td>Число</td>
<td>Float(53)</td>
</tr><tr>
<td>Логический</td>
<td>Bit</td>
</tr><tr>
<td>Дата</td>
<td>DateTimeOffset(3)</td>
</tr>
<tr>
<td>Строка</td>
<td>Nvarchar(max)</td>
</tr>
<tr>
<td>Буфер</td>
<td>Не поддерживается</td>
</tr><tr>
<td>Объект</td>
<td>Не поддерживается</td>
</tr><tr>
<td>Массив</td>
<td>Не поддерживается</td>
</tr><tr>
<td>Поток</td>
<td>Не поддерживается</td>
</tr>
</table> 

###<a name="TSQL"></a>Использование языка Transact-SQL для доступа к таблицам

Самый простой способ получить данные таблицы из серверных скриптов - использовать прокси [объект таблицы]. Тем не менее существуют более расширенные скрипты, которые не поддерживаются [объектом таблицы], такие как запросы соединения и другие сложные запросы и вызовы хранимых процедур. В этих случаях необходимо выполнить инструкции Transact-SQL непосредственно в отношении реляционной таблицы, пользуясь [объектом mssql]. Данный объект предоставляет следующие функции.

- **query**: выполняет запрос, заданный строкой TSQL; результаты возвращаются в обратном вызове **success** объекта **options**. Запрос может содержать параметры, если присутствует параметр *params*.
- **queryRaw**: похожа на функцию *query* за исключением того, что результирующий набор возвращается после запроса в построчном формате (см. пример ниже).
- **open**: используется для подключения к базе данных мобильных служб, после чего объект подключения можно использовать для вызова операций с базой данных, таких как транзакции.

Эти методы предоставляют более низкий уровень контроля обработки запросов.

+ [Практическое руководство. Выполнение статического запроса]
+ [Практическое руководство. Выполнение динамического запроса]
+ [Практическое руководство. Объединение реляционных таблиц]
+ [Практическое руководство. Выполнение запроса, который возвращает *необработанные* результаты]
+ [Практическое руководство. Доступ для подключения к базе данных]	

####<a name="static-query"></a>Практическое руководство. Выполнение статического запроса

Следующий запрос не содержит параметров и возвращает три записи из таблицы `statusupdate`. Набор строк представлен в стандартном формате JSON.

		mssql.query('select top 3 * from statusupdates', {
		    success: function(results) {
		        console.log(results);
		    },
            error: function(err) {
                console.log("error is: " + err);
			}
		});


####<a name="dynamic-query"></a>Практическое руководство. Выполнение динамического параметризированного запроса

В следующем примере реализуется настраиваемая авторизация путем чтения разрешений для каждого пользователя из таблицы разрешений. При выполнении запроса местозаполнитель (?) заменяется предоставленным параметром.

		    var sql = "SELECT _id FROM permissions WHERE userId = ? AND permission = 'submit order'";
		    mssql.query(sql, [user.userId], {
		        success: function(results) {
		            if (results.length > 0) {
		                // Permission record was found. Continue normal execution. 
		                request.execute();
		            } else {
		                console.log('User %s attempted to submit an order without permissions.', user.userId);
		                request.respond(statusCodes.FORBIDDEN, 'You do not have permission to submit orders.');
		            }
		        },
            	error: function(err) {
                	console.log("error is: " + err);
				}	
		    });


####<a name="joins"></a>Практическое руководство. Объединение реляционных таблиц

Можно объединить две таблицы с помощью метода **query** [объекта mssql] для передачи в коде TSQL, который реализует соединение. Предположим, у нас есть некоторые элементы в таблице **ToDoItem**, а каждый элемент в таблице имеет свойство **priority**, которое соответствует столбцу в таблице. Элемент может выглядеть следующим образом.

		{ text: 'Убрать мусор', complete: false, priority: 1}

Также предположим, что у нас есть дополнительная таблица, которая называется **Приоритет**, со строками, содержащими **номер** приоритета и текстовое **описание**. Например, номер приоритета 1 может иметь описание "Критический", а объект выглядит следующим образом:

		{ number: 1, description: 'Critical'}

Теперь можно заменить номер **приоритета** в нашем элементе текстовым описанием номера приоритета. Это делается с помощью реляционного соединения двух таблиц.

		mssql.query('SELECT t.text, t.complete, p.description FROM ToDoItem as t INNER JOIN Priority as p ON t.priority = p.number', {
			success: function(results) {
				console.log(results);
			},
            error: function(err) {
                console.log("error is: " + err);
		});
	
Скрипт соединяет две таблицы и записывает результаты в журнал. Полученные объекты могут выглядеть следующим образом.

		{ text: 'Убрать мусор', complete: false, description: 'Critical'}


####<a name="raw"></a>Практическое руководство. Выполнение запроса, который возвращает *необработанные* результаты

В этом примере запрос выполняется, как и раньше, но возвращает результирующий набор в построчном формате, который требуется проанализировать по строкам и по столбцам. Возможный сценарий этого - если вам нужен доступ к типам данных, которые не поддерживают мобильные службы. Этот код просто записывает выходные данные в журнал консоли, что позволяет вам просматривать данные в построчном формате.

		mssql.queryRaw('SELECT * FROM ToDoItem', {
		    success: function(results) {
		        console.log(results);
		    },
            error: function(err) {
                console.log("error is: " + err);
			}
		});

Здесь представлен результат выполнения данного запроса. Он содержит метаданные о каждом столбце в таблице, за которыми следует представление строк и столбцов.

		{ meta: 
		   [ { name: 'id',
		       size: 19,
		       nullable: false,
		       type: 'number',
		       sqlType: 'bigint identity' },
		     { name: 'text',
		       size: 0,
		       nullable: true,
		       type: 'text',
		       sqlType: 'nvarchar' },
		     { name: 'complete',
		       size: 1,
		       nullable: true,
		       type: 'boolean',
		       sqlType: 'bit' },
		     { name: 'priority',
		       size: 53,
		       nullable: true,
		       type: 'number',
		       sqlType: 'float' } ],
		  rows: 
		   [ [ 1, 'good idea for the future', null, 3 ],
		     [ 2, 'this is important but not so much', null, 2 ],
		     [ 3, 'fix this bug now', null, 0 ],
		     [ 4, 'we need to fix this one real soon now', null, 1 ],
		   ] }

####<a name="connection"></a>Практическое руководство. Доступ для подключения к базе данных

Чтобы получить доступ для подключения к базе данных, можно использовать метод **open**. Одной из причин для этого может быть необходимость использовать транзакции базы данных.

Успешное выполнение **open** вызывает подключение к базе данных, которое передается в функцию **success** в качестве параметра. Можно вызвать любую из следующих функций объекта **connection**: *close*, *queryRaw*, *query*, *beginTransaction*, *commit* и *rollback*.

		    mssql.open({
		        success: function(connection) {
		            connection.query(//query to execute);
		        },
	            error: function(err) {
	                console.log("error is: " + err);
				}
		    });

##<a name="debugging"></a>Отладка и устранение неполадок

Основным способом отладки и устранения неполадок серверных скриптов является запись в журнал службы. По умолчанию мобильные службы записывают ошибки, возникающие во время выполнения скрипта службы, в журналы служб. Ваши скрипты также могут записывать в журналы. Запись в журналы - отличный способ отладить скрипты и убедиться, что они работают правильно.

###<a name="write-to-logs"></a>Практическое руководство. Запись выходных данных в журналы мобильной службы

Для записи в журналы используется глобальный [консольный объект]. Для записи предупреждений на уровне сведений используются функции **log** или **info**. Функции **warning** и **error** записывают соответствующие уровни, которые вызываются в журналах. 

<div class="dev-callout"><strong>Примечание.</strong>
<p>Для просмотра журналов для мобильной службы выполните вход на <a href="https://manage.windowsazure.com/">Портал управления</a>, выберите мобильную службу, а затем выберите вкладку <strong>Журналы</strong>.</p></div>

Для форматирования сообщений с помощью параметров можно также использовать функции ведения журнала [консольного объекта]. В следующем примере в качестве параметра в строку сообщения подставляется объект JSON.

	function insert(item, user, request) {
	    console.log("Inserting item '%j' for user '%j'.", item, user);  
	    request.execute();
	}

Обратите внимание, что строка `%j` используется как заполнитель для объекта JSON и что параметры предоставляются в последовательном порядке. 

Чтобы избежать перегрузки журнала, следует удалить или отключить вызовы console.log(), которые не нужны для работы.

<!-- Anchors. -->
[Введение]: #intro
[Операции с таблицами]: #table-scripts
[Практическое руководство. Регистрация для операций с таблицами]: #register-table-scripts
[Практическое руководство. Определение скриптов таблицы]: #execute-operation
[Практическое руководство. Переопределение ответа по умолчанию]: #override-response
[Практическое руководство. Изменение операции]: #modify-operation
[Практическое руководство. Переопределение успеха и ошибки]: #override-success-error
[Практическое руководство. Переопределение успешного выполнения]: #override-success
[Практическое руководство. Переопределение обработки ошибок по умолчанию]: #override-error
[Практическое руководство. Доступ к таблицам из сценариев]: #access-tables
[Практическое руководство. Добавление пользовательских параметров]: #access-headers.
[Практическое руководство. Работа с пользователями]: #work-with-users
[Практическое руководство. Определение сценариев запланированных заданий]: #scheduler-scripts
[Практическое руководство. Уточнение возможности доступа к таблицам]: #authorize-tables
[Использование языка Transact-SQL для доступа к таблицам]: #TSQL
[Практическое руководство. Выполнение статического запроса]: #static-query
[Практическое руководство. Выполнение динамического запроса]: #dynamic-query
[Практическое руководство. Выполнение запроса, который возвращает *необработанные* результаты]: #raw
[Практическое руководство. Доступ для подключения к базе данных]: #connection
[Практическое руководство. Объединение реляционных таблиц]: #joins
[Практическое руководство. Выполнение массовой вставки]: #bulk-inserts
[Практическое руководство. Сопоставление типов JSON с типами баз данных]: #JSON-types
[Практическое руководство. Загрузка модулей Node.js]: #modules-helper-functions
[Практическое руководство. Запись выходных данных в журналы мобильной службы]: #write-to-logs
[Система управления версиями, общий код и вспомогательные функции]: #shared-code
[Использование программы командной строки]: #command-prompt
[Работа с таблицами]: #working-with-tables
[Привязка настраиваемого интерфейса API]: #custom-api
[Практическое руководство. Определение настраиваемого интерфейса API]: #define-custom-api
[Практическое руководство. Совместное использование кода с помощью системы управления версиями]: #shared-code-source-control
[Практическое руководство. Использование вспомогательных функций]: #helper-functions
[Отладка и устранение неполадок]: #debugging
[Практическое руководство. Реализация методов HTTP]: #handle-methods
[Практическое руководство. Работа с пользователями и заголовками в настраиваемом интерфейсе API]: #get-api-user
[Практическое руководство. Доступ к заголовкам запросов настраиваемого интерфейса API]: #get-api-headers
[Планировщик заданий]: #scheduler-scripts
[Практическое руководство. Определение нескольких маршрутов настраиваемого интерфейса API]: #api-routes
[Практическое руководство. Отправка и получение данных в формате XML]: #api-return-xml
[Практическое руководство. Работа с параметрами приложения]: #app-settings

[1]: ./media/mobile-services-how-to-use-server-scripts/1-mobile-insert-script-users.png
[2]: ./media/mobile-services-how-to-use-server-scripts/2-mobile-custom-api-script.png
[3]: ./media/mobile-services-how-to-use-server-scripts/3-mobile-schedule-job-script.png
[4]: ./media/mobile-services-how-to-use-server-scripts/4-mobile-source-local-cli.png

<!-- URLs. -->
[Справочник серверных скриптов мобильных служб]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554226.aspx
[Планирование серверных заданий в мобильных службах]: /ru-ru/develop/mobile/tutorials/schedule-backend-tasks/
[объект запроса]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554218.aspx
[объект ответа]: http://msdn.microsoft.com/ru-ru/library/windowsazure/dn303373.aspx
[Объект пользователя]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554220.aspx
[push-объект]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554217.aspx
[функция insert]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554229.aspx
[вставка]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554229.aspx
[функции update]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554214.aspx
[функция delete]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554215.aspx
[функция read]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554224.aspx
[обновить]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554214.aspx
[удалить]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554215.aspx
[чтение]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554224.aspx
[объект query]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj613353.aspx
[объект apns]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj839711.aspx
[Объект mpns]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj871025.aspx
[Объект wns]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj860484.aspx
[объект таблицы]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554210.aspx
[объект таблиц]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj614364.aspx
[объект mssql]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554212.aspx
[объект консоли]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554209.aspx
[Чтение и запись данных]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj631640.aspx
[Проверка данных]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj631638.aspx
[Изменить запрос]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj631635.aspx
[Изменить ответ]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj631631.aspx
[Портал управления]: https://manage.windowsazure.com/
[Запланированные задания]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj860528.aspx
[Проверка и изменение данных в мобильных службах с помощью серверных скриптов]: /ru-ru/develop/mobile/tutorials/validate-modify-and-augment-data-dotnet/
[Команды для управления мобильными службами Azure]: /ru-ru/manage/linux/other-resources/command-line-tools/#Commands_to_manage_mobile_services/#Mobile_Scripts
[Push-уведомление магазина Windows]: /ru-ru/develop/mobile/tutorials/get-started-with-push-dotnet/
[Push-уведомление Windows Phone]: /ru-ru/develop/mobile/tutorials/get-started-with-push-wp8/
[Push-уведомление iOS]: /ru-ru/develop/mobile/tutorials/get-started-with-push-ios/
[Push-уведомление Android]: /ru-ru/develop/mobile/tutorials/get-started-with-push-android/
[Пакет Azure SDK для Node.js]: http://go.microsoft.com/fwlink/p/?LinkId=275539
[Отправить HTTP-запрос]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj631641.aspx
[Отправить сообщение электронной почты с мобильных служб с помощью SendGrid]: /ru-ru/develop/mobile/tutorials/send-email-with-sendgrid/
[Приступая к работе с аутентификацией]: http://go.microsoft.com/fwlink/p/?LinkId=287177
[API: шифрование]: http://go.microsoft.com/fwlink/p/?LinkId=288802
[API: путь]: http://go.microsoft.com/fwlink/p/?LinkId=288803
[API: строка запроса]: http://go.microsoft.com/fwlink/p/?LinkId=288804
[API: URL-адрес]: http://go.microsoft.com/fwlink/p/?LinkId=288805
[util API]: http://go.microsoft.com/fwlink/p/?LinkId=288806
[zlib API]: http://go.microsoft.com/fwlink/p/?LinkId=288807
[Настраиваемая служба API]: http://msdn.microsoft.com/ru-ru/library/windowsazure/dn280974.aspx
[Вызов из клиента настраиваемого интерфейса API]: /ru-ru/develop/mobile/tutorials/call-custom-api-dotnet/#define-custom-api
[Библиотека Express.js]: http://go.microsoft.com/fwlink/p/?LinkId=309046
[Определение настраиваемого интерфейса API с поддержкой периодических уведомлений]: /ru-ru/develop/mobile/tutorials/create-pull-notifications-dotnet/
[объект express в express.js]: http://expressjs.com/api.html#express
[Хранение серверных скриптов системе управления версиями]: /ru-ru/develop/mobile/tutorials/store-scripts-in-source-control/
[Использование общего кода и модулей Node.js в серверном скрипте]: /ru-ru/develop/mobile/tutorials/store-scripts-in-source-control/#use-npm
[объект службы]: http://msdn.microsoft.com/ru-ru/library/windowsazure/dn303371.aspx
[Параметры приложения]: http://msdn.microsoft.com/ru-ru/library/dn529070.aspx
[модуль config]: http://msdn.microsoft.com/ru-ru/library/dn508125.aspx
[Поддержка package.json в мобильных службах Azure]: http://go.microsoft.com/fwlink/p/?LinkId=391036
