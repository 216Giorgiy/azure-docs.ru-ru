<properties 
	pageTitle="Работа с серверной мобильной службой JavaScript" 
	description="Содержит примеры того, как определить, зарегистрировать и использовать серверные сценарии в мобильных службах Azure." 
	services="mobile-services" 
	documentationCenter="" 
	authors="RickSaling" 
	manager="dwrede" 
	editor=""/>

<tags 
	ms.service="mobile-services" 
	ms.workload="mobile" 
	ms.tgt_pltfrm="" 
	ms.devlang="multiple" 
	ms.topic="article" 
	ms.date="02/12/2015" 
	ms.author="ricksal"/>


# Работа с серверной мобильной службой JavaScript

<div class="dev-center-tutorial-subselector"><a href="/documentation/articles/mobile-services-dotnet-backend-how-to-use/" title=".NET backend">Серверная служба .NET</a> | <a href="/documentation/articles/mobile-services-how-to-use-server-scripts/"  title="JavaScript backend" class="current">Серверная служба JavaScript</a></div>
 
Эта статья содержит подробную информацию о программировании серверной части на JavaScript в мобильных службах Azure и соответствующие примеры. 

## <a name="intro"></a>Введение

В серверной части мобильной службы JavaScript можно определить настраиваемую бизнес-логику в коде JavaScript, который хранится и выполняется на сервере. Этот серверный код сценария назначается одной из следующих функций сервера:

+ [Операции вставки, чтения, обновления и удаления в заданной таблице][Операции с таблицей].
+ [Запланированные задания][Планировщик заданий].
+ [HTTP-методы, определенные в настраиваемом интерфейсе API][Привязка настраиваемого интерфейса API]. 

Подпись основной функции в серверном скрипте зависит от контекста использования скрипта. Можно также определить общий код скрипта как модули nodes.js, которые являются общими для скриптов. Дополнительные сведения см. разделе [Контроль версий и общий код][Контроль версий, общий код и вспомогательные функции].

Описания отдельных объектов и функций серверных скриптов см. в разделе [Справочник серверных скриптов мобильных служб] 


## <a name="table-scripts"></a>Операции с таблицами

Скрипт операций с таблицами - серверный скрипт, который зарегистрирован на операцию вставки, чтения, обновления или удаления таблицы (*del*). В этом разделе описывается работа с операциями таблицы в серверном приложении JavaScript, включая следующие разделы:

+ [Общие сведения об операциях с таблицами][Основные операции с таблицей]
+ [Практическое руководство. Регистрация для операций с таблицами]
+ [Практическое руководство. Переопределение ответа по умолчанию]
+ [Практическое руководство. Переопределение успешного выполнения]
+ [Практическое руководство. Переопределение обработки ошибок по умолчанию]
+ [Практическое руководство. Создание уникальных значений идентификатора](#generate-guids)
+ [Практическое руководство. Добавление настраиваемых параметров].
+ [Практическое руководство. Работа с пользователями таблиц][Практическое руководство. Работа с пользователями]

### <a name="basic-table-ops"></a>Обзор операций с таблицами

Имя скрипта должно совпадать с типом операции, для которой он зарегистрирован. Для данной операции с таблицей может быть зарегистрирован только один скрипт. Скрипт выполняется каждый раз при вызове данной операции запросом REST, например при получении запроса POST для вставки элемента в таблицу. Мобильные службы не сохраняют состояния между выполнениями скриптов. Так как каждый раз, когда запускается скрипт, создается новый глобальный контекст, снова инициализируются все состояния переменных, определенных в скрипте. Если требуется сохранять состояние от одного запроса к другому, создайте в своей мобильной службе таблицу, а затем читайте и записывайте состояние в таблицу. Дополнительную информацию см. в разделах [Практическое руководство. Доступ к таблицам из сценариев]

Скрипты операций с таблицами пишут, когда необходимо применять настраиваемую бизнес-логику при выполнении операции. Например, приведенный ниже скрипт отклоняет операции вставки, если длина строки поля `text` больше десяти символов. 

	function insert(item, user, request) {
	    if (item.text.length > 10) {
	        request.respond(statusCodes.BAD_REQUEST, 
				'Text length must be less than 10 characters');
	    } else {
	        request.execute();
	    }
	}

Функция скрипта таблицы всегда принимает три аргумента.

- Первый аргумент зависит от операции с таблицей. 

	- Для вставок и обновлений это объект **item**, который является JSON-представлением строки, задействованной в операции. Это позволяет получить доступ к значениям столбцов по имени, например  *item.Owner*, где *Owner* является одним из имен в JSON-представлении.
	- Для удаления это идентификатор записи, которую требуется удалить. 
	- Для чтения это [объект query], задающий набор строк для возврата.

- Вторым аргументом всегда является [объект user][Объект user], который представляет пользователя, отправившего запрос. 

- Третьим аргументом всегда является [объект request][Объект request], с помощью которого можно контролировать выполнение запрошенной операции и отправляемый клиенту ответ.

Ниже приведены канонические подписи функций main для операций с таблицей. 

+ [Insert][insert]: `function insert (item, user, request) { ... }`
+ [Update][update]: `function update (item, user, request) { ... }`
+ [Delete][delete]: `function del (id, user, request) { ... }`
+ [Read][read]: `function read (query, user, request) { ... }`

>[AZURE.NOTE]delete является зарезервированным ключевым словом в языке JavaScript, поэтому функция, зарегистрированная для операции удаления, должна иметь имя _del_. 

Каждый серверный скрипт имеет функцию main и может иметь дополнительные вспомогательные функции. Даже если серверный скрипт был создан для определенной таблицы, он может также ссылаться на другие таблицы в той же базе данных. Можно также определить общие функции как модули, которые могут быть общими для скриптов. Дополнительные сведения см. разделе [Контроль версий и общий код][Контроль версий, общий код и вспомогательные функции].

### <a name="register-table-scripts"></a>Практическое руководство. Регистрация сценариев таблиц

Серверные скрипты, которые зарегистрированы для операции с таблицей, можно определить одним из следующих способов:

+ В [портале управления Azure][Портал управления]. Доступ к скриптам для операций с таблицами осуществляется во вкладке **Скрипты** для данной таблицы. Ниже показан код по умолчанию, зарегистрированный для скрипта вставки в таблицу `TodoItem`. Можно переопределить этот код с помощью собственной настраиваемой бизнес-логики.

	![1][1]
	
	Чтобы узнать, как это сделать, см. раздел [Проверка и изменение данных в мобильных службах с помощью серверных скриптов].  

+ С помощью системы управления версиями. Если включена система управления версиями, просто создайте файл с именем <em>`<table>`</em>.<em>`<operation>`</em>.js во вложенной папке .\service\table репозитория git, где <em>`<table>`</em> - это имя таблицы, а <em>`<operation>`</em> - имя регистрируемой операции. Дополнительные сведения см. разделе [Контроль версий и общий код][Контроль версий, общий код и вспомогательные функции].

+ В командной строке с помощью программы командной строки Azure. Дополнительные сведения см. в разделе [Использование программы командной строки].


Скрипт операции с таблицей должен вызывать по крайней мере одну из перечисленных ниже функций [объекта запроса], чтобы гарантировать получение ответа клиентом. 
 
+ **Функция execute**. Выполняется запрошенная операция, и возвращается стандартный ответ.
 
+ **Функция respond**. Возвращается настраиваемый ответ.

> [AZURE.ВАЖНО] Если скрипт содержит путь кода, в котором не вызывается ни функция **execute**, ни функция **respond**, операция может перестать отвечать.

Следующий скрипт вызывает функцию **execute** для завершения операции с данными, запрошенной клиентом: 

	function insert(item, user, request) { 
	    request.execute(); 
	}

В этом примере элемент вставляется в базу данных, а пользователю возвращается код соответствующего состояния. 

При вызове функции **execute** для выполнения операции используется значение `item`, [query][объект query] или `id`, переданное в качестве первого аргумента в функцию скрипта. Для операции вставки, обновления или запроса можно изменить значение item или query перед вызовом функции **execute**. 

	function insert(item, user, request) { 
	    item.scriptComment =
			'this was added by a script and will be saved to the database'; 
	    request.execute(); 
	} 
 
	function update(item, user, request) { 
	    item.scriptComment = 
			'this was added by a script and will be saved to the database'; 
	    request.execute(); 
	} 

	function read(query, user, request) { 
		// Only return records for the current user 	    
		query.where({ userid: user.userId}); 
	    request.execute(); 
	}
 
>[AZURE.NOTE]В скрипте удаления изменение значения предоставляемой переменной userId не влияет на то, какая запись удаляется.

Дополнительные примеры см. в разделах [Чтение и запись данных], [Изменение запроса] и [Проверка данных].


### <a name="override-response"></a>Практическое руководство. Переопределение ответа по умолчанию

Скрипт также можно использовать для реализации логики проверки, чтобы переопределить отклик по умолчанию. Если проверка не пройдена, просто вызовите функцию **respond** вместо функции **execute** и запишите ответ клиенту. 

	function insert(item, user, request) {
	    if (item.userId !== user.userId) {
	        request.respond(statusCodes.FORBIDDEN, 
	        'You may only insert records with your userId.');
	    } else {
	        request.execute();
	    }
	}

В этом примере запрос отклоняется, если свойство `userId` вставляемого элемента не соответствует свойству `userId` [объекта user], который предоставляется для прошедшего проверку подлинности клиента. В данном случае операции с базой данных (*insert*) не производится и клиенту возвращается ответ с настраиваемым сообщением об ошибке и кодом состояния HTTP 403. Дополнительные примеры см. в разделе [Изменение отклика].

### <a name="override-success"></a>Практическое руководство. Переопределение успешного выполнения

По умолчанию в операции с таблицей функция **execute** автоматически записывает ответы. Тем не менее в функцию "execute" можно передать два необязательных параметра, которые переопределят ее поведение в случае успеха или ошибки.

Передавая обработчик **success** при вызове функции "execute", можно изменить результаты запроса до их записи в ответ. В следующем примере вызывается функция `execute({ success: function(results) { ... })`. Она выполняет дополнительные действия после чтения данных из базы данных, но перед записью ответа.

	function read(query, user, request) {
	    request.execute({
	        success: function(results) {
	            results.forEach(function(r) {
	                r.scriptComment = 
	                'this was added by a script after querying the database';
	            });
	            request.respond();
	        }
	    });
	}

При вводе обработчика **success** для функции **execute** необходимо также вызвать функцию **respond** как часть обработчика **success**, чтобы среда выполнения знала, что скрипт завершен и можно записать ответ. При вызове функции **respond** без передачи каких-либо аргументов, мобильные службы создают ответ по умолчанию. 

>[AZURE.NOTE]Функцию **respond** без аргументов для вызова ответа по умолчанию можно вызвать только в том случае, если вначале вызвать функцию **execute**.
 
### <a name="override-error"></a>Практическое руководство. Переопределение обработки ошибок по умолчанию

Функция **execute** может завершиться ошибкой в случае потери подключения к базе данных, недопустимого объекта или неверного запроса. По умолчанию при возникновении ошибки серверные скрипты записывают ошибку в журнал и записывают ошибочный результат в ответ. Поскольку мобильные службы обеспечивают обработку ошибок по умолчанию, нет необходимости обрабатывать ошибки, возникающие в службе. 

Если вы хотите произвести определенное компенсирующее действие или использовать глобальный объект console для записи в журнал более подробных сведений, то обработку ошибок по умолчанию можно переопределить путем реализации явной обработки ошибок. Это можно сделать, указав обработчик **error** для функции **execute**:

	function update(item, user, request) { 
	  request.execute({ 
	    error: function(err) { 
	      // Do some custom logging, then call respond. 
	      request.respond(); 
	    } 
	  }); 
	}
 

Если имеется обработчик ошибок, мобильные службы возвращают клиенту результат ошибки при вызове функции **respond**.

При желании можно указать и обработчик **success**, и обработчик **error**.

### <a name="generate-guids"></a>Практическое руководство. Создание уникальных значений идентификатора

Мобильные службы поддерживают уникальные настраиваемые строковые значения для столбца **идентификатор** таблицы. Это позволяет приложениям использовать в качестве идентификатора настраиваемые значения, такие как адреса электронной почты или имена пользователей. 

Строковые идентификаторы предоставляют следующие преимущества.

+ Идентификаторы создаются без обмена данными с базой данных.
+ Можно легко объединять записи из разных таблиц или баз данных.
+ Значения идентификаторов можно удобно интегрировать с логикой приложения.

Если не задано строковое значение идентификатора для вставленной записи, мобильные службы создают уникальное значение для идентификатора. Можно создавать собственные уникальные значения идентификатора в серверных скриптах. В следующем примере скрипта создается настраиваемый идентификатор GUID, который назначается идентификатору новой записи. Этот идентификатор похож на значение, создаваемое мобильными службами, если не передать значение идентификатора записи.

	// Example of generating an id. This is not required since Mobile Services
	// will generate an id if one is not passed in.
	item.id = item.id || newGuid();
	request.execute();

	function newGuid() {
		var pad4 = function(str) { return "0000".substring(str.length) + str; };
		var hex4 = function () { return pad4(Math.floor(Math.random() * 0x10000 /* 65536 */ ).toString(16)); };
		return (hex4() + hex4() + "-" + hex4() + "-" + hex4() + "-" + hex4() + "-" + hex4() + hex4() + hex4());
	}


Если приложение предоставляет значение для идентификатора, мобильные службы сохраняют его как есть. (В том числе с начальными или конечными пробелами.) Пробелы не удаляются из значения.

Значение для `id` должно быть уникальным и не должно содержать символы из следующих наборов:

+ Управляющие символы: [0x0000-0x001F] и [0x007F-0x009F]. Дополнительные сведения см. в разделе [Управляющие коды ASCII C0 и C1](http://en.wikipedia.org/wiki/Data_link_escape_character#C1_set).
+  Печатные символы: **"**(0x0022), **\+** (0x002B), **/** (0x002F), **?** (0x003F), **\\** (0x005C), **`** (0x0060)
+  Идентификаторы "." и ".."

Также для таблиц можно использовать целочисленные идентификаторы. Чтобы использовать целочисленный идентификатор, необходимо создать таблицу с помощью `mobile table create` команды с параметром `--integerId`. Эта команда используется в интерфейсе командной строки (CLI) Azure. Дополнительные сведения об использовании CLI см. в разделе [Интерфейс командной строки для управления таблицами мобильных служб](virtual-machines-command-line-tools.md/#Mobile_Tables).


### <a name="access-headers"></a>Практическое руководство. Доступ к настраиваемым параметрам

При отправке запроса к мобильной службе можно добавить настраиваемые параметры в URI запроса, чтобы указать скриптам операций с таблицей, как обращаться с данным запросом. Измените скрипт для проверки параметра, чтобы определить путь обработки.

Например, следующий URI для запроса POST сообщает службе не допускать вставки нового элемента *TodoItem*, который имеет то же текстовое значение:

		https://todolist.azure-mobile.net/tables/TodoItem?duplicateText=false

Доступ к этим настраиваемым параметрам запроса осуществляется как к JSON-значениям из свойства **параметры** [объекта запроса]. Мобильные службы предоставляют объект **запрос** для любой функции, зарегистрированной для операции с таблицей. Следующий серверный скрипт для операции вставки проверяет значение параметра `duplicateText` перед операцией вставки.

		function insert(item, user, request) {
		    var todoItemTable = tables.getTable('TodoItem');
		    // Check the supplied custom parameter to see if
		    // we should allow duplicate text items to be inserted.		   
		    if (request.parameters.duplicateText === 'false') {
		        // Find all existing items with the same text
		        // and that are not marked 'complete'. 
		        todoItemTable.where({
		            text: item.text,
		            complete: false
		        }).read({
		            success: insertItemIfNotComplete
		        });
		    } else {
		        request.execute();
		    }

		    function insertItemIfNotComplete(existingItems) {
		        if (existingItems.length > 0) {
		            request.respond(statusCodes.CONFLICT, 
                        "Duplicate items are not allowed.");
		        } else {
		            // Insert the item as normal. 
		            request.execute();
		        }
		    }
		}

Обратите внимание, что в **insertItemIfNotComplete** функция **execute** [объекта запроса] вызывается для вставки элемента при отсутствии повторяющегося текста; в противном случае вызывается функция **respond**, которая уведомляет клиента о повторе. 

Обратите внимание на синтаксис вызова функции **success** в приведенном выше коде.

 		        }).read({
		            success: insertItemIfNotComplete
		        });

В JavaScript это компактная версия более длинного эквивалента: 

		success: function(results) 
		{ 
			insertItemIfNotComplete(results); 
		}


### <a name="work-with-users"></a>Практическое руководство. Работа с пользователями

В мобильных службах Azure можно использовать поставщика удостоверений для проверки подлинности пользователей. Дополнительные сведения см. в разделе [Приступая к работе с проверкой подлинности]. Когда прошедший проверку пользователь вызывает операцию с таблицей, мобильные службы используют [объект пользователя] для предоставления сведений о пользователе зарегистрированной функции скрипта. Свойство **userId** можно использовать для хранения и извлечения данных конкретного пользователя. В следующем примере устанавливается свойство владельца элемента на основе ИД пользователя, прошедшего проверку (userId):

	function insert(item, user, request) {
	    item.owner = user.userId;
	    request.execute();
	}

В следующем примере добавляется дополнительный фильтр запроса на основе **userId** прошедшего проверку пользователя. Этот фильтр ограничивает результаты только теми элементами, которые принадлежат текущему пользователю:  

	function read(query, user, request) {
	    query.where({
	        owner: user.userId
	    });
	    request.execute();
	}

## <a name="custom-api"></a>Настраиваемые API

В этом разделе описывается, как создавать настраиваемые конечные точки API и работать с ними (ниже перечислены соответствующие подразделы). 
	
+ [Общие сведения о настраиваемых API](#custom-api-overview)
+ [Практическое руководство. Определение настраиваемого интерфейса API]
+ [Практическое руководство. Реализация методов HTTP]
+ [Практическое руководство. Отправка и получение данных в формате XML]
+ [Практическое руководство. Работа с пользователями и заголовками в настраиваемом интерфейсе API]
+ [Практическое руководство. Определение нескольких маршрутов настраиваемого интерфейса API]

### <a name="custom-api-overview"></a>Общие сведения о настраиваемых API

Настраиваемый интерфейс API является конечной точкой в мобильной службе, доступной через один или несколько стандартных методов HTTP: GET, POST, PUT, PATCH и DELETE. Для каждого метода HTTP, который поддерживает настраиваемый интерфейс API, можно определить отдельную функцию экспорта в одном и том же файле скрипта. Зарегистрированный скрипт вызывается при получении запроса настраиваемого интерфейса API с помощью данного метода. Дополнительные сведения см. в разделе [Настраиваемый интерфейс API].

При вызове функций настраиваемого интерфейса API средой выполнения мобильных служб предоставляется объект [request][объект request] и объект [response][объект response]. Эти объекты предоставляют функциональные возможности [библиотеки express.js], которыми можно управлять с помощью скриптов. Следующий настраиваемый интерфейс API с именем **hello** - очень простой пример, который возвращает _Hello, world! _ в ответ на запрос POST:

		exports.post = function(request, response) {
		    response.send(200, "{ message: 'Hello, world!' }");
		} 

Функция **send** [объекта ответа] возвращает нужный ответ клиенту. Этот код вызывается отправлением запроса POST по следующему URL-адресу:

		https://todolist.azure-mobile.net/api/hello  

Глобальное состояние сохраняется между выполнениями. 

### <a name="define-custom-api"></a>Практическое руководство. Определение настраиваемого интерфейса API

Серверные скрипты, которые зарегистрированы для методов HTTP в конечной точке настраиваемого интерфейса API, можно определить одним из следующих способов:

+ В [портале управления Azure][Портал управления]. Скрипты настраиваемого интерфейса API создаются и изменяются во вкладке **API**. Код серверного скрипта находится во вкладке **Скрипты** данного настраиваемого интерфейса API. Ниже приведен скрипт, который вызывается по запросу POST к конечной точке `CompleteAll` настраиваемого API. 

	![2][2]
	
	На вкладке "Разрешения" назначаются разрешения на доступ для методов настраиваемого интерфейса API. Как был создан этот настраиваемый интерфейс API, см. в разделе [Вызов настраиваемого API из клиента]  

+ С помощью системы управления версиями. Если включена система управления версиями, просто создайте файл с именем <em>`<custom_api>`</em>.js во вложенной папке .\service\api репозитория git, где <em>`<custom_api>`</em> является именем регистрируемого настраиваемого API. Этот файл скрипта содержит функцию _exported_ для каждого метода HTTP, предоставляемого настраиваемым API. Разрешения определены в файле-компаньоне .json. Дополнительные сведения см. разделе [Контроль версий и общий код][Контроль версий, общий код и вспомогательные функции].

+ В командной строке с помощью программы командной строки Azure. Дополнительные сведения см. в разделе [Использование программы командной строки].

### <a name="handle-methods"></a>Практическое руководство. Реализация методов HTTP

Настраиваемый интерфейс API может обрабатывать один или несколько методов HTTP: GET, POST, PUT, PATCH и DELETE. Для каждого HTTP-метода, который обрабатывает настраиваемый интерфейс API, определяется экспортированная функция. Один файл кода настраиваемого API может экспортировать одну или все из следующих функций:

		exports.get = function(request, response) { ... };
		exports.post = function(request, response) { ... };
		exports.patch = function(request, response) { ... };
		exports.put = function(request, response) { ... };
		exports.delete = function(request, response) { ... };

Конечную точку настраиваемого интерфейса API нельзя вызвать с помощью HTTP-метода, который не был реализован в серверном скрипте, и возвращается сообщение об ошибке 405 (недопустимый метод). Для каждого HTTP-метода поддержки можно назначить отдельные уровни разрешения.

### <a name="api-return-xml"></a>Практическое руководство. Отправка и получение данных в формате XML

Когда клиенты хранят и извлекают данные, мобильные службы используют JavaScript Object Notation (JSON) для представления данных в теле сообщения. Однако существуют скрипты, где вместо этого требуется использовать полезные данные формата XML. Например, приложения для магазина Windows имеют встроенные возможности периодических уведомлений, для которых требуется, чтобы служба выдавала XML. Дополнительные сведения содержатся в разделе [Определение настраиваемого интерфейса API с поддержкой периодических уведомлений].

Следующая функция настраиваемого API-интерфейса **OrderPizza** возвращает простой XML-документ как полезные данные ответа:

		exports.get = function(request, response) {
		  response.set('content-type', 'application/xml');
		  var xml = '<?xml version="1.0"?><PizzaOrderForm><PizzaOrderForm/>';
		  response.send(200, xml);
		};

Эта функция настраиваемого API вызывается с помощью запроса HTTP GET к следующей конечной точке:

		https://todolist.azure-mobile.net/api/orderpizza

### <a name="get-api-user"></a>Практическое руководство. Работа с пользователями и заголовками в настраиваемом интерфейсе API

В мобильных службах Azure можно использовать поставщика удостоверений для проверки подлинности пользователей. Дополнительные сведения см. в разделе [Приступая к работе с проверкой подлинности]. Когда пользователь с подтвержденной подлинностью запрашивает настраиваемый интерфейс API, мобильные службы используют [объект пользователя], чтобы предоставить сведения о пользователе для кода настраиваемого API. Доступ к [объекту пользователя] осуществляется через свойство пользователя [объекта запроса]. Свойство **userId** можно использовать для хранения и извлечения данных конкретного пользователя. 

Следующая функция настраиваемого API-интерфейса **OrderPizza** задает свойство владельца элемента на основе ИД пользователя (userId), прошедшего проверку подлинности:

		exports.post = function(request, response) {
			var userTable = request.service.tables.getTable('user');
			userTable.lookup(request.user.userId, {
				success: function(userRecord) {
					callPizzaAPI(userRecord, request.body, function(orderResult) {
						response.send(201, orderResult);
					});
				}
			});
		
		};

Эта функция настраиваемого API вызывается с помощью запроса HTTP POST к следующей конечной точке:

		https://<service>.azure-mobile.net/api/orderpizza

Доступ к конкретному заголовку HTTP можно также получить из [объекта запроса], как показано в следующем коде:

		exports.get = function(request, response) {    
    		var header = request.header('my-custom-header');
    		response.send(200, "You sent: " + header);
		};

Этот простой пример считывает настраиваемый заголовок с именем `my-custom-header`, а затем возвращает значение в ответе.

### <a name="api-routes"></a>Практическое руководство. Определение нескольких маршрутов настраиваемого интерфейса API

Мобильные службы позволяют определить несколько путей или маршрутов в настраиваемом интерфейсе API. Например, HTTP-запрос GET на следующий URL-адрес в настраиваемом интерфейсе API **калькулятор** будет вызывать функцию **add** или **subtract** соответственно: 

+ `https://<service>.azure-mobile.net/api/calculator/add`
+ `https://<service>.azure-mobile.net/api/calculator/sub`

Несколько маршрутов определяются путем экспорта функции **register**, которая передает объект **api** (подобно [объекту express в express.js]), используемый для регистрации маршрутов в конечной точке настраиваемого API. В следующем примере реализуются методы **add** и **sub** в настраиваемом интерфейсе API **калькулятор**: 

		exports.register = function (api) {
		    api.get('add', add);
		    api.get('sub', subtract);
		}
		
		function add(req, res) {
		    var result = parseInt(req.query.a) + parseInt(req.query.b);
		    res.send(200, { result: result });
		}
		
		function subtract(req, res) {
		    var result = parseInt(req.query.a) - parseInt(req.query.b);
		    res.send(200, { result: result });
		}

Объект **api**, переданный функции **register**, предоставляет функцию для каждого метода HTTP (**get**, **post**, **put**, **patch**, **delete**). Эти функции регистрируют маршрут к определенной функции для конкретного метода HTTP. Каждая функция принимает два параметра: первый - имя маршрута, а второй - функция, зарегистрированная для маршрута. 

Два маршрута в приведенном выше примере настраиваемого API могут вызываться HTTP-запросами GET (показаны с ответом) следующим образом:

+ `https://<service>.azure-mobile.net/api/calculator/add?a=1&b=2`

		{"result":3}

+ `https://<service>.azure-mobile.net/api/calculator/sub?a=3&b=5`

		{"result":-2}

## <a name="scheduler-scripts"></a>Планировщик заданий

Мобильные службы позволяют определить серверные скрипты, которые выполняются либо как задания по фиксированному расписанию, либо по требованию с портала управления. Запланированные задания можно использовать для выполнения периодических задач, таких как очистка данных таблицы и пакетная обработка. Дополнительные сведения см. в разделе [Расписание заданий].

Скрипты, зарегистрированные для запланированных заданий, имеют функцию "main" с тем же именем, что и запланированное задание. Поскольку запланированный скрипт не вызывается с помощью запроса HTTP, не существует контекста, который может быть передан средой выполнения сервера, и функция не принимает параметров. Как и для других видов скриптов, у вас могут быть функции подпрограмм и требование общих модулей. Дополнительные сведения содержатся в разделе [Система управления версиями, общий код и вспомогательные функции][Практическое руководство. Совместное использование кода с помощью системы управления версиями].

### <a name="scheduler-scripts"></a>Практическое руководство. Определение сценариев запланированных заданий

Серверные скрипты могут назначаться заданию, определенному в планировщике мобильных служб. Эти скрипты относятся к заданию и выполняются согласно расписания заданий. (Можно также использовать [портал управления][Портал управления] для выполнения заданий по запросу). Скрипт, определяющий запланированное задание, не имеет параметров, так как мобильные службы не передают ему никаких данных; он выполняется как регулярная функция JavaScript и непосредственно не взаимодействует с мобильными службами. 

Запланированные задания определяются одним из следующих способов: 

+ В [портале управления Azure][Портал управления] на вкладке **Скрипт** в планировщике:

	![3][3]

	Дополнительные сведения о том, как это сделать, см. в разделе [Планирование заданий сервера в мобильных службах]. 

+ В командной строке с помощью программы командной строки Azure. Дополнительные сведения см. в разделе [Использование программы командной строки].

>[AZURE.NOTE]Если система управления версиями включена, можно редактировать файлы скриптов запланированных заданий непосредственно во вложенной папке .\service\scheduler в репозитории git. Дополнительную информацию см. в разделах [Практическое руководство. Совместное использование кода с помощью системы управления версиями]

## <a name="shared-code"></a>Система управления версиями, общий код и вспомогательные функции

В следующих разделах показано, как использовать систему управления версиями для добавления собственных настраиваемых модулей node.js, общего кода и других стратегий повторного использования кода (разделы перечислены ниже).

+ [Обзор использования общего кода](#leverage-source-control)
+ [Практическое руководство. Загрузка модулей Node.js]
+ [Практическое руководство. Использование вспомогательных функций]
+ [Практическое руководство. Совместное использование кода с помощью системы управления версиями]
+ [Практическое руководство. Работа с параметрами приложения] 

### <a name="leverage-source-control"></a>Обзор использования общего кода

Так как Node.js используется мобильными службами на сервере, скрипты уже имеют доступ к встроенным модулям Node.js. Также можно использовать систему управления версиями для определения собственных модулей или добавления других модулей Node.js к службе.

Ниже представлены лишь некоторые полезные модули, которые могут использоваться в скрипте с помощью глобальной функции **require**:

+ **azure**: предоставляет функциональные возможности пакета SDK для Azure для Node.js. Дополнительные сведения см. в разделе [Azure SDK для Node.js][Пакет SDK для Azure для Node.js]. 
+ **crypto**: обеспечивает функциональные возможности шифрования OpenSSL. Дополнительные сведения см. в разделе [Документация по Node.js][API-интерфейс crypto].
+ **path**: содержит служебные программы для работы с путями файлов. Дополнительные сведения см. в разделе [Документация по Node.js][API-интерфейс path].
+ **querystring**: содержит служебные программы для работы со строками запросов. Дополнительные сведения см. в разделе [Документация по Node.js][API-интерфейс querystring].
+ **request**: отправляет HTTP-запросы к внешним службам REST, таким как Twitter и Facebook. Дополнительные сведения см. в разделе [Отправка запроса HTTP][Отправка запроса HTTP].
+ **sendgrid**: отправляет электронную почту с помощью службы электронной почты Sendgrid в Azure. Дополнительные сведения содержатся в разделе [Отправка электронной почты с мобильных служб с помощью SendGrid](/develop/mobile/tutorials/send-email-with-sendgrid/).
+ **url**: содержит служебные программы для анализа и разрешения URL-адресов. Дополнительные сведения см. в разделе [Документация по Node.js][API-интерфейс url].
+ **util**: содержит различные служебные программы, такие как функции форматирования строк и проверки типов объектов. Дополнительные сведения см. в разделе [Документация по Node.js][API-интерфейс util]. 
+ **zlib**: предоставляет функциональные возможности сжатия, например gzip и deflate. Дополнительные сведения см. в разделе [Документация по Node.js][API-интерфейс zlib]. 

### <a name="modules-helper-functions"></a>Практическое руководство. Использование модулей

Мобильные службы предоставляют набор модулей, загружаемых скриптами с помощью глобальной функции **require**. Например, скрипт может требовать функцию **request** для выполнения HTTP-запросов: 

	function update(item, user, request) { 
	    var httpRequest = require('request'); 
	    httpRequest('http://www.google.com', function(err, response, body) { 
	    	... 
	    }); 
	} 


### <a name="shared-code-source-control"></a>Практическое руководство. Совместное использование кода с помощью системы управления версиями

Система управления версиями с диспетчером пакетов Node.js (npm) позволяет контролировать, какие модули доступны для вашей мобильной службы. Это можно осуществить двумя путями:

+ Для модулей, опубликованных и установленных с помощью npm, объявите пакеты, которые должна устанавливать мобильная служба, в файле package.json. Таким образом служба всегда имеет доступ к последней версии необходимых пакетов. Файл package.json находится в каталоге  `.\service`. Дополнительные сведения содержатся в разделе [Поддержка package.json в мобильных службах Azure].

+ Для закрытых или настраиваемых модулей можно использовать npm, чтобы вручную установить модуль в каталог `.\service\node_modules` системы управления версиями. Пример того, как вручную загрузить модуль, см. в разделе [Использование общего кода и модулей Node.js в серверных скриптах].

	>[AZURE.NOTE]Если `node_modules` уже существует в иерархии каталогов, диспетчер пакетов NPM создает там подкаталог `\node-uuid`, а не создает новый каталог `node_modules` в репозитории. В этом случае удалите существующий каталог `node_modules`.

После применения файла package.json или настраиваемых модулей к репозиторию для мобильной службы, используйте функцию **require** для ссылки на модули по имени.   

>[AZURE.NOTE] Модули, которые вы указали в package.json или загрузили в свою мобильную службу, используются только в коде серверного скрипта. Эти модули не используются средой выполнения мобильных служб.

### <a name="helper-functions"></a>Практическое руководство. Использование вспомогательных функций

Помимо запрашивания модулей, отдельные серверные скрипты могут включать вспомогательные функции. Это функции, не зависимые от основной функции, которые можно использовать для разделения кода в скрипте. 

В следующем примере регистрируется скрипт таблицы для операции вставки, которая включает вспомогательную функцию **handleUnapprovedItem**:


	function insert(item, user, request) {
	    if (!item.approved) {
	        handleUnapprovedItem(item, user, request);
	    } else {
	        request.execute();
	    }
	}
	
	function handleUnapprovedItem(item, user, request) {
	    // Do something with the supplied item, user, or request objects.
	}
 
В скрипте вспомогательные функции должны быть объявлены после основной функции. В скрипте необходимо объявить все переменные. Необъявленные переменные приводят к ошибке.

Определенные один раз вспомогательные функции также могут совместно использоваться серверными скриптами. Чтобы функция могла совместно использоваться сценариями, функции необходимо экспортировать, а файл сценария должен существовать в каталоге `.\service\shared\`. Ниже приведен шаблон для экспорта общей функции в файл `.\services\shared\helpers.js`.

		exports.handleUnapprovedItem = function (tables, user, callback) {
		    
		    // Do something with the supplied tables or user objects and 
			// return a value to the callback function.
		};
 
Затем такую функцию можно использовать в скрипте операции с таблицей.

		function insert(item, user, request) {
		    var helper = require('../shared/helper');
		    helper.handleUnapprovedItem(tables, user, function(result) {
		        	
					// Do something based on the result.
		            request.execute();
		        }
		    }
		}

В этом примере необходимо передать общей функции [объект таблицы] и [объект пользователя]. Это связано с тем, что для общих скриптов недоступен глобальный [объект таблицы], а [объект пользователя] существует только в контексте запроса.

Файлы скриптов передаются в общий каталог с помощью [системы управления версиями][Практическое руководство. Совместное использование кода с помощью системы управления версиями] или с помощью [программы командной строки][Использование программы командной строки].

### <a name="app-settings"></a>Практическое руководство. Работа с параметрами приложения

Мобильные службы позволяют безопасно хранить значения как параметры приложения, к которым могут получить доступ серверные скрипты в среде выполнения.  При добавлении данных к параметрам приложения мобильных служб пары "имя/значение" сохраняются в зашифрованном виде и доступны в серверных скриптах без размещения их в файле скрипта. Дополнительные сведения см. в разделе [Параметры приложения].

В следующем примере настраиваемый интерфейс API использует предоставленный [объект службы] для извлечения значения параметра приложения.  

		exports.get = function(request, response) {
		
			// Get the MY_CUSTOM_SETTING value from app settings.
		    var customSetting = 
		        request.service.config.appSettings.my_custom_setting;
				
			// Do something and then send a response.

		}

Следующий код использует модуль настройки для получения значения маркера доступа к Twitter, который хранится в параметрах приложения, используемых в скрипте запланированных заданий:

		// Get the service configuration module.
		var config = require('mobileservice-config');

		// Get the stored Twitter consumer key and secret. 
		var consumerKey = config.twitterConsumerKey,
		    consumerSecret = config.twitterConsumerSecret
		// Get the Twitter access token from app settings.    
		var accessToken= config.appSettings.TWITTER_ACCESS_TOKEN,
		    accessTokenSecret = config.appSettings.TWITTER_ACCESS_TOKEN_SECRET;

Обратите внимание, что этот код также извлекает значения ключа потребителя Twitter, хранящиеся во вкладке **Удостоверение** на портале. Поскольку функция **config object** недоступна в скриптах операции с таблицами и запланированных заданий, для доступа к параметрам приложения необходимо использовать модуль конфигурации. Полный пример см. в разделе [Планирование серверных заданий в мобильных службах].

<h2><a name="command-prompt"></a>Использование программы командной строки</h2>

В мобильных службах можно создавать, изменять и удалять серверные скрипты с помощью средства командной строки Azure. Перед отправкой скриптов убедитесь, что используется следующая структура каталогов:

![4][4]

Обратите внимание, что эта структура каталогов такая же, как и репозиторий git при использовании системы управления версиями. 

При отправке файлов скриптов из программы командной строки необходимо сначала перейти в каталог `.\services\`. Следующая команда отправляет скрипт с именем `todoitem.insert.js` из подкаталога `table`:

		~$azure mobile script upload todolist table/todoitem.insert.js
		info:    Executing command mobile script upload
		info:    mobile script upload command OK

Следующая команда возвращает сведения о каждом файле скрипта, размещенном в вашей мобильной службе:

		~$ azure mobile script list todolist
		info:    Executing command mobile script list
		+ Retrieving script information
		info:    Table scripts
		data:    Name                       Size
		data:    -------------------------  ----
		data:    table/channels.insert      1980
		data:    table/TodoItem.insert      5504
		data:    table/TodoItem.read        64
		info:    Shared scripts
		data:    Name              Size
		data:    ----------------  ----
		data:    shared/helper.js  62
		data:    shared/uuid.js    7452
		info:    Scheduled job scripts
		data:    Job name    Script name           Status    Interval     Last run  Next run
		data:    ----------  --------------------  --------  -----------  --------  --------
		data:    getUpdates  scheduler/getUpdates  disabled  15 [minute]  N/A       N/A
		info:    Custom API scripts
		data:    Name                    Get          Put          Post         Patch        Delete
		data:    ----------------------  -----------  -----------  -----------  -----------  -----------
		data:    completeall             application  application  application  application  application
		data:    register_notifications  application  application  user         application  application
		info:    mobile script list command OK

Дополнительные сведения см. в разделе [Команды для управления мобильными службами Azure]. 

## <a name="working-with-tables"></a>Работа с таблицами

В этом разделе описаны стратегии для работы непосредственно с данными таблицы базы данных SQL, (подразделы перечислены ниже):

+ [Общие сведения о работе с таблицами](#overview-tables)
+ [Практическое руководство. Доступ к таблицам из сценариев]
+ [Практическое руководство. Выполнение массовой вставки]
+ [Практическое руководство. Сопоставление типов JSON с типами баз данных]
+ [Использование языка Transact-SQL для доступа к таблицам]

### <a name="overview-tables"></a>Общие сведения о работе с таблицами

Во многих сценариях использования мобильных служб необходимы серверные скрипты для доступа к таблицам в базе данных. К примеру, поскольку мобильные службы не сохраняют состояния между выполнениями скрипта, любые данные, которые должны сохраняться между выполнениями скрипта, должны храниться в таблицах. Можно также просмотреть записи в таблице разрешений или хранения данных аудита, а не просто записать их в журнал, где данные хранятся ограниченное время и не доступны программно. 

Мобильные службы имеют два способа доступа к таблицам: с помощью прокси [объект таблицы] или путем составления запросов Transact-SQL с помощью [объекта mssql]. [Объект таблицы] упрощает доступ к данным таблицы из кода серверного скрипта, но [объект mssql] поддерживает более сложные операции с данными и предоставляет наибольшую гибкость. 

### <a name="access-tables"></a>Практическое руководство. Доступ к таблицам из сценариев

Наиболее простой способ доступа к таблицам из скрипта - использовать [объект таблиц]. Функция **GetTable** возвращает экземпляр [объекта таблицы], который является прокси для доступа к запрашиваемой таблице. Затем можно вызвать функции прокси для доступа к данным и их изменения. 

Скрипты, зарегистрированные для операций с таблицей и запланированных заданий, могут получить доступ к [объекту таблиц] как глобальному объекту. Эта строка кода возвращает прокси для таблицы *TodoItems* из глобального [объекта tables]: 

		var todoItemsTable = tables.getTable('TodoItems');

Настраиваемые скрипты API могут получать доступ к [объекту таблицы] из <strong>свойства</strong> service предоставленного [объекта запроса]. Эта строка кода получает [объект таблиц] из запроса:

		var todoItemsTable = request.service.tables.getTable('TodoItem');

> [AZURE.NOTE] Общие функции не могут получить доступ к объекту **tables** напрямую. В случае общей функции необходимо передать этот объект функции.

После того как у вас есть [объект таблицы], можно вызвать одну или несколько функций операций с таблицей: вставки, обновления, удаления или чтения. Этот пример считывает разрешения пользователей из таблицы разрешений:

	function insert(item, user, request) {
		var permissionsTable = tables.getTable('permissions');
	
		permissionsTable
			.where({ userId: user.userId, permission: 'submit order'})
			.read({ success: checkPermissions });
			
		function checkPermissions(results) {
			if(results.length > 0) {
				// Permission record was found. Continue normal execution.
				request.execute();
			} else {
				console.log('User %s attempted to submit an order without permissions.', user.userId);
				request.respond(statusCodes.FORBIDDEN, 'You do not have permission to submit orders.');
			}
		}
	}

Следующий пример записывает данные аудита в таблицу **audit**:

	function update(item, user, request) {
		request.execute({ success: insertAuditEntry });
		
		function insertAuditEntry() {
			var auditTable = tables.getTable('audit');
			var audit = {
				record: 'checkins',
				recordId: item.id,
				timestamp: new Date(),
				values: JSON.stringify(item)
			};
			auditTable.insert(audit, {
				success: function() {
					// Write to the response now that all data operations are complete
					request.respond();
				}
			});
		}
	}

Еще один, последний, пример кода см. в разделе [Практическое руководство. Доступ к пользовательским параметрам][Практическое руководство. Добавление настраиваемых параметров].

### <a name="bulk-inserts"></a>Практическое руководство. Выполнение массовой вставки

При использовании цикла **for** или **while** для непосредственной вставки в таблицу большого количества элементов (например, 1000) могут возникнуть ограничения на число подключений SQL, которые приведут к сбою некоторых вставок. Ваш запрос может не завершиться или вернуть сообщение HTTP 500 "Внутренняя ошибка сервера".  Чтобы избежать этой проблемы, можно вставлять элементы партиями по 10 или около того. После вставки первой партии отправьте следующую и т. д.

С помощью следующего скрипта можно установить размер пакета записей для вставки в параллельном режиме. Рекомендуется устанавливать небольшое количество записей. Функция **insertItems** вызывает себя рекурсивно при завершении асинхронной пакетной вставки. Цикл for в конце вставляет по одной записи за раз и вызывает **insertComplete** в случае успеха и **errorHandler** при возникновении ошибки. **insertComplete** указывает, следует ли вызвать **insertItems** рекурсивно для следующего пакета, либо задание выполнено и следует выйти из скрипта.

		var todoTable = tables.getTable('TodoItem');
		var recordsToInsert = 1000;
		var batchSize = 10; 
		var totalCount = 0;
		var errorCount = 0; 
		
		function insertItems() {        
		    var batchCompletedCount = 0;  
		
		    var insertComplete = function() { 
		        batchCompletedCount++; 
		        totalCount++; 
		        if(batchCompletedCount === batchSize || totalCount === recordsToInsert) {                        
		            if(totalCount < recordsToInsert) {
		                // kick off the next batch 
		                insertItems(); 
		            } else { 
		                // or we are done, report the status of the job 
		                // to the log and don't do any more processing 
		                console.log("Insert complete. %d Records processed. There were %d errors.", totalCount, errorCount); 
		            } 
		        } 
		    }; 
		
		    var errorHandler = function(err) { 
		        errorCount++; 
		        console.warn("Ignoring insert failure as part of batch.", err); 
		        insertComplete(); 
		    };
		
		    for(var i = 0; i < batchSize; i++) { 
		        var item = { text: "This is item number: " + totalCount + i }; 
		        todoTable.insert(item, { 
		            success: insertComplete, 
		            error: errorHandler 
		        }); 
		    } 
		} 
		
		insertItems(); 


Полный пример кода и сопутствующие обсуждение можно найти в этой [записи блога](http://blogs.msdn.com/b/jpsanders/archive/2013/03/20/server-script-to-insert-table-items-in-windows-azure-mobile-services.aspx) Если вы используете этот код, можно адаптировать его к конкретной ситуации и тщательно протестировать.

### <a name="JSON-types"></a>Практическое руководство. Сопоставление типов JSON с типами баз данных

Коллекции типов данных на стороне клиента и в таблице базы данных мобильных служб различаются. Иногда их легко сопоставить друг с другом, иногда - нет. Мобильные службы выполняют ряд преобразований типа в сопоставлении:

- Для типов в клиентах, реализованных на разных языках, выполняется сериализация в JSON.
- Прежде чем появиться в серверном сценарии, представление JSON преобразуется в JavaScript.
- Типы данных JavaScript преобразуются в типы базы данных SQL при сохранении с использованием [объекта tables].

Преобразование из схемы клиента в JSON меняется в зависимости от платформы.  Клиенты магазина Windows и Windows Phone используют JSON.NET. Клиент Android использует библиотеку gson.  Клиент iOS использует класс NSJSONSerialization. Используется сериализация по умолчанию каждой из этих библиотек за исключением того, что объекты даты преобразуются в строки JSON, содержащие даты, закодированные с помощью ISO 8601.

При написании серверных скриптов, использующих функции [insert], [update], [read] или [delete], можно получить доступ к представлению данных в JavaScript. Мобильные службы используют функцию десериализации Node.js ([JSON.parse](http://es5.github.io/#x15.12)) для преобразования объектов JSON при передаче в объекты JavaScript. Однако мобильные службы выполняют преобразование для извлечения объектов **Дата** из строк ISO 8601.

Если вы используете [объект таблиц] или [объект mssql] или просто позволяете выполниться скриптам таблицы, десериализованные объекты JavaScript вставляются в базу данных SQL. В этом процессе свойства объекта сопоставляются с типами T-SQL:

<table border="1">
<tr>
<td>Свойство JavaScript</td>
<td>Тип T-SQL</td>
</tr><tr>
<td>Число</td>
<td>Float(53)</td>
</tr><tr>
<td>Логический</td>
<td>Bit</td>
</tr><tr>
<td>Дата</td>
<td>DateTimeOffset(3)</td>
</tr>
<tr>
<td>Строка</td>
<td>Nvarchar(max)</td>
</tr>
<tr>
<td>Буфер</td>
<td>Не поддерживается</td>
</tr><tr>
<td>Объект</td>
<td>Не поддерживается</td>
</tr><tr>
<td>Массив</td>
<td>Не поддерживается</td>
</tr><tr>
<td>Поток</td>
<td>Не поддерживается</td>
</tr>
</table> 

### <a name="TSQL"></a>Использование языка Transact-SQL для доступа к таблицам

Самый простой способ получить данные таблицы из серверных скриптов - использовать прокси [объект таблицы]. Тем не менее существуют более расширенные скрипты, которые не поддерживаются [объектом таблицы], такие как запросы соединения и другие сложные запросы и вызовы хранимых процедур. В этих случаях необходимо выполнить инструкции Transact-SQL непосредственно в отношении реляционной таблицы, пользуясь [объектом mssql]. Данный объект предоставляет следующие функции:

- **query**: выполняет запрос, заданный строкой TSQL; результаты возвращаются в обратном вызове **success** объекта **options**. Запрос может содержать параметры, если присутствует параметр *params*.
- **queryRaw**: похожа на  *query* за исключением того, что результирующий набор возвращается из запроса в формате raw (см. пример ниже).
- **open**: используется для подключения к базе данных мобильных служб, после чего объект подключения можно использовать для вызова операций базы данных, таких как транзакции.

Эти методы предоставляют более низкий уровень контроля обработки запросов.

+ [Практическое руководство. Выполнение статического запроса]
+ [Практическое руководство. Выполнение динамического запроса]
+ [Практическое руководство. Объединение реляционных таблиц]
+ [Практическое руководство. Выполнение запроса, который возвращает необработанные  *raw* результаты]
+ [Практическое руководство. Доступ для подключения к базе данных]	

#### <a name="static-query"></a>Практическое руководство. Выполнение статического запроса

Следующий запрос не содержит параметров и возвращает три записи из таблицы `statusupdate`. Набор строк представлен в стандартном формате JSON.

		mssql.query('select top 3 * from statusupdates', {
		    success: function(results) {
		        console.log(results);
		    },
            error: function(err) {
                console.log("error is: " + err);
			}
		});


#### <a name="dynamic-query"></a>Практическое руководство. Выполнение динамического параметризированного запроса

В следующем примере реализуется настраиваемая авторизация путем считывания разрешений для каждого пользователя из таблицы разрешений. При выполнении запроса местозаполнитель (?) заменяется предоставленным параметром.

		    var sql = "SELECT _id FROM permissions WHERE userId = ? AND permission = 'submit order'";
		    mssql.query(sql, [user.userId], {
		        success: function(results) {
		            if (results.length > 0) {
		                // Permission record was found. Continue normal execution. 
		                request.execute();
		            } else {
		                console.log('User %s attempted to submit an order without permissions.', user.userId);
		                request.respond(statusCodes.FORBIDDEN, 'You do not have permission to submit orders.');
		            }
		        },
            	error: function(err) {
                	console.log("error is: " + err);
				}	
		    });


#### <a name="joins"></a>Практическое руководство. Объединение реляционных таблиц

Можно объединить две таблицы с помощью метода **query** [объекта mssql] для передачи в коде TSQL, который реализует соединение. Предположим, у нас есть некоторые элементы в таблице **ToDoItem**, а каждый элемент в таблице имеет свойство **priority**, которое соответствует столбцу в таблице. Элемент может выглядеть следующим образом:

		{ text: 'Take out the trash', complete: false, priority: 1}

Также предположим, что у нас есть дополнительная таблица, которая называется **Приоритет**, со строками, содержащими **номер** приоритета и текстовое **описание**. Например, номер приоритета 1 может иметь описание "Критический", а объект выглядит следующим образом:

		{ number: 1, description: 'Critical'}

Теперь можно заменить номер **приоритет** в нашем элементе текстовым описанием номера приоритета. Это делается с помощью реляционного соединения двух таблиц.

		mssql.query('SELECT t.text, t.complete, p.description FROM ToDoItem as t INNER JOIN Priority as p ON t.priority = p.number', {
			success: function(results) {
				console.log(results);
			},
            error: function(err) {
                console.log("error is: " + err);
		});
	
Скрипт соединяет две таблицы и записывает результаты в журнал. Полученные объекты могут выглядеть следующим образом:

		{ text: 'Take out the trash', complete: false, description: 'Critical'}


#### <a name="raw"></a>Практическое руководство. Выполнение запроса, который возвращает необработанные  *raw* результаты

В этом примере запрос выполняется, как и раньше, но возвращает необработанный результирующий набор в построчном формате, который требуется проанализировать по строкам и по столбцам. Возможный сценарий этого - когда вам нужен доступ к типам данных, которые не поддерживаются мобильными службами. Этот код просто записывает выходные данные в журнал консоли, так что можно изучить формат raw.

		mssql.queryRaw('SELECT * FROM ToDoItem', {
		    success: function(results) {
		        console.log(results);
		    },
            error: function(err) {
                console.log("error is: " + err);
			}
		});

Здесь представлен результат выполнения данного запроса. Он содержит метаданные о каждом столбце в таблице, за которыми следует представление строк и столбцов.

		{ meta: 
		   [ { name: 'id',
		       size: 19,
		       nullable: false,
		       type: 'number',
		       sqlType: 'bigint identity' },
		     { name: 'text',
		       size: 0,
		       nullable: true,
		       type: 'text',
		       sqlType: 'nvarchar' },
		     { name: 'complete',
		       size: 1,
		       nullable: true,
		       type: 'boolean',
		       sqlType: 'bit' },
		     { name: 'priority',
		       size: 53,
		       nullable: true,
		       type: 'number',
		       sqlType: 'float' } ],
		  rows: 
		   [ [ 1, 'good idea for the future', null, 3 ],
		     [ 2, 'this is important but not so much', null, 2 ],
		     [ 3, 'fix this bug now', null, 0 ],
		     [ 4, 'we need to fix this one real soon now', null, 1 ],
		   ] }

#### <a name="connection"></a>Практическое руководство. Доступ для подключения к базе данных

Чтобы получить доступ для подключения к базе данных, можно использовать метод **open**. Одной из причин для этого может быть необходимость использовать транзакции базы данных.

Успешное выполнение **open** вызывает подключение к базе данных, которое передается в функцию **success** в качестве параметра. Можно вызвать любую из следующих функций объекта **connection**: *close*, *queryRaw*, *query*, *beginTransaction*, *commit* и *rollback*.

		    mssql.open({
		        success: function(connection) {
		            connection.query(//query to execute);
		        },
	            error: function(err) {
	                console.log("error is: " + err);
				}
		    });

## <a name="debugging"></a>Отладка и устранение неполадок

Основным способом отладки и устранения неполадок серверных скриптов является запись в журнал службы. По умолчанию мобильные службы записывают ошибки, возникающие во время выполнения скрипта службы, в журналы служб. Ваши скрипты также могут записывать в журналы. Запись в журналы - отличный способ отладить скрипты и проверить, что они ведут себя, как требуется.

### <a name="write-to-logs"></a>Практическое руководство. Запись выходных данных в журналы мобильной службы

Для записи в журналы используется глобальный [консольный объект]. Для записи предупреждений на уровне сведений используются функции **log** или **info**. Функции **warning** и **error** записывают соответствующие уровни, которые вызываются в журналах. 

> [AZURE.NOTE] Для просмотра журналов мобильной службы войдите на [портал управления](https://manage.windowsazure.com/), выберите мобильную службу и перейдите на вкладку **Журналы**.

Для форматирования сообщений с помощью параметров можно также использовать функции ведения журнала [консольного объекта]. В следующем примере в качестве параметра в строку сообщения подставляется объект JSON:

	function insert(item, user, request) {
	    console.log("Inserting item '%j' for user '%j'.", item, user);  
	    request.execute();
	}

Обратите внимание, что строка `%j` используется как заполнитель для объекта JSON и что параметры предоставляются последовательно. 

Чтобы избежать перегрузки журнала, следует удалить или отключить вызовы console.log(), которые не нужны для работы.

<!-- Anchors. -->
[Введение]: #intro
[Операции с таблицей]: #table-scripts
[Основные операции с таблицей]: #basic-table-ops
[Практическое руководство. Регистрация для операций с таблицами]: #register-table-scripts
[Практическое руководство. Определение скриптов таблицы]: #execute-operation
[Практическое руководство. Переопределение ответа по умолчанию]: #override-response
[Практическое руководство. Изменение операции]: #modify-operation
[Практическое руководство. Переопределение успеха и ошибки]: #override-success-error
[Практическое руководство. Переопределение успешного выполнения]: #override-success
[Практическое руководство. Переопределение обработки ошибок по умолчанию]: #override-error
[Практическое руководство. Доступ к таблицам из сценариев]: #access-tables
[Практическое руководство. Добавление настраиваемых параметров]: #access-headers
[Практическое руководство. Работа с пользователями]: #work-with-users
[Практическое руководство. Определение сценариев запланированных заданий]: #scheduler-scripts
[Практическое руководство. Уточнение возможности доступа к таблицам]: #authorize-tables
[Использование языка Transact-SQL для доступа к таблицам]: #TSQL
[Практическое руководство. Выполнение статического запроса]: #static-query
[Практическое руководство. Выполнение динамического запроса]: #dynamic-query
[Практическое руководство. Выполнение запроса, который возвращает необработанные  *raw* результаты]: #raw
[Практическое руководство. Доступ для подключения к базе данных]: #connection
[Практическое руководство. Объединение реляционных таблиц]: #joins
[Практическое руководство. Выполнение массовой вставки]: #bulk-inserts
[Практическое руководство. Сопоставление типов JSON с типами баз данных]: #JSON-types
[Практическое руководство. Загрузка модулей Node.js]: #modules-helper-functions
[Практическое руководство. Запись выходных данных в журналы мобильной службы]: #write-to-logs
[Контроль версий, общий код и вспомогательные функции]: #shared-code
[Использование программы командной строки]: #command-prompt
[Работа с таблицами]: #working-with-tables
[Привязка настраиваемого интерфейса API]: #custom-api
[Практическое руководство. Определение настраиваемого интерфейса API]: #define-custom-api
[Практическое руководство. Совместное использование кода с помощью системы управления версиями]: #shared-code-source-control
[Практическое руководство. Использование вспомогательных функций]: #helper-functions
[Отладка и устранение неполадок]: #debugging
[Практическое руководство. Реализация методов HTTP]: #handle-methods
[Практическое руководство. Работа с пользователями и заголовками в настраиваемом интерфейсе API]: #get-api-user
[Практическое руководство. Доступ к заголовкам запросов настраиваемого интерфейса API]: #get-api-headers
[Планировщик заданий]: #scheduler-scripts
[Практическое руководство. Определение нескольких маршрутов настраиваемого интерфейса API]: #api-routes
[Практическое руководство. Отправка и получение данных в формате XML]: #api-return-xml
[Практическое руководство. Работа с параметрами приложения]: #app-settings

[1]: ./media/mobile-services-how-to-use-server-scripts/1-mobile-insert-script-users.png
[2]: ./media/mobile-services-how-to-use-server-scripts/2-mobile-custom-api-script.png
[3]: ./media/mobile-services-how-to-use-server-scripts/3-mobile-schedule-job-script.png
[4]: ./media/mobile-services-how-to-use-server-scripts/4-mobile-source-local-cli.png

<!-- URLs. -->
[Справочник серверных скриптов мобильных служб]: http://msdn.microsoft.com/library/windowsazure/jj554226.aspx
[Использование программы командной строки]: /develop/mobile/tutorials/schedule-backend-tasks/
[Планирование заданий сервера в мобильных службах]: /develop/mobile/tutorials/schedule-backend-tasks/
[Планирование серверных заданий в мобильных службах]: /develop/mobile/tutorials/schedule-backend-tasks/
[Объект request]: http://msdn.microsoft.com/library/windowsazure/jj554218.aspx
[объект request]: http://msdn.microsoft.com/library/windowsazure/jj554218.aspx
[объекта запроса]: http://msdn.microsoft.com/library/windowsazure/jj554218.aspx
[Объект response]: http://msdn.microsoft.com/library/windowsazure/dn303373.aspx
[объект response]: http://msdn.microsoft.com/library/windowsazure/dn303373.aspx
[объекта ответа]: http://msdn.microsoft.com/library/windowsazure/dn303373.aspx
[объекту пользователя]: http://msdn.microsoft.com/library/windowsazure/jj554220.aspx
[объект пользователя]: http://msdn.microsoft.com/library/windowsazure/jj554220.aspx
[Объект User]: http://msdn.microsoft.com/library/windowsazure/jj554220.aspx
[объекта user]: http://msdn.microsoft.com/library/windowsazure/jj554220.aspx
[Объект push]: http://msdn.microsoft.com/library/windowsazure/jj554217.aspx
[Функция insert]: http://msdn.microsoft.com/library/windowsazure/jj554229.aspx
[insert]: http://msdn.microsoft.com/library/windowsazure/jj554229.aspx
[Функция update]: http://msdn.microsoft.com/library/windowsazure/jj554214.aspx
[Функция delete]: http://msdn.microsoft.com/library/windowsazure/jj554215.aspx
[Функция read]: http://msdn.microsoft.com/library/windowsazure/jj554224.aspx
[update]: http://msdn.microsoft.com/library/windowsazure/jj554214.aspx
[delete]: http://msdn.microsoft.com/library/windowsazure/jj554215.aspx
[read]: http://msdn.microsoft.com/library/windowsazure/jj554224.aspx
[Объект query]: http://msdn.microsoft.com/library/windowsazure/jj613353.aspx
[объект query]: http://msdn.microsoft.com/library/windowsazure/jj613353.aspx
[Объект apns]: http://msdn.microsoft.com/library/windowsazure/jj839711.aspx
[Объект mpns]: http://msdn.microsoft.com/library/windowsazure/jj871025.aspx
[Объект wns]: http://msdn.microsoft.com/library/windowsazure/jj860484.aspx
[Объект table]: http://msdn.microsoft.com/library/windowsazure/jj554210.aspx
[Объект таблиц]: http://msdn.microsoft.com/library/windowsazure/jj554210.aspx
[объект таблиц]: http://msdn.microsoft.com/library/windowsazure/jj554210.aspx
[объекта таблицы]: http://msdn.microsoft.com/library/windowsazure/jj554210.aspx
[объектом таблицы]: http://msdn.microsoft.com/library/windowsazure/jj554210.aspx
[Объект таблицы]: http://msdn.microsoft.com/library/windowsazure/jj554210.aspx

[объект таблицы]: http://msdn.microsoft.com/library/windowsazure/jj614364.aspx
[Объект tables]: http://msdn.microsoft.com/library/windowsazure/jj614364.aspx
[объекту таблиц]: http://msdn.microsoft.com/library/windowsazure/jj614364.aspx
[объекта tables]: http://msdn.microsoft.com/library/windowsazure/jj614364.aspx
[объекту таблицы]: http://msdn.microsoft.com/library/windowsazure/jj614364.aspx

[объектом mssql]: http://msdn.microsoft.com/library/windowsazure/jj554212.aspx
[Объект mssql]: http://msdn.microsoft.com/library/windowsazure/jj554212.aspx
[объекта mssql]: http://msdn.microsoft.com/library/windowsazure/jj554212.aspx
[объект mssql]: http://msdn.microsoft.com/library/windowsazure/jj554212.aspx
[Объект console]: http://msdn.microsoft.com/library/windowsazure/jj554209.aspx
[консольный объект]: http://msdn.microsoft.com/library/windowsazure/jj554209.aspx
[консольного объекта]: http://msdn.microsoft.com/library/windowsazure/jj554209.aspx

[Чтение и запись данных]: http://msdn.microsoft.com/library/windowsazure/jj631640.aspx
[Проверка данных]: http://msdn.microsoft.com/library/windowsazure/jj631638.aspx
[Изменение запроса]: http://msdn.microsoft.com/library/windowsazure/jj631635.aspx
[Изменение отклика]: http://msdn.microsoft.com/library/windowsazure/jj631631.aspx
[Изменение ответа]: http://msdn.microsoft.com/library/windowsazure/jj631631.aspx
[Портал управления]: https://manage.windowsazure.com/
[Планирование заданий]: http://msdn.microsoft.com/library/windowsazure/jj860528.aspx
[Расписание заданий]: http://msdn.microsoft.com/library/windowsazure/jj860528.aspx

[Проверка и изменение данных в мобильных службах с помощью серверных скриптов]: /develop/mobile/tutorials/validate-modify-and-augment-data-dotnet/
[Команды для управления мобильными службами Azure]: /documentation/articles/virtual-machines-command-line-tools/#Mobile_Scripts
[Принудительная отправка для Магазина Windows]: /develop/mobile/tutorials/get-started-with-push-dotnet/
[Принудительная отправка для Windows Phone]: /develop/mobile/tutorials/get-started-with-push-wp8/
[Принудительная отправка для iOS]: /develop/mobile/tutorials/get-started-with-push-ios/
[Принудительная отправка для Android]: /develop/mobile/tutorials/get-started-with-push-android/
[Пакет SDK для Azure для Node.js]: http://go.microsoft.com/fwlink/p/?LinkId=275539
[Отправка запроса HTTP]: http://msdn.microsoft.com/library/windowsazure/jj631641.aspx
[Отправка сообщений электронной почты из мобильных служб с помощью SendGrid]: /develop/mobile/tutorials/send-email-with-sendgrid/
[Приступая к работе с проверкой подлинности]: http://go.microsoft.com/fwlink/p/?LinkId=287177
[API-интерфейс crypto]: http://go.microsoft.com/fwlink/p/?LinkId=288802
[API-интерфейс path]: http://go.microsoft.com/fwlink/p/?LinkId=288803
[API-интерфейс querystring]: http://go.microsoft.com/fwlink/p/?LinkId=288804
[API-интерфейс url]: http://go.microsoft.com/fwlink/p/?LinkId=288805
[API-интерфейс util]: http://go.microsoft.com/fwlink/p/?LinkId=288806
[API-интерфейс zlib]: http://go.microsoft.com/fwlink/p/?LinkId=288807
[Настраиваемый интерфейс API]: http://msdn.microsoft.com/library/windowsazure/dn280974.aspx
[Вызов из клиента настраиваемого интерфейса API]: /develop/mobile/tutorials/call-custom-api-dotnet/#define-custom-api
[библиотеки express.js]: http://go.microsoft.com/fwlink/p/?LinkId=309046
[Определение настраиваемого интерфейса API с поддержкой периодических уведомлений]: /develop/mobile/tutorials/create-pull-notifications-dotnet/
[Объект express в express.js]: http://expressjs.com/api.html#express
[объекту express в express.js]: http://expressjs.com/api.html#express
[Хранение серверных скриптов в системе управления версиями]: /develop/mobile/tutorials/store-scripts-in-source-control/
[Использование общего кода и модулей Node.js в серверных скриптах]: /develop/mobile/tutorials/store-scripts-in-source-control/#use-npm
[Объект service]: http://msdn.microsoft.com/library/windowsazure/dn303371.aspx
[объект службы]: http://msdn.microsoft.com/library/windowsazure/dn303371.aspx

[Параметры приложения]: http://msdn.microsoft.com/library/dn529070.aspx
[модуль config]: http://msdn.microsoft.com/library/dn508125.aspx
[Поддержка package.json в мобильных службах Azure]: http://go.microsoft.com/fwlink/p/?LinkId=391036

<!--HONumber=47-->