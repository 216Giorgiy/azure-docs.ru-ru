<properties pageTitle="Work with a JavaScript backend mobile service" metaKeywords="server scripts, mobile devices, Azure, scheduler" description="Provides examples on how to define, register, and use server scripts in Azure Mobile Services." metaCanonical="" services="mobile-services" documentationCenter="Mobile" title="Work with server scripts in Mobile Services" authors="ricksal" solutions="" manager="" editor="" />

<tags ms.service="mobile-services" ms.workload="mobile" ms.tgt_pltfrm="mobile-multiple" ms.devlang="multiple" ms.topic="article" ms.date="01/01/1900" ms.author="ricksal" />

# Работа с серверной мобильной службой JavaScript

<div class="dev-center-tutorial-subselector"><a href="/ru-ru/documentation/articles/mobile-services-dotnet-backend-how-to-use/" title="Серверная часть .NET">Серверная часть .NET</a> | <a href="/ru-ru/documentation/articles/mobile-services-how-to-use-server-scripts/"  title="Серверная часть JavaScript" class="current">Серверная часть JavaScript</a></div>

Эта статья содержит подробную информацию о программировании серверной части на JavaScript в мобильных службах Azure и соответствующие примеры. Этот раздел содержит следующие параграфы:

-   [Введение][Введение]
-   [Операции с таблицами][Операции с таблицами]
    -   [Практическое руководство. Регистрация для операций с таблицами][Практическое руководство. Регистрация для операций с таблицами]
    -   [Практическое руководство. Переопределение ответа по умолчанию][Практическое руководство. Переопределение ответа по умолчанию]
    -   [Практическое руководство. Переопределение успешного выполнения][Практическое руководство. Переопределение успешного выполнения]
    -   [Практическое руководство. Переопределение обработки ошибок по умолчанию][Практическое руководство. Переопределение обработки ошибок по умолчанию]
    -   [Практическое руководство. Добавление пользовательских параметров][Практическое руководство. Добавление пользовательских параметров].
    -   [Практическое руководство. Работа с пользователями таблицы][Практическое руководство. Работа с пользователями таблицы]
-   [Настраиваемая служба API][Настраиваемая служба API]
    -   [Практическое руководство. Определение настраиваемого интерфейса API][Практическое руководство. Определение настраиваемого интерфейса API]
    -   [Практическое руководство. Реализация методов HTTP][Практическое руководство. Реализация методов HTTP]
    -   [Практическое руководство. Отправка и получение данных в формате XML][Практическое руководство. Отправка и получение данных в формате XML]
    -   [Практическое руководство. Работа с пользователями и заголовками в настраиваемом интерфейсе API][Практическое руководство. Работа с пользователями и заголовками в настраиваемом интерфейсе API]
    -   [Практическое руководство. Определение нескольких маршрутов настраиваемого интерфейса API][Практическое руководство. Определение нескольких маршрутов настраиваемого интерфейса API]
-   [Планировщик заданий][Планировщик заданий]
    -   [Практическое руководство. Определение сценариев запланированных заданий][Планировщик заданий]
-   [Система управления версиями, общий код и вспомогательные функции][Система управления версиями, общий код и вспомогательные функции]
    -   [Практическое руководство. Загрузка модулей Node.js][Практическое руководство. Загрузка модулей Node.js]
    -   [Практическое руководство. Использование вспомогательных функций][Практическое руководство. Использование вспомогательных функций]
    -   [Практическое руководство. Совместное использование кода с помощью системы управления версиями][Практическое руководство. Совместное использование кода с помощью системы управления версиями]
    -   [Практическое руководство. Работа с параметрами приложения][Практическое руководство. Работа с параметрами приложения]
-   [Использование программы командной строки][Использование программы командной строки]
-   [Работа с таблицами][Работа с таблицами]
    -   [Практическое руководство. Доступ к таблицам из сценариев][Практическое руководство. Доступ к таблицам из сценариев]
    -   [Практическое руководство. Выполнение массовой вставки][Практическое руководство. Выполнение массовой вставки]
    -   [Практическое руководство. Сопоставление типов JSON с типами баз данных][Практическое руководство. Сопоставление типов JSON с типами баз данных]
    -   [Использование языка Transact-SQL для доступа к таблицам][Использование языка Transact-SQL для доступа к таблицам]
-   [Отладка и устранение неполадок][Отладка и устранение неполадок]
    -   [Практическое руководство. Запись выходных данных в журналы мобильной службы][Практическое руководство. Запись выходных данных в журналы мобильной службы]

## <a name="intro"></a> Введение

В серверной мобильной службе JavaScript можно определить настраиваемую бизнес-логику в коде JavaScript, который хранится и выполняется на сервере. Этот серверный код сценария назначается одной из следующих функций сервера:

-   [Операции вставки, чтения, обновления или удаления данной таблицы][Операции с таблицами].
-   [Запланированные задания][Планировщик заданий].
-   [HTTP-методы, определенные в настраиваемом API-интерфейсе][Настраиваемая служба API].

Подпись основной функции в серверном скрипте зависит от контекста использования скрипта. Можно также определить общий код скрипта как модули nodes.js, которые являются общими для скриптов. Дополнительные сведения содержатся в разделе [Система управления версиями и общий код][Система управления версиями, общий код и вспомогательные функции]

Описания отдельных объектов и функций серверных скриптов см. в разделе [Справочник серверных скриптов мобильных служб][Справочник серверных скриптов мобильных служб]

## <a name="table-scripts"></a>Операции с таблицами

Скрипт операций с таблицами — серверный скрипт, который зарегистрирован на операцию вставки, чтения, обновления или удаления таблицы (*del*). Имя скрипта должно совпадать с типом операции, для которой он зарегистрирован. Для данной операции с таблицей может быть зарегистрирован только один скрипт. Сценарий выполняется при каждом вызове данной операции запросом REST, например при получении запроса POST для вставки элемента в таблицу. Мобильные службы не сохраняют состояния между выполнениями скриптов. Так как каждый раз, когда запускается скрипт, создается новый глобальный контекст, снова инициализируются все состояния переменных, определенных в скрипте. Если требуется сохранять состояние от одного запроса к другому, создайте в своей мобильной службе таблицу, а затем читайте и записывайте состояние в таблицу. Дополнительные сведения см. в разделе [Практическое руководство. Доступ к таблицам из сценариев][Практическое руководство. Доступ к таблицам из сценариев]

Скрипты операций с таблицами пишутся при необходимости применять настраиваемую бизнес-логику при выполнении операции. Например, в приведенном ниже сценарии отклоняются операции вставки, если в строке поля `text` больше десяти символов.

    function insert(item, user, request) {
        if (item.text.length > 10) {
            request.respond(statusCodes.BAD_REQUEST, 
                'Text length must be less than 10 characters');
        } else {
            request.execute();
        }
    }

Функция скрипта таблицы всегда принимает три аргумента.

-   Первый аргумент зависит от операции с таблицей.

    -   Для вставок и обновлений — это объект **item**, который является JSON-представлением строки, затронутой операцией. Это позволяет получить доступ к значениям столбцов по имени, например, *элемент.Владелец*, где *Владелец* является одним из имен в JSON-представлении.
    -   Для удаления это идентификатор записи, которую требуется удалить.
    -   Наконец, для чтения это [объект query][объект query], задающий набор строк для возврата.
-   Второй аргумент — всегда [объект user][объект user], который представляет пользователя, отправившего запрос.

-   Третьим аргументом всегда является [объект request][объект request], позволяющий контролировать выполнение запрошенной операции и ответ, который отправляется клиенту.

Ниже приведены канонические подписи функций main для операций с таблицей.

-   [Функция insert][Функция insert]: `function insert (item, user, request) { ... }`
-   [Функция update][Функция update]: `function update (item, user, request) { ... }`
-   [Функция delete][Функция delete]: `function del (id, user, request) { ... }`
-   [Функция read][Функция read]: `function read (query, user, request) { ... }`

> [WACOM.NOTE]Так как delete является зарезервированным ключевым словом в JavaScript, функция, зарегистрированная для операции удаления, должна иметь имя *del*.

Каждый серверный скрипт имеет функцию main и может иметь дополнительные вспомогательные функции. Даже если серверный скрипт был создан для определенной таблицы, он может также ссылаться на другие таблицы в той же базе данных. Можно также определить общие функции как модули, которые могут быть общими для скриптов. Дополнительные сведения содержатся в разделе [Система управления версиями и общий код][Система управления версиями, общий код и вспомогательные функции]

### <a name="register-table-scripts"></a>Практическое руководство. Регистрация сценариев таблиц

Серверные скрипты, которые зарегистрированы для операции с таблицей, можно определить одним из следующих способов:

-   На [портале управления Azure][портале управления Azure]. Доступ к скриптам для операций с таблицами осуществляется во вкладке **Скрипты** для данной таблицы. Ниже показан код по умолчанию, зарегистрированный для сценария вставки для таблицы `TodoItem`. Можно переопределить этот код с помощью собственной настраиваемой бизнес-логики.

    ![1][1]

    Чтобы узнать, как это сделать, см. раздел [Проверка и изменение данных в мобильных службах с помощью серверных скриптов][Проверка и изменение данных в мобильных службах с помощью серверных скриптов].

-   С помощью системы управления версиями. При включенной системе управления версиями просто создайте файл с именем *`<table>`*.*`<operation>`*.js во вложенной папке .\\service\\table репозитория git, где *`<table>`* — имя таблицы, а *`<operation>`* — операция с таблицей, которая регистрируется. Дополнительные сведения содержатся в разделе [Система управления версиями и общий код][Система управления версиями, общий код и вспомогательные функции]

-   В командной строке с помощью программы командной строки Azure. Дополнительные сведения см. в разделе [Использование программы командной строки][Использование программы командной строки].

Скрипт операции с таблицей должен вызывать по крайней мере одну из перечисленных ниже функций [объекта запроса][объект request], чтобы гарантировать получение ответа клиентом.

-   **Функцию execute**. Выполняется запрошенная операция, и возвращается стандартный ответ.

-   **Функцию respond**. Возвращается настраиваемый ответ.

<div class="dev-callout"><strong>Важно!</strong>
<p>Когда сценарий содержит путь кода, в котором не вызывается ни функция <b>execute</b>, ни функция <b>respond</b>, операция может перестать отвечать.</p></div>

Следующий скрипт вызывает функцию **execute** для завершения операции с данными, запрошенной клиентом:

    function insert(item, user, request) { 
        request.execute(); 
    }

В этом примере элемент вставляется в базу данных, а пользователю возвращается код соответствующего состояния.

При выполнения операции используется первый аргумент функции **execute** — `item`, объект [query][объект query] или значение `id`. Для операции вставки, обновления или запроса можно изменить значение item или query перед вызовом функции **execute**.

    function insert(item, user, request) { 
        item.scriptComment =
            'this was added by a script and will be saved to the database'; 
        request.execute(); 
    } 
    function update(item, user, request) { 
        item.scriptComment = 
            'this was added by a script and will be saved to the database'; 
        request.execute(); 
    } 
    function read(query, user, request) { 
        // Only return records for the current user         
        query.where({ userid: user.userId}); 
        request.execute(); 
    }

> [WACOM.NOTE]В сценарии удаления значение предоставляемой переменной userId не влияет на то, какая запись удаляется.

Дополнительные примеры см. в разделах [Чтение и запись данных][Чтение и запись данных], [Изменение запроса][Изменение запроса] и [Проверка данных][Проверка данных].

### <a name="override-response"></a>Практическое руководство. Переопределение ответа по умолчанию

Скрипт также можно использовать для реализации логики проверки, чтобы переопределить отклик по умолчанию. Если проверка не пройдена, просто вызовите функцию **respond** вместо функции **execute** и запишите ответ клиенту.

    function insert(item, user, request) {
        if (item.userId !== user.userId) {
            request.respond(statusCodes.FORBIDDEN, 
            'You may only insert records with your userId.');
        } else {
            request.execute();
        }
    }

В этом примере запрос отклоняется, если свойство `userId` вставляемого элемента не соответствует свойству `userId` [объекта user][объект user], который предоставляется для аутентифицированного клиента. В данном случае операции с базой данных (*insert*) не производится и клиенту возвращается ответ с настраиваемым сообщением об ошибке и кодом состояния HTTP 403. Дополнительные примеры см. в разделе [Изменение отклика][Изменение отклика].

### <a name="override-success"></a>Практическое руководство. Переопределение успешного выполнения

По умолчанию в операции с таблицей функция **execute** автоматически записывает ответы. Тем не менее в функцию "execute" можно передать два необязательных параметра, которые переопределят ее поведение в случае успеха или ошибки.

Передавая обработчик **success** при вызове функции "execute", можно изменить результаты запроса до их записи в ответ. В следующем примере вызывается функция `execute({ success: function(results) { ... })`. Она выполняет дополнительные действия после чтения данных из базы данных, но перед записью отклика.

    function read(query, user, request) {
        request.execute({
            success: function(results) {
                results.forEach(function(r) {
                    r.scriptComment = 
                    'this was added by a script after querying the database';
                });
                request.respond();
            }
        });
    }

При вводе обработчика **success** для функции **execute** необходимо также вызвать функцию **respond** как часть обработчика **success**, чтобы среда выполнения знала, что скрипт завершен и можно записать ответ. При вызове функции **respond** без передачи каких-либо аргументов, мобильные службы создают ответ по умолчанию.

> [WACOM.NOTE]Функцию **respond** без аргументов для вызова ответа по умолчанию можно вызвать только после функции **execute**.

### <a name="override-error"></a>Практическое руководство. Переопределение обработки ошибок по умолчанию

Функция **execute** может завершиться ошибкой в случае потери подключения к базе данных, недопустимого объекта или неверного запроса. По умолчанию при возникновении ошибки серверные скрипты записывают ошибку в журнал и записывают ошибочный результат в ответ. Поскольку мобильные службы обеспечивают обработку ошибок по умолчанию, нет необходимости обрабатывать ошибки, возникающие в службе.

Если вы хотите произвести определенное компенсирующее действие или использовать глобальный консольный объект для записи в журнал более подробных сведений, то обработку ошибок по умолчанию можно переопределить путем реализации явной обработки ошибок. Это можно сделать, указав обработчик **error** для функции **execute**:

    function update(item, user, request) { 
      request.execute({ 
        error: function(err) { 
          // Do some custom logging, then call respond. 
          request.respond(); 
        } 
      }); 
    }

Если имеется обработчик ошибок, мобильные службы возвращают клиенту результат ошибки при вызове функции **respond**.

При желании можно указать и обработчик **success**, и обработчик **error**.

### <a name="access-headers"></a>Практическое руководство. Доступ к настраиваемым параметрам

При отправке запроса к мобильной службе можно включить настраиваемые параметры в URI запроса, чтобы указать скриптам операций с таблицей, как обращаться с данным запросом. Измените скрипт для проверки параметра, чтобы определить путь обработки.

Например, следующий URI для запроса POST сообщает службе не допускать вставки нового элемента *TodoItem*, который имеет то же текстовое значение:

        https://todolist.azure-mobile.net/tables/TodoItem?duplicateText=false

Доступ к этим настраиваемым параметрам запроса осуществляется как к JSON-значениям из свойства **параметры** [объекта запроса][объект request]. Мобильные службы предоставляют объект **запрос** для любой функции, зарегистрированной для операции с таблицей. Следующий серверный сценарий для операции вставки проверяет значение параметра `duplicateText` перед операцией вставки.

        function insert(item, user, request) {
            var todoItemTable = tables.getTable('TodoItem');
            // Check the supplied custom parameter to see if
            // we should allow duplicate text items to be inserted.        
            if (request.parameters.duplicateText === 'false') {
                // Find all existing items with the same text
                // and that are not marked 'complete'. 
                todoItemTable.where({
                    text: item.text,
                    complete: false
                }).read({
                    success: insertItemIfNotComplete
                });
            } else {
                request.execute();
            }
            function insertItemIfNotComplete(existingItems) {
                if (existingItems.length > 0) {
                    request.respond(statusCodes.CONFLICT, 
                        "Duplicate items are not allowed.");
                } else {
                    // Insert the item as normal. 
                    request.execute();
                }
            }
        }

Обратите внимание, что в **insertItemIfNotComplete** функция **execute** [объекта запроса][объект request] вызывается для вставки элемента при отсутствии повторяющегося текста; в противном случае вызывается функция **respond**, которая уведомляет клиента о повторе.

Обратите внимание на синтаксис вызова функции **success** в приведенном выше коде.

                }).read({
                    success: insertItemIfNotComplete
                });

В JavaScript это компактная версия более длинного эквивалента:

        success: function(results) 
        { 
            insertItemIfNotComplete(results); 
        }

### <a name="work-with-users"></a>Практическое руководство. Работа с пользователями

В мобильных службах Azure можно использовать поставщика удостоверений для проверки подлинности пользователей. Дополнительные сведения см. в разделе [Приступая к работе с аутентификацией][Приступая к работе с аутентификацией]. Когда прошедший проверку пользователь вызывает операцию с таблицей, мобильные службы используют [объект пользователя][объект user] для предоставления сведений о пользователе зарегистрированной функции скрипта. Свойство **userId** можно использовать для хранения и извлечения данных конкретного пользователя. В следующем примере устанавливается свойство владельца элемента на основе ИД пользователя, прошедшего проверку (userId):

    function insert(item, user, request) {
        item.owner = user.userId;
        request.execute();
    }

В следующем примере добавляется дополнительный фильтр запроса на основе **userId** прошедшего проверку пользователя. Этот фильтр ограничивает результаты только теми элементами, которые принадлежат текущему пользователю:

    function read(query, user, request) {
        query.where({
            owner: user.userId
        });
        request.execute();
    }

## <a name="custom-api"></a>Настраиваемый интерфейс API

Настраиваемый интерфейс API является конечной точкой в мобильной службе, доступ к которой осуществляется с помощью стандартных методов HTTP: GET, POST, PUT, PATCH и DELETE. Для каждого метода HTTP, который поддерживает настраиваемый интерфейс API, можно определить отдельную функцию экспорта в одном и том же файле скрипта. Зарегистрированный скрипт вызывается при получении запроса настраиваемого интерфейса API с помощью данного метода. Дополнительные сведения см. в разделе [Настраиваемый интерфейс API][Настраиваемый интерфейс API].

При вызове функций настраиваемого интерфейса API средой выполнения мобильных служб поставляются и объект [запроса][объект request], и объект [ответа][ответа]. Эти объекты предоставляют функциональные возможности [библиотеки express.js][библиотеки express.js], которыми можно управлять с помощью скриптов. Приведенный ниже настраиваемый API-интерфейс с именем **hello** — это очень простой пример, который возвращает фразу *Hello, world!* в ответ на запрос POST.

        exports.post = function(request, response) {
            response.send(200, "{ message: 'Hello, world!' }");
        } 

Функция **send** [объекта ответа][ответа] возвращает нужный ответ клиенту. Этот код вызывается отправлением запроса POST по следующему URL-адресу:

        https://todolist.azure-mobile.net/api/hello  

Глобальное состояние сохраняется между выполнениями.

### <a name="define-custom-api"></a>Практическое руководство. Определение настраиваемого интерфейса API

Серверные скрипты, которые зарегистрированы для методов HTTP в конечной точке настраиваемого интерфейса API, можно определить одним из следующих способов:

-   На [портале управления Azure][портале управления Azure]. Скрипты настраиваемого интерфейса API создаются и изменяются во вкладке **API**. Код серверного скрипта находится во вкладке **Скрипты** данного настраиваемого интерфейса API. Ниже приведен сценарий, который вызывается по запросу POST к конечной точке `CompleteAll` настраиваемого API.

    ![2][2]

    На вкладке "Разрешения" назначаются разрешения на доступ для методов настраиваемого интерфейса API. Как был создан этот настраиваемый интерфейс API, см. в разделе [Вызов настраиваемого API из клиента][Вызов настраиваемого API из клиента]

-   С помощью системы управления версиями. При включенной системе управления версиями просто создайте файл с именем *`<custom_api>`*.js во вложенной папке .\\service\\api репозитория git, где *`<custom_api>`* — имя настраиваемого API-интерфейса, который регистрируется. Этот файл скрипта содержит функцию *exported* для каждого метода HTTP, предоставляемого настраиваемым API-интерфейсом. Разрешения определены в файле-компаньоне .json. Дополнительные сведения содержатся в разделе [Система управления версиями и общий код][Система управления версиями, общий код и вспомогательные функции]

-   В командной строке с помощью программы командной строки Azure. Дополнительные сведения см. в разделе [Использование программы командной строки][Использование программы командной строки].

### <a name="handle-methods"></a>Практическое руководство. Реализация методов HTTP

Настраиваемый интерфейс API может обрабатывать один или несколько методов HTTP: GET, POST, PUT, PATCH и DELETE. Для каждого HTTP-метода, который обрабатывает настраиваемый интерфейс API, определяется экспортированная функция. Один файл кода настраиваемого API может экспортировать одну или все из следующих функций:

        exports.get = function(request, response) { ... };
        exports.post = function(request, response) { ... };
        exports.patch = function(request, response) { ... };
        exports.put = function(request, response) { ... };
        exports.delete = function(request, response) { ... };

Конечную точку настраиваемого интерфейса API нельзя вызвать с помощью HTTP-метода, который не был реализован в серверном скрипте, и возвращается сообщение об ошибке 405 (недопустимый метод). Для каждого HTTP-метода поддержки можно назначить отдельные уровни разрешения.

### <a name="api-return-xml"></a>Практическое руководство. Отправка и получение данных в формате XML

Когда клиенты хранят и извлекают данные, мобильные службы используют JavaScript Object Notation (JSON) для представления данных в теле сообщения. Однако существуют скрипты, где вместо этого требуется использовать полезные данные формата XML. Например, приложения для магазина Windows имеют встроенные возможности периодических уведомлений, для которых требуется, чтобы служба выдавала XML. Дополнительные сведения содержатся в разделе [Определение настраиваемого интерфейса API с поддержкой периодических уведомлений][Определение настраиваемого интерфейса API с поддержкой периодических уведомлений].

Следующая функция настраиваемого API-интерфейса **OrderPizza** возвращает простой XML-документ как полезные данные ответа:

        exports.get = function(request, response) {
          response.set('content-type', 'application/xml');
          var xml = '<?xml version="1.0"?><PizzaOrderForm><PizzaOrderForm/>';
          response.send(200, xml);
        };

Эта функция настраиваемого API вызывается с помощью запроса HTTP GET к следующей конечной точке:

        https://todolist.azure-mobile.net/api/orderpizza

### <a name="get-api-user"></a>Практическое руководство. Работа с пользователями и заголовками в настраиваемом интерфейсе API

В мобильных службах Azure можно использовать поставщика удостоверений для проверки подлинности пользователей. Дополнительные сведения см. в разделе [Приступая к работе с аутентификацией][Приступая к работе с аутентификацией]. Когда пользователь с подтвержденной подлинностью запрашивает настраиваемый интерфейс API, мобильные службы используют [объект пользователя][объект user], чтобы предоставить сведения о пользователе для кода настраиваемого API. Доступ к [объекту пользователя][объект user] осуществляется через свойство пользователя [объекта запроса][объект request]. Свойство **userId** можно использовать для хранения и извлечения данных конкретного пользователя.

Следующая функция настраиваемого API-интерфейса **OrderPizza** задает свойство владельца элемента на основе ИД пользователя (userId), прошедшего проверку подлинности:

        exports.post = function(request, response) {
            var userTable = request.service.tables.getTable('user');
            userTable.lookup(request.user.userId, {
                success: function(userRecord) {
                    callPizzaAPI(userRecord, request.body, function(orderResult) {
                        response.send(201, orderResult);
                    });
                }
            });
        
        };

Эта функция настраиваемого API вызывается с помощью запроса HTTP POST к следующей конечной точке:

        https://<service>.azure-mobile.net/api/orderpizza

Доступ к конкретному заголовку HTTP можно также получить из [объекта запроса][объект request], как показано в следующем коде:

        exports.get = function(request, response) {    
            var header = request.header('my-custom-header');
            response.send(200, "You sent: " + header);
        };

Этот простой пример считывает настраиваемый заголовок с именем `my-custom-header`, а затем возвращает значение в ответе.

### <a name="api-routes"></a>Практическое руководство. Определение нескольких маршрутов настраиваемого интерфейса API

Мобильные службы позволяют определить несколько путей или маршрутов в настраиваемом интерфейсе API. Например, HTTP-запрос GET на следующий URL-адрес в настраиваемом интерфейсе API **калькулятор** будет вызывать функцию **add** или **subtract** соответственно:

-   `https://<service>.azure-mobile.net/api/calculator/add`
-   `https://<service>.azure-mobile.net/api/calculator/sub`

Несколько маршрутов определяются путем экспорта функции **register**, которая передает объект **api** (подобно [объекту express в express.js][объекту express в express.js]), используемый для регистрации маршрутов в конечной точке настраиваемого API. В следующем примере реализуются методы **add** и **sub** в настраиваемом интерфейсе API **калькулятор**:

        exports.register = function (api) {
            api.get('add', add);
            api.get('sub', subtract);
        }
        
        function add(req, res) {
            var result = parseInt(req.query.a) + parseInt(req.query.b);
            res.send(200, { result: result });
        }
        
        function subtract(req, res) {
            var result = parseInt(req.query.a) - parseInt(req.query.b);
            res.send(200, { result: result });
        }

Объект **api**, переданный функции **register**, предоставляет функцию для каждого метода HTTP (**get**, **post**, **put**, **patch**, **delete**). Эти функции регистрируют маршрут к определенной функции для конкретного метода HTTP. Каждая функция принимает два параметра: первый — имя маршрута, а второй — функция, зарегистрированная для маршрута.

Два маршрута в приведенном выше примере настраиваемого API могут вызываться HTTP-запросами GET (показаны с ответом) следующим образом:

-   `https://<service>.azure-mobile.net/api/calculator/add?a=1&b=2`

        {"result":3}

-   `https://<service>.azure-mobile.net/api/calculator/sub?a=3&b=5`

        {"result":-2}

## <a name="scheduler-scripts"></a>Планировщик заданий

Мобильные службы позволяют определить серверные скрипты, которые выполняются либо как задания по фиксированному расписанию, либо по требованию с портала управления. Запланированные задания можно использовать для выполнения периодических задач, таких как очистка данных таблицы и пакетная обработка. Дополнительные сведения см. в разделе [Расписание заданий][Расписание заданий].

Скрипты, зарегистрированные для запланированных заданий, имеют функцию "main" с тем же именем, что и запланированное задание. Поскольку запланированный скрипт не вызывается с помощью запроса HTTP, не существует контекста, который может быть передан средой выполнения сервера, и функция не принимает параметров. Как и для других видов скриптов, у вас могут быть функции подпрограмм и требование общих модулей. Дополнительные сведения содержатся в разделе [Система управления версиями, общий код и вспомогательные функции][Система управления версиями, общий код и вспомогательные функции].

### <a name="scheduler-scripts"></a>Практическое руководство. Определение сценариев запланированных заданий

Серверные скрипты могут назначаться заданию, определенному в планировщике мобильных служб. Эти скрипты относятся к заданию и выполняются согласно расписания заданий. (Можно также использовать [портал управления][портале управления Azure] для выполнения заданий по запросу). Скрипт, определяющий запланированное задание, не имеет параметров, так как мобильные службы не передают ему никаких данных; он выполняется как регулярная функция JavaScript и непосредственно не взаимодействует с мобильными службами.

Запланированные задания определяются одним из следующих способов:

-   На [портале управления Azure][портале управления Azure] на вкладке **Сценарий** в планировщике:

    ![3][3]

    Дополнительные сведения о том, как это сделать, см. в разделе [Планирование заданий сервера в мобильных службах][Планирование заданий сервера в мобильных службах].

-   В командной строке с помощью программы командной строки Azure. Дополнительные сведения см. в разделе [Использование программы командной строки][Использование программы командной строки].

> [WACOM.NOTE]Если система управления версиями включена, файлы сценариев запланированных заданий можно редактировать непосредственно во вложенной папке .\\service\\scheduler в репозитории Git. Дополнительные сведения см. в разделе [Практическое руководство. Совместное использование кода с помощью системы управления версиями][Практическое руководство. Совместное использование кода с помощью системы управления версиями]

## <a name="shared-code"></a>Система управления версиями, общий код и вспомогательные функции

Так как Node.js используется мобильными службами на сервере, скрипты уже имеют доступ к встроенным модулям Node.js. Также можно использовать систему управления версиями для определения собственных модулей или добавления других модулей Node.js к службе.

Ниже представлены лишь некоторые полезные модули, которые могут использоваться в скрипте с помощью глобальной функции **require**:

-   **azure**: предоставляет функциональные возможности пакета SDK для Azure для Node.js. Дополнительную информацию см. в разделе [Azure SDK for Node.js][Azure SDK for Node.js] (Пакет SDK для Azure для Node.js).
-   **crypto**: обеспечивает функциональные возможности шифрования OpenSSL. Дополнительные сведения см. в [Документации по Node.js][Документации по Node.js].
-   **path**: содержит служебные программы для работы с путями файлов. Дополнительные сведения см. в [Документации по Node.js][4].
-   **querystring**: содержит служебные программы для работы со строками запросов. Дополнительные сведения см. в [Документации по Node.js][5].
-   **request**: отправляет HTTP-запросы к внешним службам REST, таким как Twitter и Facebook. Дополнительные сведения см. в разделе [Отправка запроса HTTP][Отправка запроса HTTP].
-   **sendgrid**: отправляет электронную почту с помощью службы электронной почты Sendgrid в Azure. Дополнительные сведения содержатся в разделе [Отправка электронной почты с мобильных служб с помощью SendGrid][Отправка электронной почты с мобильных служб с помощью SendGrid].
-   **url**: содержит служебные программы для анализа и разрешения URL-адресов. Дополнительные сведения см. в [Документации по Node.js][6].
-   **util**: содержит различные служебные программы, такие как функции форматирования строк и проверки типов объектов. Дополнительные сведения см. в [Документации по Node.js][7].
-   **zlib**: предоставляет функциональные возможности сжатия, например gzip и deflate. Дополнительные сведения см. в [Документации по Node.js][8].

### <a name="modules-helper-functions"></a>Практическое руководство. Использование модулей

Мобильные службы предоставляют набор модулей, загружаемых скриптами с помощью глобальной функции **require**. Например, скрипт может требовать функцию **request** для выполнения HTTP-запросов:

    function update(item, user, request) { 
        var httpRequest = require('request'); 
        httpRequest('http://www.google.com', function(err, response, body) { 
            ... 
        }); 
    } 

### <a name="shared-code-source-control"></a>Практическое руководство. Совместное использование кода с помощью системы управления версиями

Система управления версиями с диспетчером пакетов Node.js (npm) позволяет контролировать, какие модули доступны для вашей мобильной службы. Это можно осуществить двумя путями:

-   Для модулей, опубликованных и установленных с помощью npm, объявите пакеты, которые должна устанавливать мобильная служба, в файле package.json. Таким образом служба всегда имеет доступ к последней версии необходимых пакетов. Файл package.json находится в каталоге `.\service`. Дополнительные сведения содержатся в разделе [Поддержка package.json в мобильных службах Azure][Поддержка package.json в мобильных службах Azure].

-   Для закрытых или настраиваемых модулей можно использовать npm, чтобы вручную установить модуль в каталог `.\service\node_modules` системы управления версиями. Пример того, как вручную загрузить модуль, см. в разделе [Использование общего кода и модулей Node.js в серверных скриптах][Использование общего кода и модулей Node.js в серверных скриптах].

    > [WACOM.NOTE]Если в иерархии каталогов уже есть каталог `node_modules`, NPM создает там подкаталог `\node-uuid`, а не создает новый каталог `node_modules` в репозитории. В этом случае удалите существующий каталог `node_modules`.

После применения файла package.json или настраиваемых модулей к репозиторию для мобильной службы, используйте функцию **require** для ссылки на модули по имени.

> [WACOM.NOTE] Модули, указанные в файле package.json или переданные в мобильную службу, используются только в коде серверного сценария. Эти модули не используются средой выполнения мобильных служб.

### <a name="helper-functions"></a>Практическое руководство. Использование вспомогательных функций

Помимо запрашивания модулей, отдельные серверные скрипты могут включать вспомогательные функции. Это функции, не зависимые от основной функции, которые можно использовать для разделения кода в скрипте.

В следующем примере регистрируется скрипт таблицы для операции вставки, которая включает вспомогательную функцию **handleUnapprovedItem**:

    function insert(item, user, request) {
        if (!item.approved) {
            handleUnapprovedItem(item, user, request);
        } else {
            request.execute();
        }
    }
    function handleUnapprovedItem(item, user, request) {
        // Do something with the supplied item, user, or request objects.
    }

В скрипте вспомогательные функции должны быть объявлены после основной функции. В скрипте необходимо объявить все переменные. Необъявленные переменные приводят к ошибке.

Определенные один раз вспомогательные функции также могут совместно использоваться серверными скриптами. Чтобы функция могла совместно использоваться сценариями, функции необходимо экспортировать, а файл сценария должен существовать в каталоге `.\service\shared\`. Ниже приведен шаблон для экспорта общей функции в файл `.\services\shared\helpers.js`.

        exports.handleUnapprovedItem = function (tables, user, callback) {
            
            // Do something with the supplied tables or user objects and 
            // return a value to the callback function.
        };

Затем такую функцию можно использовать в скрипте операции с таблицей.

        function insert(item, user, request) {
            var helper = require('../shared/helper');
            helper.handleUnapprovedItem(tables, user, function(result) {
                    
                    // Do something based on the result.
                    request.execute();
                }
            }
        }

В этом примере необходимо передать общей функции [объект таблицы][объект таблицы] и [объект пользователя][объект user]. Это связано с тем, что для общих скриптов недоступен глобальный [объект таблицы][объект таблицы], а [объект пользователя][объект user] существует только в контексте запроса.

Файлы скриптов передаются в общий каталог с помощью [системы управления версиями][Практическое руководство. Совместное использование кода с помощью системы управления версиями] или с помощью [средства командной строки][Использование программы командной строки].

### <a name="app-settings"></a>Практическое руководство. Работа с параметрами приложения

Мобильные службы позволяют безопасно хранить значения как параметры приложения, к которым могут получить доступ серверные скрипты в среде выполнения. При добавлении данных к параметрам приложения мобильных служб пары "имя/значение" сохраняются в зашифрованном виде и доступны в серверных скриптах без размещения их в файле скрипта. Дополнительные сведения см. в разделе [Параметры приложения][Параметры приложения].

В следующем примере настраиваемый интерфейс API использует предоставленный [объект службы][объект службы] для извлечения значения параметра приложения.

        exports.get = function(request, response) {
        
            // Get the MY_CUSTOM_SETTING value from app settings.
            var customSetting = 
                request.service.config.appSettings.my_custom_setting;
                
            // Do something and then send a response.
        }

Следующий код использует модуль настройки для получения значения маркера доступа к Twitter, который хранится в параметрах приложения, используемых в скрипте запланированных заданий:

        // Get the service configuration module.
        var config = require('mobileservice-config');
        // Get the stored Twitter consumer key and secret. 
        var consumerKey = config.twitterConsumerKey,
            consumerSecret = config.twitterConsumerSecret
        // Get the Twitter access token from app settings.    
        var accessToken= config.appSettings.TWITTER_ACCESS_TOKEN,
            accessTokenSecret = config.appSettings.TWITTER_ACCESS_TOKEN_SECRET;

Обратите внимание, что этот код также извлекает значения ключа потребителя Twitter, хранящиеся во вкладке **Удостоверение** на портале. Поскольку функция **config object** недоступна в скриптах операции с таблицами и запланированных заданий, для доступа к параметрам приложения необходимо использовать модуль конфигурации. Полный пример см. в разделе [Планирование серверных заданий в мобильных службах][Планирование заданий сервера в мобильных службах].

## <a name="command-prompt"></a>Использование программы командной строки

В мобильных службах можно создавать, изменять и удалять серверные скрипты с помощью средства командной строки Azure. Перед отправкой скриптов убедитесь, что используется следующая структура каталогов:

![4][9]

Обратите внимание, что эта структура каталогов такая же, как и репозиторий git при использовании системы управления версиями.

При отправке файлов сценария из программы командной строки необходимо сначала перейти в каталог `.\services\`. Следующая команда отправляет сценарий с именем `todoitem.insert.js` из подкаталога `table`:

        ~$azure mobile script upload todolist table/todoitem.insert.js
        info:    Executing command mobile script upload
        info:    mobile script upload command OK

Следующая команда возвращает сведения о каждом файле скрипта, размещенном в вашей мобильной службе:

        ~$ azure mobile script list todolist
        info:    Executing command mobile script list
        + Retrieving script information
        info:    Table scripts
        data:    Name                       Size
        data:    -------------------------  ----
        data:    table/channels.insert      1980
        data:    table/TodoItem.insert      5504
        data:    table/TodoItem.read        64
        info:    Shared scripts
        data:    Name              Size
        data:    ----------------  ----
        data:    shared/helper.js  62
        data:    shared/uuid.js    7452
        info:    Scheduled job scripts
        data:    Job name    Script name           Status    Interval     Last run  Next run
        data:    ----------  --------------------  --------  -----------  --------  --------
        data:    getUpdates  scheduler/getUpdates  disabled  15 [minute]  N/A       N/A
        info:    Custom API scripts
        data:    Name                    Get          Put          Post         Patch        Delete
        data:    ----------------------  -----------  -----------  -----------  -----------  -----------
        data:    completeall             application  application  application  application  application
        data:    register_notifications  application  application  user         application  application
        info:    mobile script list command OK

Дополнительные сведения см. в разделе [Команды для управления мобильными службами Azure][Команды для управления мобильными службами Azure].

## <a name="working-with-tables"></a>Работа с таблицами

Для многих скриптов мобильных служб необходимы серверные скрипты для доступа к таблицам в базе данных. К примеру, поскольку мобильные службы не сохраняют состояния между выполнениями скрипта, любые данные, которые должны сохраняться между выполнениями скрипта, должны храниться в таблицах. Можно также просмотреть записи в таблице разрешений или хранения данных аудита, а не просто записать их в журнал, где данные хранятся ограниченное время и не доступны программно.

Мобильные службы имеют два способа доступа к таблицам: с помощью прокси [объект таблицы][10] или путем составления запросов Transact-SQL с помощью [объекта mssql][объекта mssql]. [Объект таблицы][10] упрощает доступ к данным таблицы из кода серверного скрипта, но [объект mssql][объекта mssql] поддерживает более сложные операции с данными и предоставляет наибольшую гибкость.

### <a name="access-tables"></a>Практическое руководство. Доступ к таблицам из сценариев

Наиболее простой способ доступа к таблицам из скрипта — использовать [объект таблиц][объект таблицы]. Функция **GetTable** возвращает экземпляр [объекта таблицы][10], который является прокси для доступа к запрашиваемой таблице. Затем можно вызвать функции прокси для доступа к данным и их изменения.

Скрипты, зарегистрированные для операций с таблицей и запланированных заданий, могут получить доступ к [объекту таблиц][объект таблицы] как глобальному объекту. Эта строка кода возвращает прокси для таблицы *TodoItems* из глобального [объекта таблиц][объект таблицы]:

        var todoItemsTable = tables.getTable('TodoItems');

Скрипты настраиваемого API могут получить доступ к [объекту таблиц][объект таблицы] из свойства **службы** предоставляемого [объекта запроса][объект request]. Эта строка кода получает [объект таблиц][объект таблицы] из запроса:

        var todoItemsTable = request.service.tables.getTable('TodoItem');

<div class="dev-callout"><strong>Примечание</strong>
<p>Общие функции не могут получить доступ к объекту <strong>tables</strong> напрямую. В случае общей функции необходимо передать этот объект функции.</p></div>

После передачи [объекта table][10] можно вызвать одну или несколько функций операций с таблицами: вставки, обновления, удаления или чтения. Этот пример считывает разрешения пользователей из таблицы разрешений:

    function insert(item, user, request) {
        var permissionsTable = tables.getTable('permissions');
        permissionsTable
            .where({ userId: user.userId, permission: 'submit order'})
            .read({ success: checkPermissions });
            
        function checkPermissions(results) {
            if(results.length > 0) {
                // Permission record was found. Continue normal execution.
                request.execute();
            } else {
                console.log('User %s attempted to submit an order without permissions.', user.userId);
                request.respond(statusCodes.FORBIDDEN, 'You do not have permission to submit orders.');
            }
        }
    }

Следующий пример записывает данные аудита в таблицу **audit**:

    function update(item, user, request) {
        request.execute({ success: insertAuditEntry });
        
        function insertAuditEntry() {
            var auditTable = tables.getTable('audit');
            var audit = {
                record: 'checkins',
                recordId: item.id,
                timestamp: new Date(),
                values: JSON.stringify(item)
            };
            auditTable.insert(audit, {
                success: function() {
                    // Write to the response now that all data operations are complete
                    request.respond();
                }
            });
        }
    }

Еще один, последний, пример кода см. в разделе [Практическое руководство. Доступ к настраиваемым параметрам][Практическое руководство. Добавление пользовательских параметров].

### <a name="bulk-inserts"></a>Практическое руководство. Выполнение массовой вставки

При использовании цикла **for** или **while** для непосредственной вставки в таблицу большого количества элементов (например, 1000) могут возникнуть ограничения на число подключений SQL, которые приведут к сбою некоторых вставок. Ваш запрос может не завершиться или вернуть сообщение HTTP 500 "Внутренняя ошибка сервера". Чтобы избежать этой проблемы, можно вставлять элементы партиями по 10 или около того. После вставки первой партии отправьте следующую и т. д.

С помощью следующего скрипта можно установить размер пакета записей для вставки в параллельном режиме. Рекомендуется устанавливать небольшое количество записей. Функция **insertItems** вызывает себя рекурсивно при завершении асинхронной пакетной вставки. Цикл "for" в конце вставляет одну запись за один раз и вызывает **insertComplete** в случае успеха и **errorHandler** при ошибке. Функция **insertComplete** контролирует, будет ли **insertItems** вызываться рекурсивно для следующего пакета или задание выполнено и следует выйти из скрипта.

        var todoTable = tables.getTable('TodoItem');
        var recordsToInsert = 1000;
        var batchSize = 10; 
        var totalCount = 0;
        var errorCount = 0; 
        
        function insertItems() {        
            var batchCompletedCount = 0;  
        
            var insertComplete = function() { 
                batchCompletedCount++; 
                totalCount++; 
                if(batchCompletedCount === batchSize || totalCount === recordsToInsert) {                        
                    if(totalCount < recordsToInsert) {
                        // kick off the next batch 
                        insertItems(); 
                    } else { 
                        // or we are done, report the status of the job 
                        // to the log and don't do any more processing 
                        console.log("Insert complete. %d Records processed. There were %d errors.", totalCount, errorCount); 
                    } 
                } 
            }; 
        
            var errorHandler = function(err) { 
                errorCount++; 
                console.warn("Ignoring insert failure as part of batch.", err); 
                insertComplete(); 
            };
        
            for(var i = 0; i < batchSize; i++) { 
                var item = { text: "This is item number: " + totalCount + i }; 
                todoTable.insert(item, { 
                    success: insertComplete, 
                    error: errorHandler 
                }); 
            } 
        } 
        
        insertItems(); 

Полный пример кода и сопутствующие обсуждение можно найти в этом [блоге][блоге] Если вы используете этот код, можно адаптировать его к конкретной ситуации и тщательно протестировать.

### <a name="JSON-types"></a>Практическое руководство. Сопоставление типов JSON с типами баз данных

Коллекции типов данных на стороне клиента и в таблице базы данных мобильных служб различаются. Иногда их легко сопоставить друг с другом, иногда — нет. Мобильные службы выполняют ряд преобразований типа в сопоставлении:

-   Для типов в клиентах, реализованных на разных языках, выполняется сериализация в JSON.
-   Прежде чем появиться в серверном сценарии, представление JSON преобразуется в JavaScript.
-   Типы данных JavaScript при сохранении с помощью [объекта tables][объект таблицы] преобразуются в типы базы данных SQL.

Преобразование из схемы клиента в JSON меняется в зависимости от платформы. Клиенты магазина Windows и Windows Phone используют JSON.NET. Клиент Android использует библиотеку gson. Клиент iOS использует класс NSJSONSerialization. Используется сериализация по умолчанию каждой из этих библиотек за исключением того, что объекты даты преобразуются в строки JSON, содержащие даты, закодированные с помощью ISO 8601.

При написании серверных скриптов, использующих функции [insert][Функция insert], [update][Функция update], [read][Функция read] или [delete][Функция delete], можно получить доступ к представлению данных в JavaScript. Мобильные службы используют функцию десериализации Node.js ([JSON.parse][JSON.parse]) для преобразования объектов JSON при передаче в объекты JavaScript. Однако мобильные службы выполняют преобразование для извлечения объектов **Дата** из строк ISO 8601.

Если вы используете [объект таблиц][объект таблицы] или [объект mssql][объекта mssql] или просто позволяете выполниться скриптам таблицы, десериализованные объекты JavaScript вставляются в базу данных SQL. В этом процессе свойства объекта сопоставляются с типами T-SQL:
<table border="1">
<tr>
<td>Свойство JavaScript</td>
<td>Тип T-SQL</td>
</tr><tr>
<td>Число</td>
<td>Float(53)</td>
</tr><tr>
<td>Логический</td>
<td>Bit</td>
</tr><tr>
<td>Дата</td>
<td>DateTimeOffset(3)</td>
</tr>
<tr>
<td>Строка</td>
<td>Nvarchar(max)</td>
</tr>
<tr>
<td>Буфер</td>
<td>Не поддерживается</td>
</tr><tr>
<td>Объект</td>
<td>Не поддерживается</td>
</tr><tr>
<td>Массив</td>
<td>Не поддерживается</td>
</tr><tr>
<td>Поток</td>
<td>Не поддерживается</td>
</tr>
</table>

### <a name="TSQL"></a>Использование языка Transact-SQL для доступа к таблицам

Самый простой способ получить данные таблицы из серверных скриптов — использовать прокси [объект таблицы][10]. Тем не менее существуют более расширенные скрипты, которые не поддерживаются [объектом таблицы][10], такие как запросы соединения и другие сложные запросы и вызовы хранимых процедур. В этих случаях необходимо выполнить инструкции Transact-SQL непосредственно в отношении реляционной таблицы, пользуясь [объектом mssql][объекта mssql]. Данный объект предоставляет следующие функции:

-   **query**: выполняет запрос, заданный строкой TSQL; результаты возвращаются в обратном вызове **success** объекта **options**. Запрос может содержать параметры, если присутствует параметр *params*.
-   **queryRaw**: похожа на функцию *query* за исключением того, что результирующий набор возвращается после запроса в «построчном» формате (см. пример ниже).
-   **open**: используется для подключения к базе данных мобильных служб, после чего объект подключения можно использовать для вызова операций с базой данных, таких как транзакции.

Эти методы предоставляют более низкий уровень контроля обработки запросов.

-   [Практическое руководство. Выполнение статического запроса][Практическое руководство. Выполнение статического запроса]
-   [Практическое руководство. Выполнение динамического запроса][Практическое руководство. Выполнение динамического запроса]
-   [Практическое руководство. Объединение реляционных таблиц][Практическое руководство. Объединение реляционных таблиц]
-   [Практическое руководство. Выполнение запроса, который возвращает *необработанные* результаты][Практическое руководство. Выполнение запроса, который возвращает *необработанные* результаты]
-   [Практическое руководство. Доступ для подключения к базе данных][Практическое руководство. Доступ для подключения к базе данных]

#### <a name="static-query"></a>Практическое руководство. Выполнение статического запроса

Следующий запрос не содержит параметров и возвращает три записи из таблицы `statusupdate`. Набор строк представлен в стандартном формате JSON.

        mssql.query('select top 3 * from statusupdates', {
            success: function(results) {
                console.log(results);
            },
            error: function(err) {
                console.log("error is: " + err);
            }
        });

#### <a name="dynamic-query"></a>Практическое руководство. Выполнение динамического параметризированного запроса

В следующем примере реализуется настраиваемая авторизация путем считывания из таблицы разрешения для каждого пользователя. При выполнении запроса местозаполнитель (?) заменяется предоставленным параметром.

            var sql = "SELECT _id FROM permissions WHERE userId = ? AND permission = 'submit order'";
            mssql.query(sql, [user.userId], {
                success: function(results) {
                    if (results.length > 0) {
                        // Permission record was found. Continue normal execution. 
                        request.execute();
                    } else {
                        console.log('User %s attempted to submit an order without permissions.', user.userId);
                        request.respond(statusCodes.FORBIDDEN, 'You do not have permission to submit orders.');
                    }
                },
                error: function(err) {
                    console.log("error is: " + err);
                }   
            });

#### <a name="joins"></a>Практическое руководство. Объединение реляционных таблиц

Можно объединить две таблицы с помощью метода **query** [объекта mssql][объекта mssql] для передачи в коде TSQL, который реализует соединение. Предположим, у нас есть некоторые элементы в таблице **ToDoItem**, а каждый элемент в таблице имеет свойство **priority**, которое соответствует столбцу в таблице. Элемент может выглядеть следующим образом:

        { text: 'Take out the trash', complete: false, priority: 1}

Также предположим, что у нас есть дополнительная таблица, которая называется **Приоритет**, со строками, содержащими **номер** приоритета и текстовое **описание**. Например, номер приоритета 1 может иметь описание "Критический", а объект выглядит следующим образом:

        { number: 1, description: 'Critical'}

Теперь можно заменить номер **приоритет** в нашем элементе текстовым описанием номера приоритета. Это делается с помощью реляционного соединения двух таблиц.

        mssql.query('SELECT t.text, t.complete, p.description FROM ToDoItem as t INNER JOIN Priority as p ON t.priority = p.number', {
            success: function(results) {
                console.log(results);
            },
            error: function(err) {
                console.log("error is: " + err);
        });

Скрипт соединяет две таблицы и записывает результаты в журнал. Полученные объекты могут выглядеть следующим образом:

        { text: 'Take out the trash', complete: false, description: 'Critical'}

#### <a name="raw"></a>Практическое руководство. Выполнение запроса, который возвращает *необработанные* результаты

В этом примере запрос выполняется, как и раньше, но возвращает результирующий набор в формате "raw", который требуется проанализировать по строкам и по столбцам. Возможный сценарий этого — если вам нужен доступ к типам данных, которые не поддерживают мобильные службы. Этот код просто записывает выходные данные в журнал консоли, так что можно изучить формат raw.

        mssql.queryRaw('SELECT * FROM ToDoItem', {
            success: function(results) {
                console.log(results);
            },
            error: function(err) {
                console.log("error is: " + err);
            }
        });

Здесь представлен результат выполнения данного запроса. Он содержит метаданные о каждом столбце в таблице, за которыми следует представление строк и столбцов.

        { meta: 
           [ { name: 'id',
               size: 19,
               nullable: false,
               type: 'number',
               sqlType: 'bigint identity' },
             { name: 'text',
               size: 0,
               nullable: true,
               type: 'text',
               sqlType: 'nvarchar' },
             { name: 'complete',
               size: 1,
               nullable: true,
               type: 'boolean',
               sqlType: 'bit' },
             { name: 'priority',
               size: 53,
               nullable: true,
               type: 'number',
               sqlType: 'float' } ],
          rows: 
           [ [ 1, 'good idea for the future', null, 3 ],
             [ 2, 'this is important but not so much', null, 2 ],
             [ 3, 'fix this bug now', null, 0 ],
             [ 4, 'we need to fix this one real soon now', null, 1 ],
           ] }

#### <a name="connection"></a>Практическое руководство. Доступ для подключения к базе данных

Чтобы получить доступ для подключения к базе данных, можно использовать метод **open**. Одной из причин для этого может быть необходимость использовать транзакции базы данных.

Успешное выполнение **open** вызывает подключение к базе данных, которое передается в функцию **success** в качестве параметра. Можно вызвать любую из следующих функций объекта **connection**: *close*, *queryRaw*, *query*, *beginTransaction*, *commit* и *rollback*.

            mssql.open({
                success: function(connection) {
                    connection.query(//query to execute);
                },
                error: function(err) {
                    console.log("error is: " + err);
                }
            });

## <a name="debugging"></a>Отладка и устранение неполадок

Основной способ отладки и устранения неполадок серверных скриптов является запись в журнал службы. По умолчанию мобильные службы записывают ошибки, возникающие во время выполнения скрипта службы, в журналы служб. Ваши скрипты также могут записывать в журналы. Запись в журналы — отличный способ отладить скрипты и проверить, что они ведут себя, как требуется.

### <a name="write-to-logs"></a>Практическое руководство. Запись выходных данных в журналы мобильной службы

Для записи в журналы используется глобальный [консольный объект][консольный объект]. Для записи предупреждений на уровне сведений используются функции **log** или **info**. Функции **warning** и **error** записывают соответствующие уровни, которые вызываются в журналах.

<div class="dev-callout"><strong>Примечание.</strong>
<p>Для просмотра журналов мобильной службы войдите на <a href="https://manage.windowsazure.com/">портал управления</a>, выберите мобильную службу и перейдите на вкладку <strong>Журналы</strong>.</p></div>

Для форматирования сообщений с помощью параметров можно также использовать функции ведения журнала [консольного объекта][консольный объект]. В следующем примере в качестве параметра в строку сообщения подставляется объект JSON:

    function insert(item, user, request) {
        console.log("Inserting item '%j' for user '%j'.", item, user);  
        request.execute();
    }

Обратите внимание, что строка `%j` используется как заполнитель для объекта JSON и что параметры предоставляются последовательно.

Чтобы избежать перегрузки журнала, следует удалить или отключить вызовы console.log(), которые не нужны для работы.



  [Введение]: #intro
  [Операции с таблицами]: #table-scripts
  [Практическое руководство. Регистрация для операций с таблицами]: #register-table-scripts
  [Практическое руководство. Переопределение ответа по умолчанию]: #override-response
  [Практическое руководство. Переопределение успешного выполнения]: #override-success
  [Практическое руководство. Переопределение обработки ошибок по умолчанию]: #override-error
  [Практическое руководство. Добавление пользовательских параметров]: #access-headers
  [Практическое руководство. Работа с пользователями таблицы]: #work-with-users
  [Настраиваемая служба API]: #custom-api
  [Практическое руководство. Определение настраиваемого интерфейса API]: #define-custom-api
  [Практическое руководство. Реализация методов HTTP]: #handle-methods
  [Практическое руководство. Отправка и получение данных в формате XML]: #api-return-xml
  [Практическое руководство. Работа с пользователями и заголовками в настраиваемом интерфейсе API]: #get-api-user
  [Практическое руководство. Определение нескольких маршрутов настраиваемого интерфейса API]: #api-routes
  [Планировщик заданий]: #scheduler-scripts
  [Система управления версиями, общий код и вспомогательные функции]: #shared-code
  [Практическое руководство. Загрузка модулей Node.js]: #modules-helper-functions
  [Практическое руководство. Использование вспомогательных функций]: #helper-functions
  [Практическое руководство. Совместное использование кода с помощью системы управления версиями]: #shared-code-source-control
  [Практическое руководство. Работа с параметрами приложения]: #app-settings
  [Использование программы командной строки]: #command-prompt
  [Работа с таблицами]: #working-with-tables
  [Практическое руководство. Доступ к таблицам из сценариев]: #access-tables
  [Практическое руководство. Выполнение массовой вставки]: #bulk-inserts
  [Практическое руководство. Сопоставление типов JSON с типами баз данных]: #JSON-types
  [Использование языка Transact-SQL для доступа к таблицам]: #TSQL
  [Отладка и устранение неполадок]: #debugging
  [Практическое руководство. Запись выходных данных в журналы мобильной службы]: #write-to-logs
  [Справочник серверных скриптов мобильных служб]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554226.aspx
  [объект query]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj613353.aspx
  [объект user]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554220.aspx
  [объект request]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554218.aspx
  [Функция insert]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554229.aspx
  [Функция update]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554214.aspx
  [Функция delete]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554215.aspx
  [Функция read]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554224.aspx
  [портале управления Azure]: https://manage.windowsazure.com/
  [1]: ./media/mobile-services-how-to-use-server-scripts/1-mobile-insert-script-users.png
  [Проверка и изменение данных в мобильных службах с помощью серверных скриптов]: /ru-ru/develop/mobile/tutorials/validate-modify-and-augment-data-dotnet/
  [Чтение и запись данных]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj631640.aspx
  [Изменение запроса]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj631635.aspx
  [Проверка данных]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj631638.aspx
  [Изменение отклика]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj631631.aspx
  [Приступая к работе с аутентификацией]: http://go.microsoft.com/fwlink/p/?LinkId=287177
  [Настраиваемый интерфейс API]: http://msdn.microsoft.com/ru-ru/library/windowsazure/dn280974.aspx
  [ответа]: http://msdn.microsoft.com/ru-ru/library/windowsazure/dn303373.aspx
  [библиотеки express.js]: http://go.microsoft.com/fwlink/p/?LinkId=309046
  [2]: ./media/mobile-services-how-to-use-server-scripts/2-mobile-custom-api-script.png
  [Вызов настраиваемого API из клиента]: /ru-ru/develop/mobile/tutorials/call-custom-api-dotnet/#define-custom-api
  [Определение настраиваемого интерфейса API с поддержкой периодических уведомлений]: /ru-ru/develop/mobile/tutorials/create-pull-notifications-dotnet/
  [объекту express в express.js]: http://expressjs.com/api.html#express
  [Расписание заданий]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj860528.aspx
  [3]: ./media/mobile-services-how-to-use-server-scripts/3-mobile-schedule-job-script.png
  [Планирование заданий сервера в мобильных службах]: /ru-ru/develop/mobile/tutorials/schedule-backend-tasks/
  [Azure SDK for Node.js]: http://go.microsoft.com/fwlink/p/?LinkId=275539
  [Документации по Node.js]: http://go.microsoft.com/fwlink/p/?LinkId=288802
  [4]: http://go.microsoft.com/fwlink/p/?LinkId=288803
  [5]: http://go.microsoft.com/fwlink/p/?LinkId=288804
  [Отправка запроса HTTP]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj631641.aspx
  [Отправка электронной почты с мобильных служб с помощью SendGrid]: /ru-ru/develop/mobile/tutorials/send-email-with-sendgrid/
  [6]: http://go.microsoft.com/fwlink/p/?LinkId=288805
  [7]: http://go.microsoft.com/fwlink/p/?LinkId=288806
  [8]: http://go.microsoft.com/fwlink/p/?LinkId=288807
  [Поддержка package.json в мобильных службах Azure]: http://go.microsoft.com/fwlink/p/?LinkId=391036
  [Использование общего кода и модулей Node.js в серверных скриптах]: /ru-ru/develop/mobile/tutorials/store-scripts-in-source-control/#use-npm
  [объект таблицы]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj614364.aspx
  [Параметры приложения]: http://msdn.microsoft.com/ru-ru/library/dn529070.aspx
  [объект службы]: http://msdn.microsoft.com/ru-ru/library/windowsazure/dn303371.aspx
  [9]: ./media/mobile-services-how-to-use-server-scripts/4-mobile-source-local-cli.png
  [Команды для управления мобильными службами Azure]: /ru-ru/manage/linux/other-resources/command-line-tools/#Commands_to_manage_mobile_services/#Mobile_Scripts
  [10]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554210.aspx
  [объекта mssql]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554212.aspx
  [блоге]: http://blogs.msdn.com/b/jpsanders/archive/2013/03/20/server-script-to-insert-table-items-in-windows-azure-mobile-services.aspx
  [JSON.parse]: http://es5.github.io/#x15.12
  [Практическое руководство. Выполнение статического запроса]: #static-query
  [Практическое руководство. Выполнение динамического запроса]: #dynamic-query
  [Практическое руководство. Объединение реляционных таблиц]: #joins
  [Практическое руководство. Доступ для подключения к базе данных]: #connection
  [консольный объект]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554209.aspx
