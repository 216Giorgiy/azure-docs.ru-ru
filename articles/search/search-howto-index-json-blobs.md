---
title: Индексация больших двоичных объектов JSON из индексатора больших двоичных объектов Azure для полнотекстового поиска в службе "Поиск Azure"
description: Сканирование больших двоичных объектов Azure JSON для поиска текстового содержимого с помощью индексатора больших двоичных объектов службы поиска Azure. Индексаторы автоматизируют прием данных из выбранных источников, таких как хранилище BLOB-объектов Azure.
ms.date: 12/21/2018
author: HeidiSteen
manager: cgronlun
ms.author: heidist
services: search
ms.service: search
ms.devlang: rest-api
ms.topic: conceptual
ms.custom: seodec2018
ms.openlocfilehash: 6df8d9a5c1ca1e587834ea08f73b3dd9498f8537
ms.sourcegitcommit: 7862449050a220133e5316f0030a259b1c6e3004
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/22/2018
ms.locfileid: "53753155"
---
# <a name="indexing-json-blobs-with-azure-search-blob-indexer"></a>Индексирование BLOB-объектов JSON с помощью индексатора BLOB-объектов службы поиска Azure
В этой статье показано, как настроить индексатор больших двоичных объектов в службе поиска Azure для извлечения структурированного содержимого из больших двоичных объектов JSON в хранилище BLOB-объектов Azure.

Вы можете использовать [портал](#json-indexer-portal), [REST API](#json-indexer-rest) или [пакет SDK для .NET](#json-indexer-dotnet) для индексирования содержимого JSON. Все подходы объединяют документы JSON, расположенные в контейнере больших двоичных объектов в учетной записи службы хранилища Azure. Рекомендации по отправке документов JSON с других платформ, отличных от Azure, см. в разделе [Импорт данных в службе поиска Azure](search-what-is-data-import.md).

Большие двоичные объекты JSON в хранилище BLOB-объектов Azure обычно представляют собой отдельный документ JSON или массив JSON. Индексатор больших двоичных объектов в службе поиска Azure может анализировать любую конструкцию в зависимости от значения параметра **parsingMode** в запросе.

<a name="json-indexer-portal"></a>

## <a name="use-the-portal"></a>Использование портала

Самый простой способ индексирования документов JSON — использование мастера на [портале Azure](https://portal.azure.com/). Путем синтаксического анализа метаданных в контейнере больших двоичных объектов Azure мастер [**импорта данных**](search-import-data-portal.md) может создать индекс по умолчанию, сопоставить поля источника с целевыми полями индекса и загрузить индекс в рамках одной операции. В зависимости от размера и сложности исходных данных можно создать рабочий индекс полнотекстового поиска за считаные минуты.

### <a name="1---prepare-source-data"></a>1. Подготовка исходных данных

У вас должна быть учетная запись хранилища Azure с хранилищем больших двоичных объектов и контейнер документов JSON. Если вы не знакомы с этими задачами, просмотрите требования в разделе "Настройка службы BLOB-объектов Azure и загрузка примера данных" в [кратком руководстве по когнитивному поиску](cognitive-search-quickstart-blob.md#set-up-azure-blob-service-and-load-sample-data).

### <a name="2---start-import-data-wizard"></a>2. Запуск мастера импорта данных

Вы можете [запустить мастер](search-import-data-portal.md) из командной строки на странице службы поиска Azure или щелкнуть **Добавить поиск Azure** в разделе **Служба BLOB-объектов** в левой панели навигации учетной записи хранения.

### <a name="3---set-the-data-source"></a>3. Настройка источника данных

На странице **Источник данных** должен быть указан источник **Хранилище BLOB-объектов Azure** со следующими спецификациями.

+ Для параметра **Извлекаемые данные** выберите *Контент и метаданные*. При выборе этого варианта мастер может определить схему индекса и сопоставить поля для импорта.
   
+ Для параметра **Режим анализа** должно быть указано *JSON* или *Массив JSON*. 

  *JSON* определяет каждый большой двоичный объект как один поисковой документ, отображающийся как независимый элемент в результатах поиска. 

  *Массив JSON* предназначен для BLOB-объектов, состоящих из нескольких элементов, где каждый элемент должен быть определен как отдельный поисковой документ. Если большие двоичные объекты являются составными и вы не выберете *Массив JSON*, весь большой двоичный объект будет обработан как один документ.
   
+ Для параметра **Контейнер хранилища** укажите свою учетную запись хранения и контейнер или строку подключения, которая разрешается к контейнеру. Строки подключения можно получить на странице портала службы BLOB-объектов.

   ![Определение источника данных BLOB-объектов](media/search-howto-index-json/import-wizard-json-data-source.png)

### <a name="4---skip-the-add-cognitive-search-page-in-the-wizard"></a>4. Пропуск страницы "Добавление когнитивного поиска" в мастере

Добавление когнитивных навыков не требуется для импорта документов JSON. Если у вас нет необходимости [включать API-интерфейсы Cognitive Services и преобразования](cognitive-search-concept-intro.md) в конвейер индексирования, пропустите этот шаг.

Чтобы пропустить шаг, щелкните следующую страницу: **Настройка целевого индекса**.

### <a name="5---set-index-attributes"></a>5. Настройка атрибутов индекса

На странице **Индекс** вы увидите список полей с типом данных и ряд флажков для настройки атрибутов индекса. Мастер может создать индекс по умолчанию на основе метаданных и путем выборки исходных данных. 

Значения по умолчанию часто дают приемлемое решение: выбор поля (приведение в виде строки) в качестве ключа или идентификатора документа для уникальной идентификации каждого документа, а также полей, которые являются хорошими кандидатами для полнотекстового поиска и извлечения в результирующий набор. Для больших двоичных объектов поле `content` является лучшим кандидатом для содержимого, поддерживающего поиск.

Вы можете принять значения по умолчанию или просмотреть описание [атрибутов индекса](https://docs.microsoft.com/rest/api/searchservice/create-index#bkmk_indexAttrib) и [языковых анализаторов](https://docs.microsoft.com/rest/api/searchservice/language-support), чтобы переопределить или дополнить начальные значения. 

Просмотрите выбранные параметры. После запуска мастера создаются структуры физических данных и вы не сможете изменить эти поля без удаления и повторного создания всех объектов.

   ![Определение индексов больших двоичных объектов](media/search-howto-index-json/import-wizard-json-index.png)

### <a name="6---create-indexer"></a>6. Создание индексатора

Полностью настроенный мастер создает три разных объекта в службе поиска. Объект источника данных и объект индекса сохраняются как именованные ресурсы в службе поиска Azure. На последнем шаге создает объект индексатора. Если присвоить индексатору имя, он будет существовать как отдельный ресурс, который можно запланировать и контролировать независимо от индекса и объекта источника данных, созданных в том же процессе мастера.

Если вы не знакомы с индексаторами, *индексатор* — это ресурс в службе поиска Azure, сканирующий внешний источник данных для поиска содержимого. Выходные данные мастера **импорта данных** — это индексатор, который сканирует источник данных JSON, извлекает содержимое для поиска и импортирует его в индекс поиска Azure.

   ![Определение индексатора больших двоичных объектов](media/search-howto-index-json/import-wizard-json-indexer.png)

Нажмите кнопку **OK** для запуска мастера и создания всех объектов. Индексирование начинается немедленно.

Вы можете отслеживать импорт данных на страницах портала. Уведомления о ходе выполнения указывают состояние индексирования и количество передаваемых документов. По завершении индексирования можно использовать [Проводник поиска](search-explorer.md), чтобы отправить запрос индексу.

<a name="json-indexer-rest"></a>

## <a name="use-rest-apis"></a>Использование REST API

Индексирование больших двоичных объектов JSON подобно извлечению стандартного документа в рабочем процессе, включающем три этапа, общем для всех индексаторов в службе поиска Azure: создание источника данных, создание индекса, создание индексатора.

Для индексирования JSON на основе кода можно использовать REST API с API-интерфейсами для [индексаторов](https://docs.microsoft.com/rest/api/searchservice/create-indexer), [источников данных](https://docs.microsoft.com/rest/api/searchservice/create-data-source) и [индексов](https://docs.microsoft.com/rest/api/searchservice/create-index). В отличие от мастера портала подход с использованием кода требует наличие индекса, готового принять документы JSON при отправке запроса **Создать индексатор**.

Большие двоичные объекты JSON в хранилище BLOB-объектов Azure обычно представляют собой отдельный документ JSON или массив JSON. Индексатор больших двоичных объектов в службе поиска Azure может анализировать любую конструкцию в зависимости от значения параметра **parsingMode** в запросе.

| Документ JSON | parsingMode | ОПИСАНИЕ | Доступность |
|--------------|-------------|--------------|--------------|
| Один на большой двоичный объект | `json` | Анализирует большие двоичные объекты JSON как отдельный блок текста. Каждый большой двоичный объект JSON становится отдельным документом в службе поиска Azure. | Общедоступен в API-интерфейсах [REST](https://docs.microsoft.com/rest/api/searchservice/indexer-operations) и [.NET](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.indexer). |
| Несколько на большой двоичный объект | `jsonArray` | Анализирует массив JSON в большом двоичном объекте, где каждый элемент массива становится отдельным документом в службе поиска Azure.  | Общедоступен в API-интерфейсах [REST](https://docs.microsoft.com/rest/api/searchservice/indexer-operations) и [.NET](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.indexer). |


### <a name="step-1-create-a-data-source"></a>Шаг 1. Создание источника данных

Первым шагом является указание сведений о подключении к источнику данных, используемых индексатором. Тип источника данных, указанный здесь как `azureblob`, определяет, какие поведения извлечения данных инициируются индексатором. Для индексирования больших двоичных объектов JSON определение источника будет одинаковым как для документов, так и массивов JSON. 

    POST https://[service name].search.windows.net/datasources?api-version=2017-11-11
    Content-Type: application/json
    api-key: [admin key]

    {
        "name" : "my-blob-datasource",
        "type" : "azureblob",
        "credentials" : { "connectionString" : "DefaultEndpointsProtocol=https;AccountName=<account name>;AccountKey=<account key>;" },
        "container" : { "name" : "my-container", "query" : "optional, my-folder" }
    }   

### <a name="step-2-create-a-target-search-index"></a>Шаг 2. Создание целевого индекса поиска 

Индексаторы связываются со схемой индекса. При использовании API-интерфейса (а не портала) необходимо предварительно подготовить индекс для указания в операции индексатора.

Индекс хранит пригодное для поиска содержимое в службе поиска Azure. Чтобы создать индекс, предоставьте схему, которая задает поля в документе, атрибуты и другие компоненты, которые определяют процедуру поиска. Если вы создаете индекс, который имеет те же имена полей и типы данных в качестве источника, индексатор будет сопоставлять поля источника и назначения и вам не придется явным образом сопоставлять эти поля.

В следующем примере показан запрос [Создать индекс](https://docs.microsoft.com/rest/api/searchservice/create-index). У индекса будет доступное для поиска поле `content` для хранения текста, извлеченного из больших двоичных объектов:   

    POST https://[service name].search.windows.net/indexes?api-version=2017-11-11
    Content-Type: application/json
    api-key: [admin key]

    {
          "name" : "my-target-index",
          "fields": [
            { "name": "id", "type": "Edm.String", "key": true, "searchable": false },
            { "name": "content", "type": "Edm.String", "searchable": true, "filterable": false, "sortable": false, "facetable": false }
          ]
    }


### <a name="step-3-configure-and-run-the-indexer"></a>Шаг 3. Настройка и выполнение индексатора

До этого момента определения индекса и источника данных не зависели от параметра parsingMode. Тем не менее на шаге 3 для конфигурации индексатора путь отличается в зависимости от способа анализа и упорядочения содержимого большого двоичного объекта JSON в индексе службы поиска Azure. Доступны `json` и `jsonArray`.

+ Задайте для параметра **parsingMode** значение `json`, чтобы индексировать каждый большой двоичный объект как один документ.

+ Задайте для параметра **parsingMode** значение `jsonArray`, если большие двоичные объекты состоят из массивов JSON и вам нужно, чтобы каждый элемент массива стал отдельным документом службе поиска Azure. Документ можно представить себе как отдельный элемент в результатах поиска. Если вы хотите, чтобы каждый элемент массива отображался в результатах поиска как независимый элемент, используйте вариант `jsonArray`.

В определении индексатора можно использовать **сопоставление полей** для выбора свойств исходного документа JSON, применяемых для заполнения целевого индекса поиска. Для массивов JSON, если массив существует как свойство нижнего уровня, можно задать корневой каталог документов, указывающий на расположение массива в пределах большого двоичного объекта.

> [!IMPORTANT]
> При использовании режима анализа `json` или `jsonArray` служба поиска Azure предполагает, что все большие двоичные объекты в источнике данных содержат JSON. Если необходима поддержка как объектов JSON, так и других объектов в одном источнике данных, сообщите нам об этом на [нашем сайте UserVoice](https://feedback.azure.com/forums/263029-azure-search).


### <a name="how-to-parse-single-json-blobs"></a>Как анализировать отдельные большие двоичные объекты JSON

По умолчанию [индексатор больших двоичных объектов Поиска Azure](search-howto-indexing-azure-blob-storage.md) анализирует большие двоичные объекты JSON как один блок текста. Часто требуется сохранить структуру документов JSON. Например, предположим, что в хранилище BLOB-объектов Azure имеется следующий документ JSON:

    {
        "article" : {
            "text" : "A hopefully useful article explaining how to parse JSON blobs",
            "datePublished" : "2016-04-13",
            "tags" : [ "search", "storage", "howto" ]    
        }
    }

Индексатор больших двоичных объектов анализирует документ JSON как один документ поиска Azure. Индексатор загружает индекс, сопоставляя значения text, datePublished и tags из источника с идентичными по названию и типу целевыми полями индекса.

Конфигурация содержится в тексте операции индексатора. Вспомните, что ранее определенный объект источника данных указывает тип источника данных и сведения о подключении. Кроме того, целевой индекс должен также существовать как пустой контейнер в службе. Расписание и параметры необязательны, но если опустить их, сразу же запускается индексатор, используя `json` как режим анализа.

Полностью указанный запрос может выглядеть следующим образом:

    POST https://[service name].search.windows.net/indexers?api-version=2017-11-11
    Content-Type: application/json
    api-key: [admin key]

    {
      "name" : "my-json-indexer",
      "dataSourceName" : "my-blob-datasource",
      "targetIndexName" : "my-target-index",
      "schedule" : { "interval" : "PT2H" },
      "parameters" : { "configuration" : { "parsingMode" : "json" } }
    }

Как уже отмечалось, сопоставления полей необязательны. Если имеется индекс с полями "text", "datePublished и "tags", индексатор больших двоичных объектов может определить правильное сопоставление без наличия сопоставления полей в запросе.

### <a name="how-to-parse-json-arrays"></a>Как анализировать массивы JSON

Кроме того, вы можете выбрать функцию массива JSON. Эту функцию можно использовать, если большие двоичные объекты содержат *массив объектов JSON*, и вы хотите представить каждый элемент массива в виде отдельного документа в службе поиска Azure. Например, если имеется следующий большой двоичный объект JSON, можно заполнить индекс поиска Azure тремя отдельными документами, каждый из которых содержит поля "id" и "text".  

    [
        { "id" : "1", "text" : "example 1" },
        { "id" : "2", "text" : "example 2" },
        { "id" : "3", "text" : "example 3" }
    ]

Для массива JSON определение индексатора должно выглядеть, как в следующем примере. Обратите внимание, что параметр parsingMode указывает средство синтаксического анализа `jsonArray`. Указание правильного средства синтаксического анализа и наличие правильных входных данных — это два требования, относящихся к массивам, для индексирования больших двоичных объектов JSON.

    POST https://[service name].search.windows.net/indexers?api-version=2017-11-11
    Content-Type: application/json
    api-key: [admin key]

    {
      "name" : "my-json-indexer",
      "dataSourceName" : "my-blob-datasource",
      "targetIndexName" : "my-target-index",
      "schedule" : { "interval" : "PT2H" },
      "parameters" : { "configuration" : { "parsingMode" : "jsonArray" } }
    }

Снова отметим, что сопоставления полей необязательны. Если имеется индекс с полями с аналогичными именами id и text, индексатор больших двоичных объектов может определить правильное сопоставление без явного списка сопоставления полей.

<a name="nested-json-arrays"></a>

### <a name="nested-json-arrays"></a>Вложенные массивы JSON
Что делать, если требуется индексировать массив объектов JSON, но он является вложенным в документ? Можно выбрать, какое свойство содержит массив, с помощью свойства конфигурации `documentRoot` . Например, если большой двоичный объект выглядит следующим образом:

    {
        "level1" : {
            "level2" : [
                { "id" : "1", "text" : "Use the documentRoot property" },
                { "id" : "2", "text" : "to pluck the array you want to index" },
                { "id" : "3", "text" : "even if it's nested inside the document" }  
            ]
        }
    }

Используйте эту конфигурацию для индексации массива, содержащегося в свойстве `level2`:

    {
        "name" : "my-json-array-indexer",
        ... other indexer properties
        "parameters" : { "configuration" : { "parsingMode" : "jsonArray", "documentRoot" : "/level1/level2" } }
    }

### <a name="using-field-mappings-to-build-search-documents"></a>Построение документов поиска с помощью сопоставления полей

Если исходные и целевые поля не полностью согласованы, можно определить область сопоставления полей в тексте запроса для их явного сопоставления.

Сейчас служба поиска Azure не может индексировать произвольные документы JSON напрямую, так как она поддерживает только простые типы данных, строковые массивы и точки GeoJSON. Однако с помощью **сопоставления полей** можно выбирать части документа JSON и "поднимать" до полей верхнего уровня документа поиска. Общие сведения о сопоставлении полей см. в статье [Сопоставление полей в индексаторах Поиска Azure](search-indexer-field-mappings.md).

Вернемся к нашему примеру документа JSON:

    {
        "article" : {
            "text" : "A hopefully useful article explaining how to parse JSON blobs",
            "datePublished" : "2016-04-13"
            "tags" : [ "search", "storage", "howto" ]    
        }
    }

Допустим, что у вас есть индекс поиска со следующими полями: `text` типа `Edm.String`, `date` типа `Edm.DateTimeOffset` и `tags` типа `Collection(Edm.String)`. Обратите внимание на несоответствие между полем "datePublished" в источнике и полем `date` в индексе. Чтобы сопоставить JSON с необходимой формой, используйте следующие сопоставления полей:

    "fieldMappings" : [
        { "sourceFieldName" : "/article/text", "targetFieldName" : "text" },
        { "sourceFieldName" : "/article/datePublished", "targetFieldName" : "date" },
        { "sourceFieldName" : "/article/tags", "targetFieldName" : "tags" }
      ]

Имена полей источника в сопоставлениях задаются с помощью нотации [указателя JSON](https://tools.ietf.org/html/rfc6901) . Укажите косую черту (корень документа JSON) и путь до нужного свойства (на произвольном уровне вложенности), разделяя элементы пути косой чертой.

Также можно ссылаться на отдельные элементы массива, используя отсчитываемый от нуля индекс. Например, чтобы выбрать первый элемент массива "tags" из приведенного выше примера, используйте следующее сопоставление полей:

    { "sourceFieldName" : "/article/tags/0", "targetFieldName" : "firstTag" }

> [!NOTE]
> Если имя поля источника в пути сопоставления полей ссылается на свойство, которое не существует в JSON, это сопоставление пропускается без ошибки. Это необходимо для поддержки документов с разными схемами (что часто встречается на практике). Поскольку проверка на ошибки не выполняется, будьте внимательны и не допускайте опечаток в спецификации сопоставления полей.
>
>

### <a name="rest-example-indexer-request-with-field-mappings"></a>Пример REST: запрос индексатора с сопоставлениями полей

В примере ниже показаны полностью указанные полезные данные индексатора, включая сопоставления полей:

    POST https://[service name].search.windows.net/indexers?api-version=2017-11-11
    Content-Type: application/json
    api-key: [admin key]

    {
      "name" : "my-json-indexer",
      "dataSourceName" : "my-blob-datasource",
      "targetIndexName" : "my-target-index",
      "schedule" : { "interval" : "PT2H" },
      "parameters" : { "configuration" : { "parsingMode" : "json" } },
      "fieldMappings" : [
        { "sourceFieldName" : "/article/text", "targetFieldName" : "text" },
        { "sourceFieldName" : "/article/datePublished", "targetFieldName" : "date" },
        { "sourceFieldName" : "/article/tags", "targetFieldName" : "tags" }
        ]
    }

<a name="json-indexer-dotnet"></a>

## <a name="use-net-sdk"></a>Использование пакета SDK для .NET

Пакет SDK для .NET имеет полное равенство с REST API. Мы рекомендуем прочитать предыдущий раздел о REST API, чтобы ознакомиться с концепциями, рабочим процессом и требованиями. Используйте следующую справочную документацию по .NET API для реализации индексатора JSON в управляемом коде.

+ [microsoft.azure.search.models.datasource](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.datasource?view=azure-dotnet)
+ [microsoft.azure.search.models.datasourcetype](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.datasourcetype?view=azure-dotnet) 
+ [microsoft.azure.search.models.index](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.index?view=azure-dotnet) 
+ [microsoft.azure.search.models.indexer](https://docs.microsoft.com/dotnet/api/microsoft.azure.search.models.indexer?view=azure-dotnet)

## <a name="see-also"></a>См. также

+ [Индексаторы в службе поиска Azure](search-indexer-overview.md)
+ [Индексирование BLOB-объектов JSON с помощью индексатора BLOB-объектов службы поиска Azure](search-howto-index-json-blobs.md)
+ [Индексирование BLOB-объектов в формате CSV с помощью индексатора BLOB-объектов службы поиска Azure](search-howto-index-csv-blobs.md)
+ [Руководство Поиск частично структурированных данных в хранилище BLOB-объектов Azure](search-semi-structured-data.md)
