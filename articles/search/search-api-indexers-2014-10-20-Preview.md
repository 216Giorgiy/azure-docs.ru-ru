<properties pageTitle="Операции с индексаторами (API REST службы поиска Azure: версия 2014-10-20-Preview)" description="Операции с индексаторами (API REST службы поиска Azure: версия 2014-10-20-Preview)" services="search" documentationCenter="" authors="HeidiSteen" manager="mblythe" />

<tags ms.service="search" ms.devlang="rest-api" ms.workload="search" ms.topic="article"  ms.tgt_pltfrm="na" ms.date="07/08/2015" ms.author="heidist" />

#Операции с индексаторами (API REST службы поиска Azure: версия 2014-10-20-Preview)

> [AZURE.NOTE]В этой статье описаны прототипы новых функций, которых нет в выпущенной версии API. Дополнительные сведения о версиях и поддержке различных возможностей см. в статье [Управление версиями службы поиска](http://msdn.microsoft.com/library/azure/dn864560.aspx) на сайте MSDN. Дополнительные сведения о других функциях, реализованных в этой предварительной версии API, см. в статье [API REST службы поиска Azure: версия 2014-10-20-Preview](search-api-2014-10-20-preview.md).

## Обзор

Служба "Поиск Azure" может интегрироваться непосредственно с некоторыми общими источниками данных, что избавляет вас от необходимости писать код для индексирования данных. Чтобы настроить индексирование данных, можно вызвать интерфейс API службы "Поиск Azure" для создания **индексаторов** и **источников данных**, а также управления ими.

**Источник данных** определяет, какие данные нужно индексировать, какие учетные данные требуются для доступа к данным и какие политики нужны, чтобы служба "Поиск Azure" могла эффективно выявлять изменения в данных (такие как измененные или удаленные строки в таблице базы данных).

**Индексатор** описывает процесс передачи данных из источника данных в индекс поиска. Индексатор используется для выполнения следующих задач:

- однократное копирование данных;
- синхронизация индекса службы поиска Azure с изменениями в источнике данных по расписанию;
- копирование посредством вызова по запросу в любой момент.

В настоящее время поддерживаются следующие источники данных:

- База данных SQL Azure
- DocumentDB 

Мы планируем в будущем обеспечить поддержку дополнительных источников данных. Чтобы помочь нам определить приоритеты этих решений, оставьте свой отзыв на [форум отзывов по Поиску Azure](http://feedback.azure.com/forums/263029-azure-search).

**ПРИМЕЧАНИЕ.** Описанные здесь функции поддерживаются начиная с версии `2014-10-20-Preview` API Поиска Azure.

## Типичные рабочий процесс

Для настройки автоматического индексирования обычно необходимо выполнить перечисленные ниже действия.

1. Определите источник данных, содержащий данные, которые необходимо проиндексировать. Имейте в виду, что служба поиска Azure может не поддерживать все типы данных, которые присутствуют в источнике.

2. Создайте индекс поиска Azure, схема которого совместима с источником данных.
  
3. Создайте источник данных для службы поиска Azure, как описано в разделе «Операции с источником данных» ниже.
  
4. Создайте индексатор для службы поиска Azure и проконтролируйте его работу, как описано в разделе «Операции с источником данных» ниже.

## Правила именования

- Имя источника данных должно содержать только строчные буквы, цифры или дефисы, не может начинаться или заканчиваться тире и не должно быть длиннее 128 символов.
- Имя индексатора должно содержать только строчные буквы, цифры или дефисы, не может начинаться или заканчиваться тире и не должно быть длиннее 128 символов.

## Пределы и ограничения

Дополнительные сведения см. на странице [Пределы и ограничения](http://msdn.microsoft.com/library/azure/dn798934.aspx).

## Операции с источником данных
Для создания источников данных в службе поиска Azure и управления ими используются простые HTTP-запросы (POST, GET, PUT, DELETE), отправляемые к определенному ресурсу источника.

### Создание источника данных

Для создания источника данных в службе поиска Azure используется запрос HTTP POST.
	
    POST https://[service name].search.windows.net/datasources?api-version=[api-version]
    Content-Type: application/json
    api-key: [admin key]

Вы также можете использовать метод PUT и указать имя источника данных в универсальном коде ресурса (URI). Если такого источника данных не существует, он будет создан.

    PUT https://[service name].search.windows.net/datasources/[datasource name]?api-version=[api-version]

**Примечание.** Максимальное разрешенное количество источников данных зависит от ценовой категории. В бесплатной версии службы можно использовать до трех источников. Стандартная служба позволяет использовать до 50 источников данных.

**Запрос**

Все запросы к службе отправляются по протоколу HTTPS. Для отправки запроса на **создание источника данных** можно использовать метод POST или PUT. Для метода POST в тексте запроса необходимо указать имя источника данных вместе с его определением. Для метода PUT имя указывается в составе URL-адреса. Если такого источника данных не существует, он будет создан. Если он уже есть, его определение будет обновлено.

Имя источника данных вводится строчными буквами, должно начинаться с буквы или цифры, не должно содержать символов косой черты и точки, а его максимальная длина составляет 127 знаков. Начиная со второго символа имя источника данных может содержать буквы, цифры и дефисы (однако последовательности из двух или большего числа дефисов запрещены).

Параметр `api-version` является обязательным. Допустимые значения — `2014-10-20-Preview` или более поздняя версия.

**Заголовки запроса**

В списке ниже перечислены обязательные и необязательные заголовки запроса.

- `Content-Type`: обязательный. Для этого заголовка необходимо задать значение `application/json`.
- `api-key`: обязательный. Заголовок `api-key` используется для проверки подлинности запроса в службе поиска. Это уникальное строковое значение, присваиваемое службе. Запрос на **создание источника данных** должен содержать заголовок `api-key` со значением ключа администратора (а не ключа запроса). 
 
Для формирования URL-адреса запроса также понадобится имя службы. Имя и `api-key` можно найти в панели мониторинга службы на портале предварительной версии Azure. Дополнительные сведения о навигации по страницам см. в статье, посвященной [созданию службы поиска на портале](search-create-service-portal.md).

<a name="CreateDataSourceRequestSyntax"></a> **Синтаксис тела запроса**

Текст запроса содержит определение источника данных, которое включает тип источника данных, учетные данные для чтения данных, а также необязательные политики обнаружения изменения и удаления данных, которые используются для эффективного определения измененных или удаленных данных в источнике данных при использовании совместно с индексатором, работающим по регулярному расписанию.


Ниже описан синтаксис полезных данных запроса. Далее в этом разделе приведен образец запроса.

    { 
		"name" : "Required for POST, optional for PUT. The name of the data source",
    	"description" : "Optional. Anything you want, or nothing at all",
    	"type" : "Required. Must be 'azuresql' or 'docdb'",
    	"credentials" : { "connectionString" : "Required. Connection string for your Azure SQL database" },
    	"container" : { "name" : "Required. The name of the table or collection you wish to index" },
    	"dataChangeDetectionPolicy" : { Optional. See below for details }, 
    	"dataDeletionDetectionPolicy" : { Optional. See below for details }
	}

Запрос может содержать перечисленные ниже атрибуты.

- `name`: обязательный. Имя источника данных. Имя источника данных должно содержать только строчные буквы, цифры или дефисы, не может начинаться или заканчиваться тире и не должно быть длиннее 128 символов.
- `description`: необязательное описание. 
- `type`: обязательный. Для источника данных Azure SQL следует указывать значение `azuresql`, для источника DocumentDB — значение `docdb`.
- `container`: 
	- Обязательное свойство `name` определяет таблицу или представление (для источника данных Azure SQL) или коллекцию (для источника данных DocumentDB), которые будут индексироваться. 
	- Источники данных DocumentDB также поддерживают необязательное свойство `query`, которое позволяет указать запрос, выполняющий сведение произвольного макета документа JSON в плоскую схему, доступную для индексирования с помощью службы "Поиск Azure".   
- Необязательные параметры `dataChangeDetectionPolicy` и `dataDeletionDetectionPolicy` описаны ниже.

<a name="DataChangeDetectionPolicies"></a> **Политики обнаружения изменения данных**

Политика обнаружения изменения данных предназначена для эффективного определения измененных элементов данных. Поддерживаемые политики зависят от типа источника данных. В следующих разделах описывается каждая из политик.

***Политика обнаружения изменений верхнего предела***

Эта политика используется, если источник данных содержит столбец или свойство, соответствующие следующим критериям:
 
- при каждой вставке указывается значение для столбца; 
- при всех обновлениях элементов также изменяется значение столбца; 
- значение этого столбца растет с каждым изменением;
- могут эффективно выполняться запросы, использующие предложение фильтра, аналогичное предложению `WHERE [High Water Mark Column] > [Current High Water Mark Value]`.

Например, при использовании источников данных Azure SQL индексированный столбец `rowversion` является идеальным претендентом на использование с политикой верхнего предела.

При использовании источников данных DocumentDB необходимо использовать свойство `_ts`, предоставленное в DocumentDB.
 
Эту политику можно указать следующим образом.

	{ 
		"@odata.type" : "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
		"highWaterMarkColumnName" : "[a row version or last_updated column name]" 
	} 

***Встроенная политика определения изменений SQL***

Если база данных SQL поддерживает [функцию интегрированного отслеживания изменений SQL](http://technet.microsoft.com/library/cc280462.aspx), мы советуем использовать соответствующую политику. Эта политика обеспечивает наиболее эффективное отслеживание изменений, а также позволяет Поиску Azure выявлять удаленные строки без необходимости добавлять в схему отдельный столбец обратимого удаления.

Встроенное отслеживание изменений поддерживается, начиная со следующих версий базы данных SQL: SQL Server 2008 R2, если используется SQL на виртуальных машинах IaaS; Azure SQL Database V12, если используется база данных SQL Azure.

**ПРИМЕЧАНИЕ.** При использовании интегрированной политики отслеживания изменений SQL не указывайте отдельную политику обнаружения удаления данных, так как она уже поддерживает выявление удаленных строк.

**ПРИМЕЧАНИЕ.** Эту политику можно использовать только с таблицами. С представлениями ее использовать нельзя. Перед использованием этой политики вам потребуется включить отслеживание изменений для используемой таблицы.
 
Интегрированную политику отслеживания изменений SQL можно задать следующим образом.

	{ 
		"@odata.type" : "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy" 
	}

<a name="DataDeletionDetectionPolicies"></a> **Политики обнаружения удаления данных**

Политика обнаружения удаления данных предназначена для эффективного определения удаленных элементов данных. В настоящее время единственной поддерживаемой политикой является политика `Soft Delete`, которая указывается следующим образом.

	{ 
		"@odata.type" : "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy",
		"softDeleteColumnName" : "the column that specifies whether a row was deleted", 
		"softDeleteMarkerValue" : "the value that identifies a row as deleted" 
	}

<a name="CreateDataSourceRequestExamples"></a> **Примеры тела запроса**

Если планируется использовать источник данных с индексатором, который запускается по расписанию, в этом примере показано, как задать политики .

    { 
		"name" : "asqldatasource",
		"description" : "a description",
    	"type" : "azuresql",
    	"credentials" : { "connectionString" : "Server=tcp:....database.windows.net,1433;Database=...;User ID=...;Password=...;Trusted_Connection=False;Encrypt=True;Connection Timeout=30;" },
    	"container" : { "name" : "sometable" },
    	"dataChangeDetectionPolicy" : { "@odata.type" : "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy", "highWaterMarkColumnName" : "RowVersion" }, 
    	"dataDeletionDetectionPolicy" : { "@odata.type" : "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy", "softDeleteColumnName" : "IsDeleted", "softDeleteMarkerValue" : true }
	}

Если планируется использовать источник данных для разового копирования данных, политики можно опустить.

    { 
		"name" : "asqldatasource",
    	"description" : "anything you want, or nothing at all",
    	"type" : "azuresql",
    	"credentials" : { "connectionString" : "Server=tcp:....database.windows.net,1433;Database=...;User ID=...;Password=...;Trusted_Connection=False;Encrypt=True;Connection Timeout=30;" },
    	"container" : { "name" : "sometable" }
	} 

**Ответ**

Для успешного запроса: «201 — Создан ресурс».

### Обновление источника данных

Обновить существующий источник данных можно с помощью HTTP-запроса PUT. Имя источника данных, который необходимо обновить, указывается в универсальном коде ресурса (URI) запроса.

    PUT https://[service name].search.windows.net/datasources/[datasource name]?api-version=[api-version]
    Content-Type: application/json
    api-key: [admin key]

**Запрос** Синтаксис тела запроса такой же, как и при [создании источника данных](#CreateDataSourceRequestSyntax).

**Ответ** Для успешного запроса: возвращается код состояния «201 — Создан ресурс», если источник данных был создан, и «204 — Нет содержимого», если был обновлен существующий источник данных.

**ПРИМЕЧАНИЕ.** Некоторые свойства В существующем источнике данных нельзя обновить. Например, невозможно изменить тип существующего источника данных.

### Список источников данных

Операция **получение списка источников данных** возвращает список источников данных в службе поиска Azure.

    GET https://[service name].search.windows.net/datasources?api-version=[api-version]
    api-key: [admin key]

**Ответ**

Для успешного запроса: «200 — ОК».

Вот пример тела запроса:

    {
      "value" : [
        {
          "name": "datasource1",
          "type": "azuresql",
		  ... other data source properties
        }]
    }

Обратите внимание на то, что в ответе можно отфильтровать нужные свойства. Например, если необходим только список имен источников данных, задайте параметр запроса OData `$select`.

    GET /datasources?api-version=2014-10-20-Preview&$select=name

В этом случае ответ из приведенного выше примера будет выглядеть так:

    {
      "value" : [ { "name": "datasource1" }, ... ]
    }

Это удобный способ сократить нагрузку на пропускную способность, если в службе поиска много источников данных.

### Получение источника данных

Операция **получения источника данных** позволяет получить определение источника данных из службы поиска Azure.

    GET https://[service name].search.windows.net/datasources/[datasource name]?api-version=[api-version]
    api-key: [admin key]

**Ответ**

Код состояния: в качестве успешного ответа возвращается код "200 — ОК".

Ответ похож на примеры, приведенные в разделе «Примеры тела запроса» статьи [Создание источника данных](#CreateDataSourceRequestExamples).

	{ 
		"name" : "asqldatasource",
		"description" : "a description",
    	"type" : "azuresql",
    	"credentials" : { "connectionString" : "Server=tcp:....database.windows.net,1433;Database=...;User ID=...;Password=...;Trusted_Connection=False;Encrypt=True;Connection Timeout=30;" },
    	"container" : { "name" : "sometable" },
    	"dataChangeDetectionPolicy" : { 
            "@odata.type" : "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
			"highWaterMarkColumnName" : "RowVersion" }, 
    	"dataDeletionDetectionPolicy" : { 
            "@odata.type" : "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy",
			"softDeleteColumnName" : "IsDeleted", 
			"softDeleteMarkerValue" : true }
	}

**ПРИМЕЧАНИЕ.** Не устанавливайте для заголовка запроса `Accept` значение `application/json;odata.metadata=none` при вызове этого интерфейса API, так как это приведет к исключению атрибута `@odata.type` из ответа, и вы не сможете различить политики обнаружения изменения и удаления данных различных типов.

### Удаление источника данных

Операция **удаления источника данных** удаляет источник данных из службы поиска Azure.

    DELETE https://[service name].search.windows.net/datasources/[datasource name]?api-version=[api-version]
    api-key: [admin key]

**ПРИМЕЧАНИЕ**. Если какие-либо индексаторы ссылаются на удаляемый источник данных, операция удаления все равно будет продолжена. Однако эти индексаторы перейдут в состояние ошибки при их следующем запуске.

**Ответ**

Код состояния: в качестве успешного ответа возвращается код «204 — Нет содержимого».

## Операции с индексатором

Индексатор — это ресурс, соединяющий источники данных с целевыми индексами поиска. Для каждой комбинации целевого индекса и источника данных необходимо запланировать создание одного индексатора. Несколько индексаторов могут выполнять запись в один индекс, однако один индексатор не может записывать данные в несколько индексов.

Для создания индексаторов и управления ими используются простые HTTP-запросы (POST, GET, PUT, DELETE), отправляемые к определенному ресурсу индекса.

После создания индексатора можно получить его состояние выполнения с помощью операции [Получение состояния индексатора](#GetIndexerStatus). Кроме того, индексатор можно запустить в любое время (в дополнение к его периодическому выполнению по расписанию или вместо него), используя операцию [Запуск индексатора](#RunIndexer).

### Создание индексатора

Для создания индекса в службе поиска Azure используется запрос HTTP POST.
	
    POST https://[service name].search.windows.net/indexers?api-version=[api-version]
    Content-Type: application/json
    api-key: [admin key]

Вы также можете использовать метод PUT и указать имя источника данных в универсальном коде ресурса (URI). Если такого источника данных не существует, он будет создан.

    PUT https://[service name].search.windows.net/indexers/[indexer name]?api-version=[api-version]

**Примечание.** Максимальное разрешенное количество индексаторов зависит от ценовой категории. В бесплатной версии службы можно использовать до трех индексаторов. Стандартная служба позволяет использовать до 50 индексаторов.

<a name="CreateIndexerRequestSyntax"></a> **Синтаксис тела запроса**

Текст запроса содержит определение индексатора, которое указывает на источник данных и целевой индекс для индексирования, а также необязательное расписание индексирования и параметры.


Ниже описан синтаксис полезных данных запроса. Далее в этом разделе приведен образец запроса.

    { 
		"name" : "Required for POST, optional for PUT. The name of the indexer",
    	"description" : "Optional. Anything you want, or null",
    	"dataSourceName" : "Required. The name of an existing data source",
        "targetIndexName" : "Required. The name of an existing index",
        "schedule" : { Optional. See Indexing Schedule below. },
        "parameters" : { Optional. See Indexing Parameters below. }
	}

**Расписание индексирования**

Индексатор может дополнительно задавать расписание. Если расписание уже имеется, индексатор будет выполняться согласно расписанию. Расписание имеет следующие атрибуты.

- `interval`. Обязательный. Значение длительности, указывающее интервал или период между запусками индексатора. Наименьший допустимый интервал — 5 минут, наибольший — один день. Значение должно быть отформатировано как значение dayTimeDuration XSD (ограниченное подмножество значения [продолжительности ISO 8601](http://www.w3.org/TR/xmlschema11-2/#dayTimeDuration)). Используется следующий шаблон: `P(nD)(T(nH)(nM))`. Примеры: `PT15M`— каждые 15 минут, `PT2H` — каждые 2 часа. 

- `startTime`. Обязательный. Дата и время начала работы индексатора в формате UTC.

**Параметры индексирования**

При необходимости индексатор может указывать несколько параметров, которые влияют на его поведение. Все параметры являются необязательными.

- `maxFailedItems` количество не прошедших индексирование элементов, превышение которого рассматривается как сбой индексатора. Значение по умолчанию — `0`. Сведения об ошибочных элементах возвращаются операцией [получения состояния индексатора](#GetIndexerStatus). 

- `maxFailedItemsPerBatch`: количество не прошедших индексирование элементов в каждом пакете, превышение которого рассматривается как сбой индексатора. Значение по умолчанию — `0`.

- `base64EncodeKeys` указывает, заданы ли ключи документа в кодировке base-64. Поиск Azure накладывает ограничения на символы, которые может содержать ключ документа. Однако данные источника могут содержать недопустимые символы. Если необходимо индексировать такие значения как ключи документов, этому флагу можно задать значение true. Значение по умолчанию — `false`.

<a name="CreateIndexerRequestExamples"></a> **Примеры тела запроса**

В следующем примере создается индексатор, копирующий данные из таблицы, указанной источником данных `ordersds`, в индекс `orders` по расписанию, которое начинается 1 января 2015 г. Индексатор запускается каждый час. Каждый вызов индексатора будет успешным, если происходит сбой при индексировании не более 5 элементов в каждом пакете и всего не удается индексировать не более 10 элементов.

	{
        "name" : "myindexer",
        "description" : "a cool indexer",
        "dataSourceName" : "ordersds",
        "targetIndexName" : "orders",
        "schedule" : { "interval" : "PT1H", "startTime" : "2015-01-01T00:00:00Z" },
        "parameters" : { "maxFailedItems" : 10, "maxFailedItemsPerBatch" : 5, "base64EncodeKeys": false }
	}

**Ответ**

Успешный запрос возвращает код состояния «201 — Создан ресурс».

### Обновление индексатора

Обновить существующий индексатор можно с помощью HTTP-запроса PUT. Указать имя обновляемого индексатора можно в универсальном коде ресурса (URI) запроса.

    PUT https://[service name].search.windows.net/indexers/[indexer name]?api-version=[api-version]
    Content-Type: application/json
    api-key: [admin key]

**Запрос**

Синтаксис текста запроса такой же, как и при [создании источника данных](#CreateIndexerRequestSyntax).

**Ответ**

Для успешного запроса: возвращается код состояния «201 — Создан ресурс», если индексатор был создан, и «204 — Нет содержимого», если был обновлен существующий индексатор.

### Получение списка индексаторов

Операция **получения списка индексаторов** возвращает список индексаторов в службе поиска Azure.

    GET https://[service name].search.windows.net/indexers?api-version=[api-version]
    api-key: [admin key]

**Ответ**

Для успешного запроса: «200 — ОК».

Вот пример тела запроса:

    {
      "value" : [
      {
        "name" : "myindexer",
        "description" : "a cool indexer",
        "dataSourceName" : "ordersds",
        "targetIndexName" : "orders",
        ... other indexer properties
	  }]
    }

Обратите внимание на то, что в ответе можно отфильтровать нужные свойства. Например, если необходим только список имен индексаторов, задайте параметр запроса OData `$select`:

    GET /indexers?api-version=2014-10-20-Preview&$select=name

В этом случае ответ из приведенного выше примера будет выглядеть так:

    {
      "value" : [ { "name": "myindexer" } ]
    }

Это удобный способ сократить нагрузку на пропускную способность, если в службе поиска много индексаторов.

### Получение индексатора

Операция **получения индексатора** возвращает определение индексатора из службы поиска Azure.

    GET https://[service name].search.windows.net/indexers/[indexer name]?api-version=[api-version]
    api-key: [admin key]

**Ответ**

Код состояния: в качестве успешного ответа возвращается код "200 — ОК".

Ответ похож на примеры, приведенные в разделе «Примеры тела запроса» статьи [Создание индексатора](#CreateIndexerRequestExamples).

	{
        "name" : "myindexer",
        "description" : "a cool indexer",
        "dataSourceName" : "ordersds",
        "targetIndexName" : "orders",
        "schedule" : { "interval" : "PT1H", "startTime" : "2015-01-01T00:00:00Z" },
        "parameters" : { "maxFailedItems" : 10, "maxFailedItemsPerBatch" : 5, "base64EncodeKeys": false }
	}

### Удаление индексатора

Операция **удаления индексатора** удаляет индексатор из службы поиска Azure.

    DELETE https://[service name].search.windows.net/indexers/[indexer name]?api-version=[api-version]
    api-key: [admin key]

При удалении индексатора выполняемые в этот момент операции индексатора будут полностью завершены, однако новые выполнения планироваться не будут. Попытки использовать несуществующий индексатор возвращают код состояния HTTP «404 — Не найдено».
 
**Ответ**

Код состояния: в качестве успешного ответа возвращается код "204 — Нет содержимого".

<a name="RunIndexer"></a>
### Запуск индексатора

Помимо периодического выполнения по расписанию индексатор также можно вызывать по запросу с помощью операции **запуска индексатора**.

	POST https://[service name].search.windows.net/indexers/[indexer name]/run?api-version=[api-version]
    api-key: [admin key]

**Ответ**

Код состояния: в качестве успешного ответа возвращается код «202 — Принято».

<a name="GetIndexerStatus"></a>
### Получение состояния индексатора

Операция **получения состояния индексатора** возвращает текущий журнал состояния и выполнения индексатора.

	GET https://[service name].search.windows.net/indexers/[indexer name]/status?api-version=[api-version]
    api-key: [admin key]

**Ответ**

Код состояния: в качестве успешного ответа возвращается код «200 — ОК».

Текст ответа содержит сведения об общем состоянии работоспособности индексатора и последнем его вызове, а также журнал последних вызовов индексатора (при наличии).

Пример текста ответа выглядит следующим образом.

	{
		"status":"running",
		"lastResult": {
			"status":"success",
			"errorMessage":null,
			"startTime":"2014-11-26T03:37:18.853Z",
			"endTime":"2014-11-26T03:37:19.012Z",
			"errors":[],
			"itemsProcessed":11,
			"itemsFailed":0,
			"initialTrackingState":null,
			"finalTrackingState":null
         },
		"executionHistory":[ {
			"status":"success",
         	"errorMessage":null,
			"startTime":"2014-11-26T03:37:18.853Z",
			"endTime":"2014-11-26T03:37:19.012Z",
			"errors":[],
			"itemsProcessed":11,
			"itemsFailed":0,
			"initialTrackingState":null,
			"finalTrackingState":null
		}]
	}

**Состояние индексатора**

Состояние индексатора может принимать одно из перечисленных ниже значений.

- `running` указывает, что индексатор работает нормально. Обратите внимание, что некоторые из запусков индексатора все равно могут быть завершены неудачно, поэтому также рекомендуется проверить свойство `lastResult`. 

- `error` указывает, что в индексаторе возникла ошибка, которую невозможно исправить без вмешательства человека. Например, истек срок действия учетных данных источника данных либо схемы источника данных или целевого индекса изменены так, что перестали работать.

**Результат выполнения индексатора**

Результат выполнения индексатора содержит сведения об одном выполнении индексатора. Последний результат представлен как свойство `lastResult` состояния индексатора. Другие недавние результаты (при их наличии) возвращаются в виде свойства `executionHistory` состояния индексатора.

Результат выполнения индексатора содержит перечисленные ниже свойства.

- `status`: состояние выполнения. Подробные сведения см. в разделе [Состояние выполнения индексатора](#IndexerExecutionStatus) ниже. 

- `errorMessage`: сообщение об ошибке при выполнении.

- `startTime`: время начала этого запуска в формате UTC.

- `endTime`: время завершения этого запуска в формате UTC. Это значение не установлено, если операция все еще выполняется.

- `errors`: список ошибок на уровне элементов, если таковые имеются.

- `itemsProcessed`: число элементов в источнике данных (например, строк таблицы), которые индексатор пытался проиндексировать во время этого выполнения.

- `itemsFailed`: число элементов, которые не удалось проиндексировать во время этого выполнения.
 
- `initialTrackingState`: всегда принимает значение `null` для первого выполнения индексатора или в том случае, если политика отслеживания изменений в данных для используемого источника не включена. Если такая политика включена, этот параметр в последующих выполнениях содержит первое (наименьшее) значение отслеживания изменений, обработанных в ходе этого выполнения.

- `finalTrackingState`: всегда принимает значение `null`, если политика отслеживания изменений в данных для используемого источника данных не включена. В противном случае указывает последнее (наибольшее) значение отслеживания изменений, успешно обработанное в ходе этого выполнения.

<a name="IndexerExecutionStatus"></a> **Состояние выполнения индексатора**

Состояние выполнения индексатора регистрирует состояние одного выполнения индексатора. Этот параметр может принимать перечисленные ниже значения.

- `success` указывает на успешное завершение выполнения индексатора.

- `inProgress` указывает, что идет процесс выполнения индексатора.

- `transientFailure` указывает, что вызов индексатора завершился ошибкой, однако она может быть временной. Вызовы индексатора будут продолжаться по расписанию, если оно установлено.

- `persistentFailure` указывает на сбой индексатора, который, вероятно, требует вмешательства человека (например, в случае несовместимости схем источника данных и целевого индекса). Запланированные запуски индексатора прекращаются, а для решения этой проблемы требуются действия пользователя (см. описание свойства `errorMessage`), который затем должен перезапустить индексатор.

- `reset` указывает, что индексатор сброшен путем вызова операции сброса индексатора из API (см. ниже).

<a name="ResetIndexer"></a>
### Сброс индексатора

Операция **сброса индексатора** сбрасывает состояние отслеживания изменений, связанное с индексатором. Это позволяет запускать повторную индексацию с нуля (например, если была изменена схема источника данных) или изменять политику обнаружения изменений данных для источника данных, связанного с индексатором.

	POST https://[service name].search.windows.net/indexers/[indexer name]/reset?api-version=[api-version]
    api-key: [admin key]

**Ответ**

Код состояния: в качестве успешного ответа возвращается код «204 — Нет содержимого».

## Сопоставление типов данных SQL и типов данных службы "Поиск Azure"

<table style="font-size:12">
<tr>
<td>Тип данных SQL</td>	
<td>Совместимые типы полей целевого индекса</td>
<td>Примечания</td>
</tr>
<tr>
<td>bit</td>
<td>Edm.Boolean, Edm.String</td>
<td></td>
</tr>
<tr>
<td>int, smallint, tinyint</td>
<td>Edm.Int32, Edm.Int64, Edm.String</td>
<td></td>
</tr>
<tr>
<td>bigint</td>
<td>Edm.Int64, Edm.String</td>
<td></td>
</tr>
<tr>
<td>real, float</td>
<td>Edm.Double, Edm.String</td>
<td></td>
</tr>
<tr>
<td>smallmoney, money<br>decimal<br>numeric
</td>
<td>Edm.String</td>
<td>Поиск Azure не поддерживает преобразование десятичных типов в Edm.Double, так как это отрицательно скажется на точности.
</td>
</tr>
<tr>
<td>char, nchar, varchar, nvarchar</td>
<td>Edm.String</td>
<td></td>
</tr>
<tr>
<td>smalldatetime, datetime, datetime2, date, datetimeoffset</td>
<td>Edm.DateTimeOffset, Edm.String</td>
<td></td>
</tr>
<tr>
<td>uniqueidentifer</td>
<td>Edm.String</td>
<td></td>
</tr>
<tr>
<td>rowversion</td>
<td>Недоступно</td>
<td>Столбцы версии строк не могут храниться в индексе поиска, но их можно использовать для отслеживания изменений.</td>
</tr>
<tr>
<td>time, timespan<br>binary, varbinary, image<br>xml<br>geometry<br> geography<br>Типы CLR</td>
<td>Недоступно</td>
<td>Не поддерживается</td>
</tr>
</table>

## Сопоставление типов данных JSON и типов данных службы поиска Azure

<table style="font-size:12">
<tr>
<td>Тип данных JSON</td>	
<td>Совместимые типы полей целевого индекса</td>
<td>Примечания</td>
</tr>
<tr>
<td>bool</td>
<td>Edm.Boolean, Edm.String</td>
<td></td>
</tr>
<tr>
<td>Целые числа</td>
<td>Edm.Int32, Edm.Int64, Edm.String</td>
<td>В JSON нет типизированных целых чисел, поэтому используется самый объемлющий формат: 64-разрядные объекты типа int.</td>
</tr>
<tr>
<td>Числа с плавающей запятой</td>
<td>Edm.Double, Edm.String</td>
<td></td>
</tr>
<tr>
<td>string</td>
<td>Edm.String</td>
<td></td>
</tr>
<tr>
<td>Массивы примитивных типов, например ["a", "b", "c"]</td>
<td>Collection(Edm.String)</td>
<td></td>
</tr>
<tr>
<td>Строки, которые выглядят как даты</td>
<td>Edm.DateTimeOffset, Edm.String</td>
<td></td>
</tr>
<tr>
<td>Объекты JSON</td>
<td>Недоступно</td>
<td>Не поддерживаются. В настоящее время служба поиска Azure поддерживает только типы примитивов и коллекции строк.</td>
</tr>
</table>

<!---HONumber=August15_HO6-->