---
title: "Подключение базы данных SQL Azure к службе поиска Azure с помощью индексаторов | Документация Майкрософт"
description: "Узнайте, как извлекать данные из Базы данных SQL Azure в индекс Поиска Azure с помощью индексаторов."
services: search
documentationcenter: 
author: chaosrealm
manager: pablocas
editor: 
ms.assetid: e9bbf352-dfff-4872-9b17-b1351aae519f
ms.service: search
ms.devlang: rest-api
ms.workload: search
ms.topic: article
ms.tgt_pltfrm: na
ms.date: 10/27/2016
ms.author: eugenesh
translationtype: Human Translation
ms.sourcegitcommit: 096fcd2a7415da03714f05bb1f29ceac6f186eda
ms.openlocfilehash: dba7cd466d94cb68896ee9270bc765fe822ca00e

---

# <a name="connecting-azure-sql-database-to-azure-search-using-indexers"></a>Подключение базы данных SQL Azure к Поиску Azure с помощью индексаторов
Служба Поиск Azure является размещенной облачной службой поиска, которая позволяет легче предоставляться расширенные возможности поиска. Перед началом поиска необходимо заполнить индекс Поиск Azure данными. Если данные находятся в базе данных SQL Azure, новый **индексатор Поиска Azure для базы данных SQL Azure** (сокращенно — **индексатор SQL Azure**) поможет автоматизировать индексирование. Это позволит сократить размер кода и объем инфраструктуры.

В этой статье рассматривается механизм использования индексаторов, а также подробно описываются функции, доступные только в базах данных SQL Azure (например, интегрированное отслеживание изменений). Поиск Azure также поддерживает другие источники данных, в том числе Azure DocumentDB, хранилище BLOB-объектов и хранилище таблиц. Если вам требуется поддержка дополнительных источников данных, оставьте отзыв на [форуме отзывов и предложений по Поиску Azure](https://feedback.azure.com/forums/263029-azure-search/).

## <a name="indexers-and-data-sources"></a>Индексаторы и источники данных
Индексатор SQL Azure можно установить и настроить с помощью:

* мастера импорта данных на [портале Azure](https://portal.azure.com);
* [пакета SDK .NET для Поиска Azure](https://msdn.microsoft.com/library/azure/dn951165.aspx);
* [REST API](http://go.microsoft.com/fwlink/p/?LinkID=528173) Поиска Azure.

В этой статье мы будем использовать REST API, чтобы показать, как создавать **индексаторы** и **источники данных** и управлять ими.

**Источник данных** определяет, какие данные следует индексировать, какие учетные данные требуются для доступа к данным и какие политики нужны, чтобы эффективно выявлять изменения в данных (новые, измененные или удаленные строки). Он определяется как независимый ресурс, который могут использовать несколько индексаторов.

**Индексатор** — это ресурс, соединяющий источники данных с целевыми индексами поиска. Индексатор используется в следующих случаях.

* Для выполнения однократного копирования данных с целью заполнения индекса.
* добавление в индекс изменений в источнике данных по расписанию;
* запуск по требованию для обновления индекса при необходимости.

## <a name="when-to-use-azure-sql-indexer"></a>Когда следует использовать индексатор Azure SQL
Уместность использования индексатора Azure SQL зависит от нескольких факторов, связанных с данными. Если данные соответствуют следующим требованиям, вы можете использовать индексатор Azure SQL.

* Все данные поступают из одной таблицы или представления
  * Если данные разбиты на несколько таблиц, вы можете создать представление и использовать его с индексатором. Однако при использовании представления вы не сможете использовать интегрированное отслеживание изменений SQL Server. Дополнительные сведения см. в [этом разделе](#CaptureChangedRows).
* Индексатор поддерживает типы данных, используемые в источнике данных. Поддерживается большинство типов SQL, но не все из них. Дополнительные сведения см. в статье [Data type map for indexers in Azure Search](http://go.microsoft.com/fwlink/p/?LinkID=528105) (Сопоставление типов данных для индексаторов в службе поиска Azure).
* При изменении строки вам не нужны обновления индекса в псевдореальном времени.
  * Индексатор может выполнять повторное индексирование таблицы не чаще, чем раз в 5 минут. Если изменения в данных происходят часто и их нужно отражать в индексе в пределах нескольких секунд или минут, мы рекомендуем использовать [API индекса Поиска Azure](https://msdn.microsoft.com/library/azure/dn798930.aspx) напрямую.
* Если вы располагаете большим набором данных и собираетесь запускать индексатор по расписанию, ваша схема позволяет нам эффективно выявлять измененные (и удаленные, если это необходимо) строки. Дополнительные сведения см. в разделе "Запись измененных и удаленных строк" ниже.
* Размер индексированных полей в строке не превышает максимальный размер запроса на индексирование Поиска Azure, который составляет 16 МБ.

## <a name="create-and-use-an-azure-sql-indexer"></a>Создание и использование индексатора Azure SQL
Во-первых, создайте источник данных:

    POST https://myservice.search.windows.net/datasources?api-version=2016-09-01
    Content-Type: application/json
    api-key: admin-key

    {
        "name" : "myazuresqldatasource",
        "type" : "azuresql",
        "credentials" : { "connectionString" : "Server=tcp:<your server>.database.windows.net,1433;Database=<your database>;User ID=<your user name>;Password=<your password>;Trusted_Connection=False;Encrypt=True;Connection Timeout=30;" },
        "container" : { "name" : "name of the table or view that you want to index" }
    }


Вы можете получить строку подключения на [классическом портале Azure](https://portal.azure.com). Используйте вариант `ADO.NET connection string`.

Затем создайте целевой индекс Поиска Azure, если вы еще не сделали это. Создать индекс можно с помощью [пользовательского интерфейса портала](https://portal.azure.com) или [API создания индекса](https://msdn.microsoft.com/library/azure/dn798941.aspx). Убедитесь, что схема целевого индекса совместима со схемой исходной таблицы. Ознакомьтесь с разделом [Сопоставление типов данных SQL и поиска Azure](#TypeMapping).

Наконец, создайте индексатор, задав ему имя и связав источник данных с целевым индексом:

    POST https://myservice.search.windows.net/indexers?api-version=2016-09-01
    Content-Type: application/json
    api-key: admin-key

    {
        "name" : "myindexer",
        "dataSourceName" : "myazuresqldatasource",
        "targetIndexName" : "target index name"
    }

У индексатора, созданного таким образом, нет расписания. Он автоматически выполняется один раз сразу после создания. Вы можете снова выполнить его в любой момент с помощью запроса на **запуск индексатора** :

    POST https://myservice.search.windows.net/indexers/myindexer/run?api-version=2016-09-01
    api-key: admin-key

Вы можете настроить несколько аспектов поведения индексатора, например размер пакета и сколько документов можно пропустить, прежде чем выполнение индексатора завершится с ошибкой. Чтобы узнать больше, ознакомьтесь с [API создания индексатора](https://msdn.microsoft.com/library/azure/dn946899.aspx).

Вам может потребоваться разрешить службам Azure подключаться к вашей базе данных. Сведения о том, как это сделать, см. в разделе [Подключение из Azure](https://msdn.microsoft.com/library/azure/ee621782.aspx#ConnectingFromAzure).

Для наблюдения за состоянием индексатора и журналом выполнения (количество проиндексированных элементов, ошибки и т. д.) используйте запрос на получение **состояния индексатора**:

    GET https://myservice.search.windows.net/indexers/myindexer/status?api-version=2016-09-01
    api-key: admin-key

Ответ должен выглядеть так:

    {
        "@odata.context":"https://myservice.search.windows.net/$metadata#Microsoft.Azure.Search.V2015_02_28.IndexerExecutionInfo",
        "status":"running",
        "lastResult": {
            "status":"success",
            "errorMessage":null,
            "startTime":"2015-02-21T00:23:24.957Z",
            "endTime":"2015-02-21T00:36:47.752Z",
            "errors":[],
            "itemsProcessed":1599501,
            "itemsFailed":0,
            "initialTrackingState":null,
            "finalTrackingState":null
        },
        "executionHistory":
        [
            {
                "status":"success",
                "errorMessage":null,
                "startTime":"2015-02-21T00:23:24.957Z",
                "endTime":"2015-02-21T00:36:47.752Z",
                "errors":[],
                "itemsProcessed":1599501,
                "itemsFailed":0,
                "initialTrackingState":null,
                "finalTrackingState":null
            },
            ... earlier history items
        ]
    }

Журнал выполнения включает до 50 записей о недавно завершенных запусках, которые сортируются в обратном хронологическом порядке (то есть в ответе первым отображается последний запуск).
Дополнительные сведения об ответе см. [здесь](http://go.microsoft.com/fwlink/p/?LinkId=528198).

## <a name="run-indexers-on-a-schedule"></a>Запуск индексаторов по расписанию
Вы также можете организовать запуск индикатора по расписанию. Для этого добавьте свойство **schedule** при создании или обновлении индексатора. В примере ниже показан PUT- запрос для обновления индексатора:

    PUT https://myservice.search.windows.net/indexers/myindexer?api-version=2016-09-01
    Content-Type: application/json
    api-key: admin-key

    {
        "dataSourceName" : "myazuresqldatasource",
        "targetIndexName" : "target index name",
        "schedule" : { "interval" : "PT10M", "startTime" : "2015-01-01T00:00:00Z" }
    }

Параметр **interval** обязателен. Он указывает время между двумя последовательными запусками индексатора. Наименьшее допустимое значение — 5 минут, наибольшее — один день. Значение должно быть отформатировано как значение dayTimeDuration XSD (ограниченное подмножество значения [продолжительности ISO 8601](http://www.w3.org/TR/xmlschema11-2/#dayTimeDuration) ). Используется следующий шаблон: `P(nD)(T(nH)(nM))`. Примеры: `PT15M` для каждых 15 минут, `PT2H` для каждых 2 часов.

Необязательный параметр **startTime** указывает время, когда должно начаться выполнение по расписанию. Если опустить этот параметр, используется текущее время в формате UTC. Это время может быть прошедшим. В таком случае первое выполнение планируется так, как если бы индексатор не прекращал работу со времени, указанного в параметре startTime.  

Одновременно можно выполнить только один запуск выбранного индексатора. Если во время запланированного выполнения индексатор уже работает, то выполнение откладывается до следующего запланированного времени.

Для большей ясности рассмотрим пример. Предположим, мы настроили следующее почасовое расписание:

    "schedule" : { "interval" : "PT1H", "startTime" : "2015-03-01T00:00:00Z" }

Происходит следующее:

1. Первый запуск индексатора выполняется 1 марта 2015 года ровно или приблизительно в 00:00. Время в формате UTC.
2. Предположим, выполнение займет 20 минут (или иное количество времени в пределах часа).
3. Второй запуск выполняется 1 марта 2015 года ровно или приблизительно в 01:00.
4. Теперь предположим, что выполнение занимает более часа (например, 70 минут) и завершается около 2:10.
5. На часах 02:00 — время для выполнения третьего запуска. Но так как с 01:00 выполняется еще второй запуск, третий запуск пропускается. Третье выполнение начинается в 03:00.

Вы можете добавить, изменить или удалить расписание для существующего индексатора с помощью **PUT-запроса для индексатора** .

<a name="CaptureChangedRows"></a>

## <a name="capturing-new-changed-and-deleted-rows"></a>Запись новых, измененных и удаленных строк
Если таблица содержит много строк, следует использовать политику обнаружения изменений данных. Обнаружение изменений позволяет эффективно извлекать только новые или измененные строки без необходимости повторно индексировать всю таблицу.

### <a name="sql-integrated-change-tracking-policy"></a>Интегрированная политика отслеживания изменений SQL
Если база данных SQL поддерживает [отслеживание изменений](https://msdn.microsoft.com/library/bb933875.aspx), мы рекомендуем использовать **интегрированную политику отслеживания изменений SQL**. Это наиболее эффективная политика. Кроме того, она позволяет Поиску Azure выявлять удаленные строки без необходимости добавлять в таблицу отдельный столбец с информацией об обратимом удалении.

Интегрированное отслеживание изменений поддерживается, начиная со следующих версий баз данных SQL Server:

* SQL Server 2008 R2 и более поздних версий, если вы используете SQL Server на виртуальных машинах Azure.
* База данных SQL Azure 12, если вы используете базу данных SQL Azure.

При использовании интегрированной политики отслеживания изменений SQL не указывайте отдельную политику обнаружения удаления данных, так как она уже поддерживает выявление удаленных строк.

Эту политику можно использовать только с таблицами. С представлениями ее использовать невозможно. Перед использованием этой политики вам потребуется включить отслеживание изменений для используемой таблицы. Инструкции см. в разделе [Включение и отключение отслеживания изменений](https://msdn.microsoft.com/library/bb964713.aspx).

Чтобы использовать эту политику, создайте или обновите источник данных следующим образом:

    {
        "name" : "myazuresqldatasource",
        "type" : "azuresql",
        "credentials" : { "connectionString" : "connection string" },
        "container" : { "name" : "table or view name" },
        "dataChangeDetectionPolicy" : {
           "@odata.type" : "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy"
      }
    }

<a name="HighWaterMarkPolicy"></a>

### <a name="high-water-mark-change-detection-policy"></a>Политика обнаружения изменений максимального уровня
Хотя рекомендуется использовать политику интегрированного отслеживания изменений SQL, ее можно использовать только для таблиц, а не представлений. Если используются представления, то можно использовать политику верхнего предела. Эту политику можно использовать, если ваша таблица или представление содержит столбец, соответствующий следующим условиям:

* при каждой вставке указывается значение для столбца;
* при всех обновлениях элементов также изменяется значение столбца;
* значение этого столбца растет с каждым изменением;
* возможно эффективное выполнение запросов со следующими предложениями WHERE и ORDER BY: `WHERE [High Water Mark Column] > [Current High Water Mark Value] ORDER BY [High Water Mark Column]`.

Например, индексированный столбец **rowversion** идеально подходит на роль столбца максимального уровня.
Чтобы использовать эту политику, создайте или обновите источник данных следующим образом:

    {
        "name" : "myazuresqldatasource",
        "type" : "azuresql",
        "credentials" : { "connectionString" : "connection string" },
        "container" : { "name" : "table or view name" },
        "dataChangeDetectionPolicy" : {
           "@odata.type" : "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy",
           "highWaterMarkColumnName" : "[a row version or last_updated column name]"
      }
    }

> [!WARNING]
> Если исходная таблица не имеет индекс для столбца верхнего предела, то время ожидания выполнения запросов, используемых индексатором SQL, может истечь. В частности, если таблица содержит много строк, то для эффективного выполнения предложения `ORDER BY [High Water Mark Column]` требуется индекс.
>
>

Если возникают ошибки времени ожидания, можно использовать параметр конфигурации индексатора `queryTimeout`, чтобы задать время ожидания запроса, превышающее время ожидания по умолчанию, равное 5 минутам. Например, чтобы задать время ожидания, равное 10 минутам, создайте или обновите индексатор, используя приведенную ниже конфигурацию.

    {
      ... other indexer definition properties
     "parameters" : {
            "configuration" : { "queryTimeout" : "00:10:00" } }
    }

Можно также отключить предложение `ORDER BY [High Water Mark Column]`. Однако это не рекомендуется, так как в случае прерывания выполнения индексатора из-за ошибки ему придется повторно обработать все строки при последующем запуске, даже если на момент прерывания почти все из них уже были обработаны. Чтобы отключить предложение `ORDER BY`, используйте параметр `disableOrderByHighWaterMarkColumn` в определении индексатора.  

    {
     ... other indexer definition properties
     "parameters" : {
            "configuration" : { "disableOrderByHighWaterMarkColumn" : true } }
    }

### <a name="soft-delete-column-deletion-detection-policy"></a>Политика обнаружения обратимого удаления столбца
Строки, удаляемые из исходной таблицы, вероятно, также следует удалить из индекса поиска. Если вы используете интегрированную политику отслеживания изменений SQL, это происходит автоматически. Однако политика отслеживания изменений максимального уровня не затрагивает удаленные строки. Что делать?

Если строки физически удалены из таблицы, то Поиску Azure не удастся определить присутствие уже несуществующих записей.  Тем не менее можно использовать метод обратимого удаления, чтобы логически удалять строки, не удаляя их из таблицы. Добавьте специальный столбец в таблицу или представление и помечайте удаленные строки с помощью этого столбца.

При использовании метода обратимого удаления можно указать соответствующую политику во время создания или обновления источника данных:

    {
        …,
        "dataDeletionDetectionPolicy" : {
           "@odata.type" : "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy",
           "softDeleteColumnName" : "[a column name]",
           "softDeleteMarkerValue" : "[the value that indicates that a row is deleted]"
        }
    }

Параметр **softDeleteMarkerValue** должен быть строкой. Используйте строковое представление действительного значения. Например, если имеется столбец целочисленных значений, в котором удаленные строки помечаются значением 1, то следует использовать `"1"`. Если имеется битовый столбец, в котором удаленные строки помечаются логическим значением true, то следует использовать `"True"`.

<a name="TypeMapping"></a>

## <a name="mapping-between-sql-data-types-and-azure-search-data-types"></a>Сопоставление типов данных SQL и поиска Azure
| Тип данных SQL | Совместимые типы полей целевого индекса | Примечания |
| --- | --- | --- |
| bit |Edm.Boolean, Edm.String | |
| int, smallint, tinyint |Edm.Int32, Edm.Int64, Edm.String | |
| bigint |Edm.Int64, Edm.String | |
| real, float |Edm.Double, Edm.String | |
| smallmoney, money decimal numeric |Edm.String |Поиск Azure не поддерживает преобразование десятичных типов в Edm.Double, так как это отрицательно скажется на точности. |
| char, nchar, varchar, nvarchar |Edm.String<br/>Collection(Edm.String) |Для заполнения поля Collection(Edm.String) может использоваться строка SQL, если она представляет массив строк JSON: `["red", "white", "blue"]`. |
| smalldatetime, datetime, datetime2, date, datetimeoffset |Edm.DateTimeOffset, Edm.String | |
| uniqueidentifer |Edm.String | |
| geography |Edm.GeographyPoint |Поддерживаются только географические объекты типа POINT с SRID 4326 (значение по умолчанию). |
| rowversion |Недоступно |Столбцы версии строк не могут храниться в индексе поиска, но их можно использовать для отслеживания изменений. |
| time, timespan, binary, varbinary, image, xml, geometry, CLR types |Недоступно |Не поддерживается |

## <a name="configuration-settings"></a>Параметры конфигурации
Индексатор SQL предоставляет несколько параметров конфигурации.

| Настройка | Тип данных | Назначение | Значение по умолчанию |
| --- | --- | --- | --- |
| queryTimeout |строка |Задает время ожидания для выполнения запроса SQL. |5 мин ("00:05:00") |
| disableOrderByHighWaterMarkColumn |bool |Указывает SQL-запросу, используемому политикой верхнего предела, опустить предложение ORDER BY. Ознакомьтесь с [политикой верхнего предела](#HighWaterMarkPolicy). |нет |

Эти параметры используются в объекте `parameters.configuration` в определении индексатора. Например, чтобы задать время ожидания запроса, равное 10 минутам, создайте или обновите индексатор, используя приведенную ниже конфигурацию.

    {
      ... other indexer definition properties
     "parameters" : {
            "configuration" : { "queryTimeout" : "00:10:00" } }
    }

## <a name="frequently-asked-questions"></a>Часто задаваемые вопросы
**Вопрос.** Можно ли использовать индексатор Azure SQL с базами данных SQL на виртуальных машинах IaaS в Azure?

Ответ. Да. Тем не менее необходимо разрешить службе поиска подключаться к базе данных. Дополнительные сведения см. в статье [Настройка подключения из индексатора Поиска Azure к SQL Server на виртуальной машине Azure](search-howto-connecting-azure-sql-iaas-to-azure-search-using-indexers.md).

**Вопрос.** Можно ли использовать индексатор Azure SQL с локальными базами данных SQL?

Ответ. Мы не рекомендуем и не поддерживаем это, так как в таком случае вам придется открыть свои базы данных для интернет-трафика.

**Вопрос.** Можно ли использовать индексатор Azure SQL с базами данных в IaaS в Azure помимо баз SQL Server?

Ответ. Мы не поддерживаем этот сценарий, так как мы не проверяли работу индексатора с базами данных не из SQL Server.  

**Вопрос.** Можно ли создать несколько индексаторов, выполняющих обработку по расписанию?

Ответ. Да. Но на одном узле одновременно может выполнять обработку только один индексатор. Если вам требуется, чтобы одновременно работали несколько индексаторов, вы можете расширить службу поиска, добавив несколько модулей поиска.

**Вопрос.** Влияет ли выполнение индексатора на рабочую нагрузку запросов?

Ответ. Да. Индексатор выполняется на одном из узлов службы поиска, и ресурсы этого узла распределяются между выполнением индексирования, обслуживанием трафика запросов и другими запросами API. Если при выполнении интенсивных рабочих нагрузок индексирования и запросов часто отображается ошибка 503 или увеличивается время ответа, вы можете расширить службу поиска.



<!--HONumber=Nov16_HO3-->


