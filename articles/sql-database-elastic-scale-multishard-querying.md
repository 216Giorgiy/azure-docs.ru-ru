<properties title="Multi-Shard Querying" pageTitle="Многосегментное формирование запросов" description="Run queries across shards using Elastic Scale APIs." metaKeywords="sharding scaling, Azure SQL DB sharding, elastic scale, multi-shard, multishard, querying" services="sql-database" documentationCenter="" manager="jhubbard" authors="sidneyh@microsoft.com"/>

<tags ms.service="sql-database" ms.workload="sql-database" ms.tgt_pltfrm="na" ms.devlang="na" ms.topic="article" ms.date="10/02/2014" ms.author="sidneyh" />

#Многосегментное формирование запросов
**Многосегментное формирование запросов** используется для таких задач, как сбор данных и создание отчетов, требующих запуска запроса, распространяющегося на несколько сегментов. (Сравните с [маршрутизацией, зависящей от данных](./sql-database-elastic-scale-data-dependent-routing.md), когда все действия выполняются в пределах одного сегмента.) 

Клиентская библиотека эластичного масштабирования вводит новое пространство имен с названием **Microsoft.Azure.SqlDatabase.ElasticScale.Query**, предоставляющее возможность выполнять запрос к нескольким сегментам, используя один запрос и один результат. Это позволяет абстрагировать обработку запросов по набору сегментов. Также предоставляются альтернативные политики выполнения, в особенности частичные результаты для обработки сбоев при выполнении запросов по нескольким сегментам.  

Главной точкой входа в процесс многосегментного формирования запросов является класс **MultiShardConnection**. Так же, как и при маршрутизации, зависящей от данных, API использует знакомые возможности классов и методов из **[System.Data.SqlClient](http://msdn.microsoft.com/library/System.Data.SqlClient(v=vs.110).aspx)**. С помощью библиотеки **SqlClient** выполните первый шаг - создание **SqlConnection**, затем создайте **SqlCommand** для подключения, затем выполните команду, используя один из методов **Execute**. И наконец, **SqlDataReader** просматривает все наборы результатов, возвращаемые вследствие выполнения команды. При взаимодействии с многосегментным запросом API-интерфейсы выполняют следующие шаги. 

1. Создать **MultiShardConnection**.
2. Создать **MultiShardCommand** для **MultiShardConnection**.
3. Выполнить команду.
4. Использовать результаты с помощью **MultiShardDataReader**. 

Основное различие состоит в построении многосегментных подключений. Если **SqlConnection** действует в пределах одной базы данных, **MultiShardConnection** принимает ***коллекцию сегментов*** в качестве входных данных. Коллекцию сегментов можно составить по карте сегментов. После этого выполняется запрос для коллекции сегментов с использованием семантики **UNION ALL** для формирования одного общего результата. При необходимости к выходным данным можно добавить имя сегмента, из которого поступает строка, используя для команды свойство **ExecutionOptions**. В следующем примере кода показано применение многосегментного формирования запросов с использованием заданной карты **ShardMap** с именем *myShardMap*. 

    using (MultiShardConnection conn = new MultiShardConnection( 
                                        myShardMap.GetShards(), 
                                        myShardConnectionString) 
          ) 
    { 
    using (MultiShardCommand cmd = conn.CreateCommand())
           { 
            cmd.CommandText = "SELECT c1, c2, c3 FROM ShardedTable"; 
            cmd.CommandType = CommandType.Text; 
            cmd.ExecutionOptions = MultiShardExecutionOptions.IncludeShardNameColumn; 
            cmd.ExecutionPolicy = MultiShardExecutionPolicy.PartialResults; 

            using (MultiShardDataReader sdr = cmd.ExecuteReader()) 
            	{ 
                	while (sdr.Read())
                    	{ 
                        	var c1Field = sdr.GetString(0); 
                        	var c2Field = sdr.GetFieldValue<int>(1); 
                        	var c3Field = sdr.GetFieldValue<Int64>(2);
                    	} 
             	} 
           } 
    } 
 

Обратите внимание на обращение к **myShardMap.GetShards()**. С помощью этого метода все сегменты извлекаются из карты сегментов, и обеспечивается простой способ выполнения запроса по всем сегментам данной карты. Коллекцию сегментов для многосегментного запроса можно уточнить, выполнив запрос LINQ по коллекции, возвращенной в результате обращения к **myShardMap.GetShards()**. Эта возможность в многосегментном формировании запросов, в сочетании с политикой частичных результатов, разработана для применения к сегментам в количестве от десятков до сотен.
В настоящий момент существует ограничение для многосегментного формирования запросов, состоящее в отсутствии проверки для сегментов и шардлетов, к которым обращен запрос. Если при маршрутизации, зависящей от данных, выполняется проверка того, что указанный сегмент является частью карты сегментов на момент выполнения запроса, то при многосегментном формировании запросов такая проверка не происходит. Это может привести к тому, что многосегментные запросы будут обращаться к сегментам, удаленным из карты сегментов.

###Многосегментные запросы и операции разбиения-слияния

При многосегментных запросах не выполняется проверка на участие шардлетов из запрашиваемого сегмента в операциях разбиения или слияния. Это может привести к несогласованности, когда строки одного шардлета отображаются для нескольких сегментов в одном многосегментном запросе. Следует учитывать эти ограничения, фильтрование текущих операций разбиения или слияния, а также изменения карты сегментов при выполнении многосегментных запросов.

[AZURE.INCLUDE [elastic-scale-include](../includes/elastic-scale-include.md)]
