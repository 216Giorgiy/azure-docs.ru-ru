<properties
	pageTitle="Пакет SDK для устройств Azure IoT для C — IoTHubClient | Microsoft Azure"
	description="Узнайте больше об использовании библиотеки IoTHubClient из пакета SDK для устройств Azure IoT для C."
	services="iot-hub"
	documentationCenter=""
	authors="MichelBarnett"
	manager="timlt"
	editor=""/>

<tags
     ms.service="iot-hub"
     ms.devlang="cpp"
     ms.topic="article"
     ms.tgt_pltfrm="na"
     ms.workload="na"
     ms.date="09/29/2015"
     ms.author="michelb"/>

# Пакет SDK для устройств Microsoft Azure IoT для C — дополнительные сведения о библиотеке IoTHubClient

В [первой статье](iot-hub-device-sdk-c-intro.md) курса вы познакомились с **пакетом SDK для устройств Microsoft Azure IoT для C**. В ней объяснялось, что в пакете SDK есть два архитектурных уровня. В основе лежит библиотека **IoTHubClient**, которая непосредственно управляет связью с центром IoT (IoT — «Интернет вещей»). На втором уровне находится библиотека **serializer**, которая реализована поверх упомянутой выше и предоставляет службы сериализации. В данной статье мы раскроем дополнительные подробности о библиотеке **IoTHubClient**.

В предыдущей статье мы рассказали, как с помощью библиотеки **IoTHubClient** отправлять события в центр IoT и получать из него сообщения. В данной статье мы продолжим обсуждение этой темы. Мы объясним, как можно с большей точностью управлять *временем* отправки и получения данных, используя **интерфейсы API нижнего уровня**. Также мы объясним, как прикреплять свойства к событиям (и извлекать их из сообщений) с помощью функций обработки свойств в библиотеке **IoTHubClient**. Кроме того, мы предоставим дополнительное описание различных способов обработки сообщений, полученных из центра IoT.

В конце статьи будет раскрыто несколько других тем, включая дополнительные сведения об учетных данных устройства и о том, как изменять поведение **IoTHubClient** через параметры конфигурации.

Чтобы раскрыть эти темы на должном уровне, мы будем использовать образцы из пакета SDK для библиотеки **IoTHubClient**. Если вы хотите сразу же проверять все, о чем мы рассказываем, найдите приложения **iothub\_client\_sample\_http** и **iothub\_client\_sample\_amqp**. Они входят в пакет SDK для устройств Azure IoT для C. Все, что описано ниже, продемонстрировано именно в этих примерах.

## Интерфейсы API нижнего уровня

В предыдущей статье мы описали основные операции библиотеки **IotHubClient** в контексте приложения **iothub\_client\_sample\_amqp**. В частности, мы объяснили, как инициализировать библиотеку с помощью следующего кода.

```
IOTHUB_CLIENT_HANDLE iotHubClientHandle;
iotHubClientHandle = IoTHubClient_CreateFromConnectionString(connectionString, AMQP_Protocol);
```

Мы рассказали, как отправлять события с помощью вызова функции.

```
IoTHubClient_SendEventAsync(iotHubClientHandle, message.messageHandle, SendConfirmationCallback, &message);
```

Также мы описали, как получать сообщения путем регистрации функции обратного вызова.

```
int receiveContext = 0;
IoTHubClient_SetMessageCallback(iotHubClientHandle, ReceiveMessageCallback, &receiveContext);
```

Мы не обошли стороной и вопрос освобождения ресурсов.

```
IoTHubClient_Destroy(iotHubClientHandle);
```

Для каждого из этих интерфейсов API существуют сопутствующие функции:

-   IoTHubClient\_LL\_CreateFromConnectionString;

-   IoTHubClient\_LL\_SendEventAsync;

-   IoTHubClient\_LL\_SetMessageCallback;

-   IoTHubClient\_LL\_Destroy.


В имени API всех этих функций содержатся символы LL (Lower Level — нижний уровень). За исключением этого, параметры каждой из этих функций идентичны аналогам без символов LL. Однако в работе этих функций есть одна важная особенность.

При вызове **IoTHubClient\_CreateFromConnectionString** базовые библиотеки создают новый поток, выполняемый в фоновом режиме. Этот поток обрабатывает отправку событий в центр IoT и прием сообщений из него. При работе с интерфейсами API нижнего уровня (LL) такой поток не создается. Создание фонового потока — это удобный инструмент для разработчиков. Вам не нужно беспокоиться о явной отправке событий и получении сообщений из центра IoT — это происходит автоматически в фоновом режиме. Напротив, интерфейсы API нижнего уровня (LL) позволяют вам контролировать обмен данными с центром IoT, если вам это необходимо.

Чтобы лучше понять это, рассмотрим пример.

При вызове **IoTHubClient\_SendEventAsync** вы фактически помещаете событие в буфер. Фоновый поток, созданный при вызове **IoTHubClient\_CreateFromConnectionString**, постоянно отслеживает этот буфер и отправляет любые содержащиеся в нем данные в центр IoT. Это происходит в фоновом режиме в то же время, когда основной поток выполняет другую работу.

Аналогичным образом когда вы регистрируете функцию обратного вызова для сообщений с помощью **IoTHubClient\_SetMessageCallback**, вы указываете пакету SDK, что фоновый поток должен вызвать функцию обратного вызова, когда будет получено сообщение. Независимо от того, что в это время будет делать основной поток.

Интерфейсы API нижнего уровня не создают фоновый поток. Вместо этого для явной отправки и получения данных из центра IoT необходимо вызывать новый интерфейс API. Давайте рассмотрим еще один пример.

Приложение **Iothub\_client\_sample\_http**, включенное в пакет SDK, демонстрирует интерфейсы API нижнего уровня. В этом примере мы отправляем события в центр IoT с помощью следующего кода.

```
EVENT_INSTANCE message;
sprintf_s(msgText, sizeof(msgText), "Message_%d_From_IoTHubClient_LL_Over_HTTP", i);
message.messageHandle = IoTHubMessage_CreateFromByteArray((const unsigned char*)msgText, strlen(msgText));

IoTHubClient_LL_SendEventAsync(iotHubClientHandle, message.messageHandle, SendConfirmationCallback, &message)
```

Первые три строки создают сообщение, а последняя строка отправляет событие. Тем не менее, как было сказано выше, «отправка» события означает, что данные просто помещаются в буфер. При вызове **IoTHubClient\_LL\_SendEventAsync** ничего не передается по сети. Чтобы фактически передать данные в центр IoT, вам необходимо вызвать **IoTHubClient\_LL\_DoWork**, как в следующем примере.

```
while (1)
{
    IoTHubClient_LL_DoWork(iotHubClientHandle);
    ThreadAPI_Sleep(1000);
}
```

Этот фрагмент кода (из приложения **iothub\_client\_sample\_http**) постоянно вызывает функцию **IoTHubClient\_LL\_DoWork**. При каждом вызове функции **IoTHubClient\_LL\_DoWork** она отправляет некоторые события из буфера в центр IoT и получает сообщение из очереди, отправляемое на устройство. В последнем случае это означает, что если мы зарегистрировали функцию обратного вызова для сообщений, то задействуется обратный вызов (предполагается, что в очереди есть сообщения). Такую функцию обратного вызова мы зарегистрируем с помощью следующего кода:

```
IoTHubClient_LL_SetMessageCallback(iotHubClientHandle, ReceiveMessageCallback, &receiveContext)
```

Причина частого циклического вызова **IoTHubClient\_LL\_DoWork** в том, что при каждом вызове этой функции она отправляет *некоторые* буферизованные события в центр IoT и извлекает *следующее* сообщение из очереди для устройства. Отправка всех буферизованных событий каждым вызовом или получение всех сообщений из очереди не гарантируется. Если вам нужно отправить все события из буфера, а затем заняться другой обработкой, замените упомянутый выше цикл следующим кодом.

```
IOTHUB_CLIENT_STATUS status;

while ((IoTHubClient_LL_GetSendStatus(iotHubClientHandle, &status) == IOTHUB_CLIENT_OK) && (status == IOTHUB_CLIENT_SEND_STATUS_BUSY))
{
    IoTHubClient_LL_DoWork(iotHubClientHandle);
    ThreadAPI_Sleep(1000);
}
```

Эта логика вызывает **IoTHubClient\_LL\_DoWork** до тех пор, пока все события из буфера не будут отправлены в центр IoT. Обратите внимание: это не означает, что все сообщения из очереди получены. Частично причина кроется в том, что проверка «всех» сообщений не является очень детерминированным действием. Что произойдет, если вы извлечете «все» сообщения, но сразу же после этого на устройство будет отправлено еще одно? Лучше такие моменты решать через запрограммированное время ожидания. Например, функция обратного вызова сообщений может сбрасывать таймер при каждом вызове. Затем можно написать логику для продолжения обработки, если, например, ни одно сообщение не было получено за последние X секунд.

После завершения передачи событий и получения сообщений не забудьте вызвать функцию для очистки ресурсов.

```
IoTHubClient_LL_Destroy(iotHubClientHandle);
```

Это все. По сути существует один набор интерфейсов API для отправки и получения данных в фоновом потоке и другой набор API, который делает то же самое без фонового потока. Многие разработчики предпочитают интерфейсы API, не относящие к нижнему уровню. Тем не менее, API нижнего уровня полезны, когда разработчику нужно контролировать передачу данных по сети. Например, некоторые устройства собирают данные в течение продолжительного периода и передают события только через заданные интервалы времени (например, раз в час или раз в день). Интерфейсы API нижнего уровня позволяют вам четко контролировать, когда будут отправляться и приниматься данные из центра IoT. Другие разработчики предпочитают простоту интерфейсов API нижнего уровня: все выполняется в основном потоке, не в фоновом.

Выбрав ту или иную модель, обязательно используйте соответствующие API. Если вы начнете с вызова **IoTHubClient\_LL\_CreateFromConnectionString**, в последующей работе используйте только соответствующие API-интерфейсы нижнего уровня:

-   IoTHubClient\_LL\_SendEventAsync;

-   IoTHubClient\_LL\_SetMessageCallback;

-   IoTHubClient\_LL\_Destroy;

-   IoTHubClient\_LL\_DoWork.

И наоборот: если вы начали с **IoTHubClient\_CreateFromConnectionString**, то для любой дополнительной обработки используйте интерфейсы API, не относящиеся к нижнему уровню.

В пакете SDK для устройств Azure IoT для языка C найдите приложение **iothub\_client\_sample\_http**, в котором содержится полный пример использования интерфейсов API нижнего уровня. В приложении **iothub\_client\_sample\_amqp** служит полным примером использования интерфейсов API, не относящихся к нижнему уровню.

## Обработка свойств

До сих пор для описания отправки данных мы использовали текст сообщения. Рассмотрим для примера такой фрагмент кода:

```
EVENT_INSTANCE message;
sprintf_s(msgText, sizeof(msgText), "Hello World");
message.messageHandle = IoTHubMessage_CreateFromByteArray((const unsigned char*)msgText, strlen(msgText));
IoTHubClient_LL_SendEventAsync(iotHubClientHandle, message.messageHandle, SendConfirmationCallback, &message)
```

Этот код отправляет в центр IoT сообщение с текстом «Hello World». Но центр IoT также позволяет к каждому сообщению прикреплять свойства. Свойства — это просто пары «имя — значение», которые можно присоединять к сообщению. Например, мы можем прикрепить свойство к сообщению, изменив приведенный выше код.

```
MAP_HANDLE propMap = IoTHubMessage_Properties(message.messageHandle);
sprintf_s(propText, sizeof(propText), "%d", i);
Map_AddOrUpdate(propMap, "SequenceNumber", propText);
```

Сначала мы вызываем функцию **IoTHubMessage\_Properties** и передаем ей дескриптор нашего сообщения. Обратно мы получаем ссылку **MAP\_HANDLE**, которая позволяет добавлять свойства. Для добавления свойств мы вызываем метод **Map\_AddOrUpdate**, который принимает ссылку на MAP\_HANDLE, имя свойства и значение свойства. С помощью этого API мы можем добавить сколько угодно свойств.

Когда событие считывается из **концентратора событий**, получатель может перечислить свойства и извлечь их соответствующие значения. Например, в среде .NET это можно реализовать путем обращения к [коллекции свойств в объекте EventData](https://msdn.microsoft.com/library/microsoft.servicebus.messaging.eventdata.properties.aspx).

В приведенном выше примере мы прикрепляем свойства к событию, которое отправляем в центр IoT. Но свойства можно также прикреплять к сообщениям, получаемым из центра IoT. Чтобы извлечь свойства из сообщения, в функции обратного вызова сообщения используйте следующий код.

```
static IOTHUBMESSAGE_DISPOSITION_RESULT ReceiveMessageCallback(IOTHUB_MESSAGE_HANDLE message, void* userContextCallback)
{
    . . .

    // Retrieve properties from the message
    MAP_HANDLE mapProperties = IoTHubMessage_Properties(message);
    if (mapProperties != NULL)
    {
        const char*const* keys;
        const char*const* values;
        size_t propertyCount = 0;
        if (Map_GetInternals(mapProperties, &keys, &values, &propertyCount) == MAP_OK)
        {
            if (propertyCount > 0)
            {
                printf("Message Properties:\r\n");
                for (size_t index = 0; index < propertyCount; index++)
                {
                    printf("\tKey: %s Value: %s\r\n", keys[index], values[index]);
                }
                printf("\r\n");
            }
        }
    }

    . . .
}
```

Вызов **IoTHubMessage\_Properties** дает нам ссылку **MAP\_HANDLE**, которую мы передаем в метод **Map\_GetInternals**, чтобы получить ссылку на массив пар «имя — значение» (и количество свойств). На этом этапе для получения нужных значений достаточно просто перебрать свойства.

Вам не обязательно использовать свойства в своем приложении, но если вам нужно указывать их для событий или получать из сообщений, с библиотекой **IoTHubClient** сделать это будет просто.

## Обработка сообщений

Ранее мы рассказывали, что, когда сообщения поступают из центра IoT, библиотека **IoTHubClient** отвечает вызовом зарегистрированной функции обратного вызова. У этой функции есть параметр возврата, который требует дополнительного пояснения. Вот фрагмент функции обратного вызова из приложения **iothub\_client\_sample\_http**:

```
static IOTHUBMESSAGE_DISPOSITION_RESULT ReceiveMessageCallback(IOTHUB_MESSAGE_HANDLE message, void* userContextCallback)
{
	. . .
    return IOTHUBMESSAGE_ACCEPTED;
}
```

Обратите внимание, что тип возврата — **IOTHUBMESSAGE\_DISPOSITION\_RESULT**, а в данном случае мы возвращаем **IOTHUBMESSAGE\_ACCEPTED**. Оказывается, из этой функции мы можем возвращать другие значения, которые изменяют способ реакции библиотеки **IoTHubClient** на обратный вызов сообщения. Вот эти другие значения:

-   **IOTHUBMESSAGE\_ACCEPTED** — сообщение успешно обработано. Библиотека **IoTHubClient** не будет вызывать функцию обратного вызова еще раз для того же сообщения.

-   **IOTHUBMESSAGE\_REJECTED** — сообщение не обработано и обрабатываться не будет. Библиотеке **IoTHubClient** не нужно вызывать функцию обратного вызова еще раз для того же сообщения.

-   **IOTHUBMESSAGE\_ABANDONED** — сообщение не удалось обработать. Библиотека **IoTHubClient** должна вызвать функцию обратного вызова еще раз для того же сообщения.

Для первых двух кодов возврата библиотека **IoTHubClient** отправляет сообщение в центр IoT, указывая, что сообщение следует удалить из очереди устройства и не доставлять повторно. Совокупный эффект оказывается таким же (сообщение удаляется из очереди устройства), но все так же делается запись о том, было ли сообщение принято или отклонено. Такая запись полезна для отправителей сообщения, которые принимают обратную связь, чтобы выяснить, приняло ли устройство определенное сообщение или отклонило.

Если сообщение отклонено, оно также отправляется в центр IoT, но при этом указывается, что сообщение следует доставить повторно. Обычно отказ от сообщения выполняется тогда, когда возникла какая-то ошибка, но при этом то же сообщение нужно попытаться обработать снова. С другой стороны, отклонение сообщения уместно при возникновении неустранимой ошибки (или если вы просто определили, что это сообщение не нужно обрабатывать).

В любом случае просто помните о различных кодах возврата, позволяющих обеспечить требуемое поведение библиотеки **IoTHubClient**.

## Альтернативные учетные данные устройств

Как отмечалось ранее, первое, что нам необходимо сделать при работе с библиотекой **IoTHubClient**, — это получить дескриптор **IOTHUB\_CLIENT\_HANDLE** с помощью такого вызова:

```
IOTHUB_CLIENT_HANDLE iotHubClientHandle;
iotHubClientHandle = IoTHubClient_CreateFromConnectionString(connectionString, AMQP_Protocol);
```

По сути, аргументами **IoTHubClient\_CreateFromConnectionString** выступают строка подключения устройства и параметр, указывающий протокол, который мы будем использовать для связи с центром IoT. Строка подключения имеет следующий формат:

> HostName=IOTHUBNAME.IOTHUBSUFFIX;DeviceId=DEVICEID;SharedAccessKey=SHAREDACCESSKEY

Здесь фактически указаны четыре значения: имя центра IoT, суффикс центра IoT, идентификатор устройства и ключ общего доступа. При создании экземпляра центра IoT на портале управления Azure вы получаете полное доменное имя (FQDN) центра IoT. Из этого имени мы получаем имя центра IoT (первая часть FQDN) и суффикс центра IoT (остальная часть FQDN). Идентификатор устройства и ключ общего доступа получаются при регистрации устройства в центре IoT (см. [предыдущую статью](iot-hub-device-sdk-c-intro.md)).

**IoTHubClient\_CreateFromConnectionString** — это всего лишь один из способов инициализации библиотеки. При желании вы можете создать новый дескриптор **IOTHUB\_CLIENT\_HANDLE**, используя вместо строки подключения отдельные параметры. Для этого используется такой код:

```
IOTHUB_CLIENT_CONFIG iotHubClientConfig;
iotHubClientConfig.iotHubName = "";
iotHubClientConfig.deviceId = "";
iotHubClientConfig.deviceKey = "";
iotHubClientConfig.iotHubSuffix = "";
iotHubClientConfig.protocol = HTTP_Protocol;
IOTHUB_CLIENT_HANDLE iotHubClientHandle = IoTHubClient_LL_Create(&iotHubClientConfig);
```

Этот код выполняет то же самое, что и **IoTHubClient\_CreateFromConnectionString**.

Вы, вероятно, решите, что использовать **IoTHubClient\_CreateFromConnectionString** удобнее, чем такой подробный метод инициализации. Но не стоит забывать, что при регистрации устройства в центре IoT мы получаем только идентификатор и ключ устройства (а не строку подключения). Пакет SDK для **диспетчера устройств**, который мы упоминали в [предыдущей статье](iot-hub-device-sdk-c-intro.md), создает строку подключения на основе идентификатора устройства, ключа устройства и имени узла центра IoT с помощью библиотек из пакета **SDK для службы Azure IoT**. Поэтому метод с вызовом **IoTHubClient\_LL\_Create** может быть предпочтительнее, так как он позволяет исключить этап создания строки подключения. Используйте тот метод, который для вас удобнее.

## Варианты настройки

До сих пор все описываемые способы работы библиотеки **IoTHubClient** отражали ее стандартное поведение. Однако существует несколько параметров, позволяющих изменить то, как работает библиотека. Для этого используется API **IoTHubClient\_LL\_SetOption**. Рассмотрим следующий пример.

```
unsigned int timeout = 30000;
IoTHubClient_LL_SetOption(iotHubClientHandle, "timeout", &timeout);
```

Существует несколько часто используемых параметров:

-   **SetBatching** (логического значение). Если значение равно True, данные, отправляемые в центр IoT, передаются пакетами. При значении False сообщения отправляются по отдельности. Значение по умолчанию — False.

-   **Timeout** (целое число без знака). Это значение обозначает миллисекунды. Если отправка HTTP-запроса или прием ответа выполняется дольше этого времени, время ожидания соединения заканчивается.

С параметром пакетной обработки важно ознакомиться более тщательно. По умолчанию библиотека передает события по отдельности (одно событие — это то, что вы передаете в **IoTHubClient\_LL\_SendEventAsync**). Но если параметр пакетной обработки имеет значение True, библиотека постарается собрать из буфера максимальное число событий (вплоть до максимального размера сообщения, который принимается центром IoT). Пакет событий отправляется в центр IoT за один вызов HTTP (отдельные события объединяются в массив JSON). Включение пакетной обработки обычно позволяет существенно увеличить производительность, так как уменьшается число сетевых циклов приема и передачи. При этом также существенно экономится пропускная способность, так как вы отправляете с пакетом событий только один набор заголовков HTTP, а не отдельный набор заголовков для каждого отдельного события. Мы рекомендуем включить пакетную обработку при условии, что у вас нет веских причин поступать иначе.

## Дальнейшие действия

В этой статье подробно описывается работа библиотеки **IoTHubClient**, содержащейся в **пакете SDK для устройств Azure IoT для C**. Эти сведения позволят вам хорошо изучить возможности библиотеки **IoTHubClient**. В [следующей статье](iot-hub-device-sdk-c-serializer.md) мы подробно расскажем о библиотеке **serializer**.

<!---HONumber=Oct15_HO3-->