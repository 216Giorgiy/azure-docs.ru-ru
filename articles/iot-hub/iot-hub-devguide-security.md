<properties
 pageTitle="Руководство разработчика. Управление доступом к Центру Интернета вещей | Microsoft Azure"
 description="Руководство разработчика по Центру Интернета вещей Azure. Управление доступом к Центру Интернета вещей и безопасностью"
 services="iot-hub"
 documentationCenter=".net"
 authors="dominicbetts"
 manager="timlt"
 editor=""/>

<tags
 ms.service="iot-hub"
 ms.devlang="multiple"
 ms.topic="article"
 ms.tgt_pltfrm="na"
 ms.workload="na"
 ms.date="09/30/2016" 
 ms.author="dobett"/>


# <a name="control-access-to-iot-hub"></a>Управление доступом к Центру Интернета вещей

## <a name="overview"></a>Обзор

В этой статье описаны возможности защиты Центра Интернета вещей. Центр Интернета вещей использует *разрешения* для предоставления доступа к каждой из своих конечных точек. Разрешения ограничивают доступ к центру IoT на основе функций.

Содержание статьи

- Различные разрешения, которые можно предоставить устройству или серверному приложению для доступа к Центру Интернета вещей.
- Процесс аутентификации и маркеры, используемые для проверки разрешений.
- Определение области действия учетных данных для ограничения доступа к определенным ресурсам.
- Поддержка сертификатов X.509 в Центре Интернета вещей.
- Механизмы настраиваемой аутентификации устройства, использующие существующие реестры удостоверений устройств или схемы аутентификации.

### <a name="when-to-use"></a>Сценарии использования

Для доступа к любой конечной точке Центра Интернета вещей необходимы соответствующие разрешения. Например, устройство должно содержать маркер с учетными данными безопасности, а также все сообщения, отправленные в Центр Интернета вещей.

## <a name="access-control-and-permissions"></a>Контроль доступа и разрешений

Предоставить [разрешения](#iot-hub-permissions) можно следующими способами:

* **Политики общего доступа на уровне концентратора**. Политики общего доступа могут предоставлять любое сочетание [разрешений](#iot-hub-permissions). Политики можно задавать на [портале Azure][lnk-management-portal] или программным путем, используя [интерфейсы API поставщика ресурсов Центра Интернета вещей Azure][lnk-resource-provider-apis]. По умолчанию для только что созданного центра IoT заданы такие политики:

    - **iothubowner**: политика со всеми разрешениями;
    - **service**: политика с разрешением ServiceConnect;
    - **device**: политика с разрешением DeviceConnect;
    - **registryRead**: политика с разрешением RegistryRead;
    - **registryReadWrite**: политика с разрешениями RegistryRead и RegistryWrite.


* **Учетные данные безопасности на уровне отдельного устройства**. Каждый Центр Интернета вещей содержит [реестр удостоверений устройств][lnk-identity-registry]. Для каждого устройства в этом реестре вы можете задать учетные данные безопасности, дающие вам разрешения **DeviceConnect** , которые соответствуют конечным точкам устройств.

Например, в стандартном решении IoT:
- Компонент управления устройством использует политику *registryReadWrite* .
- Компонент обработчика событий использует политику *service* .
- Компонент бизнес-логики устройства среды выполнения использует политику *service* .
- Отдельные устройства подключаются с помощью учетных данных, которые хранятся в реестре удостоверений центра IoT.

## <a name="authentication"></a>Аутентификация

Центр Azure IoT предоставляет доступ к конечным точкам, проверяя маркер на соответствие политикам общего доступа и учетным данным безопасности в реестре удостоверений устройств.

Учетные данные безопасности, например симметричные ключи, никогда не отправляются по сети.

> [AZURE.NOTE] Безопасность для поставщика ресурсов Центра Интернета вещей Azure обеспечивается с помощью подписки Azure (это касается всех поставщиков в [Azure Resource Manager][lnk-azure-resource-manager]).

Дополнительные сведения о способах создания и использования маркеров безопасности см. в разделе [Маркеры безопасности Центра Интернета вещей][lnk-sas-tokens].

### <a name="protocol-specifics"></a>Особенности протокола

Каждый поддерживаемый протокол, например MQTT, AMQP и HTTP, передает маркеры разными способами.

При использовании протокола MQTT пакет CONNECT содержит код deviceId как значение ClientId, {iothubhostname}/{deviceId} в поле "Имя пользователя", а маркер SAS — в поле "Пароль". {iothubhostname} — это полная запись CName Центра Интернета вещей (например, contoso.azure-devices.net).

При использовании [AMQP][lnk-amqp] Центр Интернета вещей поддерживает механизм [SASL PLAIN][lnk-sasl-plain] и [стандарт защиты AMQP на основе утверждений][lnk-cbs].

Стандарт защиты AMQP на основе утверждений определяет, как следует передавать эти маркеры.

Для SASL PLAIN **имя пользователя** может быть следующим:

* `{policyName}@sas.root.{iothubName}` — при использовании маркеров уровня концентратора;
* `{deviceId}@sas.{iothubname}` — при использовании маркеров уровня устройства.

В обоих случаях поле пароля содержит маркер, как описано в разделе [Маркеры безопасности Центра Интернета вещей][lnk-sas-tokens].

Протокол HTTP реализует аутентификацию посредством включения допустимого маркера в заголовок запроса **авторизации** .

#### <a name="example"></a>Пример

Имя пользователя (значение DeviceId следует вводить с учетом регистра): `iothubname.azure-devices.net/DeviceId`

Пароль (создание SAS с помощью обозревателя устройств): `SharedAccessSignature sr=iothubname.azure-devices.net%2fdevices%2fDeviceId&sig=kPszxZZZZZZZZZZZZZZZZZAhLT%2bV7o%3d&se=1487709501`

> [AZURE.NOTE] [Пакеты SDK Центра Интернета вещей Azure][lnk-sdks] автоматически создают маркеры при подключении к службе. В некоторых случаях пакеты SDK поддерживают не все протоколы или не все методы проверки подлинности.

### <a name="special-considerations-for-sasl-plain"></a>Специальные рекомендации для SASL PLAIN

При использовании SASL PLAIN с протоколом AMQP клиент, подключающийся к Центру Интернета вещей, может использовать по одному маркеру для каждого TCP-подключения. Когда срок действия маркера истекает, TCP-подключение к службе прерывается и выполняется попытка повторного подключения. Хотя это поведение и не является проблематичным для серверного компонента приложения, оно может навредить приложению на стороне устройства по следующим причинам.

*  Шлюзы обычно подключаются от имени многих устройств. Если используется SASL PLAIN, шлюзам нужно создать отдельное TCP-подключение для каждого устройства, подключающегося к центру IoT. Этот сценарий значительно повышает потребление электроэнергии и сетевых ресурсов и увеличивает задержку подключения устройства.
* Если потребление ресурсов увеличится, устройства с ограниченными ресурсами должны будут выполнять повторное подключение после истечения срока действия маркера.

## <a name="scope-hub-level-credentials"></a>Определение области действия учетных данных на уровне концентратора

Чтобы определить область действия для политик безопасности на уровне концентратора, создайте маркеры с помощью универсального кода (URI) ограниченного ресурса. Например, конечная точка для отправки сообщений с устройства в облако — **/devices/{deviceId}/messages/events**. Кроме того, вы можете использовать политику общего доступа на уровне концентратора с разрешениями **DeviceConnect**. С ее помощью можно подписать маркер, значение resourceURI которого — **/devices/{deviceId}**. В результате такого подхода создается маркер, который можно использовать только для отправки сообщений от имени устройства с кодом **deviceId**.

Этот механизм похож на [политику издателя концентраторов событий][lnk-event-hubs-publisher-policy]. Он позволяет реализовать методы настраиваемой аутентификации.

## <a name="security-tokens"></a>Маркеры безопасности Центра Интернета вещей

Центр IoT использует маркеры безопасности для проверки подлинности устройств и служб, чтобы избежать отправки ключей по сети. Кроме того, маркеры безопасности ограничены по времени и области действия. [Пакеты SDK Центра Интернета вещей Azure][lnk-sdks] автоматически создают маркеры без специальной настройки. Однако в некоторых случаях требуется, чтобы пользователь напрямую создал и использовал маркеры. В их число входит непосредственное использование поверхностей MQTT, AMQP или HTTP или реализация схемы службы маркеров, как описано в разделе [Настраиваемая аутентификация устройства][lnk-custom-auth].

Центр Интернета вещей также позволяет устройствам использовать [сертификаты X.509][lnk-x509] для аутентификации с помощью Центра Интернета вещей. 

### <a name="security-token-structure"></a>Структура маркера безопасности
Маркеры безопасности используются для предоставления устройствам и службам ограниченного по времени доступа к определенным функциям в центре IoT. Чтобы гарантировать подключение только авторизованных устройств и служб, маркеры безопасности должны быть подписаны с помощью ключа политики общего доступа или симметричного ключа, сохраненного с удостоверением устройства в реестре удостоверений.

Маркер, подписанный с помощью ключа политики общего доступа, предоставляет доступа ко всем функциям, связанным с разрешениями политики общего доступа. С другой стороны, маркер, подписанный с помощью симметричного ключа удостоверения устройства, предоставляет только разрешение **DeviceConnect** для связанного удостоверения устройства.

Маркер безопасности имеет следующий формат:

    SharedAccessSignature sig={signature-string}&se={expiry}&skn={policyName}&sr={URL-encoded-resourceURI}

Это ожидаемые значения:

| Значение | Описание |
| ----- | ----------- |
| {signature} | Строка подписи HMAC-SHA256 формата `{URL-encoded-resourceURI} + "\n" + expiry`. **Важно!**Ключ шифруется в кодировке base64 и используется для вычислений HMAC-SHA256. |
| {resourceURI} | Начинающийся с имени узла центра IoT (без протокола) префикс URI (по сегменту) для конечных точек, доступ к которым можно получить с помощью этого маркера. Например, `myHub.azure-devices.net/devices/device1` |
| {expiry} | Строки в формате UTF8, отображающие количество секунд с начала эры 00:00:00 (в формате UTC) 1 января 1970 г. |
| {URL-encoded-resourceURI} | Строчное URL-кодирование строчного URL ресурса |
| {policyName} | Имя политики общего доступа, к которой относится этот маркер. Отсутствует, если маркеры относятся к учетным данным реестра устройства. |

**Обратите внимание**, что префикс универсального кода ресурса (URI) вычисляется по сегменту, а не по символу. Например, `/a/b` — это префикс для `/a/b/c`, а не для `/a/bc`.

Ниже указана функция Node.js, вычисляющая маркер на основе входных данных `resourceUri, signingKey, policyName, expiresInMins`. В следующих разделах показано, как инициализировать различные входные данные для различных сценариев использования маркеров.

    var crypto = require('crypto');

    var generateSasToken = function(resourceUri, signingKey, policyName, expiresInMins) {
        resourceUri = encodeURIComponent(resourceUri.toLowerCase()).toLowerCase();

        // Set expiration in seconds
        var expires = (Date.now() / 1000) + expiresInMins * 60;
        expires = Math.ceil(expires);
        var toSign = resourceUri + '\n' + expires;

        // using crypto
        var decodedPassword = new Buffer(signingKey, 'base64').toString('binary');
        const hmac = crypto.createHmac('sha256', decodedPassword);
        hmac.update(toSign);
        var base64signature = hmac.digest('base64');
        var base64UriEncoded = encodeURIComponent(base64signature);

        // construct autorization string
        var token = "SharedAccessSignature sr=" + resourceUri + "&sig="
        + base64UriEncoded + "&se=" + expires;
        if (policyName) token += "&skn="+policyName;
        // console.log("signature:" + token);
        return token;
    };
 
 Для сравнения ниже приведен аналогичный код Python:
 
    from base64 import b64encode, b64decode
    from hashlib import sha256
    from hmac import HMAC
    from urllib import urlencode
    
    def generate_sas_token(uri, key, policy_name='device', expiry=3600):
        ttl = time() + expiry
        sign_key = "%s\n%d" % (uri, int(ttl))
        signature = b64encode(HMAC(b64decode(key), sign_key, sha256).digest())
     
        return 'SharedAccessSignature ' + urlencode({
            'sr' :  uri,
            'sig': signature,
            'se' : str(int(ttl)),
            'skn': policy_name
        })

> [AZURE.NOTE] Поскольку срок действия маркера проверяется на компьютерах центра IoT, важно обеспечить минимальное смещение на часах компьютера, где создается маркер.

### <a name="use-sas-tokens-in-a-device-client"></a>Использование маркеров SAS в клиенте устройства

Существует два способа получения разрешений **DeviceConnect** для Центра Интернета вещей с маркерами безопасности: с помощью [ключа удостоверения устройства](#use-a-symmetric-key-in-the-identity-registry) или [ключа политики общего доступа](#use-a-shared-access-policy).

Помните, что все функциональные возможности, доступные с устройств, намеренно предоставляются в конечных точках с префиксом `/devices/{deviceId}`.

> [AZURE.IMPORTANT] Единственный способ проверки подлинности конкретного устройства в центре IoT предполагает использование симметричного ключа удостоверения устройства. В случаях, когда для доступа к функциям устройства применяется политика общего доступа, решение должно считать компонент, который выдает маркер безопасности, доверенным компонентом.

Далее указаны конечные точки, доступные с устройства (вне зависимости от протокола).

| Конечная точка | Функции |
| ----- | ----------- |
| `{iot hub host name}/devices/{deviceId}/messages/events` | Отправка сообщений с устройства в облако. |
| `{iot hub host name}/devices/{deviceId}/devicebound` | Получение сообщений из облака на устройство. |

### <a name="use-a-symmetric-key-in-the-identity-registry"></a>Использование симметричного ключа в реестре удостоверений

Если для создания маркера используется симметричный ключ удостоверения устройства, то элемент policyName (`skn`) пропускается.

Например, маркер, созданный для доступа ко всем функциям устройства, должен иметь следующие параметры:

* универсальный код ресурса (URI): `{IoT hub name}.azure-devices.net/devices/{device id}`;
* ключ подписывания: любой симметричный ключ для удостоверения `{device id}` ;
* имя политики не требуется;
* время окончания срока действия.

Далее приведен пример использования функции Node:

    var endpoint ="myhub.azure-devices.net/devices/device1";
    var deviceKey ="...";

    var token = generateSasToken(endpoint, deviceKey, null, 60);

Результат, предоставляющий доступ ко всем возможностям устройства device1, будет иметь следующий вид:

    SharedAccessSignature sr=myhub.azure-devices.net%2fdevices%2fdevice1&sig=13y8ejUk2z7PLmvtwR5RqlGBOVwiq7rQR3WZ5xZX3N4%3D&se=1456971697

> [AZURE.NOTE] Можно создать маркер безопасности с помощью инструмента .NET [Обозреватель устройств][lnk-device-explorer].

### <a name="use-a-shared-access-policy"></a>Использование политики общего доступа

При создании маркера из политики общего доступа в поле имени политики `skn` должно быть указано имя используемой политики. Также требуется, чтобы эта политика предоставляла разрешение **DeviceConnect** .

Существует два основных сценария использования политик общего доступа для доступа к возможностям устройств:

* [облачные шлюзы протоколов][lnk-endpoints];
* [службы маркеров][lnk-custom-auth], используемые для реализации настраиваемых схем аутентификации.

Так как политика общего доступа может предоставлять доступ для подключения в качестве любого устройства, при создании маркеров безопасности важно использовать правильный URI ресурса. Этот момент имеет особое значение для служб маркеров, которые должны определять область действия маркера для конкретного устройства с помощью URI ресурса. Он менее критичен для шлюзов протоколов, так как они уже обрабатывают трафик для всех устройств.

Например, служба маркеров, использующая предварительно созданную политику общего доступа с именем **device** , создаст маркер со следующими параметрами:

* универсальный код ресурса (URI): `{IoT hub name}.azure-devices.net/devices/{device id}`;
* ключ подписывания: один из ключей политики `device` ;
* имя политики: `device`;
* время окончания срока действия.

Далее приведен пример использования функции Node:

    var endpoint ="myhub.azure-devices.net/devices/device1";
    var policyName = 'device';
    var policyKey = '...';

    var token = generateSasToken(endpoint, policyKey, policyName, 60);

Результат, предоставляющий доступ ко всем возможностям устройства device1, будет иметь следующий вид:

    SharedAccessSignature sr=myhub.azure-devices.net%2fdevices%2fdevice1&sig=13y8ejUk2z7PLmvtwR5RqlGBOVwiq7rQR3WZ5xZX3N4%3D&se=1456971697&skn=device

Шлюз протокола может использовать этот же маркер для всех устройств, задав `myhub.azure-devices.net/devices`в качестве универсального кода ресурса (URI).

### <a name="use-security-tokens-from-service-components"></a>Использование маркеров безопасности из компонентов службы

Компоненты службы могут создавать маркеры безопасности только с помощью политик общего доступа, предоставляющих соответствующие разрешения, как описано ранее.

Ниже приведены функции службы, предоставляемые в конечных точках.

| Конечная точка | Функции |
| ----- | ----------- |
| `{iot hub host name}/devices` | Создание, обновление, извлечение и удаление удостоверений устройств. |
| `{iot hub host name}/messages/events` | Получение сообщений с устройства в облако. |
| `{iot hub host name}/servicebound/feedback` | Получение ответа на сообщения, отправляемые из облака на устройство. |
| `{iot hub host name}/devicebound` | Отправка сообщений из облака на устройство. |

Например, служба, использующая предварительно созданную политику общего доступа с именем **registryRead** , создаст маркер со следующими параметрами:

* универсальный код ресурса (URI): `{IoT hub name}.azure-devices.net/devices`;
* ключ подписывания: один из ключей политики `registryRead` ;
* имя политики: `registryRead`;
* время окончания срока действия.

    var endpoint ="myhub.azure-devices.net/devices";   var policyName = 'device';   var policyKey = '...';

    var token = generateSasToken(endpoint, policyKey, policyName, 60);

Результат, предоставляющий доступ для чтения всех идентификаторов устройств, будет иметь следующий вид:

    SharedAccessSignature sr=myhub.azure-devices.net%2fdevices&sig=JdyscqTpXdEJs49elIUCcohw2DlFDR3zfH5KqGJo4r4%3D&se=1456973447&skn=registryRead

## <a name="supported-x.509-certificates"></a>Поддерживаемые сертификаты X.509

Вы можете использовать любой сертификат X.509 для проверки подлинности устройства с помощью центра IoT. А именно:

-   **Существующий сертификат X.509**. Возможно, устройство уже имеет связанный сертификат X.509. Устройство может использовать этот сертификат для проверки подлинности с помощью центра IoT.

-   **Самостоятельно сформированный и самозаверяющий сертификат X-509**. Производитель устройства или внутренний специалист по развертыванию может создать эти сертификаты и сохранить соответствующий закрытый ключ (и сертификат) на устройстве. Для этого вы можете использовать такие инструменты, как [OpenSSL][lnk-openssl] и служебная программа [Windows SelfSignedCertificate][lnk-selfsigned].

-   **Сертификат X.509, подписанный центром сертификации**. Вы также можете использовать сертификат X.509, созданный и подписанный центром сертификации (ЦС), для идентификации устройства и проверки подлинности устройства с помощью центра IoT.

Для аутентификации устройство может использовать только один из вариантов: либо сертификат X.509, либо маркер безопасности.

### <a name="register-an-x.509-client-certificate-for-a-device"></a>Регистрация сертификата X.509 клиента для устройства

[Пакет SDK службы Центра Интернета вещей Azure для C#][lnk-service-sdk] (версия 1.0.8+) поддерживает регистрацию устройства, использующего клиентский сертификат X.509 для аутентификации. Другие интерфейсы API (например, импорт и экспорт устройств) также поддерживают клиентские сертификаты X.509.

### <a name="c\#-support"></a>Поддержка C\#

Класс **RegistryManager** предоставляет программный способ регистрации устройства. В частности, методы **AddDeviceAsync** и **UpdateDeviceAsync** позволяют пользователю регистрировать и обновлять устройства в реестре удостоверений устройств Центра Интернета вещей. Эти два метода используют экземпляр **устройства** в качестве входных данных. Класс **Device** включает свойство **Authentication**, которое позволяет пользователю указывать основной и дополнительный отпечатки сертификата X.509. Отпечаток представляет хэш SHA-1 сертификата X.509 (сохраненного с помощью двоичного кодирования DER). Пользователи могут указать основной или вторичный отпечаток или оба отпечатка сразу. Основной и вторичный отпечатки поддерживаются для обработки сценариев переключения сертификатов.

> [AZURE.NOTE] Центр IoT не требует и не хранит весь клиентский сертификат X.509, а только его отпечаток.

Ниже приведен пример фрагмента кода C\# для регистрации устройства с использованием клиентского сертификата X.509:

```
var device = new Device(deviceId)
{
  Authentication = new AuthenticationMechanism()
  {
    X509Thumbprint = new X509Thumbprint()
    {
      PrimaryThumbprint = "921BC9694ADEB8929D4F7FE4B9A3A6DE58B0790B"
    }
  }
};
RegistryManager registryManager = RegistryManager.CreateFromConnectionString(deviceGatewayConnectionString);
await registryManager.AddDeviceAsync(device);
```

### <a name="use-an-x.509-client-certificate-during-runtime-operations"></a>Использование клиентского сертификата X.509 во время выполнения операций среды выполнения

[Пакет SDK для устройств Azure IoT для .NET][lnk-client-sdk] (версия 1.0.11+) поддерживает использование клиентских сертификатов X.509.

### <a name="c\#-support"></a>Поддержка C\#

Класс **DeviceAuthenticationWithX509Certificate** поддерживает создание экземпляров  **DeviceClient** с помощью клиентского сертификата X.509.

Ниже приведен образец фрагмента кода:

```
var authMethod = new DeviceAuthenticationWithX509Certificate("<device id>", x509Certificate);

var deviceClient = DeviceClient.Create("<IotHub DNS HostName>", authMethod);
```

## <a name="custom-device-authentication"></a>Настраиваемая проверка подлинности устройства

[Реестр удостоверений устройств][lnk-identity-registry] Центра Интернета вещей позволяет настроить контроль доступа и учетные данные безопасности для каждого устройства с помощью [маркеров][lnk-sas-tokens]. Если в решение Интернета вещей уже были вложены значительные средства для реализации настраиваемого реестра удостоверений устройств и/или схемы аутентификации, эту инфраструктуру можно интегрировать в Центр Интернета вещей. Для этого нужно создать *службу маркеров*. Таким образом можно использовать и другие функции IoT в решении.

Служба маркеров — это пользовательская облачная служба. Она использует *политику общего доступа* Центра Интернета вещей с разрешениями **DeviceConnect** для создания маркеров *уровня устройства*. Эти маркеры позволяют устройству подключиться к центру IoT.

  ![Этапы для схемы службы маркеров.][img-tokenservice]

Ниже приведены основные этапы для схемы службы маркеров.

1. Создание политики общего доступа Центра Интернета вещей с разрешениями **DeviceConnect** для вашего Центра Интернета вещей. Эту политику можно создать на [портале Azure][lnk-management-portal] или программным способом. Эту политику служба маркеров будет использовать для подписания создаваемых маркеров.
2. Когда устройству требуется доступ к центру IoT, оно запрашивает у службы маркеров подписанный маркер. Для определения удостоверения устройства, используемого службой маркеров для создания маркера, устройство может использовать настраиваемую схему проверки подлинности или реестр удостоверений устройств.
3. Служба маркеров возвращает маркер. Чтобы создать маркер, используйте `/devices/{deviceId}` в качестве значения `resourceURI`, где `deviceId` — это аутентифицируемое устройство. Служба маркеров использует политики общего доступа для создания маркера.
4. Устройство использует маркер для подключения к центру IoT.

> [AZURE.NOTE] Для создания маркера в службе маркеров можно использовать класс .NET [SharedAccessSignatureBuilder][lnk-dotnet-sas] или класс Java [IotHubServiceSasToken][lnk-java-sas].

При необходимости служба маркеров может задать срок действия маркера. По истечении срока действия маркера центр IoT разрывает подключение к устройству. После этого устройство должно запросить новый маркер у службы маркеров. Короткий срок действия увеличит нагрузку как на устройство, так и на службу маркеров.

Кроме того, чтобы устройство могло подключаться к вашему центру, его необходимо добавить в реестр удостоверений устройств центра IoT, даже если для подключения устройство использует маркер, а не ключ. Поэтому контроль доступа на уровне отдельных устройств путем включения или отключения удостоверений устройств в разделе [Реестр удостоверений Центра Интернета вещей][lnk-identity-registry] продолжает работать, если устройство проходит аутентификацию с помощью маркера. Это уменьшает риск существования маркеров с длительным сроком действия.

### <a name="comparison-with-a-custom-gateway"></a>Сравнение с настраиваемым шлюзом

Вариант со службой маркеров является рекомендованным способом внедрения настраиваемого реестра удостоверений или схемы проверки подлинности с использованием центра IoT. Причина состоит в том, что так центр IoT продолжает обрабатывать большую часть трафика решения. Однако существуют случаи, когда настраиваемая схема аутентификации настолько тесно переплетена с протоколом, что для обработки всего трафика требуется отдельная служба (*настраиваемый шлюз*). В качестве примера можно привести [протокол TLS и общие ключи][lnk-tls-psk]. Дополнительные сведения см. в статье о [шлюзе протокола][lnk-protocols].

## <a name="reference"></a>Справочные материалы

### <a name="iot-hub-permissions"></a>Разрешения Центра Интернета вещей

В следующей таблице указаны разрешения, с помощью которых можно управлять доступом к Центру Интернета вещей.

| Разрешение            | Примечания |
| --------------------- | ----- |
| **RegistryRead**      | Предоставляет доступ на чтение к реестру удостоверений устройств. Дополнительные сведения см. в статье [Реестр удостоверений устройств][lnk-identity-registry]. |
| **RegistryReadWrite** | Предоставляет доступ на чтение и запись к реестру удостоверений устройств. Дополнительные сведения см. в статье [Реестр удостоверений устройств][lnk-identity-registry]. |
| **ServiceConnect**    | Предоставляет доступ к конечным точкам обмена данными и мониторинга, обращенным к облачной службе. Например, это разрешение позволяет серверным облачным службам получать сообщения с устройств, отправлять сообщения в устройства и получать соответствующие уведомления о доставке. |
| **DeviceConnect**     | Предоставляет доступ к конечным точкам обмена данными, обращенным к устройству. Например, это разрешение позволяет отправлять сообщения с устройства в облако и получать сообщения, отправленные из облака на устройство. Это разрешение используют устройства. |

### <a name="additional-reference-material"></a>Дополнительные справочные материалы

Другие справочные статьи в руководстве для разработчиков:

- Статья [Конечные точки Центра Интернета вещей][lnk-endpoints] содержит информацию о конечных точках, которые каждый Центр Интернета вещей предоставляет для операций управления и среды выполнения.
- Статья [Throttling and quotas][lnk-quotas] (Регулирование и квоты) содержит информацию о квотах, применимых к службе Центра Интернета вещей, и ожидаемом поведении регулирования при использовании службы.
- В статье [Пакеты SDK для устройств и служб Центра Интернета вещей][lnk-sdks] указаны различные языковые пакеты SDK, которые можно использовать при разработке приложений устройств и служб, взаимодействующих с Центром Интернета вещей.
- В статье [Язык запросов для двойников, методов и заданий][lnk-query] описывается язык запросов, который можно использовать для получения сведений о двойниках, методах и заданиях устройств из Центра Интернета вещей.
- Статья [Поддержка MQTT в Центре Интернета вещей][lnk-devguide-mqtt] содержит дополнительные сведения о поддержке протокола MQTT в Центре Интернета вещей.

## <a name="next-steps"></a>Дальнейшие действия

Теперь, когда вы узнали, как управлять доступом к Центру Интернета вещей, вас могут заинтересовать следующие статьи руководства для разработчиков:

- [Use device twins to synchronize state and configurations][lnk-devguide-device-twins] (Синхронизация состояния и конфигураций с помощью двойников устройств)
- [Вызов прямого метода на устройстве][lnk-devguide-directmethods]
- [Планирование заданий на нескольких устройствах][lnk-devguide-jobs]

Если вы хотели бы применить на практике некоторые основные понятия, описанные в этой статье, можно просмотреть следующие руководства по Центру Интернета вещей:

- [Get started with Azure IoT Hub][lnk-getstarted-tutorial] (Начало работы с Центром Интернета вещей Azure)
- [How to send cloud-to-device messages with IoT Hub][lnk-c2d-tutorial] (Отправка сообщений из облака на устройства с помощью Центра Интернета вещей)
- [How to process IoT Hub device-to-cloud messages][lnk-d2c-tutorial] (Обработка сообщений, отправляемых с устройства Центра Интернета вещей в облако)

<!-- links and images -->

[img-tokenservice]: ./media/iot-hub-devguide-security/tokenservice.png
[lnk-endpoints]: iot-hub-devguide-endpoints.md
[lnk-quotas]: iot-hub-devguide-quotas-throttling.md
[lnk-sdks]: iot-hub-devguide-sdks.md
[lnk-query]: iot-hub-devguide-query-language.md
[lnk-devguide-mqtt]: iot-hub-mqtt-support.md
[lnk-openssl]: https://www.openssl.org/
[lnk-selfsigned]: https://technet.microsoft.com/library/hh848633

[lnk-resource-provider-apis]: https://msdn.microsoft.com/library/mt548492.aspx
[lnk-sas-tokens]: iot-hub-devguide-security.md#security-tokens
[lnk-amqp]: https://www.amqp.org/
[lnk-azure-resource-manager]: https://azure.microsoft.com/documentation/articles/resource-group-overview/
[lnk-cbs]: https://www.oasis-open.org/committees/download.php/50506/amqp-cbs-v1%200-wd02%202013-08-12.doc
[lnk-event-hubs-publisher-policy]: https://code.msdn.microsoft.com/Service-Bus-Event-Hub-99ce67ab
[lnk-management-portal]: https://portal.azure.com
[lnk-sasl-plain]: http://tools.ietf.org/html/rfc4616
[lnk-identity-registry]: iot-hub-devguide-identity-registry.md
[lnk-dotnet-sas]: https://msdn.microsoft.com/library/microsoft.azure.devices.common.security.sharedaccesssignaturebuilder.aspx
[lnk-java-sas]: http://azure.github.io/azure-iot-sdks/java/service/api_reference/com/microsoft/azure/iot/service/auth/IotHubServiceSasToken.html
[lnk-tls-psk]: https://tools.ietf.org/html/rfc4279
[lnk-protocols]: iot-hub-protocol-gateway.md
[lnk-custom-auth]: iot-hub-devguide-security.md#custom-device-authentication
[lnk-x509]: iot-hub-devguide-security.md#supported-x509-certificates
[lnk-devguide-device-twins]: iot-hub-devguide-device-twins.md
[lnk-devguide-directmethods]: iot-hub-devguide-direct-methods.md
[lnk-devguide-jobs]: iot-hub-devguide-jobs.md
[lnk-service-sdk]: https://github.com/Azure/azure-iot-sdks/tree/master/csharp/service
[lnk-client-sdk]: https://github.com/Azure/azure-iot-sdks/tree/master/csharp/device
[lnk-device-explorer]: https://github.com/Azure/azure-iot-sdks/blob/master/tools/DeviceExplorer/doc/how_to_use_device_explorer.md

[lnk-getstarted-tutorial]: iot-hub-csharp-csharp-getstarted.md
[lnk-c2d-tutorial]: iot-hub-csharp-csharp-c2d.md
[lnk-d2c-tutorial]: iot-hub-csharp-csharp-process-d2c.md



<!--HONumber=Oct16_HO2-->


