<properties
	pageTitle="Знакомство с пакетом SDK для устройств Azure IoT для C"
	description="Основные понятия и начало работы с примерами кода из пакета SDK для устройств Azure IoT для C"
	services="iot-hub"
	documentationCenter="na"
	authors="MichelBarnett"
	manager="timlt"
	editor=""/>

<tags
     ms.service="iot-hub"
     ms.devlang="na"
     ms.topic="article"
     ms.tgt_pltfrm="na"
     ms.workload="tbd"
     ms.date="09/29/2015"
     ms.author="michelb"/>

# Знакомство с пакетом SDK для устройств Azure IoT для C

**Пакет SDK для устройств Azure IoT** — это набор библиотек, предназначенных для упрощения процесса отправки событий и получения сообщений из **центра Azure IoT**. Существуют разные варианты пакетов SDK, каждый из которых предназначен для разных платформ. В этой статье будут рассмотрены основные функции **пакета SDK для устройств Azure IoT для C**.

Пакет SDK для устройств Azure IoT для C написан на языке ANSI C (C99), что обеспечивает максимальную переносимость. Таким образом, он подходит для использования с разными платформами и устройствами, особенно в условиях ограниченных ресурсов (постоянной и оперативной памяти).

Этот пакет SDK протестирован на множестве платформ (подробные сведения см. в [документации по пакету SDK](https://github.com/Azure/azure-iot-sdks/tree/master/c)). В этой статье приведены пошаговые инструкции с примерами кода, выполняемого на платформе *Windows*. Для других поддерживаемых платформ код будет аналогичным.

Из этой статьи вы узнаете об архитектуре пакета SDK для устройств Azure IoT для C. Мы покажем, как инициализировать библиотеку, отправлять события в центр IoT и получать сообщения из него. Приведенной в этой статье информации достаточно, чтобы вы могли начать работу с пакетом SDK. Также вы найдете здесь ссылки для получения дополнительных сведений о библиотеках.


## Архитектура пакета SDK

**Пакет SDK для устройств Azure IoT для C** можно найти в следующем репозитории GitHub:

[azure-iot-sdks](https://github.com/Azure/azure-iot-sdks)

Последнюю версию библиотеки можно найти в ветке **master** этого репозитория:

  ![](media/iot-hub-device-sdk-c-intro/01-MasterBranch.PNG)

Этот репозиторий содержит все семейство пакетов SDK для устройств Azure IoT. Но эта статья описывает пакет SDK для устройств Azure IoT *для C*, который можно найти в папке **c**.

  ![](media/iot-hub-device-sdk-c-intro/02-CFolder.PNG)

Реализация ядра пакета SDK доступна в репозитории в папках **common**, **iothub\_client** и **serializer**. Папка **common** содержит общий код, используемый в библиотеках (обычно этот код не используется непосредственно из папки **common**). Однако папки **iothub\_client** и **serializer** содержат реализации двух разных слоев пакета SDK, которые вы будете использовать в своем коде.

-   **IoTHubClient** — папка **iothub\_client** содержит реализацию самого нижнего уровня API в библиотеке. Этот уровень содержит API для отправки событий в центр IoT, а также получения сообщений из него. Если вы используете этот слой, вам нужно самостоятельно реализовать сериализацию сообщений. Другие составляющие процесса взаимодействия с центром IoT реализуются автоматически.

-   **serializer** — папка **serializer** содержит реализацию библиотеки, сборка которой выполняется на основе **IoTHubClient**. В частности, библиотека **serializer** в дополнение к функциям, которые предоставляет **IoTHubClient**, добавляет возможности моделирования. Если вы используете библиотеку **serializer**, начните с определения модели, которая описывает события, отправляемые в центр IoT, а также сообщения, получаемые из него. После определения модели пакет SDK предоставит поверхность API, которая упрощает работу с событиями и сообщениями и избавляет вас от необходимости выполнять задачи, связанные с сериализацией.

Все это проще понять, взглянув на некоторые примеры кода. Следующие разделы содержат разбор нескольких примеров приложений, включенных в пакет SDK. Ознакомившись с ними, вы получите представление о разных возможностях архитектурных уровней пакета и о работе с API.

## Перед запуском примеров

Перед запуском примеров из пакета SDL для устройств Azure IoT для C вам нужно выполнить две задачи: подготовить среду разработки и получить учетные данные устройства. Инструкции по выполнению этих задач включены в [файл сведений](https://github.com/Azure/azure-iot-sdks/tree/master/c), входящий в состав пакета SDK. Кроме того, в следующих разделах приведены дополнительные комментарии к этим инструкциям.

### Подготовка среды разработки

Во-первых, вам нужно загрузить копию пакета SDK из GitHub, а затем выполнить сборку исходного кода. Копию исходного кода можно загрузить из ветки **master** репозитория GitHub:

<https://github.com/Azure/azure-iot-sdks>

После загрузки копии исходного кода вам потребуется выполнить еще несколько шагов, прежде чем запускать свой код. В статье [Подготовка среды разработки](https://github.com/Azure/azure-iot-sdks/blob/master/c/doc/devbox_setup.md) можно найти сводную информацию по этим шагам. В случае с платформой Windows самой трудоемкой операцией будет [сборка библиотеки QPID Proton](https://github.com/Azure/azure-iot-sdks/blob/master/c/doc/devbox_setup.md#rebuilding-the-qpid-proton-library-in-windows). Но вы можете воспользоваться следующими советами, которые помогут выполнить процедуру, описанную в руководстве по подготовке.

-   Создавая переменную среды **PROTON\_PATH**, сделайте ее **системной** переменной, как показано ниже:

  ![](media/iot-hub-device-sdk-c-intro/07-EnvironmentVariables.PNG)

-   Устанавливая служебную программу **CMake**, выберите параметр для добавления **CMake** в системную переменную PATH для **всех пользователей** (можно также добавить только для **текущего пользователя**).

  ![](media/iot-hub-device-sdk-c-intro/08-CMake.PNG)

-   Убедитесь, что вы устанавливаете правильную версию Python. Обычно для системы Windows требуется версия x86:

  ![](media/iot-hub-device-sdk-c-intro/09-Python.PNG)

В установщике можно оставить параметры по умолчанию.

-   Прежде чем открыть **Командную строку разработчика для VS2015**, установите *средства командной строки Git*. Чтобы установить эти средства, выполните следующие действия:

	1. Запустите программу установки **Visual Studio 2015** (или откройте на панели управления **Программы и компоненты** и последовательно выберите пункты **Microsoft Visual Studio 2015**, **Изменить**).
	2. Убедитесь, что в программе установки включен параметр **Git для Windows**: ![](media/iot-hub-device-sdk-c-intro/10-GitTools.PNG)
	3. Завершите работу мастера установки, чтобы установить инструменты.
	4. Добавьте папку **bin** инструментов Git в системную переменную среды **PATH**. В ОС Windows это будет выглядеть следующим образом: ![](media/iot-hub-device-sdk-c-intro/11-GitToolsPath.PNG)

Когда вы запускаете сценарий **build\_proton.cmd** из командной строки, исходный код Proton будет загружен из репозитория GitHub, после чего будет выполнена сборка библиотек Proton.

Выполнив предыдущие шаги, вы сможете скомпилировать примеры программ для Windows, в которых используется AMQP. Для этого откройте соответствующий файл решения для Visual Studio и в меню **Сборка** выберите **Собрать решение**.

### Получение учетных данных устройства

После настройки среды разработки вам останется получить набор учетных данных устройства. Чтобы обеспечить устройству доступ к центру IoT, добавьте его в реестр устройств центра IoT. Когда устройство будет добавлено, вы получите набор учетных данных, которые нужны для подключения этого устройства к центру IoT. Примеры приложений, которые мы рассмотрим в следующем разделе, предполагают использование этих учетных данные в виде **строки подключения устройства**.

[Диспетчер устройств](https://github.com/Azure/azure-iot-sdks/tree/master/tools/DeviceExplorer), включенный в пакет SDK для устройств Azure IoT, использует служебные библиотеки Azure IoT для выполнения различных операций в центре IoT (включая добавление устройств). Используя диспетчер устройств для добавления устройства, вы получите соответствующую строку подключения. Именно эта строка понадобится вам для запуска примера приложения.

Если вы еще не знакомы с этим процессом, изучите следующую процедуру, в которой описывается добавление устройства и получение строки подключения устройства с помощью диспетчера устройств.

Откройте **[DeviceExplorer.sln](https://github.com/Azure/azure-iot-sdks/blob/master/tools/DeviceExplorer/DeviceExplorer.sln)** в **Visual Studio 2015** и выполните сборку решения. При запуске программы вы увидите следующий интерфейс:

  ![](media/iot-hub-device-sdk-c-intro/03-DeviceExplorer.PNG)

Введите в первое поле свою **строку подключения к центру IoT** и нажмите кнопку **Обновить**. Теперь средство настроено для обмена данными с центром IoT.

Введите строку подключения к центру IoT, затем перейдите на вкладку **Управление**:

  ![](media/iot-hub-device-sdk-c-intro/04-ManagementTab.PNG)

Здесь вы можете управлять устройствами, зарегистрированными в центре IoT.

Чтобы создать устройство, нажмите кнопку **Создать**. Откроется диалоговое окно с заполненным набором ключей (первичными и вторичными). Все, что вам нужно сделать, — это ввести **идентификатор устройства** и нажать кнопку **Создать**.

  ![](media/iot-hub-device-sdk-c-intro/05-CreateDevice.PNG)

Когда устройство будет создано, список зарегистрированных устройств обновится. Он будет включать созданное ранее устройство. Если на новом устройстве щелкнуть правой кнопкой мыши, появится следующее меню:

  ![](media/iot-hub-device-sdk-c-intro/06-RightClickDevice.PNG)

Если выбрать параметр **Копировать строку подключения для выбранного устройства**, строка подключения выбранного устройства будет скопирована в буфер обмена. Сохраните ее. Эта строка потребуется вам при запуске примеров приложений, описанных ниже.

Выполнив описанные выше шаги, вы будете готовы к запуску кода. В следующих разделах описываются два примера решений (включены в пакет SDK для устройств Azure для C), демонстрирующие возможности библиотеки. Обратите внимание, что в обоих примерах в верхней части основного исходного файла имеется константа для ввода строки подключения. Например, вот соответствующая строка из приложения **iothub\_client\_sample\_amqp**.

```
static const char* connectionString = "[device connection string]";
```

Чтобы перейти к дальнейшим действиям, введите строку подключения устройства и выполните повторную сборку решения. После этого вы сможете запустить пример.

## IoTHubClient

В папке **iothub\_client** репозитория azure-iot-sdks есть папка **samples**. Она содержит приложение **iothub\_client\_sample\_amqp**.

Версия приложения **iothub\_client\_sample\_ampq** для Windows включает следующее решение Visual Studio:

  ![](media/iot-hub-device-sdk-c-intro/12-iothub-client-sample-amqp.PNG)

Проект **iothub\_client\_sample\_amqp** состоит из четырех проектов. Пример кода можно найти в проекте **iothub\_client\_sample\_amqp**. Кроме того, решение также включает проекты **common**, **iothub\_amqp\_transport** и **iothub\_client** из пакета SDK для устройств Azure IoT для C. При работе с этим пакетом SDK вам всегда нужно будет использовать проект **common**. Так как в этом образце используется AMQP, нам также нужно включить проект **iothub\_amqp\_transport** (также доступен аналогичный проект для HTTP). Кроме того, поскольку в рассматриваемом примере используются библиотеки **IoTHubClient**, нам также нужно включить в решение проект **iothub\_client**.

Реализацию примера приложения вы можете найти в исходном файле **iothub\_client\_sample\_amqp.c**:

  ![](media/iot-hub-device-sdk-c-intro/13-iothub_client_sample_amqp_c.PNG)

На примере этого приложения мы покажем, что необходимо для использования библиотеки **IoTHubClient**.


### Инициализация библиотеки

Чтобы начать работу с библиотеками, сначала вам нужно создать дескриптор клиента центра IoT:

```
IOTHUB_CLIENT_HANDLE iotHubClientHandle;
iotHubClientHandle = IoTHubClient_CreateFromConnectionString(connectionString, AMQP_Protocol);
```

Обратите внимание, что мы передаем копию строки подключения устройства этой функции (получено из диспетчера устройств). Мы также определяем протокол, который будет использоваться. В этом примере это AMQP, но также можно использовать и HTTP.

Получив обработчик **IOTHUB\_CLIENT\_HANDLE**, вы можете начинать вызывать API для отправки событий и получения сообщений из центра IoT. Эти операции мы рассмотрим далее.

### Отправка событий

Чтобы отправить события в центр IoT, выполните следующие действия:

Сначала создайте сообщение:

```
EVENT_INSTANCE message;
sprintf_s(msgText, sizeof(msgText), "Message_%d_From_IoTHubClient_Over_AMQP", i);
message.messageHandle = IoTHubMessage_CreateFromByteArray((const unsigned char*)msgText, strlen(msgText);
```

А затем отправьте его:

```
IoTHubClient_SendEventAsync(iotHubClientHandle, message.messageHandle, SendConfirmationCallback, &message);
```

Во время каждой отправки сообщения вам нужно указывать ссылку на функцию обратного вызова, которая будет вызываться при отправке данных:

```
static void SendConfirmationCallback(IOTHUB_CLIENT_CONFIRMATION_RESULT result, void* userContextCallback)
{
    EVENT_INSTANCE* eventInstance = (EVENT_INSTANCE*)userContextCallback;
    (void)printf("Confirmation[%d] received for message tracking id = %d with result = %s\r\n", callbackCounter, eventInstance->messageTrackingId, ENUM_TO_STRING(IOTHUB_CLIENT_CONFIRMATION_RESULT, result));
    /* Some device specific action code goes here... */
    callbackCounter++;
    IoTHubMessage_Destroy(eventInstance->messageHandle);
}
```

Обратите внимание на вызов функции **IoTHubMessage\_Destroy** после завершения операции с сообщением. Это необходимо для освобождения ресурсов, выделенных во время создания сообщения.

### Получение сообщений

Получение сообщения является асинхронной операцией. Сначала вам необходимо зарегистрировать функцию обратного вызова, выполняемую при получении устройством сообщения:

```
int receiveContext = 0;
IoTHubClient_SetMessageCallback(iotHubClientHandle, ReceiveMessageCallback, &receiveContext);
```

Последний параметр — это указатель void, который может указывать на что угодно. Хотя в нашем примере он указывает на целое число, в других случаях он может указывать и на более сложную структуру данных. В результате функция обратного вызова может работать в общем состоянии с объектом, вызывающим эту функцию.

Когда устройство получает сообщение, вызывается зарегистрированная функция обратного вызова:

```
static IOTHUBMESSAGE_DISPOSITION_RESULT ReceiveMessageCallback(IOTHUB_MESSAGE_HANDLE message, void* userContextCallback)
{
    int* counter = (int*)userContextCallback;
    const char* buffer;
    size_t size;
    if (IoTHubMessage_GetByteArray(message, (const unsigned char**)&buffer, &size) == IOTHUB_MESSAGE_OK)
    {
        (void)printf("Received Message [%d] with Data: <<<%.*s>>> & Size=%d\r\n", *counter, (int)size, buffer, (int)size);
    }

    /* Some device specific action code goes here... */
    (*counter)++;
    return IOTHUBMESSAGE_ACCEPTED;
}
```

Обратите внимание на использование функции **IoTHubMessage\_GetByteArray** при получении сообщения, которое в этом примере представлено строкой.

### Отмена инициализации библиотеки

Завершив операции отправки и получения сообщений, вы можете отменить инициализацию библиотеки IoT. Для этого вызовите следующую функцию:

```
IoTHubClient_Destroy(iotHubClientHandle);
```

Это действие освобождает ресурсы, выделенные функцией **IoTHubClient\_CreateFromConnectionString**.

Очевидно, что с помощью библиотеки **IoTHubClient** вы можете легко отправлять события и получать сообщения. Библиотека обеспечивает обмен данными с центром IoT, включая выбор используемого протокола (что с точки зрения разработчика является простым параметром конфигурации).

Библиотека **IoTHubClient** также позволяет вам полностью управлять способом сериализации событий, которые ваше устройство отправляет в центр IoT. В некоторых случаях это является преимуществом, но иногда подобная функция может и не требоваться в ходе реализации. В таком случае обратите внимание на библиотеку **serializer**, о которой будет рассказано далее.

## Serializer

На концептуальном уровне библиотека **serializer** управляет библиотекой **IoTHubClient**, входящей в пакет SDK. Она использует библиотеку **IoTHubClient** в качестве базового канала связи с центром IoT, а также предоставляет возможности моделирования, которые помогают решать задачи, связанные с сериализацией сообщений. Работу этой библиотеки лучше всего продемонстрировать на примере.

Папка **serializer** репозитория azure-iot-sdks включает папку **samples**. В ней находится приложение **simplesample\_amqp**. Версия этого примера для Windows включает следующее решение Visual Studio:

  ![](media/iot-hub-device-sdk-c-intro/14-simplesample_amqp.PNG)

Этот пример является проектом **simplesample\_amqp**. Как вы уже поняли, это решение включает проекты **common**, **iothub\_amqp\_transport** и **iothub\_client** из пакета SDK для устройств Azure IoT для C. Однако это решение также включает дополнительный проект с именем **serializer**. Этот проект представляет собой библиотеку, которая обеспечивает поддержку моделирования в дополнение к возможностям библиотеки **IoTHubClient**.

Реализацию примера приложения вы можете найти в файле кода **simplesample\_amqp.c**:

  ![](media/iot-hub-device-sdk-c-intro/15-simplesample_amqp_c.PNG)

Следующие разделы содержат описание основных частей этого примера.

### Инициализация библиотеки

Чтобы приступить к работе с библиотеками, вам нужно вызвать API инициализации:

```
serializer_init(NULL);

IOTHUB_CLIENT_HANDLE iotHubClientHandle = IoTHubClient_CreateFromConnectionString(connectionString, AMQP_Protocol);

ContosoAnemometer* myWeather = CREATE_MODEL_INSTANCE(WeatherStation, ContosoAnemometer);
```

Функция **serializer\_init** вызывается один раз. Она инициализирует базовую библиотеку. Затем вызывается функция **IoTHubClient\_CreateFromConnectionString**, с которой вы уже знакомы по примеру **IoTHubClient**. Вызов задает строку подключения устройства (на этом этапе вы также можете выбрать используемый протокол). Обратите внимание, что в этом примере используется протокол AMQP, но также можно использовать и HTTP.

Наконец, вызывается функция **CREATE\_MODEL\_INSTANCE**. **WeatherStation** — это пространство имен модели, а **ContosoAnemometer** — имя модели. Определив модель, вы сможете использовать ее для отправки событий и получения сообщений. Но сначала нужно понять, что такое модель.

### Определение модели

Модель в библиотеке **serializer** определяет события, которые ваше устройство может отправлять в центр IoT, а также сообщения, которые оно может получать (на языке моделирования называются *действия*). Модель определяется с помощью набора макросов C. Образец можно увидеть в примере приложения **simplesample\_amqp**:

```
BEGIN_NAMESPACE(WeatherStation);

DECLARE_MODEL(ContosoAnemometer,
WITH_DATA(ascii_char_ptr, DeviceId),
WITH_DATA(double, WindSpeed),
WITH_ACTION(TurnFanOn),
WITH_ACTION(TurnFanOff),
WITH_ACTION(SetAirResistance, int, Position)
);

END_NAMESPACE(WeatherStation);
```

Макросы **BEGIN\_NAMESPACE** и **END\_NAMESPACE** принимают имя пространства имен модели в качестве аргумента. Предполагается, что весь код, находящийся между этими макросами, и является определением моделей и структур данных, используемых в моделях.

В этом примере приведена одна модель с именем **ContosoAnemometer**. Эта модель определяет два события, которые ваше устройство может отправить в центр IoT: **DeviceId** и **WindSpeed**. Она также определяет три действия (сообщения), которые ваше устройство может получить: **TurnFanOn**, **TurnFanOff** и **SetAirResistance**. Каждое событие имеет тип, и каждое действие имеет имя (и, при необходимости, набор параметров).

События и действия, определенные в модели, определяют поверхность API, которую вы можете использовать, чтобы отправлять события в центр IoT и отвечать на сообщения, отправляемые устройству. Лучше всего это показать на примере.

### Отправка событий

Модель определяет события, которые вы можете отправить в центр IoT. В нашем примере это одно из двух событий, определенных с использованием макроса **WITH\_DATA**. Например, если вы хотите отправить событие **WindSpeed** в центр IoT, для этого потребуется выполнить несколько шагов. Первый шаг — определение данных для отправки:

```
myWeather->WindSpeed = 15;
```

Определенная ранее модель позволяет сделать это, просто задав элемент структуры. Далее нужно сериализовать событие, которое мы хотим отправить:

```
unsigned char* destination;
size_t destinationSize;

SERIALIZE(&destination, &destinationSize, myWeather->WindSpeed);
```

Этот код выполняет сериализацию события в буфер (на который указывает **destination**). В заключение мы отправим событие в центр IoT, используя следующий код:

```
sendMessage(iotHubClientHandle, destination, destinationSize);
```

Это вспомогательная функция примера приложения, которая отправляет сериализованное событие в центр IoT:

```
static void sendMessage(IOTHUB_CLIENT_HANDLE iotHubClientHandle, const unsigned char* buffer, size_t size)
{
    static unsigned int messageTrackingId;
    IOTHUB_MESSAGE_HANDLE messageHandle = IoTHubMessage_CreateFromByteArray(buffer, size);
    if (messageHandle != NULL)
    {
        if (IoTHubClient_SendEventAsync(iotHubClientHandle, messageHandle, sendCallback, (void*)(uintptr_t)messageTrackingId) != IOTHUB_CLIENT_OK)
        {
            printf("failed to hand over the message to IoTHubClient");
        }
        else
        {
            printf("IoTHubClient accepted the message for delivery\r\n");
        }

        IoTHubMessage_Destroy(messageHandle);
    }
    free((void*)buffer);
    messageTrackingId++;
}
```

Этот код очень похож на код из приложения **iothub\_client\_sample\_amqp**. В этом примере из массива байтов было создано сообщение, которое затем было отправлено в центр IoT с помощью **IoTHubClient\_SendEventAsync**. После этого нам нужно освободить дескриптор сообщения и буфер сериализованных данных (выделено ранее).

Предпоследний параметр **IoTHubClient\_SendEventAsync** — это ссылка на функцию обратного вызова, вызываемую при успешной отправке данных. Ниже приведен пример функции обратного вызова:

```
void sendCallback(IOTHUB_CLIENT_CONFIRMATION_RESULT result, void* userContextCallback)
{
    int messageTrackingId = (intptr_t)userContextCallback;

    (void)printf("Message Id: %d Received.\r\n", messageTrackingId);

    (void)printf("Result Call Back Called! Result is: %s \r\n", ENUM_TO_STRING(IOTHUB_CLIENT_CONFIRMATION_RESULT, result));
}
```

Второй параметр — это указатель на контекст пользователя. Такой же указатель мы передавали **IoTHubClient\_SendEventAsync**. В этом случае контекстом является простой счетчик. Но это может быть любой другой объект.

Это все, что касается отправки событий. Единственное, о чем осталось рассказать, — это получение сообщений.

### Получение сообщений

Получение сообщений выполняется аналогично обработке сообщений в библиотеке **IoTHubClient**. Сначала вам нужно зарегистрировать функцию обратного вызова сообщения:

```
IoTHubClient_SetMessageCallback(iotHubClientHandle, IoTHubMessage, myWeather)
```

Затем вы создаете функцию обратного вызова, которая вызывается при получении сообщения:

```
static IOTHUBMESSAGE_DISPOSITION_RESULT IoTHubMessage(IOTHUB_MESSAGE_HANDLE message, void* userContextCallback)
{
    IOTHUBMESSAGE_DISPOSITION_RESULT result;
    const unsigned char* buffer;
    size_t size;
    if (IoTHubMessage_GetByteArray(message, &buffer, &size) != IOTHUB_MESSAGE_OK)
    {
        printf("unable to IoTHubMessage_GetByteArray\r\n");
        result = EXECUTE_COMMAND_ERROR;
    }
    else
    {
        /*buffer is not zero terminated*/
        char* temp = malloc(size + 1);
        if (temp == NULL)
        {
            printf("failed to malloc\r\n");
            result = EXECUTE_COMMAND_ERROR;
        }
        else
        {
            memcpy(temp, buffer, size);
            temp[size] = '\0';
            EXECUTE_COMMAND_RESULT executeCommandResult = EXECUTE_COMMAND(userContextCallback, temp);
            result =
                (executeCommandResult == EXECUTE_COMMAND_ERROR) ? IOTHUBMESSAGE_ABANDONED :
                (executeCommandResult == EXECUTE_COMMAND_SUCCESS) ? IOTHUBMESSAGE_ACCEPTED :
                IOTHUBMESSAGE_REJECTED;
            free(temp);
        }
    }
    return result;
}
```

Данный пример кода является стандартным и может использоваться с любым решением. Эта функция получает сообщение и перенаправляет его соответствующей функции через вызов **EXECUTE\_COMMAND**. По сути, функция, которая будет вызвана в этот момент, зависит от определения действий в нашей модели.

Когда вы определяете действие в модели, вам нужно реализовать соответствующую функцию, которая вызывается при получении устройством сообщения. Например, если модель определяет следующее действие:

```
WITH_ACTION(SetAirResistance, int, Position)
```

Вам нужно определить функцию со следующей сигнатурой:

```
EXECUTE_COMMAND_RESULT SetAirResistance(ContosoAnemometer* device, int Position)
{
    (void)device;
    (void)printf("Setting Air Resistance Position to %d.\r\n", Position);
    return EXECUTE_COMMAND_SUCCESS;
}
```

Обратите внимание, что имя функции соответствует имени действия в модели, а параметры функции соответствуют параметрам, указанным для действия. Первый параметр всегда является обязательным и содержит указатель, который указывает на экземпляр нашей модели.

Когда устройство получает сообщение, которое соответствует сигнатуре, вызывается соответствующая функция. Следовательно, кроме включения шаблонного кода из **IoTHubMessage**, получение сообщений заключается в определении простой функции для каждого действия, определенного в модели.

### Отмена инициализации библиотеки

После завершения отправки и получения сообщений, вы можете отменить инициализацию библиотеки IoT:

```
        DESTROY_MODEL_INSTANCE(myWeather);
    }
    IoTHubClient_Destroy(iotHubClientHandle);
}
serializer_deinit();
```

Каждая из этих трех функций соответствуют трем функциям инициализации, описанным ранее. Вызов этих API позволит освободить выделенные ранее ресурсы.

## Дальнейшие действия

В этой статье описываются основы использования библиотек, включенных в **пакет SDK для устройств Azure IoT для C**. В ней содержатся сведения, которых будет достаточно для понимания содержимого пакета SDK и его архитектуры, а также для начала работы с примерами для Windows. В следующей статье также рассказывается о пакете SDK и приводятся [дополнительные сведения о библиотеке IoTHubClient](iot-hub-device-sdk-c-iothubclient.md).

<!---HONumber=Oct15_HO1-->