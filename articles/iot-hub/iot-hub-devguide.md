<properties
 pageTitle="Разделы руководства разработчика для центра IoT | Microsoft Azure"
 description="Руководство разработчика для центра IoT Azure, содержащее информацию о конечных точках центра IoT, его безопасности, реестре удостоверений устройств и обмене сообщениями."
 services="iot-hub"
 documentationCenter=".net"
 authors="dominicbetts"
 manager="timlt"
 editor=""/>

<tags
 ms.service="iot-hub"
 ms.devlang="multiple"
 ms.topic="article"
 ms.tgt_pltfrm="na"
 ms.workload="na"
 ms.date="02/03/2016"
 ms.author="dobett"/>

# Руководство разработчика по центру Azure IoT (IoT — Интернет вещей)

Центр IoT Azure — полностью управляемая служба, которая обеспечивает надежный и защищенный двунаправленный обмен данными между миллионами устройств IoT и серверной частью приложения.

Центр Azure IoT обеспечивает:

* безопасную связь благодаря использованию уникальных учетных данных безопасности устройства и контроля доступа;
* глобальный надежный двусторонний обмен сообщениями между облаком и устройством;
* простое подключение устройств, так как используются библиотеки устройств для большинства популярных языков и платформ.

В этой статье рассматриваются следующие темы:

- [Конечные точки](#endpoints). Раздел содержит информацию о конечных точках, которые каждый центр IoT предоставляет для операций управления и среды выполнения.
- [Реестр удостоверений устройств](#device-identity-registry). В этом разделе содержится информация о том, какие сведения хранятся в реестре удостоверений каждого устройства центра IoT и как эти сведения можно использовать и изменять.
- [Безопасность](#security). В этом разделе содержатся сведения о модели безопасности, которая обеспечивает доступ к функциям центра IoT для устройств и облачных компонентов.
- [Обмен сообщениями](#messaging). В этом разделе содержатся сведения о функциях обмена сообщениями (между устройством и облаком в обоих направлениях), которые предоставляет центр IoT.
- [Квоты и регулирование](#throttling). Раздел содержит информацию о том, какие квоты применяются при использовании центра IoT.

## Конечные точки <a id="endpoints"></a>

Центр IoT Azure — это служба с несколькими клиентами, которая предоставляет возможность пользоваться своими функциями разным субъектам. На схеме ниже показаны разные конечные точки, которые предоставляет центр IoT.

![Конечные точки центра IoT][img-endpoints]

Ниже приведено описание конечных точек.

* **Поставщик ресурсов** центра IoT предоставляет интерфейс [диспетчера ресурсов Azure][lnk-arm], с помощью которого владельцы подписки Azure могут создавать и удалять центры IoT, а также обновлять их свойства. Свойства центра IoT определяют политики безопасности на уровне центра, а не контроль доступа на уровне устройств (см. раздел [Контроль доступа](#accesscontrol) ниже), и функциональные параметры, относящиеся к двустороннему обмену сообщениями между облаком и устройством. Поставщик ресурсов также позволяет [экспортировать удостоверения устройств](#importexport).
* **Управление удостоверениями устройств**. Каждый центр IoT предоставляет набор конечных точек HTTP REST, которые позволяют управлять удостоверениями устройств (создавать, получать, обновлять и удалять их). Удостоверения устройств нужны для аутентификации устройств и контроля доступа к ним. Дополнительные сведения см. в разделе [Реестр удостоверений устройств](#device-identity-registry).
* **Конечные точки устройств**. Для каждого устройства, подготовленного в реестре удостоверений устройств, центр IoT предоставляет набор конечных точек, которые используются устройством для отправки и получения сообщений.
    - *Отправка сообщений с устройства в облако*. Эта конечная точка используется для отправки сообщений с устройства в облако. Дополнительные сведения см. в разделе [Отправка сообщений с устройства в облако](#d2c).
    - *Получение сообщений из облака на устройство*. Устройство использует эту конечную точку для получения целевых сообщений из облака. Дополнительные сведения см. в разделе [Отправка сообщений из облака на устройство](#c2d).

    Эти конечные точки предоставляются по протоколам HTTP, [MQTT][lnk-mqtt] и [AMQP][lnk-amqp]. Обратите внимание, что протокол AMQP также доступен в [WebSockets][lnk-websockets] через порт 443.
* **Конечные точки службы**. Каждый центр IoT предоставляет набор конечных точек, которые могут использоваться в серверной части приложения для взаимодействия с устройствами. Эти конечные точки в настоящее время доступны только при использовании протокола [AMQP][lnk-amqp].
    - *Получение сообщений с устройства в облако*. Эта конечная точка совместима с [концентраторами событий Azure][lnk-event-hubs]. С ее помощью в серверной части приложения считываются все сообщения, отправляемые с устройств в облако. Дополнительные сведения см. в разделе [Отправка сообщений с устройства в облако](#d2c).
    - *Отправка сообщений из облака на устройство и получение уведомлений о доставке*. Эти конечные точки позволяют серверной части приложения отправлять надежные сообщения из облака в устройство и получать уведомления о доставке или истечении срока действия. Дополнительные сведения см. в разделе [Отправка сообщений из облака на устройство](#c2d).

В статье [Интерфейсы API и пакеты SDK центра IoT][lnk-apis-sdks] описываются способы получения доступа к этим конечным точкам.

Наконец, следует отметить, что все конечные точки центра IoT используют протокол [TLS][lnk-tls]. Кроме того, конечные точки не предоставляются по незашифрованным или незащищенным каналам.

### Чтение из конечных точек, совместимых с концентраторами событий <a id="eventhubcompatible"></a>

При использовании [пакета SDK служебной шины Azure для .NET](https://www.nuget.org/packages/WindowsAzure.ServiceBus) или [концентраторов событий и узла обработчика событий][] можно использовать любые строки подключения к центру IoT с нужными разрешениями, а затем использовать **messages/events** в качестве имени концентратора событий.

При использовании пакетов SDK (или интеграции продуктов), которые не поддерживают центр IoT, следует получить конечную точку, совместимую с концентраторами событий, и имя концентратора событий в разделе параметров центра IoT на [портале Azure][]\:

1. В выноске концентратора IoT щелкните элемент **Параметры**, а затем выберите пункт **Обмен сообщениями**.
2. В разделе **Параметры отправки сообщений с устройства в облако** вы увидите значения в полях **Конечная точка, совместимая с концентраторами событий**, **Имя, совместимое с концентраторами событий** и **Разделы**.

    ![][img-eventhubcompatible]

> [AZURE.NOTE] Иногда для пакета SDK требуется указать значение **Имя узла** или **Пространство имен**. В этом случае удалите схему из поля **Конечная точка, совместимая с концентраторами событий**. Например, если конечная точка, совместимая с концентраторами событий, это **sb://iothub-ns-myiothub-1234.servicebus.windows.net/**, **именем узла** будет **iothub-ns-myiothub-1234.servicebus.windows.net**, а **пространством имен** — **iothub-ns-myiothub-1234**.

Затем можно использовать любую политику безопасности общего доступа с разрешениями **ServiceConnect**, которые позволяют выполнять подключение к указанному концентратору событий.

Если нужно создать строку подключения к концентратору событий с помощью указанных выше сведений, можно использовать следующий образец:

```
Endpoint={Event Hub-compatible endpoint};SharedAccessKeyName={iot hub policy name};SharedAccessKey={iot hub policy key}
```

Ниже приведен список пакетов SDK и интеграций, которые можно применять к совместимым с концентратором событий конечным точкам, которые предоставляет центр IoT:

* [клиент концентраторов событий Java;](https://github.com/hdinsight/eventhubs-client)
* [воронка Apache Storm](../hdinsight/hdinsight-storm-develop-csharp-event-hub-topology.md), Вы можете просмотреть [воронку источника](https://github.com/apache/storm/tree/master/external/storm-eventhubs) на портале GitHub.
* [интеграция Apache Spark.](../hdinsight/hdinsight-apache-spark-csharp-apache-zeppelin-eventhub-streaming.md)

## Реестр удостоверений устройств

В каждом центре IoT есть реестр удостоверений устройств, который можно использовать для создания в службе уникальных ресурсов устройства (например очередь с сообщениями, отправленными из облака в устройство) и который обеспечивает доступ к конечным точкам, обращенным к устройствам (см. раздел [Контроль доступа](#accesscontrol)).

На высоком уровне реестр удостоверений устройств является коллекцией с поддержкой REST, состоящей из ресурсов удостоверений устройств. Следующие разделы содержат подробные сведения о свойствах ресурсов удостоверений устройств, а также об операциях, которые реестр позволяет выполнять с удостоверениями.

> [AZURE.NOTE] Дополнительные сведения о протоколе HTTP и пакетах SDK, которые можно использовать для взаимодействия с реестром удостоверений устройств, см. в статье [Интерфейсы API и пакеты SDK центра IoT][lnk-apis-sdks].

### Свойства удостоверений устройств <a id="deviceproperties"></a>

Удостоверения устройств отображаются как JSON-документы с нижеуказанными свойствами.

| Свойство | Параметры | Описание |
| -------- | ------- | ----------- |
| deviceId | Обязательно, при обновлениях доступно только для чтения | Строка с учетом регистра (длиной до 128 символов), состоящая из букв и цифр в 7-битовом формате ASCII + `{'-', ':', '.', '+', '%', '_', '#', '*', '?', '!', '(', ')', ',', '=', '@', ';', '$', '''}`. |
| generationId | Обязательно, только для чтения | Созданная концентратором строка с учетом регистра (длиной до 128 символов). Позволяет различать устройства с одинаковым свойством **deviceId**, которые были удалены, а затем созданы повторно. |
| etag | Обязательно, только для чтения | Строка, выполняющая функцию ненадежного заголовка ETag для удостоверения устройства (согласно [RFC7232][lnk-rfc7232]).|
| auth | необязательный | Составной объект, содержащий сведения об аутентификации и материалы безопасности. |
| auth.symkey | необязательный | Составной объект, содержащий первичный и вторичный ключи, хранящиеся в формате base64. |
| status | обязательно | Может иметь значение **Включено** или **Отключено**. Если указано значение **Включено**, устройство может подключаться. Если указано значение **Отключено**, устройство не может подключаться ни к одной конечной точке, обращенной к устройству. |
| statusReason | необязательный | 128-символьная строка, указывающая причину, по которой выбран тот или иной статус удостоверения устройства. Разрешены все символы UTF-8. |
| statusUpdateTime | Только для чтения | Дата и время последнего обновления статуса. |
| connectionState | Только для чтения | Значения **Подключено** или **Отключено** отображают статус подключения устройства для центра IoT. **Важно!** Используйте это поле только в целях разработки и отладки. Состояние подключения обновляется только для устройств, использующих протокол AMQP или MQTT. Кроме того, оно определяется по запросам проверки связи (по протоколу MQTT или AMQP) и может отображаться с задержкой до 5 минут. В связи с этим могут возникать ложно положительные результаты, например, когда отключенные устройства отображаются как подключенные. |
| connectionStateUpdatedTime | Только для чтения | Дата и время последнего обновления состояния подключения. |
| lastActivityTime | Только для чтения | Дата и время последнего подключения устройства, получения сообщения на устройство и отправки сообщения с него. |

> [AZURE.NOTE] Статус подключения отображает статус подключения для центра IoT. При некоторых состояниях и конфигурациях сети обновления этого состояния могут задерживаться.

### Операции с удостоверениями устройства

Реестр удостоверений устройств центра IoT поддерживает такие операции:

* создание удостоверения устройства;
* обновление удостоверения устройства;
* получение удостоверения устройства по идентификатору;
* удаление удостоверения устройства;
* отображение списка, содержащего до 1000 удостоверений;
* экспорт всех удостоверений в хранилище BLOB-объектов;
* импорт удостоверений из хранилища BLOB-объектов.

Все эти операции позволяют использовать оптимистический параллелизм (согласно [RFC7232][lnk-rfc7232]).

> [AZURE.IMPORTANT] Единственный способ получить все удостоверения, которые содержит реестр удостоверений концентратора, — использовать функцию [Экспорт](#importexport).

Реестр удостоверений устройств в центре IoT:

- не содержит метаданные приложения;
- доступен как к словарь (в качестве ключа используется свойство **deviceId**);
- не поддерживает выразительные запросы.

Решение IoT обычно включает в себя отдельное хранилище, содержащее метаданные приложений. Например, в хранилище решения для интеллектуального здания будут записываться данные о комнате, где установлен датчик температуры.

> [AZURE.IMPORTANT] Реестр удостоверений устройства следует использовать только для управления устройствами и операций подготовки. Выполнение операций в реестре удостоверений устройств не должно влиять на пропускную способность операций в среде выполнения. Например, проверка состояния подключения устройства перед отправкой команды не является поддерживаемым шаблоном. Проверьте [уровни регулирования](#throttling) реестра удостоверений устройств и шаблон [пульса устройств][lnk-guidance-heartbeat].

### Отключение устройств

Чтобы отключить устройства, обновите в реестре свойство **status** удостоверения. Обычно отключение используется в двух сценариях.

- В процессе оркестрации подготовки. Дополнительные сведения см. в разделе [Подготовка устройств][lnk-guidance-provisioning] статьи "Разработка решения".
- Если по какой-либо причине вы решите, что безопасность устройства нарушена или оно является неавторизованным.

### Экспорт удостоверений устройства <a id="importexport"></a>

Экспорт — это долгосрочная задача, использующая предоставленный клиентом контейнер BLOB-объектов, необходимых для сохранения данных, прочитанных из реестра удостоверений устройств.

Вы можете выполнить массовый экспорт удостоверений устройств из реестра удостоверений центра IoT, используя асинхронные операции в [конечной точке поставщика ресурсов центра IoT](#endpoints).

Операции, которые можно выполнять с заданиями экспорта:

* создание задания экспорта;
* получение статуса выполняющегося задания;
* отмена выполняющегося задания.

> [AZURE.NOTE] В любой момент времени на концентраторе может быть запущена только одна задача.

Подробные сведения об API-интерфейсах импорта и экспорта см. в статье [Центр IoT Azure — интерфейсы API поставщика ресурсов][lnk-resource-provider-apis].

Дополнительные сведения об импорте и экспорте заданий см. в статье [Массовое управление удостоверениями устройств центра IoT][lnk-bulk-identity].

### Задания экспорта

Все задания экспорта имеют нижеуказанные свойства.

| Свойство | Параметры | Описание |
| -------- | ------- | ----------- |
| jobId | Формируется системой, игнорируется при создании | |
| creationTime | Формируется системой, игнорируется при создании | |
| endOfProcessingTime | Формируется системой, игнорируется при создании | |
| type | Только для чтения | **ExportDevices** |
| status | Формируется системой, игнорируется при создании | **В очереди**, **Запущено**, **Завершено**, **Сбой**. |
| ход выполнения | Формируется системой, игнорируется при создании | Целое значение, обозначающее процент выполнения. |
| outputBlobContainerURI | Обязательно для всех заданий | Универсальный код ресурса (URI) подписанного URL-адреса большого двоичного объекта с доступом на запись к контейнеру больших двоичных объектов (см. статью [Создание и использование подписи общего доступа с помощью службы BLOB-объектов][lnk-createuse-sas]). Используется для вывода статуса задания и результатов. |
| excludeKeysInExport | необязательный | Если задано значение **false**, ключи включаются в выходные данные экспорта. В противном случае экспортируются ключи со значением **null**. Значение по умолчанию — **false**. |
| failureReason | Формируется системой, игнорируется при создании | Если для статуса отображается значение **Failed**, эта строка содержит причину. |

В качестве параметра заданий экспорта указан универсальный код ресурса (URI) подписанного URL-адреса большого двоичного объекта. Это предоставляет доступ на запись к контейнеру больших двоичных объектов для вывода данных задания.

Задание записывает выходные данные в указанный контейнер больших двоичных объектов в файл с именем **devices.txt**. Этот файл содержит удостоверения устройств, сериализованные в формате JSON (как указано в разделе [Свойства удостоверений устройств](#deviceproperties)). Если для параметра **excludeKeysInExport** задано значение **true**, параметр проверки подлинности для каждого устройства, указанного в файле **devices.txt**, имеет значение **null**.

**Пример**:

```
{"id":"devA","eTag":"MQ==","status":"enabled","authentication":{"symmetricKey":{"primaryKey":"123","secondaryKey":"123"}}}
{"id":"devB","eTag":"MQ==","status":"enabled","authentication":{"symmetricKey":{"primaryKey":"123","secondaryKey":"123"}}}
{"id":"devC","eTag":"MQ==","status":"enabled","authentication":{"symmetricKey":{"primaryKey":"123","secondaryKey":"123"}}}
```

### Импорт удостоверений устройств

Импорт — это долгосрочная задача с использованием данных в предоставленном клиентом контейнере BLOB-объектов, необходимых для записи данных в реестр удостоверений устройств.

Вы можете выполнить массовый импорт удостоверений устройств в реестр удостоверений центра IoT, используя асинхронные операции в [конечной точке поставщика ресурсов центра IoT](#endpoints).

Операции, которые можно выполнять с заданиями импорта:

* создание задания импорта;
* получение статуса выполняющегося задания;
* отмена выполняющегося задания.

> [AZURE.NOTE] В любой момент времени на концентраторе может быть запущена только одна задача.

Подробные сведения об API-интерфейсах импорта и экспорта см. в статье [Центр IoT Azure — интерфейсы API поставщика ресурсов][lnk-resource-provider-apis].

Дополнительные сведения об импорте и экспорте заданий см. в статье [Массовое управление удостоверениями устройств центра IoT][lnk-bulk-identity].

### Задания импорта

Все задания импорта имеют нижеуказанные свойства.

| Свойство | Параметры | Описание |
| -------- | ------- | ----------- |
| jobId | Формируется системой, игнорируется при создании | |
| creationTime | Формируется системой, игнорируется при создании | |
| endOfProcessingTime | Формируется системой, игнорируется при создании | |
| type | Только для чтения | **ImportDevices** |
| status | Формируется системой, игнорируется при создании | **В очереди**, **Запущено**, **Завершено**, **Сбой**. |
| ход выполнения | Формируется системой, игнорируется при создании | Целое значение, обозначающее процент выполнения. |
| outputBlobContainerURI | Обязательно для всех заданий | Универсальный код ресурса (URI) подписанного URL-адреса большого двоичного объекта с доступом на запись к контейнеру больших двоичных объектов (см. статью [Создание и использование подписи общего доступа с помощью службы BLOB-объектов][lnk-createuse-sas]). Используется для вывода статуса задания. |
| inputBlobContainerURI | обязательно | Универсальный код ресурса (URI) подписанного URL-адреса большого двоичного объекта с доступом на чтение к контейнеру BLOB-объектов (см. статью [Создание и использование подписи общего доступа с помощью службы BLOB-объектов][lnk-createuse-sas]). Задание считывает сведения об устройстве для импорта из BLOB-объекта. |
| failureReason | Формируется системой, игнорируется при создании | Если для статуса отображается значение **Failed**, эта строка содержит причину. |

В качестве параметров для заданий импорта используются два универсальных кода ресурса (URI) подписанных URL-адресов. Один предоставляет доступ на запись контейнеру BLOB-объектов для вывода данных о состоянии задания, а другой — доступ на чтение для считывания входных данных.

Задание считывает входные данные из контейнера BLOB-объектов, указанного в файле **devices.txt**. Этот файл содержит удостоверения устройств, сериализованные в формате JSON (как указано в разделе [Свойства удостоверений устройств](#deviceproperties)). Поведение при импорте, предусмотренное для каждого устройства по умолчанию, можно перезаписать, добавив свойство **importMode**. Это свойство может принимать одно из следующих значений:

| importMode | Описание |
| -------- | ----------- |
| **createOrUpdate** | Если устройство с указанным **идентификатором** не существует, оно регистрируется заново. <br/>Если устройство уже существует, имеющиеся данные заменяются предоставленными входными данными вне зависимости от значения **ETag**. |
| **создание** | Если устройство с указанным **идентификатором** не существует, оно регистрируется заново. <br/>Если устройство уже существует, в файл журнала записывается ошибка. |
| **обновить** | Если устройство с указанным **идентификатором** уже существует, имеющиеся данные заменяются предоставленными входными данными вне зависимости от значения **ETag**. <br/>Если устройство не существует, в файл журнала записывается ошибка. |
| **updateIfMatchETag** | Если устройство с указанным **идентификатором** уже существует, имеющиеся данные заменяются предоставленными входными данными только при совпадении **ETag**. <br/>Если устройство не существует, в файл журнала записывается ошибка. <br/>Если имеется несовпадение **ETag**, в файл журнала записывается ошибка. |
| **createOrUpdateIfMatchETag** | Если устройство с указанным **идентификатором** не существует, оно регистрируется заново. <br/>Если устройство уже существует, имеющиеся данные заменяются предоставленными входными данными только при совпадении **ETag**. <br/>Если имеется несовпадение **ETag**, в файл журнала записывается ошибка. |
| **delete** | Если устройство с указанным **идентификатором** уже существует, оно удаляется вне зависимости от значения **ETag**. <br/>Если устройство не существует, в файл журнала записывается ошибка. |
| **deleteIfMatchETag** | Если устройство с указанным **идентификатором** уже существует, оно удаляется только при совпадении **ETag**. Если устройство не существует, в файл журнала записывается ошибка. <br/>Если имеется несовпадение ETag, в файл журнала записывается ошибка. |

**Пример**:

```
{"id":"devA","eTag":"MQ==","status":"enabled","authentication":{"symmetricKey":{"primaryKey":"123","secondaryKey":"123"}}, "importMode":"delete"}
{"id":"devB","eTag":"MQ==","status":"enabled","authentication":{"symmetricKey":{"primaryKey":"123","secondaryKey":"123"}}, "importMode":"createOrUpdate"}
{"id":"devC","eTag":"MQ==","status":"enabled","authentication":{"symmetricKey":{"primaryKey":"123","secondaryKey":"123"}}, "importMode":"create"}
```

## Безопасность <a id="security"></a>

В этом разделе описаны возможности защиты центра Azure IoT.

### Контроль доступа <a id="accesscontrol"></a>

Центр IoT использует следующий набор *разрешений*, чтобы предоставить доступ к каждой из своих конечных точек. Разрешения ограничивают доступ к центру IoT на основе функций.

* **RegistryRead**. Предоставляет доступ на чтение к реестру удостоверений устройств. Дополнительные сведения см. в разделе [Реестр удостоверений устройств](#device-identity-registry).
* **RegistryReadWrite**. Предоставляет доступ на чтение и запись к реестру удостоверений устройств. Дополнительные сведения см. в разделе [Реестр удостоверений устройств](#device-identity-registry).
* **ServiceConnect**. Предоставляет доступ к конечным точкам обмена данными и мониторинга, обращенным к облачной службе. Например, это разрешение позволяет серверным облачным службам получать сообщения с устройств, отправлять сообщения в устройства и получать соответствующие уведомления о доставке.
* **DeviceConnect**. Предоставляет доступ к конечным точкам обмена данными, обращенным к устройству. Например, это разрешение позволяет отправлять сообщения с устройства в облако и получать сообщения, отправленные из облака на устройство. Это разрешение используют устройства.

Предоставить разрешения можно следующими способами.

* **Политики общего доступа на уровне концентратора**. Политики общего доступа могут предоставлять любое сочетание разрешений из перечисленных в предыдущем разделе. Политики можно задавать на [портале Azure][lnk-management-portal] или программно, используя [интерфейсы API поставщика ресурсов центра IoT Azure][lnk-resource-provider-apis]. По умолчанию для только что созданного центра IoT заданы такие политики:

    - *iothubowner*: политика со всеми разрешениями;
    - *service*: политика с разрешением **ServiceConnect**;
    - *device*: политика с разрешением **DeviceConnect**;
    - *registryRead*: политика с разрешением **RegistryRead**;
    - *registryReadWrite*: политика с разрешениями **RegistryRead** и **RegistryWrite**.

* **Учетные данные безопасности на уровне отдельного устройства**. Каждый центр IoT содержит [реестр удостоверений устройств](#device-identity-registry). Для каждого устройства в этом реестре вы можете задать учетные данные безопасности, дающие вам разрешения **DeviceConnect**, которые соответствуют конечным точкам устройств.

**Пример**. Стандартное решение IoT:
- Компонент управления устройством использует политику *registryReadWrite*.
- Компонент обработчика событий использует политику *service*.
- Компонент бизнес-логики устройства среды выполнения использует политику *service*.
- Отдельные устройства подключаются с помощью учетных данных, которые хранятся в реестре удостоверений центра IoT.

Рекомендации по вопросам безопасности центра IoT см. в статье [Разработка решения][lnk-guidance-security].

### Аутентификация

Центр Azure IoT предоставляет доступ к конечным точкам, проверяя маркер на соответствие политикам общего доступа и учетным данным безопасности в реестре удостоверений устройств.

Учетные данные безопасности, например симметричные ключи, никогда не отправляются по сети.

> [AZURE.NOTE] Безопасность для поставщика ресурсов центра IoT Azure обеспечивается с помощью подписки Azure (это касается всех поставщиков в [диспетчере ресурсов Azure][lnk-azure-resource-manager]).

Дополнительные сведения о способах создания и использования маркеров безопасности приведены в статье [Маркеры безопасности центра IoT][lnk-sas-tokens].

#### Особенности протокола

Каждый поддерживаемый протокол, например AMQP, MQTT и HTTP, передает маркеры разными способами.

Протокол HTTP реализует проверку подлинности посредством включения допустимого маркера в заголовок запроса **Авторизация**. Маркер может передаваться и с помощью параметра запроса **Авторизация**.

При использовании [AMQP][lnk-amqp] центр IoT поддерживает механизм [SASL PLAIN][lnk-sasl-plain] и стандарт [защиты AMQP на основе утверждений][lnk-cbs].

Стандарт защиты AMQP на основе утверждений определяет, как следует передавать эти маркеры.

Для SASL PLAIN **имя пользователя** может быть следующим:

* `{policyName}@sas.root.{iothubName}` — если маркеры являются маркерами уровня концентратора;
* `{deviceId}` — если маркеры являются маркерами уровня устройства.

В обоих случаях поле пароля содержит маркер, как описано в статье [Маркеры безопасности центра IoT][lnk-sas-tokens].

При использовании протокола MQTT пакет CONNECT содержит код deviceId как значение ClientId, {iothubhostname}/{deviceId} в поле "Имя пользователя", где {iothubhostname} — это полная запись CName центра IoT (например contoso.azure-devices.net), а маркер SAS — в поле "Пароль".

##### Пример: #####

Имя пользователя (значение DeviceId чувствительно к регистру): `iothubname.azure-devices.net/DeviceId`

Пароль (создание SAS с помощью обозревателя устройства): `SharedAccessSignature sr=iothubname.azure-devices.net%2fdevices%2fDeviceId&sig=kPszxZZZZZZZZZZZZZZZZZAhLT%2bV7o%3d&se=1487709501`

> [AZURE.NOTE] [Пакеты SDK центра IoT Azure][lnk-apis-sdks] автоматически создают маркеры при подключении к службе. В некоторых случаях пакеты SDK поддерживают не все протоколы или не все методы проверки подлинности.

#### Сравнение SASL PLAIN с CBS

При использовании SASL PLAIN клиент, подключающийся к центру IoT, может использовать по одному маркеру для каждого TCP-подключения. Когда срок действия маркера истекает, TCP-подключение к службе прерывается и выполняется попытка повторного подключения. Хотя это поведение и не является проблематичным для серверного компонента приложения, оно может навредить приложению на стороне устройства по следующим причинам.

*  Шлюзы обычно подключаются от имени многих устройств. Если используется SASL PLAIN, шлюзам нужно создать отдельное TCP-подключение для каждого устройства, подключающегося к центру IoT. Это значительно повышает потребление электроэнергии и сетевых ресурсов и увеличивает задержку подключения устройства.
* Если потребление ресурсов увеличится, устройства с ограниченными ресурсами должны будут выполнять повторное подключение после истечения срока действия маркера.

### Определение области действия учетных данных на уровне концентратора

Чтобы определить область действия для политик безопасности на уровне концентратора, создайте маркеры с помощью универсального кода (URI) ограниченного ресурса. Например, конечная точка для отправки сообщений с устройства в облако — **/devices/{deviceId}/messages/events**. Кроме того, для подписи маркера со значением resourceURI **/devices/{deviceId}** можно использовать политику общего доступа на уровне концентратора с разрешениями **DeviceConnect**. В результате будет создан маркер, который можно использовать только для отправки устройств от имени устройства с кодом **deviceId**.

Этот механизм похож на [политику издателя концентраторов событий][lnk-event-hubs-publisher-policy]. Он позволяет реализовывать методы настраиваемой проверки подлинности (как объясняется в разделе о безопасности в статье [Разработка решения][lnk-guidance-security]).

## Обмен сообщениями

Центр IoT предоставляет примитивы обмена сообщениями для приведенных ниже вариантов взаимодействия.
- [С облака на устройство](#c2d): из серверной части приложения (*службы* или *облака*).
- [С устройства в облако](#d2c): с устройства в серверную часть приложения.

Основные свойства функции обмена сообщениями в центре IoT — надежность и устойчивость сообщений. Поэтому они сохраняются, если на стороне устройства прерывается подключение и если наступает момент пиковой загрузки на стороне облака при обработке событий. Центр IoT гарантирует *как минимум однократную* доставку при двухстороннем обмене сообщениями между устройством и облаком.

Центр IoT поддерживает несколько обращенных к устройству протоколов (например, AMQP и HTTP/1). Для поддержки эффективного взаимодействия по протоколам центр IoT задает общий формат сообщений, поддерживаемый всеми обращенными к устройству протоколами.

### Формат сообщений <a id="messageformat"></a>

Сообщения центра IoT включают в себя следующие компоненты.

* Набор *свойств системы.* Это свойства, которые интерпретирует или задает центр IoT. Этот набор определяется предварительно.
* Набор *свойств приложения*. Это словарь свойств строки, которые приложение может задать и использовать без необходимости десериализации текста сообщения. Центр IoT никогда не изменяет эти свойства.
* Непрозрачная двоичная основная часть.

Дополнительные сведения о разных способах кодировки сообщения в разных протоколах см. в статье [Интерфейсы API и пакеты SDK центра IoT][lnk-apis-sdks].

Это набор системных свойств в сообщениях центра IoT.

| Свойство | Описание |
| -------- | ----------- |
| MessageId | Задаваемый пользователем идентификатор сообщения, обычно используемый для шаблонов типа запрос-ответ. Формат: строка с учетом регистра (длиной до 128 символов), состоящая из букв и цифр в 7-битовом формате ASCII + `{'-', ':',’.', '+', '%', '_', '#', '*', '?', '!', '(', ')', ',', '=', '@', ';', '$', '''}`. |
| Порядковый номер | Число (уникальное для каждой очереди устройства), которое центр IoT назначает каждому сообщению, отправленному из облака на устройство. |
| Кому | Используется в сообщениях, отправляемых [из облака в устройство](#c2d), для указания места назначения. |
| ExpiryTimeUtc | Дата и время истечения срока действия сообщения. |
| EnqueuedTime | Дата и время получения сообщения центром IoT. |
| CorrelationId | Строковое свойство в сообщении ответа, которое обычно содержит идентификатор сообщения запроса в шаблонах "запрос-ответ". |
| UserId | Используется для указания источника сообщения. Если сообщения создает центр IoT, для этого параметра задается значение `{iot hub name}`. |
| Ack | Используется в сообщениях, отправляемых из облака в устройство, чтобы запросить у центра IoT отправку отзыва после того, как сообщение будет использовано устройством. Возможные значения: **none** (по умолчанию) — отзывы не создаются; **positive** — отзыв будет получен, когда исходное сообщение будет передано; **negative** — отзыв будет получен, когда истечет срок действия исходного сообщения (или будет превышен лимит доставок) и при этом устройство его не примет; **full**: активированы значения positive и negative. Дополнительную информацию см. в разделе [Отзыв на сообщение](#feedback). |
| ConnectionDeviceId | Центр IoT устанавливает это свойство в сообщениях, отправляемых с устройства в облако. Содержит идентификатор **deviceId** устройства, отправившего сообщение. |
| ConnectionDeviceGenerationId | Центр IoT устанавливает это свойство в сообщениях, отправляемых с устройства в облако. Содержит идентификатор **generationId** (см. раздел [Свойства удостоверений устройств](#deviceproperties)) устройства, отправившего сообщение. |
| ConnectionAuthMethod | Центр IoT устанавливает это свойство в сообщениях, отправляемых с устройства в облако. Сведения о методе аутентификации, используемом для аутентификации устройства, отправляющего сообщение. Дополнительные сведения см. в разделе [Защита сообщений, отправляемых с устройства в облако, от спуфинга](#antispoofing).|

### Выбор протокола связи <a id="amqpvshttp"></a>

Центр IoT поддерживает протоколы [AMQP][lnk-amqp], AMQP через WebSocket, MQTT, HTTP/1 для обмена данными на стороне устройства. Далее приведен список рекомендаций по их применению.

* **Шаблон сообщения из облака на устройство**. Протокол HTTP/1 не позволяет отправлять данные по инициативе сервере. Таким образом, при использовании протокола HTTP/1 устройства опрашивают центр IoT на предмет наличия сообщений из облака на устройство. Это очень неэффективно для устройства и центра IoT. На данный момент при использовании протокола HTTP/1 каждое устройство должно отправлять запросы не реже, чем раз в 25 минут. С другой стороны, протоколы AMQP и MQTT поддерживают отправку сообщений по инициативе сервера из облака на устройство и позволяют незамедлительно передавать сообщения из центра IoT на устройство. Если задержка доставки является проблемой, лучше использовать протокол AMQP или MQTT. С другой стороны, если устройство едва подключается, подойдет и протокол HTTP/1.
* **Шлюзы поля**. Протоколы HTTP-1 и MQTT не позволяют подключать по TLS-соединению одновременно несколько устройств (на каждом из которых используются собственные учетные данные). Таким образом, эти протоколы не подходят для ситуаций с [использованием полевого шлюза][lnk-azure-gateway-guidance], поскольку требуют отдельного TLS-подключения между полевым шлюзом и центром IoT для каждого устройства, подключаемого к полевому шлюзу.
* **Устройства с небольшим количеством ресурсов**. Библиотеки MQTT и HTTP/1 уступают по объему библиотекам AMQP, а значит, только их можно использовать для устройств с ограниченными ресурсами (например, если размер ОЗУ меньше 1 МБ).
* **Обход сети**. Протокол MQTT прослушивает порт 8883. Это может вызвать проблемы в сетях, закрытых для других протоколов. В подобных случаях используются протоколы HTTP и AMQP (через WebSocket).
* **Объем полезных данных**. AMQP и MQTT — это двоичные протоколы, значительно более компактные, чем HTTP/1.

На высоком уровне по возможности следует выбирать протокол AMQP (или AMQP через WebSocket), а MQTT использовать только в том случае, если ресурсы ограничивают применение протокола AMQP. HTTP/1 следует применять только в том случае, если обход и конфигурация сети не позволяют использовать протоколы MQTT и AMQP. Кроме того, при использовании протокола HTTP/1 каждое устройство должно проверять наличие сообщений из облака на устройство не реже, чем раз в 25 минут.

> [AZURE.NOTE] Разумеется, во время разработки частота такой проверки может быть выше.

<a id="mqtt-support">
#### Примечания о поддержке протокола MQTT
В центре IoT протокол MQTT 3.1.1 реализован со следующими ограничениями и особенностями:

  * **QoS 2 не поддерживается**. Если клиент устройства пакет публикует сообщение с **QoS 2**, центр IoT закрывает сетевое подключение. Если клиент устройства подписывается на раздел с **QoS 2**, центр IoT присваивает пакету **SUBACK** уровень QoS не выше первого.
  * **Сохранение**. Если клиент устройства публикует сообщение с флагом RETAIN, имеющим значение 1, центр IoT добавляет в сообщение свойство **x-opt-retain**. Это значит, что центр IoT не сохранит сообщение, а передаст его во внутреннее приложение.

И наконец, обратите внимание на [шлюз протокола Azure IoT][lnk-azure-protocol-gateway], с помощью которого можно развернуть высокопроизводительный настраиваемый шлюз протокола, который взаимодействует с центром IoT напрямую. Шлюз протокола Azure IoT позволяет настроить протокол устройства для уже существующих развертываний MQTT или других настраиваемых протоколов. Недостаток этого подхода — это необходимость самостоятельно размещать настраиваемый шлюз протокола и управлять им.

### Отправка сообщений с устройства в облако<a id="d2c"></a>

Как описано в разделе [Конечные точки](#endpoints), сообщения, отправляемые с устройства в облако, передаются через конечную точку, подключенную к устройству (**/devices/{идентификатор\_устройства}/messages/events**). Устройства получают их через конечную точку, подключенную к службе (**/messages/events**), которая совместима с [концентраторами событий][lnk-event-hubs]. Таким образом, чтобы получать сообщения, отправляемые из устройства в облако, можно использовать стандартную интеграцию концентраторов событий и пакетов SDK.

Реализация отправки сообщений с устройства в облако в центре IoT похожа на реализацию в [концентраторах событий][lnk-event-hubs]. При этом сообщения центра IoT, отправляемые с устройства в облако, больше похожи на *события* концентраторов событий, чем на *сообщения* [служебной шины][lnk-servicebus].

Далее перечислены следствия этой реализации.

* Подобно *событиям* концентраторов событий, сообщения с устройства в облако устойчивы и хранятся в центре IoT до 7 дней (см. раздел [Параметры конфигурации сообщений, отправляемых с устройства в облако](#d2cconfiguration)).
* Сообщения, отправляемые с устройства в облако, секционируются по фиксированному набору секций, заданному во время создания (см. подраздел [Параметры конфигурации сообщений, отправляемых с устройства в облако](#d2cconfiguration)).
* Подобно тому, как это происходит с концентраторами событий, клиенты, читающие сообщения, отправляемые с устройства в облако, должны работать с секциями и назначением контрольных точек. См. раздел [Концентраторы событий — использование событий][lnk-event-hubs-consuming-events].
* Как и в случае с событиями концентраторов событий, размер сообщений, поступающих с устройства в облако, не может превышать 256 КБ; их можно объединять в пакеты, чтобы оптимизировать отправку. Размер пакетов не может превышать 256 КБ, а сами пакеты не могут содержать более 500 сообщений.

При этом сообщения центра IoT, отправляемые с устройства в облако, и сообщения, отправляемые концентраторами событий, существенно различаются.

* Как объяснено в разделе [Безопасность](#security), центр IoT позволяет проводить аутентификацию каждого устройства и осуществлять контроль доступа.
* Центр IoT позволяет одновременно подключать миллионы устройств (см. раздел [Квоты и регулирование](#throttling)), тогда как концентраторы событий позволяют выполнять максимум 5000 подключений по протоколу AMQP в одном пространстве имен.
* Центр IoT не позволяет выполнять произвольное секционирование с помощью **PartitionKey**. Сообщения, отправляемые с устройства в облако, секционируются на основе их исходного **deviceId**.
* Масштабирование центра IoT немного отличается от масштабирования концентраторов событий. Дополнительную информацию см. в статье [Масштабирование центра IoT][lnk-guidance-scale].

Обратите внимание: это не означает, что центр IoT может заменить концентраторы событий во всех сценариях. Например, иногда при вычислениях для обработки событий может понадобиться перераспределить события на основе другого свойства или поля, чтобы проанализировать потоки данных. В этом сценарии с помощью концентратора событий можно отделить друг от друга два раздела конвейера обработки потока. Дополнительные сведения см. в разделе *Шаблоны* статьи [Обзор концентраторов событий Azure][lnk-eventhub-partitions].

Сведения об использовании обмена сообщениями с устройства в облако см. в статье [Интерфейсы API и пакеты SDK центра IoT][lnk-apis-sdks].

> [AZURE.NOTE] При использовании протокола HTTP для отправки сообщений с устройства в облако имена и значения свойств могут содержать только буквенно-цифровые знаки ASCII и знаки ``{'!', '#', '$', '%, '&', "'", '*', '*', '+', '-', '.', '^', '_', '`', '|', '~'}``.

#### Трафик, передающийся без использования телеметрии

Часто устройства отправляют не только точки данных телеметрии, но и сообщения и запросы, выполнение и обработку которых осуществляет та часть приложения, которая отвечает за бизнес-логику. Например, устройство отправляет критические оповещения, которые должны активировать определенное действие в серверной части, или отвечает на команды, отправленные из серверной части.

Дополнительные сведения об оптимальных методах обработки таких сообщений см. в статье [Учебник: как обрабатывать сообщения, отправляемые с устройства в облако, с помощью центра IoT][lnk-guidance-d2c-processing].

#### Параметры конфигурации сообщений, отправляемых с устройства в облако <a id="d2cconfiguration"></a>

Центр IoT позволяет управлять сообщениями, отправляемыми с устройства в облако, с помощью приведенных ниже свойств.

* **Количество секций**. Это свойство можно задать во время создания, чтобы определить количество разделов для приема событий сообщений, отправляемых с устройства в облако.
* **Время хранения**. Это свойство определяет время хранения сообщений, отправляемых с устройства в облако. Значение по умолчанию — один день, но это значение можно увеличить до семи дней.

Кроме того, как и концентраторы событий, центр IoT предоставляет возможность управлять группами потребителей в конечной точке, которая получает сообщения, отправляемые с устройства в облако.

Вы можете изменить все эти свойства на [портале Azure][lnk-management-portal] или программно (с помощью [API-интерфейсов поставщика ресурсов в центре IoT Azure][lnk-resource-provider-apis]).

#### Свойства для защиты от спуфинга <a id="antispoofing"></a>

Чтобы избежать спуфинга устройств при работе с сообщениями, отправляемыми с устройства в облако, центр IoT отмечает все сообщения такими свойствами:

* **ConnectionDeviceId;**
* **ConnectionDeviceGenerationId;**
* **ConnectionAuthMethod.**

Первые два свойства содержат параметры **deviceId** и **generationId** исходного устройства (согласно разделу [Свойства удостоверений устройств](#deviceproperties)).

Свойство **ConnectionAuthMethod** содержит сериализованный объект JSON, имеющий такие свойства:

```
{
  "scope": "{ hub | device}",
  "type": "{ symkey | sas}",
  "issuer": "iothub"
}
```

### Отправка сообщений из облака на устройство <a id="c2d"></a>

Как подробно описано в статье [Конечные точки](#endpoints), сообщения из облака на устройство можно отправлять через конечную точку, подключенную к службе (**/messages/devicebound**), а устройства могут получить их через конечную точку конкретного устройства (**/devices/{идентификатор\_устройства}/messages/devicebound**).

Каждое сообщение, отправляемое из облака на устройство, адресовано отдельному устройству, то есть для свойства **to** задается значение **/devices/{идентификатор\_устройства}/messages/devicebound**.

**Важно!** Одна очередь устройства может содержать не более 50 сообщений, отправляемых из облака на устройство. Попытка отправить на устройство большее количество сообщений приведет к ошибке.

> [AZURE.NOTE] При отправке сообщений из облака на устройство имена и значения свойств могут содержать только буквенно-цифровые знаки ASCII и знаки ``{'!', '#', '$', '%, '&', "'", '*', '*', '+', '-', '.', '^', '_', '`', '|', '~'}``.

#### Жизненный цикл сообщения <a id="message lifecycle"></a>

Чтобы реализовать гарантию *как минимум однократной* доставки, сообщения, отправляемые из облака на устройство, хранятся в очередях устройств. Сами устройства должны явно подтвердить *завершение* доставки, чтобы центр IoT мог удалить сообщения из очереди. Это гарантирует устойчивость к сбоям подключения и ошибкам устройств.

На следующей схеме показан жизненный цикл сообщений, отправляемых с облака в устройство.

![Жизненный цикл сообщений, отправляемых из облака на устройство][img-lifecycle]

Когда служба отправляет сообщение, считается, что оно *поставлено в очередь*. Когда устройству нужно *получить* сообщение, центр IoT *блокирует* сообщение (устанавливает состояние **Invisible**), чтобы другие потоки на том же устройстве начали получать другие сообщения. Когда поток устройства завершает обработку сообщения, он уведомляет центр IoT путем *завершения* сообщения.

Устройство также может:
- *отклонить* сообщение, в результате чего центр IoT переводит его в состояние **Deadlettered**;
- *прервать* сообщение, в результате чего центр IoT помещает его в очередь с состоянием **Enqueued**.

При обработке сообщения потоком может произойти ошибка без уведомления центра IoT. В этом случае состояние сообщения автоматически меняется с **Invisible** на **Enqueued** после *истечения срока видимости (или блокировки)* (значение по умолчанию — одна минута). Состояние сообщения может изменяться с **Enqueued** на **Invisible** и наоборот столько раз, сколько указано в свойстве *Максимальное количество доставок* центра IoT. После выполнения этого количества изменений центр IoT устанавливает для сообщения состояние **Deadlettered**. Таким же образом центр IoT устанавливает для сообщения состояние ** доставлено** после истечения срока действия сообщения (см. раздел [Срок жизни](#ttl)).

Руководство по сообщениям, отправляемым из облака на устройство, см. в статье. [Отправка сообщений из облака на устройство с помощью центра IoT Azure][lnk-getstarted-c2d-tutorial]. Справочную информацию о том, как разные API-интерфейсы и пакеты SDK предоставляют функцию отправки сообщений из облака на устройство, см. в статье [Интерфейсы API и пакеты SDK центра IoT][lnk-apis-sdks].

> [AZURE.NOTE] Обычно, если потеря сообщения, отправляемого с облака в устройство, никак не влияет на логику приложения, эти сообщения завершаются. Это может произойти в различных сценариях. Например, когда содержимое сообщения успешно сохранено в локальном хранилище, когда операция успешно выполнена или когда сообщение содержит временные сведения, потеря которых не влияет на функциональность приложения. Иногда при работе с долгосрочной задачей сообщение, отправляемое с облака в устройство, можно завершить после того, как описание задачи сохранится в локальном хранилище. После этого на различных этапах выполнения задачи в серверную часть приложения отправляется одно или несколько уведомлений.

#### Срок жизни <a id="ttl"></a>

Каждое сообщение из облака на устройство имеет срок действия. Его может быть явно задавать служба (в свойстве **ExpiryTimeUtc**) или центр IoT, в котором задан *срок жизни* по умолчанию, указанный в соответствующем свойстве центра IoT. См. раздел [Параметры конфигурации сообщений, отправляемых из облака на устройство](#c2dconfiguration).

> [AZURE.NOTE] Распространенный способ воспользоваться сроком действия сообщения — задать короткое время жизни, чтобы сообщения не отправлялись на отключенные устройства. Это позволяет добиться того же результата, что и поддержание состояния подключения устройства, но при этом обладает значительно большей эффективностью. Запрашивая подтверждения сообщений у центра IoT, также можно узнать, какие устройства могут получать сообщения, а какие находятся в автономном режиме или в состоянии сбоя.

#### Отзыв на сообщение <a id="feedback"></a>

При отправке сообщений с облака в устройство служба может запросить отзыв на каждое сообщение, уведомляющий о его конечном состоянии.

- Если для свойства **Ack** задать значение **positive**, центр IoT создаст отзыв на сообщение только в том случае, если сообщение, отправляемое из облака в устройство, имеет состояние **Completed**.
- Если для свойства **Ack** задать значение **negative**, центр IoT создаст отзыв на сообщение только в том случае, если сообщение, отправляемое из облака в устройство, имеет состояние **Deadletterd**.
- Если для свойства **Ack** задать значение **full**, центр IoT создаст отзыв на сообщение в любом случае.

> [AZURE.NOTE] Если свойство **Ack** имеет значение **full** и отзыв не получен, это означает, что срок действия отзыва истек и служба не знает, что случилось с исходным сообщением. На практике служба должна убедиться, что может обработать отзыв до истечения срока его действия. Максимальный срок действия составляет два дня, и этого времени должно быть достаточно для запуска службы при сбое.

Как описано в статье [Конечные точки](#endpoints), центр IoT предоставляет отзывы в виде сообщений через конечную точку, подключенную к службе (**/messages/servicebound/feedback**). Семантика получения отзыва идентична семантике, используемой для сообщений, отправляемых из облака в устройство, с тем же [жизненным циклом сообщения](#жизненный цикл сообщения). Когда это возможно, отзывы на сообщения группируются в одно сообщение, имеющее приведенный ниже формат.

Каждое сообщение, полученное устройством из конечной точки отзыва, имеет следующие свойства:

| Свойство | Описание |
| -------- | ----------- |
| EnqueuedTime | Метка времени, указывающая, когда было создано сообщение. |
| UserId | `{iot hub name}` |
| ContentType | `application/vnd.microsoft.iothub.feedback.json` |

Основная часть — это сериализованный массив записей JSON, каждая из которых имеет следующие свойства:

| Свойство | Описание |
| -------- | ----------- |
| EnqueuedTimeUtc | Метка времени, указывающая, когда отобразился результат сообщения. Например, устройство завершило его или истек срок его действия. |
| OriginalMessageId | Идентификатор **MessageId** сообщения, которое отправляется из облака на устройство и к которому относится эта информация. |
| StatusCode | Требуется целое число. Используется в отзывах, созданных центром IoT. <br/> 0 — успешное завершение. <br/> 1 — срок действия истек. <br/> 2 — превышено максимальное количество доставок. <br/> 3 — сообщение отклонено. |
| Описание | Строковые значения **StatusCode**. |
| DeviceId | Идентификатор **DeviceId** целевого устройства, которому отправляется сообщение из облака и к которому относится этот отзыв. |
| DeviceGenerationId | Идентификатор **DeviceGenerationId** целевого устройства сообщения, которому отправляется сообщение из облака и к которому относится этот отзыв. |


**Важно!** Служба должна указать идентификатор **MessageId** для сообщения, отправляемого из облака на устройство, чтобы соотнести свой отзыв с исходным сообщением.

**Пример.** Ниже приведен пример текста сообщения отзыва.

```
[
  {
    "OriginalMessageId": "0987654321",
    "EnqueuedTimeUtc": "2015-07-28T16:24:48.789Z",
    "StatusCode": 0
    "Description": "Success",
    "DeviceId": "123",
    "DeviceGenerationId": "abcdefghijklmnopqrstuvwxyz"
  },
  {
    ...
  },
  ...
]
```

#### Параметры конфигурации сообщений, отправляемых из облака на устройство <a id="c2dconfiguration"></a>

Каждый центр IoT предоставляет следующие параметры конфигурации для отправки сообщений из облака в устройство:

| Свойство | Описание | Диапазон и значение по умолчанию |
| -------- | ----------- | ----------------- |
| defaultTtlAsIso8601 | Заданный по умолчанию срок жизни для сообщений, отправляемых из облака на устройство. | Интервал ISO\_8601 — до 2 устройств (минимум 1 минута). Значение по умолчанию — 1 час. |
| maxDeliveryCount | Лимит доставки для очереди доставки сообщений, отправляемых из облака на устройство, для каждого отдельного устройства. | От 1 до 100. Значение по умолчанию — 10. |
| feedback.ttlAsIso8601 | Хранение отзывов, направленных службе. | Интервал ISO\_8601 — до 2 устройств (минимум 1 минута). Значение по умолчанию — 1 час. |
| feedback.maxDeliveryCount | Лимит доставок для очереди отзывов. | От 1 до 100. Значение по умолчанию — 100. |

Дополнительные сведения см. в статье [Управление центрами IoT][lnk-manage].

## Квоты и регулирование <a id="throttling"></a>

Каждая подписка Azure может использовать не более 10 центров IoT.

Каждый центр IoT подготавливается с определенным количеством единиц в определенной единице хранения (SKU). Дополнительные сведения см. на странице [Центр IoT —цены][lnk-pricing]. SKU и количество единиц определяют максимальную дневную квоту сообщений, которые вы можете отправить,

а также лимиты регулирования, которые центр IoT применяет по отношению ко всем операциям.

### Регулирование операций

Регулирование операции — это ограничение скорости, выражаемое в виде диапазона (в минутах). Оно нужно для того, чтобы избежать применения не по назначению. Центр IoT пытается избежать ошибок возврата, когда это возможно. Однако если регулирование нарушается слишком долго, он начинает возвращать исключения.

Ниже приведен список случаев принудительного регулирования. Значения обозначают тот или иной концентратор.

| Регулирование | Значение концентратора |
| -------- | ------------- |
| Операции с реестром удостоверений (создание, извлечение, перечисление, обновление и удаление) | 100/мин/единица, до 5000/мин |
| Подключение устройств | 120/с/единица (для S2), 12/с/единица (для S1). <br/>Минимальное значение — 100/с. <br/> Например, для двух единиц S1 — 2 * 12 = 24/с, но в вашем случае для всех единиц это значение будет составлять не менее 100/с. Для девяти единиц S1 мы получим 108/с (9*12) для всех единиц. |
| Передачи с устройства в облако | 120/с/единица (для S2), 12/с/единица (для S1). <br/>Минимальное значение — 100/с. <br/> Например, для двух единиц S1 — 2 * 12 = 24/с, но в вашем случае для всех единиц это значение будет составлять не менее 100/с. Для девяти единиц S1 мы получим 108/с (9*12) для всех единиц. |
| Передачи из облака на устройство | 100/мин/единица |
| Получение из облака на устройство | 1000/мин/единица |

Важно уточнить, что регулирование *подключений устройств* управляет скоростью, с которой могут устанавливаться новые подключения устройств к центру IoT, но не максимальным числом одновременно подключенных устройств. Регулирование зависит от числа единиц, подготовленных для центра.

Например, если вы приобретаете одну единицу S1, то получаете регулирование 100 соединений в секунду. Это означает, что для подключения 100 000 устройств потребуется по меньшей мере 1000 секунд (около 16 минут). Однако вы можете иметь столько одновременно подключенных устройств, сколько устройств зарегистрировано в вашем реестре удостоверений устройств.


**Примечание**. В любой момент времени можно увеличить квоты или лимиты регулирования, увеличив количество подготовленных единиц в центре IoT.

**Важно**. Операции с реестром удостоверений следует использовать только для управления устройствами и в сценариях подготовки. Чтение или обновление большого количества удостоверений устройств поддерживается с помощью [заданий импорта и экспорта](#importexport).

## Дальнейшие действия

Вы ознакомились с общими сведениями о разработке, касающимися центра IoT. Чтобы узнать больше, перейдите по этим ссылкам:

- [Приступая к работе с центром IoT (руководство)][lnk-get-started]
- [Платформы ОС и совместимость оборудования][lnk-compatibility]
- [Центр разработчика IoT Azure][lnk-iotdev]
- [Разработка решения][lnk-guidance]

[концентраторов событий и узла обработчика событий]: http://blogs.msdn.com/b/servicebus/archive/2015/01/16/event-processor-host-best-practices-part-1.aspx

[портале Azure]: https://portal.azure.com

[img-endpoints]: ./media/iot-hub-devguide/endpoints.png
[img-lifecycle]: ./media/iot-hub-devguide/lifecycle.png
[img-eventhubcompatible]: ./media/iot-hub-devguide/eventhubcompatible.png

[lnk-compatibility]: https://github.com/Azure/azure-iot-sdks/blob/master/doc/tested_configurations.md
[lnk-apis-sdks]: https://github.com/Azure/azure-iot-sdks/blob/master/readme.md
[lnk-pricing]: https://azure.microsoft.com/pricing/details/iot-hub
[lnk-resource-provider-apis]: https://msdn.microsoft.com/library/mt548492.aspx

[lnk-sas-tokens]: iot-hub-sas-tokens.md
[lnk-azure-gateway-guidance]: iot-hub-guidance.md#field-gateways
[lnk-guidance-provisioning]: iot-hub-guidance.md#provisioning
[lnk-guidance-scale]: iot-hub-scaling.md
[lnk-guidance-security]: iot-hub-guidance.md#customauth
[lnk-guidance-heartbeat]: iot-hub-guidance.md#heartbeat

[lnk-azure-protocol-gateway]: iot-hub-protocol-gateway.md
[lnk-get-started]: iot-hub-csharp-csharp-getstarted.md
[lnk-guidance]: iot-hub-guidance.md
[lnk-getstarted-c2d-tutorial]: iot-hub-csharp-csharp-c2d.md

[lnk-amqp]: https://www.amqp.org/
[lnk-mqtt]: http://mqtt.org/
[lnk-websockets]: https://tools.ietf.org/html/rfc6455
[lnk-arm]: ../resource-group-overview.md
[lnk-azure-resource-manager]: https://azure.microsoft.com/documentation/articles/resource-group-overview/
[lnk-cbs]: https://www.oasis-open.org/committees/download.php/50506/amqp-cbs-v1%200-wd02%202013-08-12.doc
[lnk-createuse-sas]: ../storage-dotnet-shared-access-signature-part-2/
[lnk-event-hubs-publisher-policy]: https://code.msdn.microsoft.com/Service-Bus-Event-Hub-99ce67ab
[lnk-event-hubs]: http://azure.microsoft.com/documentation/services/event-hubs/
[lnk-event-hubs-consuming-events]: ../event-hubs/event-hubs-programming-guide.md#event-consumers
[lnk-guidance-d2c-processing]: iot-hub-csharp-csharp-process-d2c.md
[lnk-management-portal]: https://portal.azure.com
[lnk-rfc7232]: https://tools.ietf.org/html/rfc7232
[lnk-sasl-plain]: http://tools.ietf.org/html/rfc4616
[lnk-servicebus]: http://azure.microsoft.com/documentation/services/service-bus/
[lnk-tls]: https://tools.ietf.org/html/rfc5246
[lnk-iotdev]: https://azure.microsoft.com/develop/iot/
[lnk-bulk-identity]: iot-hub-bulk-identity-mgmt.md
[lnk-eventhub-partitions]: ../event-hubs/event-hubs-overview.md#partitions
[lnk-manage]: iot-hub-manage-through-portal.md

<!---HONumber=AcomDC_0406_2016-->