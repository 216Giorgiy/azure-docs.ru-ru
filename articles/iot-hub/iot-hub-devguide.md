---
title: Разделы руководства разработчика для центра IoT | Microsoft Docs
description: Руководство разработчика для центра IoT Azure, содержащее информацию о конечных точках центра IoT, его безопасности, реестре удостоверений устройств и обмене сообщениями.
services: iot-hub
documentationcenter: .net
author: dominicbetts
manager: timlt
editor: ''

ms.service: iot-hub
ms.devlang: multiple
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 09/02/2016
ms.author: dobett

---
# Руководство разработчика по центру Azure IoT (IoT — Интернет вещей)
Центр Azure IoT — полностью управляемая служба, которая обеспечивает надежный и защищенный двунаправленный обмен данными между миллионами устройств IoT и серверной частью приложения.

Центр Azure IoT помогает обеспечить:

* безопасную связь благодаря использованию уникальных учетных данных безопасности устройства и контроля доступа;
* глобальный надежный двусторонний обмен сообщениями между облаком и устройством;
* простое подключение устройств, так как используются библиотеки устройств для большинства популярных языков и платформ.

В этой статье рассматриваются следующие темы:

* [Конечные точки](#endpoints). Раздел содержит информацию о конечных точках, которые каждый центр IoT предоставляет для операций управления и среды выполнения.
* [Реестр удостоверений устройств](#device-identity-registry). В этом разделе содержится информация о том, какие сведения хранятся в реестре удостоверений каждого устройства центра IoT и как эти сведения можно использовать и изменять.
* [Безопасность](#security). В этом разделе содержатся сведения о модели безопасности, которая обеспечивает доступ к функциям центра IoT для устройств и облачных компонентов.
* [Обмен сообщениями](#messaging). В этом разделе содержатся сведения о функциях обмена сообщениями (между устройством и облаком в обоих направлениях), которые предоставляет центр IoT.
* [Квоты и регулирование](#throttling). Раздел содержит информацию о том, какие квоты применяются при использовании центра IoT.

## Конечные точки <a id="endpoints"></a>
Центр IoT Azure — это мультитенантная служба, которая предоставляет возможность пользоваться своими функциями разным субъектам. На схеме ниже показаны разные конечные точки, которые предоставляет центр IoT.

![Конечные точки центра IoT][img-endpoints]

Ниже приведено описание конечных точек.

* **Поставщик ресурсов**. Поставщик ресурсов центра IoT предоставляет интерфейс [Azure Resource Manager][lnk-arm], с помощью которого владельцы подписки Azure могут создавать и удалять центры IoT, а также обновлять их свойства. Свойства центра IoT определяют политики безопасности на уровне центра, а не контроль доступа на уровне устройств (см. раздел [Контроль доступа](#accesscontrol) ниже в этой статье), и функциональные параметры, относящиеся к двустороннему обмену сообщениями между облаком и устройством. Поставщик ресурсов также позволяет [экспортировать удостоверения устройств](#importexport).
* **Управление удостоверениями устройств**. Каждый центр IoT предоставляет набор конечных точек HTTP REST, которые позволяют управлять удостоверениями устройств (создавать, получать, обновлять и удалять их). Удостоверения устройств нужны для аутентификации устройств и контроля доступа к ним. Дополнительные сведения см. в разделе [Реестр удостоверений устройств](#device-identity-registry).
* **Конечные точки устройств**. Для каждого устройства, подготовленного в реестре удостоверений устройств, центр IoT предоставляет набор конечных точек, которые используются устройством для отправки и получения сообщений.
  
  * *Отправка сообщений с устройства в облако*. Эта конечная точка используется для отправки сообщений с устройства в облако. Дополнительные сведения см. в разделе [Отправка сообщений с устройства в облако](#d2c).
  * *Получение сообщений из облака на устройство*. Устройство использует эту конечную точку для получения целевых сообщений из облака. Дополнительные сведения см. в разделе [Отправка сообщений из облака на устройство](#c2d).
  * *Инициирование отправки файлов*. Устройство использует эту конечную точку для получения URI SAS хранилища Azure из центра IoT, чтобы отправить файл. Дополнительную информацию см. в разделе [Отправка файлов](#fileupload).
    
    Эти конечные точки предоставляются по протоколам [MQTT 3.1.1][lnk-mqtt], HTTP 1.1 и [AMQP 1.0][lnk-amqp]. Обратите внимание, что протокол AMQP также доступен в [WebSockets][lnk-websockets] через порт 443.
* **Конечные точки службы**. Каждый центр IoT предоставляет набор конечных точек, которые могут использоваться в серверной части приложения для взаимодействия с устройствами. Эти конечные точки в настоящее время доступны только при использовании протокола [AMQP][lnk-amqp].
  * *Получение сообщений с устройства в облако*. Эта конечная точка совместима с [концентраторами событий Azure][lnk-event-hubs]. С ее помощью в серверной части приложения считываются все сообщения, отправляемые с устройств в облако. Дополнительные сведения см. в разделе [Отправка сообщений с устройства в облако](#d2c).
  * *Отправка сообщений из облака на устройство и получение уведомлений о доставке*. Эти конечные точки позволяют серверной части приложения отправлять надежные сообщения из облака в устройство и получать уведомления о доставке или истечении срока действия. Дополнительные сведения см. в разделе [Отправка сообщений из облака на устройство](#c2d).
  * *Получение уведомлений о файлах*. Эта конечная точка обмена сообщениями позволяет получать уведомления при успешной отправке файла устройствами.

В статье [Пакеты SDK для центра IoT][lnk-sdks] описываются способы получения доступа к этим конечным точкам.

Наконец, следует отметить, что все конечные точки центра IoT используют протокол [TLS][lnk-tls]. Кроме того, конечные точки не предоставляются по незашифрованным или незащищенным каналам.

### Чтение из конечных точек, совместимых с концентраторами событий <a id="eventhubcompatible"></a>
При использовании [пакета SDK служебной шины Azure для .NET][lnk-servicebus-sdk] или [концентраторов событий и узла обработчика событий][lnk-eventprocessorhost] вы можете использовать любые строки подключения к центру IoT с нужными разрешениями. А затем использовать **messages/events** в качестве имени концентратора событий.

При использовании пакетов SDK (или интеграции продуктов), которые не поддерживают центр IoT, следует получить конечную точку, совместимую с концентраторами событий, и имя концентратора событий в разделе параметров центра IoT на [портале Azure][lnk-management-portal]\:

1. В колонке центра IoT щелкните **Сообщения**.
2. В разделе **Параметры раздела "Из устройства в облако"** отобразятся следующие значения: **Конечная точка, совместимая с концентратором событий**, **Имя, совместимое с концентратором событий** и **Разделы**.
   
    ![Параметры отправки сообщений с устройства в облако][img-eventhubcompatible]

> [!NOTE]
> Если для пакета SDK требуется указать **имя узла** или **пространство имен**, то удалите схему из **конечной точки, совместимой с концентратором событий**. Например, если конечная точка, совместимая с концентратором событий, — **sb://iothub-ns-myiothub-1234.servicebus.windows.net/**, то **именем узла** будет **iothub-ns-myiothub-1234.servicebus.windows.net**, а **пространством имен** — **iothub-ns-myiothub-1234**.
> 
> 

Затем можно использовать любую политику безопасности общего доступа с разрешениями **ServiceConnect**, которые позволяют подключаться к указанному концентратору событий.

Если нужно создать строку подключения к концентратору событий с помощью указанных выше сведений, можно использовать следующий образец:

```
Endpoint={Event Hub-compatible endpoint};SharedAccessKeyName={iot hub policy name};SharedAccessKey={iot hub policy key}
```

Ниже приведен список пакетов SDK и интеграций, которые можно применять к совместимым с концентратором событий конечным точкам, которые предоставляет центр IoT:

* [клиент концентраторов событий Java;](https://github.com/hdinsight/eventhubs-client)
* [воронка Apache Storm](../hdinsight/hdinsight-storm-develop-csharp-event-hub-topology.md), Вы можете просмотреть [воронку источника](https://github.com/apache/storm/tree/master/external/storm-eventhubs) на портале GitHub.
* [интеграция Apache Spark.](../hdinsight/hdinsight-apache-spark-eventhub-streaming.md)

## Реестр удостоверений устройств
В каждом центре IoT есть реестр удостоверений устройств. Его можно использовать для создания в службе уникальных ресурсов устройства (например очередь с сообщениями, отправленными из облака в устройство). Реестр также можно использовать для предоставления доступа к конечным точкам, обращенным к устройствам (см. раздел [Контроль доступа](#accesscontrol)).

На высоком уровне реестр удостоверений устройств является коллекцией с поддержкой REST, состоящей из ресурсов удостоверений устройств. Следующие разделы содержат подробные сведения о свойствах ресурсов удостоверений устройств, а также об операциях, которые реестр позволяет выполнять с удостоверениями.

> [!NOTE]
> Дополнительные сведения о протоколе HTTP и пакетах SDK, которые можно использовать для взаимодействия с реестром удостоверений устройств, см. в статье [Пакеты SDK для центра IoT][lnk-sdks].
> 
> 

### Свойства удостоверений устройств <a id="deviceproperties"></a>
Удостоверения устройств отображаются как JSON-документы с нижеуказанными свойствами.

| Свойство | Параметры | Описание |
| --- | --- | --- |
| deviceId |Обязательно, при обновлениях доступно только для чтения |Строка с учетом регистра (длиной до 128 символов), состоящая из букв и цифр в 7-битовом формате ASCII + `{'-', ':', '.', '+', '%', '_', '#', '*', '?', '!', '(', ')', ',', '=', '@', ';', '$', '''}`. |
| generationId |Обязательно, только для чтения |Созданная концентратором строка с учетом регистра (длиной до 128 знаков). Позволяет различать устройства с одинаковым свойством **deviceId**, которые были удалены, а затем созданы повторно. |
| etag |Обязательно, только для чтения |Строка, выполняющая функцию ненадежного заголовка ETag для удостоверения устройства (согласно [RFC7232][lnk-rfc7232]). |
| auth |необязательный |Составной объект, содержащий сведения об аутентификации и материалы безопасности. |
| auth.symkey |необязательный |Составной объект, содержащий первичный и вторичный ключи, хранящиеся в формате base64. |
| status |обязательно |Индикатор доступа. Может иметь значение **Включено** или **Отключено**. Если указано значение **Включено**, устройство может подключаться. Если указано значение **Отключено**, устройство не может подключаться ни к одной конечной точке, обращенной к устройству. |
| statusReason |необязательный |Строка длиной 128 знаков, указывающая причину, по которой выбран тот или иной статус удостоверения устройства. Разрешены все символы UTF-8. |
| statusUpdateTime |Только для чтения |Временной индикатор, показывающий дату и время последнего обновления статуса. |
| connectionState |Только для чтения |Поле, отображающее состояние подключения: **Подключено** или **Отключено**. Это поле отображает состояние подключения устройства для центра IoT. **Важно!** Используйте это поле только в целях разработки и отладки. Состояние подключения обновляется только для устройств, использующих протокол MQTT или AMQP. Кроме того, оно определяется по запросам проверки связи (по протоколу MQTT или AMQP) и может иметь максимальную задержку равную всего лишь 5 минутам. В связи с этим могут возникать ложно положительные результаты, например, когда отключенные устройства отображаются как подключенные. |
| connectionStateUpdatedTime |Только для чтения |Временной индикатор, показывающий дату и время последнего обновления состояния подключения. |
| lastActivityTime |Только для чтения |Временной индикатор, показывающий дату и время последнего подключения устройства, получения сообщения на устройство и отправки сообщения с него. |

> [!NOTE]
> Статус подключения отображает статус подключения для центра IoT. При некоторых состояниях и конфигурациях сети обновления этого состояния могут задерживаться.
> 
> 

### Операции с удостоверениями устройства
Реестр удостоверений устройств центра IoT поддерживает такие операции:

* создание удостоверения устройства;
* обновление удостоверения устройства;
* получение удостоверения устройства по идентификатору;
* удаление удостоверения устройства;
* отображение списка, содержащего до 1000 удостоверений;
* экспорт всех удостоверений в хранилище BLOB-объектов;
* импорт удостоверений из хранилища BLOB-объектов.

Все эти операции позволяют использовать оптимистичный параллелизм (согласно [RFC7232][lnk-rfc7232]).

> [!IMPORTANT]
> Единственный способ получить все удостоверения, которые содержит реестр удостоверений концентратора, — использовать функцию [Экспорт](#importexport).
> 
> 

Реестр удостоверений устройств в центре IoT:

* не содержит метаданные приложения;
* доступен как словарь (в качестве ключа используется свойство **deviceId**);
* не поддерживает выразительные запросы.

Решение IoT обычно включает в себя отдельное хранилище, содержащее метаданные приложений. Например, в хранилище решения для интеллектуального здания будут записываться данные о комнате, где установлен датчик температуры.

> [!IMPORTANT]
> Реестр удостоверений устройства следует использовать только для управления устройствами и операций подготовки. Выполнение операций в реестре удостоверений устройств не должно влиять на пропускную способность операций в среде выполнения. Например, проверка состояния подключения устройства перед отправкой команды не является поддерживаемым шаблоном. Проверьте [уровни регулирования](#throttling) реестра удостоверений устройств и шаблон [пульса устройств][lnk-guidance-heartbeat].
> 
> 

### Отключение устройств
Чтобы отключить устройства, обновите в реестре свойство **status** удостоверения. Обычно это свойство используется в двух сценариях.

* В процессе оркестрации подготовки. Дополнительные сведения см. в разделе [Подготовка устройств][lnk-guidance-provisioning] статьи "Разработка решения".
* Если по какой-либо причине вы решите, что безопасность устройства нарушена или оно является неавторизованным.

### Импорт и экспорт удостоверений устройств <a id="importexport"></a>
Можно выполнить массовый экспорт удостоверений устройств из реестра удостоверений центра IoT, используя асинхронные операции в [конечной точке поставщика ресурсов центра IoT](#endpoints). Экспорт — это долгосрочное задание, использующее предоставленный клиентом контейнер больших двоичных объектов, необходимых для сохранения идентификационных данных устройств, прочитанных из реестра удостоверений устройств.

Можно выполнить массовый импорт удостоверений устройств в реестр удостоверений центра IoT, используя асинхронные операции в [конечной точке поставщика ресурсов центра IoT](#endpoints). Импорт — это долгосрочное задание, использующее данные в предоставленном клиентом контейнере больших двоичных объектов, необходимых для записи идентификационных данных об устройстве в реестр удостоверений устройств.

* Подробные сведения об API-интерфейсах импорта и экспорта см. в статье [Центр IoT Azure — интерфейсы API поставщика ресурсов][lnk-resource-provider-apis].
* Дополнительные сведения о выполнении заданий импорта и экспорта см. в статье [Массовое управление удостоверениями устройств центра IoT][lnk-bulk-identity].

## Безопасность <a id="security"></a>
В этом разделе описаны возможности защиты центра Azure IoT.

### Контроль доступа <a id="accesscontrol"></a>
Центр IoT использует следующий набор *разрешений* для предоставления доступа к каждой из своих конечных точек. Разрешения ограничивают доступ к центру IoT на основе функций.

* **RegistryRead**. Предоставляет доступ на чтение к реестру удостоверений устройств. Дополнительные сведения см. в разделе [Реестр удостоверений устройств](#device-identity-registry).
* **RegistryReadWrite**. Предоставляет доступ на чтение и запись к реестру удостоверений устройств. Дополнительные сведения см. в разделе [Реестр удостоверений устройств](#device-identity-registry).
* **ServiceConnect**. Предоставляет доступ к конечным точкам обмена данными и мониторинга, обращенным к облачной службе. Например, это разрешение позволяет серверным облачным службам получать сообщения с устройств, отправлять сообщения в устройства и получать соответствующие уведомления о доставке.
* **DeviceConnect**. Предоставляет доступ к конечным точкам обмена данными, обращенным к устройству. Например, это разрешение позволяет отправлять сообщения с устройства в облако и получать сообщения, отправленные из облака на устройство. Это разрешение используют устройства.

Предоставить разрешения можно следующими способами.

* **Политики общего доступа на уровне концентратора**. Политики общего доступа могут предоставлять любое сочетание разрешений из перечисленных в предыдущем разделе. Политики можно задавать на [портале Azure][lnk-management-portal] или программно, используя [интерфейсы API поставщика ресурсов центра IoT Azure][lnk-resource-provider-apis]. По умолчанию для только что созданного центра IoT заданы такие политики:
  
  * **iothubowner**: политика со всеми разрешениями;
  * **service**: политика с разрешением ServiceConnect;
  * **device**: политика с разрешением DeviceConnect;
  * **registryRead**: политика с разрешением RegistryRead;
  * **registryReadWrite**: политика с разрешениями RegistryRead и RegistryWrite.
* **Учетные данные безопасности на уровне отдельного устройства**. Каждый центр IoT содержит [реестр удостоверений устройств](#device-identity-registry). Для каждого устройства в этом реестре вы можете задать учетные данные безопасности, дающие вам разрешения **DeviceConnect**, которые соответствуют конечным точкам устройств.

Например, в стандартном решении IoT:

* Компонент управления устройством использует политику *registryReadWrite*.
* Компонент обработчика событий использует политику *service*.
* Компонент бизнес-логики устройства среды выполнения использует политику *service*.
* Отдельные устройства подключаются с помощью учетных данных, которые хранятся в реестре удостоверений центра IoT.

Рекомендации по вопросам безопасности центра IoT см. в статье [Разработка решения][lnk-guidance-security].

### Аутентификация
Центр Azure IoT предоставляет доступ к конечным точкам, проверяя маркер на соответствие политикам общего доступа и учетным данным безопасности в реестре удостоверений устройств.

Учетные данные безопасности, например симметричные ключи, никогда не отправляются по сети.

> [!NOTE]
> Безопасность для поставщика ресурсов центра IoT Azure обеспечивается с помощью подписки Azure (это касается всех поставщиков в [диспетчере ресурсов Azure][lnk-azure-resource-manager]).
> 
> 

Дополнительные сведения о способах создания и использования маркеров безопасности см. в статье [Маркеры безопасности центра IoT][lnk-sas-tokens].

#### Особенности протокола
Каждый поддерживаемый протокол, например MQTT, AMQP и HTTP, передает маркеры разными способами.

Протокол HTTP реализует аутентификацию посредством включения допустимого маркера в заголовок запроса **авторизации**.

При использовании [AMQP][lnk-amqp] центр IoT поддерживает механизм [SASL PLAIN][lnk-sasl-plain] и стандарт [защиты AMQP на основе утверждений][lnk-cbs].

Стандарт защиты AMQP на основе утверждений определяет, как следует передавать эти маркеры.

Для SASL PLAIN **имя пользователя** может быть следующим:

* `{policyName}@sas.root.{iothubName}` — при использовании маркеров уровня концентратора;
* `{deviceId}` — при использовании маркеров уровня устройства.

В обоих случаях поле пароля содержит маркер, как описано в статье [Маркеры безопасности центра IoT][lnk-sas-tokens].

При использовании протокола MQTT пакет CONNECT содержит код deviceId как значение ClientId, {iothubhostname}/{deviceId} в поле "Имя пользователя", где {iothubhostname} — это полная запись CName центра IoT (например contoso.azure-devices.net), а маркер SAS — в поле "Пароль".

##### Пример:
Имя пользователя (значение DeviceId следует вводить с учетом регистра): `iothubname.azure-devices.net/DeviceId`

Пароль (создание SAS с помощью обозревателя устройств): `SharedAccessSignature sr=iothubname.azure-devices.net%2fdevices%2fDeviceId&sig=kPszxZZZZZZZZZZZZZZZZZAhLT%2bV7o%3d&se=1487709501`

> [!NOTE]
> [Пакеты SDK центра IoT Azure][lnk-sdks] автоматически создают маркеры при подключении к службе. В некоторых случаях пакеты SDK поддерживают не все протоколы или не все методы проверки подлинности.
> 
> 

#### Специальные рекомендации для SASL PLAIN
При использовании SASL PLAIN клиент, подключающийся к центру IoT, может использовать по одному маркеру для каждого TCP-подключения. Когда срок действия маркера истекает, TCP-подключение к службе прерывается и выполняется попытка повторного подключения. Хотя это поведение и не является проблематичным для серверного компонента приложения, оно может навредить приложению на стороне устройства по следующим причинам.

* Шлюзы обычно подключаются от имени многих устройств. Если используется SASL PLAIN, шлюзам нужно создать отдельное TCP-подключение для каждого устройства, подключающегося к центру IoT. Этот сценарий значительно повышает потребление электроэнергии и сетевых ресурсов и увеличивает задержку подключения устройства.
* Если потребление ресурсов увеличится, устройства с ограниченными ресурсами должны будут выполнять повторное подключение после истечения срока действия маркера.

### Определение области действия учетных данных на уровне концентратора
Чтобы определить область действия для политик безопасности на уровне концентратора, создайте маркеры с помощью универсального кода (URI) ограниченного ресурса. Например, конечная точка для отправки сообщений с устройства в облако — **/devices/{deviceId}/messages/events**. Кроме того, вы можете использовать политику общего доступа на уровне концентратора с разрешениями **DeviceConnect**. С ее помощью можно подписать маркер, значение resourceURI которого — **/devices/{deviceId}**. В результате такого подхода создается маркер, который можно использовать только для отправки устройств от имени устройства с кодом **deviceId**.

Этот механизм похож на [политику издателя концентраторов событий][lnk-event-hubs-publisher-policy]. Он позволяет реализовывать методы настраиваемой проверки подлинности. Дополнительные сведения см. в разделе, посвященном безопасности, в статье [Разработка решения][lnk-guidance-security].

## Обмен сообщениями
Центр IoT предоставляет примитивы обмена сообщениями для приведенных ниже вариантов взаимодействия.

* [Из облака на устройство](#c2d): из серверной части приложения (*службы* или *облака*).
* [С устройства в облако](#d2c): с устройства в серверную часть приложения.
* [Отправка файлов](#fileupload) с устройства в связанную учетную запись хранения Azure.

Основные свойства функции обмена сообщениями в центре IoT — надежность и устойчивость сообщений. Эти свойства сохраняются, если на стороне устройства прерывается подключение и если наступает момент пиковой загрузки на стороне облака при обработке событий. Центр IoT гарантирует *как минимум однократную* доставку при двухстороннем обмене сообщениями между устройством и облаком.

Центр IoT поддерживает несколько протоколов, доступных для устройств (например, MQTT, AMQP и HTTP). Для поддержки эффективного взаимодействия по протоколам центр IoT задает общий формат сообщений, поддерживаемый всеми обращенными к устройству протоколами.

### Формат сообщений <a id="messageformat"></a>
Сообщения центра IoT включают в себя следующие компоненты.

* Набор *свойств системы.* Это свойства, которые интерпретирует или задает центр IoT. Этот набор определяется предварительно.
* Набор *свойств приложения*. Это словарь свойств строки, которые приложение может задать и использовать без необходимости десериализации текста сообщения. Центр IoT никогда не изменяет эти свойства.
* Непрозрачная двоичная основная часть.

Дополнительные сведения о разных способах кодировки сообщений в разных протоколах см. в статье [Пакеты SDK для центра IoT][lnk-sdks].

Это набор системных свойств в сообщениях центра IoT.

| Свойство | Description (Описание) |
| --- | --- |
| MessageId |Задаваемый пользователем идентификатор сообщения, используемый для шаблонов типа запрос-ответ. Формат: строка с учетом регистра (длиной до 128 знаков), состоящая из букв и цифр в 7-битовом формате ASCII + `{'-', ':',’.', '+', '%', '_', '#', '*', '?', '!', '(', ')', ',', '=', '@', ';', '$', '''}`. |
| Порядковый номер |Число (уникальное для каждой очереди устройства), которое центр IoT назначает каждому сообщению, отправленному из облака на устройство. |
| Кому |Место назначения, которое указывается в сообщениях, отправляемых [из облака на устройство](#c2d). |
| ExpiryTimeUtc |Дата и время истечения срока действия сообщения. |
| EnqueuedTime |Дата и время получения сообщения центром IoT. |
| CorrelationId |Строковое свойство в сообщении ответа, которое обычно содержит идентификатор сообщения запроса в шаблонах "запрос-ответ". |
| UserId |Идентификатор, используемый для указания источника сообщений. Если сообщения создает центр IoT, для этого параметра задается значение `{iot hub name}`. |
| Ack |Генератор отзывов на сообщения. Это свойство используется в сообщениях, отправляемых из облака в устройство, чтобы запросить у центра IoT отправку отзыва после того, как сообщение будет использовано устройством. Возможные значения: **none** (по умолчанию) — отзывы не создаются; **positive** — отзыв будет получен, когда исходное сообщение будет передано; **negative** — отзыв будет получен, когда истечет срок действия исходного сообщения (или будет превышен лимит доставок) и при этом устройство его не примет; **full** — активированы значения positive и negative. Дополнительную информацию см. в разделе [Отзыв на сообщение](#feedback). |
| ConnectionDeviceId |Центр IoT устанавливает этот идентификатор в сообщениях, отправляемых с устройства в облако. Содержит идентификатор **deviceId** устройства, отправившего сообщение. |
| ConnectionDeviceGenerationId |Центр IoT устанавливает этот идентификатор в сообщениях, отправляемых с устройства в облако. Содержит идентификатор **generationId** (см. раздел [Свойства удостоверений устройств](#deviceproperties)) устройства, отправившего сообщение. |
| ConnectionAuthMethod |Центр IoT устанавливает этот метод проверки подлинности в сообщениях, отправляемых с устройства в облако. Это свойство содержит сведения о методе проверки подлинности, используемом для аутентификации устройства, отправляющего сообщение. Дополнительные сведения см. в разделе [Свойства для защиты от спуфинга](#antispoofing). |

### Выбор протокола связи <a id="amqpvshttp"></a>
Центр IoT поддерживает протоколы MQTT, [AMQP][lnk-amqp], AMQP через WebSocket и HTTP/1 для обмена данными на стороне устройства. Ниже в таблице приведены общие рекомендации по выбору протокола.

| Протокол | Когда следует выбрать этот протокол |
| --- | --- |
| MQTT |Используйте на всех устройствах, которые не используют WebSockets. |
| AMQPS |Используйте на собственных или облачных шлюзах, чтобы воспользоваться преимуществами мультиплексирования подключений на устройствах. <br/> Используйте, если необходимо подключаться к порту 443. |
| HTTPS |Используйте для устройств, которые не поддерживают другие протоколы. |

При выборе протокола для связи на стороне устройства учитывайте следующие факторы.

* **Шаблон сообщения из облака на устройство**. Протокол HTTP/1 не позволяет отправлять данные по инициативе сервере. Таким образом, при использовании протокола HTTP/1 устройства опрашивают центр IoT на предмет наличия сообщений из облака на устройство. Этот подход очень неэффективен для устройства и центра IoT. Согласно текущим рекомендациям для протокола HTTP/1 каждое устройство должно отправлять запросы не реже, чем раз в 25 минут. С другой стороны, протоколы MQTT и AMQP поддерживают отправку сообщений по инициативе сервера при получении сообщений из облака на устройство. Они позволяют незамедлительно передавать сообщения из центра IoT на устройство. Если задержка доставки является проблемой, то лучше использовать протокол AMQP или MQTT. Для редко подключаемых устройств протокол HTTP/1 также работает.
* **Шлюзы поля**. Протоколы HTTP-1 и MQTT не позволяют подключать по TLS-соединению одновременно несколько устройств (на каждом из которых используются собственные учетные данные). Таким образом, эти протоколы не вполне подходят для [ситуаций с использованием полевого шлюза][lnk-azure-gateway-guidance], так как требуют отдельного TLS-подключения между полевым шлюзом и центром IoT для каждого устройства, подключаемого к полевому шлюзу.
* **Устройства с небольшим количеством ресурсов**. Библиотеки MQTT и HTTP/1 уступают по объему библиотекам AMQP, а значит, только их можно использовать для устройств с ограниченными ресурсами (например, если размер ОЗУ меньше 1 МБ).
* **Обход сети**. Протокол MQTT прослушивает порт 8883, что может вызвать проблемы в сетях, закрытых для других протоколов. В подобных случаях используются протоколы HTTP и AMQP (через WebSocket).
* **Объем полезных данных**. AMQP и MQTT — это двоичные протоколы, позволяющие передавать значительно более компактные полезные данные, чем HTTP/1.

> [!NOTE]
> При использовании протокола HTTP/1 каждое устройство должно проверять наличие сообщений, передаваемых из облака на устройство, не реже, чем раз в 25 минут. Тем не менее, во время разработки частота такой проверки может быть выше.
> 
> 

<a id="mqtt-support">

#### Примечания о поддержке протокола MQTT
В центре IoT протокол MQTT 3.1.1 реализован со следующими ограничениями и особенностями:

* **QoS 2 не поддерживается**. Если клиент устройства публикует сообщение с **QoS 2**, то центр IoT закрывает сетевое подключение. Если клиент устройства подписывается на раздел с **QoS 2**, то центр IoT присваивает пакету **SUBACK** уровень QoS не выше первого.
* **Сообщения retain не сохраняются**. Если клиент устройства публикует сообщение с флагом RETAIN, имеющим значение 1, то центр IoT добавляет в сообщение свойство приложения **x-opt-retain**. В этом случае центр IoT не сохранит сообщение, а передаст его во внутреннее приложение.

Дополнительные сведения см. в разделе [Поддержка MQTT в центре IoT][lnk-mqtt-support].

И, наконец, обратите внимание на [шлюз протокола Azure IoT][lnk-azure-protocol-gateway], с помощью которого можно развернуть высокопроизводительный настраиваемый шлюз протокола, который взаимодействует с центром IoT напрямую. Шлюз протокола Azure IoT позволяет настроить протокол устройства для уже существующих развертываний MQTT или других настраиваемых протоколов. Однако при этом подходе необходимо самостоятельно размещать настраиваемый шлюз протокола и управлять им.

### Отправка сообщений с устройства в облако<a id="d2c"></a>
Как описано в разделе [Конечные точки](#endpoints), сообщения, поступающие с устройства в облако, отправляются через конечную точку, обращенную к устройству (**/devices/{deviceId}/messages/events**). Сообщения поступают через конечную точку, обращенную к службе (**/messages/events**), которая совместима с [концентраторами событий][lnk-event-hubs]. Таким образом, чтобы получать сообщения, отправляемые из устройства в облако, можно использовать стандартную интеграцию концентраторов событий и пакетов SDK.

Реализация отправки сообщений с устройства в облако в центре IoT похожа на реализацию в [концентраторах событий][lnk-event-hubs]. При этом сообщения центра IoT, отправляемые с устройства в облако, больше похожи на *события* концентраторов событий, чем на *сообщения* [служебной шины][lnk-servicebus].

Далее перечислены следствия этой реализации.

* Подобно событиям концентраторов событий, сообщения, отправляемые с устройства в облако, устойчивы и хранятся в центре IoT до семи дней (см. раздел [Параметры конфигурации сообщений, отправляемых с устройства в облако](#d2cconfiguration)).
* Сообщения, отправляемые с устройства в облако, секционируются в фиксированном наборе секций, заданном во время создания (см. раздел [Параметры конфигурации сообщений, отправляемых с устройства в облако](#d2cconfiguration)).
* Подобно тому, как это происходит с концентраторами событий, клиенты, читающие сообщения, отправляемые с устройства в облако, должны работать с секциями и назначением контрольных точек. См. раздел [Концентраторы событий — использование событий][lnk-event-hubs-consuming-events].
* Как и в случае с событиями концентраторов событий, размер сообщений, поступающих с устройства в облако, не может превышать 256 КБ; их можно объединять в пакеты, чтобы оптимизировать отправку. Размер пакетов не может превышать 256 КБ, а сами пакеты не могут содержать более 500 сообщений.

При этом сообщения центра IoT, отправляемые с устройства в облако, и сообщения, отправляемые концентраторами событий, существенно различаются.

* Как объяснено в разделе [Безопасность](#security), центр IoT обеспечивает аутентификацию и контроль доступа для каждого устройства.
* Центр IoT позволяет одновременно подключать миллионы устройств (см. раздел [Квоты и регулирование](#throttling)), тогда как концентраторы событий позволяют выполнять максимум 5000 подключений по протоколу AMQP в одном пространстве имен.
* Центр IoT не позволяет выполнять произвольное секционирование с помощью **PartitionKey**. Сообщения, отправляемые с устройства в облако, секционируются по исходному идентификатору **deviceId**.
* Масштабирование центра IoT немного отличается от масштабирования концентраторов событий. Дополнительную информацию см. в статье [Масштабирование центра IoT][lnk-guidance-scale].

Обратите внимание: это не означает, что центр IoT может заменить концентраторы событий во всех сценариях. Например, иногда при вычислениях для обработки событий может понадобиться перераспределить события на основе другого свойства или поля, чтобы проанализировать потоки данных. В этом сценарии с помощью концентратора событий можно отделить друг от друга два раздела конвейера обработки потока. Дополнительные сведения см. в разделе *Разделы* статьи [Общие сведения о концентраторах событий Azure][lnk-eventhub-partitions].

Сведения об использовании обмена сообщениями с устройства в облако см. в статье [Интерфейсы API и пакеты SDK центра IoT][lnk-sdks].

> [!NOTE]
> При использовании протокола HTTP для отправки сообщений с устройства в облако имена и значения свойств могут содержать только буквенно-цифровые знаки ASCII и знаки ``{'!', '#', '$', '%, '&', "'", '*', '*', '+', '-', '.', '^', '_', '`', '|', '~'}``.
> 
> 

#### Трафик, передающийся без использования телеметрии
Часто устройства отправляют не только точки данных телеметрии, но и сообщения и запросы, выполнение и обработку которых осуществляет та часть приложения, которая отвечает за бизнес-логику. Например, устройство отправляет критические оповещения, которые должны активировать определенное действие в серверной части, или отвечает на команды, отправленные из серверной части.

Дополнительные сведения об оптимальных методах обработки таких сообщений см. в статье [Учебник: как обрабатывать сообщения, отправляемые с устройства в облако, с помощью центра IoT][lnk-guidance-d2c-processing].

#### Параметры конфигурации сообщений, отправляемых с устройства в облако <a id="d2cconfiguration"></a>
Центр IoT позволяет управлять сообщениями, отправляемыми с устройства в облако, с помощью приведенных ниже свойств.

* **Количество секций**. Это свойство можно задать во время создания, чтобы определить количество разделов для приема событий сообщений, отправляемых с устройства в облако.
* **Время хранения**. Это свойство определяет время хранения сообщений, отправляемых с устройства в облако. Значение по умолчанию — один день, но это значение можно увеличить до семи дней.

Кроме того, как и концентраторы событий, центр IoT предоставляет возможность управлять группами потребителей в конечной точке, которая получает сообщения, отправляемые с устройства в облако.

Вы можете изменить все эти свойства на [портале Azure][lnk-management-portal] или программно (с помощью [интерфейсов API поставщика ресурсов в центре IoT Azure][lnk-resource-provider-apis]).

#### Свойства для защиты от спуфинга <a id="antispoofing"></a>
Чтобы избежать спуфинга устройств при работе с сообщениями, отправляемыми с устройства в облако, центр IoT отмечает все сообщения такими свойствами:

* **ConnectionDeviceId;**
* **ConnectionDeviceGenerationId;**
* **ConnectionAuthMethod.**

Первые два свойства содержат параметры **deviceId** и **generationId** исходного устройства (согласно разделу [Свойства удостоверений устройств](#deviceproperties)).

Свойство **ConnectionAuthMethod** содержит сериализованный объект JSON, имеющий такие свойства:

```
{
  "scope": "{ hub | device}",
  "type": "{ symkey | sas}",
  "issuer": "iothub"
}
```

### Отправка сообщений из облака на устройство <a id="c2d"></a>
Как подробно описано в разделе [Конечные точки](#endpoints), сообщения из облака на устройство можно отправлять через конечную точку, обращенную к службе (**/messages/devicebound**). А устройства могут получать их через конечную точку конкретного устройства (**/devices/{deviceId}/messages/devicebound**).

Каждое сообщение, отправляемое из облака на устройство, адресовано отдельному устройству, то есть для свойства **to** задается значение **/devices/{deviceId}/messages/devicebound**.

> [!IMPORTANT]
> Одна очередь устройства может содержать не более 50 сообщений, отправляемых из облака на устройство. Попытка отправить на устройство большее количество сообщений приведет к ошибке.
> 
> [!NOTE]
> При отправке сообщений из облака на устройство имена и значения свойств могут содержать только буквенно-цифровые знаки ASCII и знаки ``{'!', '#', '$', '%, '&', "'", '*', '*', '+', '-', '.', '^', '_', '`', '|', '~'}``.
> 
> 

#### Жизненный цикл сообщения <a id="message lifecycle"></a>
Чтобы гарантировать как минимум однократную доставку, сообщения, отправляемые из облака на устройство, хранятся в очередях устройств. Сами устройства должны явно подтвердить *завершение* доставки, чтобы центр IoT мог удалить сообщения из очереди. Это гарантирует устойчивость к сбоям подключения и ошибкам устройств.

На следующей схеме показан жизненный цикл сообщений, отправляемых с облака в устройство.

![Жизненный цикл сообщений, отправляемых из облака на устройство][img-lifecycle]

Когда служба отправляет сообщение, считается, что оно *поставлено в очередь*. Когда устройству нужно *получить* сообщение, центр IoT *блокирует* сообщение (устанавливает состояние **Невидимо**), чтобы другие потоки на том же устройстве начали получать другие сообщения. Когда поток устройства завершает обработку сообщения, он уведомляет центр IoT путем *завершения* сообщения.

Устройство также может:

* *отклонить* сообщение, в результате чего центр IoT переводит его в состояние **Deadlettered** (Не доставлено);
* *прервать* сообщение, в результате чего центр IoT помещает его в очередь с состоянием **Enqueued** (Поставлено в очередь).

При обработке сообщения потоком может произойти ошибка без уведомления центра IoT. В этом случае состояние сообщения автоматически меняется с **Невидимо** на **Enqueued** (Поставлено в очередь) после *истечения срока видимости (или блокировки)*. Значение по умолчанию — одна минута.

Состояние сообщения может изменяться с **Enqueued** (Поставлено в очередь) на **Невидимо** и наоборот столько раз, сколько указано в свойстве **Максимальное число доставок** центра IoT. После выполнения такого количества изменений центр IoT устанавливает для сообщения состояние **Deadlettered** (Не доставлено). Таким же образом центр IoT устанавливает для сообщения состояние **Deadlettered** (Не доставлено) после истечения срока действия сообщения (см. раздел [Срок действия сообщения (срок жизни)](#ttl)).

Руководство по сообщениям, отправляемым из облака на устройство, см. в статье. [Отправка сообщений из облака на устройство с помощью центра IoT Azure][lnk-getstarted-c2d-tutorial]. Справочную информацию о том, как разные интерфейсы API и пакеты SDK предоставляют функцию отправки сообщений из облака на устройство, см. в статье [Пакеты SDK для центра IoT][lnk-sdks].

> [!NOTE]
> Обычно, если потеря сообщения, отправляемого с облака в устройство, никак не влияет на логику приложения, эти сообщения завершаются. Например, когда содержимое сообщения успешно сохранено в локальном хранилище, или когда операция успешно выполнена. Сообщение может также содержать временные сведения, потеря которых не влияет на функциональность приложения. Иногда при работе с долгосрочной задачей сообщение, отправляемое с облака в устройство, можно завершить после того, как описание задачи сохранится в локальном хранилище. После этого на различных этапах выполнения задачи в серверную часть приложения отправляется одно или несколько уведомлений.
> 
> 

#### Срок действия сообщения (срок жизни) <a id="ttl"></a>
Каждое сообщение из облака на устройство имеет срок действия. Его может явно задавать служба (в свойстве **ExpiryTimeUtc**) или центр IoT, в котором задан *срок жизни* по умолчанию, указанный в соответствующем свойстве центра IoT. См. раздел [Параметры конфигурации сообщений, отправляемых из облака на устройство](#c2dconfiguration).

> [!NOTE]
> Распространенный способ воспользоваться сроком действия сообщения — задать короткое время жизни, чтобы сообщения не отправлялись на отключенные устройства. Этот подход позволяет добиться того же результата, что и поддержание состояния подключения устройства, но при этом обладает значительно большей эффективностью. Запрашивая подтверждения сообщений у центра IoT, можно узнать, какие устройства могут получать сообщения, а какие находятся в автономном режиме или в состоянии сбоя.
> 
> 

#### Отзыв на сообщение <a id="feedback"></a>
При отправке сообщений с облака в устройство служба может запросить отзыв на каждое сообщение, уведомляющий о его конечном состоянии.

* Если для свойства **Ack** задать значение **positive**, то центр IoT создаст отзыв на сообщение только в том случае, если сообщение, отправляемое из облака на устройство, имеет состояние **Завершено**.
* Если для свойства **Ack** задать значение **negative**, то центр IoT создаст отзыв на сообщение только в том случае, если сообщение, отправляемое из облака на устройство, имеет состояние **Deadletterd** (Не доставлено).
* Если для свойства **Ack** задать значение **full**, то центр IoT создаст отзыв на сообщение в любом случае.

> [!NOTE]
> Если свойство **Ack** имеет значение **full** и отзыв не получен, то это означает, что срок действия отзыва истек. Служба не знает, что случилось с исходным сообщением. На практике служба должна убедиться, что может обработать отзыв до истечения срока его действия. Максимальный срок действия составляет два дня, и этого времени достаточно для повторного запуска службы при сбое.
> 
> 

Как описано в разделе [Конечные точки](#endpoints), центр IoT предоставляет отзывы в виде сообщений через конечную точку, обращенную к службе (**/messages/servicebound/feedback**). Семантика получения отзыва идентична семантике, используемой для сообщений, отправляемых из облака в устройство, с тем же [жизненным циклом сообщения](#жизненный цикл сообщения). Когда это возможно, отзывы на сообщения группируются в одно сообщение, имеющее приведенный ниже формат.

Каждое сообщение, полученное устройством из конечной точки отзыва, имеет следующие свойства:

| Свойство | Описание |
| --- | --- |
| EnqueuedTime |Метка времени, указывающая, когда было создано сообщение. |
| UserId |.`{iot hub name}` |
| ContentType |.`application/vnd.microsoft.iothub.feedback.json` |

Основная часть — это сериализованный массив записей JSON, каждая из которых имеет следующие свойства:

| Свойство | Описание |
| --- | --- |
| EnqueuedTimeUtc |Метка времени, указывающая, когда отобразился результат сообщения. Например, устройство завершило его или истек срок его действия. |
| OriginalMessageId |Идентификатор **MessageId** сообщения, которое отправляется из облака на устройство и к которому относится эта информация. |
| StatusCode |Требуется целое число. Используется в отзывах, созданных центром IoT. <br/> 0 — успешное завершение. <br/> 1 — срок действия истек. <br/> 2 — превышено максимальное количество доставок. <br/> 3 — сообщение отклонено. |
| Description (Описание) |Строковые значения **StatusCode**. |
| DeviceId |Идентификатор **DeviceId** целевого устройства, которому отправляется сообщение из облака и к которому относится этот отзыв. |
| DeviceGenerationId |Идентификатор **DeviceGenerationId** целевого устройства сообщения, которому отправляется сообщение из облака и к которому относится этот отзыв. |

> [!IMPORTANT]
> Служба должна указать идентификатор **MessageId** для сообщения, отправляемого из облака на устройство, чтобы соотнести свой отзыв с исходным сообщением.
> 
> 

Ниже приведен пример текста сообщения отзыва.

```
[
  {
    "OriginalMessageId": "0987654321",
    "EnqueuedTimeUtc": "2015-07-28T16:24:48.789Z",
    "StatusCode": 0
    "Description": "Success",
    "DeviceId": "123",
    "DeviceGenerationId": "abcdefghijklmnopqrstuvwxyz"
  },
  {
    ...
  },
  ...
]
```

#### Параметры конфигурации сообщений, отправляемых из облака на устройство <a id="c2dconfiguration"></a>
Каждый центр IoT предоставляет следующие параметры конфигурации для отправки сообщений из облака на устройство.

| Свойство | Описание | Диапазон и значение по умолчанию |
| --- | --- | --- |
| defaultTtlAsIso8601 |Заданный по умолчанию срок жизни для сообщений, отправляемых из облака на устройство. |Интервал ISO\_8601 — до 2 устройств (минимум 1 минута). Значение по умолчанию — 1 час. |
| maxDeliveryCount |Лимит доставки для очереди доставки сообщений, отправляемых из облака на устройство, для каждого отдельного устройства. |От 1 до 100. Значение по умолчанию — 10. |
| feedback.ttlAsIso8601 |Хранение отзывов, направленных службе. |Интервал ISO\_8601 — до 2 устройств (минимум 1 минута). Значение по умолчанию — 1 час. |
| feedback.maxDeliveryCount |Лимит доставок для очереди отзывов. |От 1 до 100. Значение по умолчанию — 100. |

Дополнительные сведения см. в статье [Управление центрами IoT через портал Azure][lnk-portal].

### Отправка файлов <a id="fileupload"></a>
Как описано в разделе [Конечные точки](#endpoints), устройства могут инициировать передачу файлов путем отправки уведомления через конечную точку, обращенную к устройству (**/devices/{deviceId}/files**). Когда устройство уведомляет центр IoT о завершении отправки, центр IoT создает уведомления об отправке файлов. Затем они в виде сообщений передаются пользователю через конечную точку, обращенную к службе (**/messages/servicebound/filenotifications**).

Вместо функций брокера сообщений центр IoT выполняет роль диспетчера для связанной учетной записи хранения Azure. Устройство запрашивает из центра IoT маркер хранилища, относящийся к файлу, который должно отправить устройство. Для отправки файла в хранилище устройство использует код URI SAS, а по завершении загрузки отправляет соответствующее уведомление в центр IoT. Центр IoT проверяет, отправлен ли файл, и добавляет уведомление о его передаче в новую конечную точку, обращенную к службе.

#### Связывание учетной записи хранения Azure с центром IoT
Чтобы использовать функции отправки файлов, сначала необходимо связать учетную запись хранения Azure с центром IoT. Это можно сделать на [портале Azure][lnk-management-portal] или программно (с помощью [интерфейсов API поставщика ресурсов в центре IoT Azure][lnk-resource-provider-apis]). После привязки учетной записи хранения к центру IoT служба возвращает код URI SAS на устройство, получив от него запрос на отправку файла.

> [!NOTE]
> [Пакеты SDK центра IoT Azure][lnk-sdks] автоматически управляют получением кода URI SAS, отправкой файла и уведомлением центра IoT о завершении отправки.
> 
> 

#### Инициализация отправки файла
Центр IoT располагает двумя конечными точками REST для поддержки отправки файлов. Одна предназначена для получения кода URI SAS для хранения, а другая — для уведомления центра IoT о завершении загрузки. Устройство инициирует передачу файла, отправив запрос GET в центр IoT по адресу `{iot hub}.azure-devices.net/devices/{deviceId}/files/{filename}`. Концентратор возвращает код URI SAS, относящийся к отправляемому файлу, и идентификатор корреляции, который будет использоваться по завершении отправки.

#### Уведомление центра IoT о завершении отправки файла
Устройство отвечает за отправку файла в хранилище при помощи пакетов SDK службы хранилища Azure. По завершении передачи устройство отправляет запрос POST в центр IoT по адресу `{iot hub}.azure-devices.net/devices/{deviceId}/files/notifications/{correlationId}`, используя идентификатор корреляции, полученный из первоначального запроса GET.

#### Уведомления об отправке файлов
Когда устройство отправляет файл и уведомляет центр IoT о завершении отправки, служба при необходимости создает сообщение с уведомлением, которое содержит имя и расположение файла.

Как описано в разделе [Конечные точки](#endpoints), центр IoT доставляет уведомления об отправке файлов через конечную точку, обращенную к службе (**/messages/servicebound/fileuploadnotifications**), в виде сообщений. Семантика получения уведомлений об отправке файлов идентична семантике, используемой для сообщений, отправляемых из облака на устройство, с тем же [жизненным циклом сообщения](#жизненный цикл сообщения). Каждое сообщение, полученное из конечной точки уведомления об отправке файла, — это запись JSON с перечисленными ниже свойствами.

| Свойство | Описание |
| --- | --- |
| EnqueuedTimeUtc |Метка времени, указывающая, когда было создано уведомление. |
| DeviceId |**DeviceId** устройства, с которого был отправлен файл. |
| BlobUri |Код URI переданного файла. |
| BlobName |Имя переданного файла. |
| LastUpdatedTime |Метка времени, указывающая, когда файл был в последний раз обновлен. |
| BlobSizeInBytes |Размер переданного файла. |

**Пример**. Это пример текста уведомления об отправке файла.

```
{
    "deviceId":"mydevice",
    "blobUri":"https://{storage account}.blob.core.windows.net/{container name}/mydevice/myfile.jpg",
    "blobName":"mydevice/myfile.jpg",
    "lastUpdatedTime":"2016-06-01T21:22:41+00:00",
    "blobSizeInBytes":1234,
    "enqueuedTimeUtc":"2016-06-01T21:22:43.7996883Z"
}
```

#### Параметры конфигурации уведомления об отправке файла <a id="c2dconfiguration"></a>
Каждый центр IoT предоставляет перечисленные ниже параметры конфигурации уведомлений об отправке файлов.

| Свойство | Описание | Диапазон и значение по умолчанию |
| --- | --- | --- |
| **enableFileUploadNotifications** |Позволяет указать, следует ли записывать уведомления об отправке файлов в конечную точку файловых уведомлений. |Bool. По умолчанию: True. |
| **fileNotifications.ttlAsIso8601** |Значение TTL по умолчанию для уведомлений об отправке файлов. |Интервал ISO\_8601 — до 48 часов (минимум 1 минута). Значение по умолчанию — 1 час. |
| **fileNotifications.lockDuration** |Длительность блокировки для очереди уведомлений об отправке файлов. |5–300 секунд (минимум 5 секунд). Значение по умолчанию — 60 секунд. |
| **fileNotifications.maxDeliveryCount** |Максимальное количество доставок для очереди уведомлений об отправке файлов. |От 1 до 100. Значение по умолчанию — 100. |

Дополнительные сведения см. в статье [Управление центрами IoT через портал Azure][lnk-portal].

## Квоты и регулирование <a id="throttling"></a>
Каждая подписка Azure может использовать не более 10 центров IoT.

Каждый центр IoT подготавливается с определенным количеством единиц в определенной единице хранения (SKU). Дополнительные сведения см. на странице [Центр IoT —цены][lnk-pricing]. SKU и количество единиц определяют максимальную дневную квоту сообщений, которые вы можете отправить,

а также лимиты регулирования, которые центр IoT применяет по отношению ко всем операциям.

### Регулирование операций
Регулирование операции — это ограничение скорости, выражаемое в виде диапазона (в минутах). Оно нужно для того, чтобы избежать применения не по назначению. Центр IoT пытается избежать ошибок возврата, когда это возможно. Однако если регулирование нарушается слишком долго, он начинает возвращать исключения.

Ниже приведен список случаев принудительного регулирования. Значения обозначают тот или иной концентратор.

| Регулирование | Значение концентратора |
| --- | --- |
| Операции с реестром удостоверений (создание, извлечение, перечисление, обновление и удаление) |5000 в минуту на единицу (для S3), <br/> 100 в минуту на единицу (для S1 и S2). |
| Подключение устройств |6000 в секунду на единицу (для S3), 120 в секунду на единицу (S2), 12 в секунду на единицу (для S1). <br/> Минимальное значение — 100/с. <br/> Например, для двух единиц S1 это 2 * 12 = 24 в секунду, но в вашем случае для всех единиц это значение составляет не менее 100 в секунду. Для девяти единиц S1 мы получим 108/с (9*12) для всех единиц. |
| Передачи с устройства в облако |6000 в секунду на единицу (для S3), 120 в секунду на единицу (S2), 12 в секунду на единицу (для S1). <br/> Минимальное значение — 100/с. <br/> Например, для двух единиц S1 это 2 * 12 = 24 в секунду, но в вашем случае для всех единиц это значение составляет не менее 100 в секунду. Для девяти единиц S1 мы получим 108/с (9*12) для всех единиц. |
| Передачи из облака на устройство |5000 в минуту на единицу (для S3), 100 в минуту на единицу (для S1 и S2). |
| Получение из облака на устройство |50000 в минуту на единицу (для S3), 1000 в минуту на единицу (для S1 и S2). |
| Операции отправки файлов |5000 уведомлений о передаче файла в минуту на единицу (для S3), 100 уведомлений о передаче файла в минуту на единицу (для S1 и S2). <br/> Допускается одновременная выдача 10 000 универсальных кодов ресурса (URI) SAS для учетной записи хранения.<br/> Допускается одновременная выдача до 10 универсальных кодов ресурса (URI) SAS на устройство. |

Важно уточнить, что регулирование *подключений устройств* управляет скоростью, с которой могут устанавливаться новые подключения устройств к центру IoT, но не максимальным числом одновременно подключенных устройств. Регулирование зависит от числа единиц, подготовленных для центра.

Например, если вы приобретаете одну единицу S1, то получаете регулирование 100 соединений в секунду. Это означает, что для подключения 100 000 устройств потребуется по меньшей мере 1000 секунд (около 16 минут). Однако вы можете иметь столько одновременно подключенных устройств, сколько устройств зарегистрировано в вашем реестре удостоверений устройств.

В записи блога, посвященной [регулированию в центре IoT][lnk-throttle-blog], приводится подробное описание стратегии регулирования в центре IoT.

> [!NOTE]
> В любой момент времени можно увеличить квоты или лимиты регулирования, увеличив количество подготовленных единиц в центре IoT.
> 
> [!IMPORTANT]
> Операции с реестром удостоверений следует использовать только для управления устройствами и в сценариях подготовки. Чтение или обновление большого количества удостоверений устройств поддерживается с помощью [заданий импорта и экспорта](#importexport).
> 
> 

## Дальнейшие действия
Вы ознакомились с общими сведениями о разработке, касающимися центра IoT. См. также:

* [Tutorial: How to upload files from devices to the cloud with IoT Hub (Руководство. Как отправлять файлы с устройств в облако с помощью центра IoT)][lnk-file upload]
* [Создание центра IoT программно][lnk-create-hub]
* [Знакомство с пакетом SDK для устройств Azure IoT для C][lnk-c-sdk]
* [Пакеты SDK для центра IoT][lnk-sdks]

Для дальнейшего изучения возможностей центра IoT см. следующие статьи:

* [Разработка решения][lnk-design]
* [Обзор управления устройствами центра IoT с помощью примера пользовательского интерфейса][lnk-dmui]
* [Пакет SDK для шлюза IoT (бета-версия): отправка сообщений с устройства в облако через виртуальное устройство с помощью Linux][lnk-gateway]
* [Управление центрами IoT через портал Azure][lnk-portal]
* [Все аспекты безопасности решения IoT][lnk-securing]

[lnk-eventprocessorhost]: http://blogs.msdn.com/b/servicebus/archive/2015/01/16/event-processor-host-best-practices-part-1.aspx

[img-endpoints]: ./media/iot-hub-devguide/endpoints.png
[img-lifecycle]: ./media/iot-hub-devguide/lifecycle.png
[img-eventhubcompatible]: ./media/iot-hub-devguide/eventhubcompatible.png

[lnk-pricing]: https://azure.microsoft.com/pricing/details/iot-hub
[lnk-resource-provider-apis]: https://msdn.microsoft.com/library/mt548492.aspx

[lnk-sas-tokens]: iot-hub-sas-tokens.md
[lnk-azure-gateway-guidance]: iot-hub-guidance.md#field-gateways
[lnk-guidance-provisioning]: iot-hub-guidance.md#provisioning
[lnk-guidance-scale]: iot-hub-scaling.md
[lnk-guidance-security]: iot-hub-guidance.md#customauth
[lnk-guidance-heartbeat]: iot-hub-guidance.md#heartbeat

[lnk-azure-protocol-gateway]: iot-hub-protocol-gateway.md
[lnk-getstarted-c2d-tutorial]: iot-hub-csharp-csharp-c2d.md

[lnk-amqp]: https://www.amqp.org/
[lnk-mqtt]: http://mqtt.org/
[lnk-websockets]: https://tools.ietf.org/html/rfc6455
[lnk-arm]: ../resource-group-overview.md
[lnk-azure-resource-manager]: https://azure.microsoft.com/documentation/articles/resource-group-overview/
[lnk-cbs]: https://www.oasis-open.org/committees/download.php/50506/amqp-cbs-v1%200-wd02%202013-08-12.doc
[lnk-event-hubs-publisher-policy]: https://code.msdn.microsoft.com/Service-Bus-Event-Hub-99ce67ab
[lnk-event-hubs]: http://azure.microsoft.com/documentation/services/event-hubs/
[lnk-event-hubs-consuming-events]: ../event-hubs/event-hubs-programming-guide.md#event-consumers
[lnk-guidance-d2c-processing]: iot-hub-csharp-csharp-process-d2c.md
[lnk-management-portal]: https://portal.azure.com
[lnk-rfc7232]: https://tools.ietf.org/html/rfc7232
[lnk-sasl-plain]: http://tools.ietf.org/html/rfc4616
[lnk-servicebus]: http://azure.microsoft.com/documentation/services/service-bus/
[lnk-tls]: https://tools.ietf.org/html/rfc5246
[lnk-bulk-identity]: iot-hub-bulk-identity-mgmt.md
[lnk-eventhub-partitions]: ../event-hubs/event-hubs-overview.md#partitions
[lnk-mqtt-support]: iot-hub-mqtt-support.md
[lnk-throttle-blog]: https://azure.microsoft.com/blog/iot-hub-throttling-and-you/
[lnk-servicebus-sdk]: https://www.nuget.org/packages/WindowsAzure.ServiceBus

[lnk-file upload]: iot-hub-csharp-csharp-file-upload.md
[lnk-create-hub]: iot-hub-rm-template-powershell.md
[lnk-c-sdk]: iot-hub-device-sdk-c-intro.md
[lnk-sdks]: iot-hub-sdks-summary.md

[lnk-design]: iot-hub-guidance.md
[lnk-dmui]: iot-hub-device-management-ui-sample.md
[lnk-gateway]: iot-hub-linux-gateway-sdk-simulated-device.md
[lnk-portal]: iot-hub-manage-through-portal.md
[lnk-securing]: iot-hub-security-ground-up.md

<!---HONumber=AcomDC_0907_2016-->