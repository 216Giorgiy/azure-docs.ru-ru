<properties
	pageTitle="Пакет SDK для устройств Azure IoT для C — Serializer | Microsoft Azure"
	description="Узнайте больше об использовании библиотеки Serializer из пакета SDK для устройств Azure IoT для C."
	services="iot-hub"
	documentationCenter=""
	authors="MichelBarnett"
	manager="timlt"
	editor=""/>

<tags
     ms.service="iot-hub"
     ms.devlang="cpp"
     ms.topic="article"
     ms.tgt_pltfrm="na"
     ms.workload="nana"
     ms.date="09/29/2015"
     ms.author="michelb"/>

# Пакет SDK для устройств Microsoft Azure IoT для C — дополнительные сведения о библиотеке serializer

В [первой статье](iot-hub-device-sdk-c-intro.md) этого курса вы познакомились с **пакетом SDK для устройств Azure IoT для C**. В этой статье представлено более подробное описание [**IoTHubClient**](iot-hub-device-sdk-c-iothubclient.md). Здесь мы завершим изучение пакета SDK, более подробно рассмотрев оставшийся компонент: библиотеку **serializer**.

В первой статье вы узнали, как использовать библиотеку **serializer** для отправки событий в центр IoT и получения сообщений из него. В этой статье мы углубим свои знания, более подробно изучив моделирование данных с помощью макроязыка библиотеки **serializer**. Мы также подробнее рассмотрим механизмы, используемые библиотекой для сериализации сообщений (которые в некоторых случаях позволяют управлять поведением сериализации). Также здесь описываются некоторые параметры, доступные для изменения и определяющие размер создаваемой модели.

В конце мы подведем итоги, вернувшись к некоторым рассмотренным ранее вопросам, включая обработку сообщений и свойств. Также вы узнаете, что при использовании библиотеки **serializer** эти функции работают также, как и при использовании библиотеки **IoTHubClient**.

Все приведенные ниже инструкции основаны на примерах использования примеров **serializer** из пакета SDK. Чтобы перейти к выполнению действий, просмотрите приложения **simplesample\_amqp** и **simplesample\_http**, включенные в пакет SDK для устройств Azure IoT для C.

## Язык моделирования

В [первой статье](iot-hub-device-sdk-c-intro.md) этого курса вы познакомились с языком моделирования **пакета SDK для устройств Azure IoT для C** на примере приложения **simplesample\_amqp**.

```
BEGIN_NAMESPACE(WeatherStation);

DECLARE_MODEL(ContosoAnemometer,
WITH_DATA(ascii_char_ptr, DeviceId),
WITH_DATA(double, WindSpeed),
WITH_ACTION(TurnFanOn),
WITH_ACTION(TurnFanOff),
WITH_ACTION(SetAirResistance, int, Position)
);

END_NAMESPACE(WeatherStation);
```

Как вы видите, язык моделирования основан на макросах C. Определение всегда начинается с ключевого слова **BEGIN\_NAMESPACE** и всегда заканчивается ключевым словом **END\_NAMESPACE**. Зачастую для пространства имен выбирается название компании или, как в этом примере, название рабочего проекта.

Все, что происходит «внутри» пространства имен, определяет модель. В данном случае создается одна модель для анемометра. Снова-таки, модели может быть присвоено любое имя, но обычно оно соответствует имени устройства или типу данных для взаимодействия с центром IoT.

Модели содержат определение событий, которые вы можете отправить в центр IoT (*данные*), и сообщений, которые вы можете получить из центра IoT (*действия*). Как видно из примера, для событий указываются тип и имя; а для действий — имя и необязательные параметры (каждый с указанием типа).

Стоит отметить, что этот пример не демонстрирует дополнительные типы данных, поддерживаемые пакетом SDK. Об этом мы поговорим далее.

> Обратите внимание, что данные, отправляемые устройством, интерпретируются центром IoT как *события*, тогда как в языке моделирования они называются *данными* (определяются макросом **WITH\_DATA**). Аналогично, данные, отправляемые устройству, интерпретируются центром как *сообщения*, тогда как в языке моделирования они называются *действиями* (определяются макросом **WITH\_ACTION**). Просто помните, что в этой статье эти понятия могут быть взаимозаменяемыми.

### Поддерживаемые типы данных

В моделях, созданных с помощью библиотеки **serializer**, поддерживаются следующие типы данных:

| Тип | Описание |
|-------------------------|----------------------------------------|
| double | число с плавающей запятой двойной точности |
| int | 32-разрядное целое число |
| float; | число с плавающей запятой одиночной точности |
| длинное целое число | длинное целое число |
| int8\_t | 8-разрядное целое число |
| int16\_t | 16-разрядное целое число |
| int32\_t | 32-разрядное целое число |
| int64\_t | 64-разрядное целое число |
| bool | Логическое |
| ascii\_char\_ptr | строка ASCII |
| EDM\_DATE\_TIME\_OFFSET | смещение даты и времени |
| EDM\_GUID | GUID |
| EDM\_BINARY | binary; |
| DECLARE\_STRUCT | сложный тип данных |

Давайте начнем с последнего типа данных. Макрос **DECLARE\_STRUCT** позволяет определять сложные типы данных — типов, которые являются группировками, состоящими из других простых типов. Это позволяет определить модель, которая выглядит следующим образом:

```
DECLARE_STRUCT(TestType,
double, aDouble,
int, aInt,
float, aFloat,
long, aLong,
int8_t, aInt8,
uint8_t, auInt8,
int16_t, aInt16,
int32_t, aInt32,
int64_t, aInt64,
bool, aBool,
ascii_char_ptr, aAsciiCharPtr,
EDM_DATE_TIME_OFFSET, aDateTimeOffset,
EDM_GUID, aGuid,
EDM_BINARY, aBinary
);

DECLARE_MODEL(TestModel,
WITH_DATA(TestType, Test)
);
```

Наша модель содержит одно событие, инициируемое изменением данных, типа **TestType**. **TestType** является сложным типом, который содержит несколько элементов. Все эти элементы демонстрируют простые типы, поддерживаемые языком моделирования **serializer**.

С помощью такой модели мы можем отправлять данные в центр IoT, используя следующий код:

```
TestModel* testModel = CREATE_MODEL_INSTANCE(MyThermostat, TestModel);

testModel->Test.aDouble = 1.1;
testModel->Test.aInt = 2;
testModel->Test.aFloat = 3.0f;
testModel->Test.aLong = 4;
testModel->Test.aInt8 = 5;
testModel->Test.auInt8 = 6;
testModel->Test.aInt16 = 7;
testModel->Test.aInt32 = 8;
testModel->Test.aInt64 = 9;
testModel->Test.aBool = true;
testModel->Test.aAsciiCharPtr = "ascii string 1";

time_t now;
time(&now);
testModel->Test.aDateTimeOffset = GetDateTimeOffset(now);

EDM_GUID guid = { { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F } };
testModel->Test.aGuid = guid;

unsigned char binaryArray[3] = { 0x01, 0x02, 0x03 };
EDM_BINARY binaryData = { sizeof(binaryArray), &binaryArray };
testModel->Test.aBinary = binaryData;

SendAsync(iotHubClientHandle, (const void*)&(testModel->Test));
```

Фактически, мы присваиваем значение каждому элементу структуры **Test**, а затем вызываем **SendAsync** для отправки события **Test** в облако. Функция **SendAsync** является вспомогательной и служит для отправки одного события, инициируемого изменением данных, в центр IoT:

```
void SendAsync(IOTHUB_CLIENT_LL_HANDLE iotHubClientHandle, const void *dataEvent)
{
	unsigned char* destination;
	size_t destinationSize;
	if (SERIALIZE(&destination, &destinationSize, *(const unsigned char*)dataEvent) ==
	{
		// null terminate the string
		char* destinationAsString = (char*)malloc(destinationSize + 1);
		if (destinationAsString != NULL)
		{
			memcpy(destinationAsString, destination, destinationSize);
			destinationAsString[destinationSize] = '\0';
			IOTHUB_MESSAGE_HANDLE messageHandle = IoTHubMessage_CreateFromString(destinationAsString);
			if (messageHandle != NULL)
			{
				IoTHubClient_SendEventAsync(iotHubClientHandle, messageHandle, sendCallback, (void*)0);

				IoTHubMessage_Destroy(messageHandle);
			}
			free(destinationAsString);
		}
		free(destination);
	}
}
```

Эта функция сериализует нужное нам событие, инициируемое изменением данных, и отправляет его в центр IoT с помощью функции **IoTHubClient\_SendEventAsync**. Этот же код мы использовали в предыдущих статьях (**SendAsync** просто заключает логику в удобную функцию).

Второй вспомогательной функцией, используемой в приведенном выше примере, является **GetDateTimeOffset**. Эта функция преобразует заданное значение времени в значение типа **EDM\_DATE\_TIME\_OFFSET**:

```
EDM_DATE_TIME_OFFSET GetDateTimeOffset(time_t time)
{
	struct tm newTime;
	gmtime_s(&newTime, &time);
	EDM_DATE_TIME_OFFSET dateTimeOffset;
	dateTimeOffset.dateTime = newTime;
	dateTimeOffset.fractionalSecond = 0;
	dateTimeOffset.hasFractionalSecond = 0;
	dateTimeOffset.hasTimeZone = 0;
	dateTimeOffset.timeZoneHour = 0;
	dateTimeOffset.timeZoneMinute = 0;
	return dateTimeOffset;
}
```

Если запустить приведенный код, в центр IoT будет отправлено следующее сообщение:

```
{"aDouble":1.100000000000000, "aInt":2, "aFloat":3.000000, "aLong":4, "aInt8":5, "auInt8":6, "aInt16":7, "aInt32":8, "aInt64":9, "aBool":true, "aAsciiCharPtr":"ascii string 1", "aDateTimeOffset":"2015-09-14T21:18:21Z", "aGuid":"00010203-0405-0607-0809-0A0B0C0D0E0F", "aBinary":"AQID"}
```

Обратите внимание, что сериализация выполняется в формат JSON. В библиотеке **serializer** для сериализации используется именно этот формат. Также обратите внимание, что каждый элемент сериализованного объекта JSON соответствует элементам типа **TestType**, определенного в нашей модели. Значения также совпадают с теми, которые использовались в коде. Однако учтите, что двоичные данные имеют кодировку base64. В данном случае значению AQID соответствует строка {0x01, 0x02, 0x03} в кодировке base64.

В этом примере показаны преимущества использования библиотеки **serializer**. Она позволяет отправлять данные JSON в облако без необходимости выполнять явную сериализацию в коде приложения. Все, что от нас требуется, — это задать в модели значения для событий, инициируемых изменением данных, а затем вызвать простые API для отправки этих событий в облако.

Используя приведенную выше информацию, вы сможете определять модели с использованием различных типов данных, включая сложные типы (при необходимости мы даже можем включить одни сложные типы в другие). Но сериализованный код JSON, созданный в этом примере, поднимает один важный вопрос. *Каким образом* при отправке данных библиотека **serializer** определяет способ формирования JSON? Об этом моменте мы поговорим далее.

## Дополнительные сведения о сериализации

В предыдущем разделе был приведен пример выходных данных, созданных библиотекой **serializer**. В этом разделе мы подробно рассмотрим этот вопрос, а также объясним, как библиотека сериализует данные и как вы можете управлять этим поведением с помощью API сериализации.

Чтобы продолжить изучение сериализации, мы создадим новую модель на основе термостата. Но сначала мы приведем более подробную информацию о сценарии, который мы пытаемся реализовать.

Нам нужна модель термостата, который измеряет температуру и влажность. При этом каждый блок данных будет отправляться в центр IoT по-отдельности. По умолчанию термостат будет генерировать событие температуры каждые 2 минуты, а событие влажности — каждые 15 минут. В каждое генерируемое событие необходимо включить метку времени, в которое были измерены соответствующие показатели температуры или влажности.

На основании этого сценария мы покажем два способа моделирования данных и объясним влияние каждого из этих способов на сериализованные выходные данные.

### Модель 1

Вот первый вариант модели, которая поддерживает описанный выше сценарий:

```
BEGIN_NAMESPACE(Contoso);

DECLARE_STRUCT(TemperatureEvent,
int, Temperature,
EDM_DATE_TIME_OFFSET, Time);

DECLARE_STRUCT(HumidityEvent,
int, Humidity,
EDM_DATE_TIME_OFFSET, Time);

DECLARE_MODEL(Thermostat,
WITH_DATA(TemperatureEvent, Temperature),
WITH_DATA(HumidityEvent, Humidity)
);

END_NAMESPACE(Contoso);
```

Обратите внимание, что модель включает два события, инициируемые изменением данных: **Temperature** и **Humidity**. В отличие от предыдущих примеров, тип каждого события представлен структурой, определенной с помощью макроса **DECLARE\_STRUCT**. Структура **TemperatureEvent** содержит значение измеренной температуры и метку времени, а структура **HumidityEvent** — значение измеренной влажности и метку времени. Эта модель естественным образом моделирует данные для описанного выше сценария. Когда мы отправляем событие в облако, мы будем отправлять либо пару значений «температура/время», либо пару значений «влажность/время».

Отправить событие температуры в облако можно с помощью следующего кода:

```
time_t now;
time(&now);
thermostat->Temperature.Temperature = 75;
thermostat->Temperature.Time = GetDateTimeOffset(now);

unsigned char* destination;
size_t destinationSize;
if (SERIALIZE(&destination, &destinationSize, thermostat->Temperature) == IOT_AGENT_OK)
{
    sendMessage(iotHubClientHandle, destination, destinationSize);
}
```

В этом примере мы используем жестко заданные значения температуры и влажности. Но предположим, что эти значения поступают от соответствующих датчиков реального термостата.

В приведенном выше примере используется вспомогательный метод **GetDateTimeOffset**, о котором было сказано ранее. По причинам, о которых будет сказано позже, задачи сериализации и отправки события в этом коде выполняются раздельно. Событие температуры сериализуется в буфер. Затем вспомогательный метод **sendMessage** (включен в приложение **simplesample\_amqp**) отправляет событие в центр IoT:

```
static void sendMessage(IOTHUB_CLIENT_HANDLE iotHubClientHandle, const unsigned char* buffer, size_t size)
{
    static unsigned int messageTrackingId;
    IOTHUB_MESSAGE_HANDLE messageHandle = IoTHubMessage_CreateFromByteArray(buffer, size);
    if (messageHandle != NULL)
    {
        IoTHubClient_SendEventAsync(iotHubClientHandle, messageHandle, sendCallback, (void*)(uintptr_t)messageTrackingId);

        IoTHubMessage_Destroy(messageHandle);
    }
    free((void*)buffer);
}
```

Этот код является частью вспомогательного метода **SendAsync**, описанного в предыдущем разделе, поэтому мы не будем повторно рассказывать о нем.

Если запустить приведенный код для отправки события температуры, в центр IoT отправится следующая сериализованная строка:

```
{"Temperature":75, "Time":"2015-09-17T18:45:56Z"}
```

Мы отправляем значение температуры, имеющее тип **TemperatureEvent**. Эта структура содержит элементы **Temperature** и **Time**. Это напрямую отражается в сериализованных данных. Ничего неожиданного.

Точно так же событие влажности можно отправить с помощью следующего кода:

```
thermostat->Humidity.Humidity = 45;
thermostat->Humidity.Time = GetDateTimeOffset(now);
if (SERIALIZE(&destination, &destinationSize, thermostat->Humidity) == IOT_AGENT_OK)
{
    sendMessage(iotHubClientHandle, destination, destinationSize);
}
```

В сериализованной форме (то, как данные отправляются в центр IoT), это выглядит следующим образом:

```
{"Humidity":45, "Time":"2015-09-17T18:45:56Z"}
```

Опять же, все как и ожидалось.

Взглянув на приведенную выше модель, несложно понять, что новые события добавляются очень легко. Достаточно определить новые структуры с помощью макроса **DECLARE\_STRUCT**, а затем добавить в модель соответствующие события с помощью макроса **WITH\_DATA**.

Но теперь давайте изменим модель, включив в нее те же данные, но с другой структурой.

### Модель 2

Рассмотрим следующую измененную модель:

```
DECLARE_MODEL(Thermostat,
WITH_DATA(int, Temperature),
WITH_DATA(int, Humidity),
WITH_DATA(EDM_DATE_TIME_OFFSET, Time)
);
```

Здесь мы убрали макрос **DECLARE\_STRUCT** и определили элементы данных из нашего сценария с помощью простых типов языка моделирования.

В данный момент не обращайте внимание на событие **Time**. Следовательно, код вызова события **Temperature** будет выглядеть так:

```
time_t now;
time(&now);
thermostat->Temperature = 75;

unsigned char* destination;
size_t destinationSize;
if (SERIALIZE(&destination, &destinationSize, thermostat->Temperature) == IOT_AGENT_OK)
{
    sendMessage(iotHubClientHandle, destination, destinationSize);
}
```

Этот код отправляет в центр IoT следующее сериализованное событие:

```
{"Temperature":75}
```

Код для отправки события влажности выглядит следующим образом:

```
thermostat->Humidity = 45;
if (SERIALIZE(&destination, &destinationSize, thermostat->Humidity) == IOT_AGENT_OK)
{
    sendMessage(iotHubClientHandle, destination, destinationSize);
}
```

В центр IoT отправляется следующее:

```
{"Humidity":45}
```

По-прежнему, ничего непредвиденного. Но давайте изменим способ использования макроса SERIALIZE.

Макрос **SERIALIZE** может принимать несколько событий, инициируемых изменением данных, в качестве аргументов. Это позволит нам одновременно сериализовать события **Temperature** и **Humidity** и отправить их в центр IoT одним вызовом:

```
if (SERIALIZE(&destination, &destinationSize, thermostat->Temperature, thermostat->Humidity) == IOT_AGENT_OK)
{
    sendMessage(iotHubClientHandle, destination, destinationSize);
}
```

Как вы можете догадаться, результатом выполнения этого кода является отправка двух событий, инициируемых изменением данных, в центр IoT:

[

{"Temperature":75},

{"Humidity":45}

]

Другими словами, вы можете решить, что этот код аналогичен раздельной отправке событий **Temperature** и **Humidity** с передачей обоих событий в метод **SERIALIZE** в рамках одного вызова. Однако это не так. Вместо этого, приведенный выше код отправляет в центр IoT одно событие, инициируемое изменением данных:

{"Temperature":75, "Humidity":45}

Это может показаться странным, так как в нашей модели события **Temperature** и **Humidity** определены как два *отдельных* события:

```
DECLARE_MODEL(Thermostat,
WITH_DATA(int, Temperature),
WITH_DATA(int, Humidity),
WITH_DATA(EDM_DATE_TIME_OFFSET, Time)
);
```

Более того, в нашей модели мы не включали события **Temperature** и **Humidity** в одну структуру:

```
DECLARE_STRUCT(TemperatureAndHumidityEvent,
int, Temperature,
int, Humidity,
);

DECLARE_MODEL(Thermostat,
WITH_DATA(TemperatureAndHumidityEvent, TemperatureAndHumidity),
);
```

На примере использования этой модели будет проще понять, каким образом события **Temperature** и **Humidity** отправляются в одном сериализованном сообщении. Может возникнуть вопрос: почему при передаче обоих событий, инициируемых изменением данных, в метод **SERIALIZE** с помощью модели 2 все работает описанным образом?

Это поведение проще понять, если знать о допущениях библиотеки **serializer**. Чтобы все прояснить, давайте вернемся к нашей модели:

```
DECLARE_MODEL(Thermostat,
WITH_DATA(int, Temperature),
WITH_DATA(int, Humidity),
WITH_DATA(EDM_DATE_TIME_OFFSET, Time)
);
```

Взгляните на эту модель в контексте объектно-ориентированного подхода. В этом случае мы моделируем физическое устройство (термостат), и это устройство включает какие-то атрибуты (**Temperature** и **Humidity**).

Когда требуется, мы можем отправить общее состояние нашей модели с помощью следующего кода:

```
if (SERIALIZE(&destination, &destinationSize, thermostat->Temperature, thermostat->Humidity, thermostat->Time) == IOT_AGENT_OK)
{
    sendMessage(iotHubClientHandle, destination, destinationSize);
}
```

Если указаны значения температуры, влажности и времени, в центр IoT будет отправлено событие со следующим содержимым:

```
{"Temperature":75, "Humidity":45, "Time":"2015-09-17T18:45:56Z"}
```

Но зачастую вам нужно отправлять в облако значения только *некоторых* свойств модели (особенно это касается случаев, когда модель содержит большое количество событий, инициируемых изменением данных). Именно при таких условиях становится полезным отправлять только некоторые события, инициируемые изменением данных, как это было в примере выше:

```
{"Temperature":75, "Time":"2015-09-17T18:45:56Z"}
```

В результате будет создано такое же сериализованное событие, как если бы мы определили **TemperatureEvent** с атрибутами **Temperature** и **Time**, как в случае с моделью 1. Но за счет вызова метода **SERIALIZE** другим способом мы можем создать такое же сериализованное событие с помощью другой модели (модель 2).

Ключевым моментом здесь является то, что при передаче в метод **SERIALIZE** нескольких событий, инициируемых изменением данных, каждое такое событие рассматривается как отдельный объект JSON.

Какой подход выбрать, зависит от того, как вы воспринимаете модель. Если вы хотите отправлять «события» в облако, когда каждое событие содержит определенный набор свойств, вам лучше выбрать первый подход. В этом случае с помощью макроса **DECLARE\_STRUCT** определяется структура каждого события, а затем они включаются в модель с помощью макроса **WITH\_DATA**. Теперь события можно отправлять, как описано в первом примере. При использовании этого подхода в метод **SERIALIZER** будет передаваться только одно событие, инициируемое изменением данных.

Если вы рассматриваете свою модель с точки зрения объектно-ориентированного подхода, вам лучше использовать второй метод. В этом случае элементы, определенные с помощью макроса **WITH\_DATA**, будут «свойствами» вашего объекта. Тогда в метод **SERIALIZE** вы можете передавать любое подмножество событий, в зависимости от требований к передаче данных о состоянии объекта в облако.

Ни один из подходов нельзя назвать правильным или ошибочным. Просто нужно знать о принципах работы библиотеки **serializer** и использовать тот подход к моделированию, который подходит именно вам.

## Обработка сообщений

До сих пор в этой статье рассказывалось только об отправке событий в центр IoT, но не об их получении. Это связано с тем, что большая часть информации о получении сообщений была изложена в [предыдущей статье](iot-hub-device-sdk-c-intro.md). Как вы помните, обработка сообщений выполняется путем регистрации функции обратного вызова:

```
IoTHubClient_SetMessageCallback(iotHubClientHandle, IoTHubMessage, myWeather)
```

Затем вы создаете функцию обратного вызова, которая вызывается при получении сообщения:

```
static IOTHUBMESSAGE_DISPOSITION_RESULT IoTHubMessage(IOTHUB_MESSAGE_HANDLE message, void* userContextCallback)
{
    IOTHUBMESSAGE_DISPOSITION_RESULT result;
    const unsigned char* buffer;
    size_t size;
    if (IoTHubMessage_GetByteArray(message, &buffer, &size) != IOTHUB_MESSAGE_OK)
    {
        printf("unable to IoTHubMessage_GetByteArray\r\n");
        result = EXECUTE_COMMAND_ERROR;
    }
    else
    {
        /*buffer is not zero terminated*/
        char* temp = malloc(size + 1);
        if (temp == NULL)
        {
            printf("failed to malloc\r\n");
            result = EXECUTE_COMMAND_ERROR;
        }
        else
        {
            memcpy(temp, buffer, size);
            temp[size] = '\0';
            EXECUTE_COMMAND_RESULT executeCommandResult = EXECUTE_COMMAND(userContextCallback, temp);
            result =
                (executeCommandResult == EXECUTE_COMMAND_ERROR) ? IOTHUBMESSAGE_ABANDONED :
                (executeCommandResult == EXECUTE_COMMAND_SUCCESS) ? IOTHUBMESSAGE_ACCEPTED :
                IOTHUBMESSAGE_REJECTED;
            free(temp);
        }
    }
    return result;
}
```

Эта реализация **IoTHubMessage** обеспечивает вызов нужной функции для каждого действия, определенного в модели. Например, если модель определяет следующее действие:

```
WITH_ACTION(SetAirResistance, int, Position)
```

Вам нужно определить функцию со следующей сигнатурой:

```
EXECUTE_COMMAND_RESULT SetAirResistance(ContosoAnemometer* device, int Position)
{
    (void)device;
    (void)printf("Setting Air Resistance Position to %d.\r\n", Position);
    return EXECUTE_COMMAND_SUCCESS;
}
```

Функция **SetAirResistance** вызывается при отправке сообщения устройству.

Но мы все еще не рассказали вам о том, как выглядит сериализованная версия сообщения. Другими словами, если вы хотите отправить устройству сообщение **SetAirResistance**, как оно будет выглядеть?

При отправке сообщения устройству вы используете пакет SDK для службы Azure IoT. Однако вам по-прежнему нужно знать, какую строку отправить, чтобы вызвать определенное действие. В общем, отправляемое сообщение имеет следующий формат:

```
{"Name" : "", "Parameters" : "" }
```

Вы отправляете сериализованный объект JSON с двумя свойствами: **Name** (имя действия, т. е. сообщение) и **Parameters** (параметры этого действия).

Например, чтобы вызвать функцию **SetAirResistance**, вам нужно отправить устройству следующее сообщение:

```
{"Name" : "SetAirResistance", "Parameters" : { "Position" : 5 }}
```

Имя действия должно совпадать с именем, определенным в модели. Точно так же должны совпадать имена параметров. Обратите внимание, что имена чувствительны к регистру. Параметры **Name** и **Parameters** всегда пишутся с прописной буквы. Также следите за соответствием регистра в именах действий и параметров, определенных в модели. В этом примере действие называется SetAirResistance (не setairresistance).

Вот и все, что вам нужно знать об отправке событий и получении сообщений с помощью библиотеки **serializer**. Но прежде чем продолжить, давайте рассмотрим ряд изменяемых параметров, которые позволяют управлять размером модели.

## Конфигурация макросов

Если вы используете библиотеку **serializer**, помните, что нужную вам часть пакета SDK можно найти здесь:

> .\\c\\common\\tools\\macro\_utils\_h\_generator.

Эта папка содержит решение Visual Studio с именем **macro\_utils\_h\_generator.sln**:

  ![](media/iot-hub-device-sdk-c-serializer/01-macro_utils_h_generator.PNG)

В этом решении программа создает файл **macro\_utils.h**, который помещается в каталог .\\c\\common\\inc. Вместе с пакетом SDK поставляется стандартная версия файла macro\_utils.h. Однако это решение позволяет изменить ряд параметров, а затем повторно создать файл заголовка с учетом этих изменений.

Два ключевых параметра, о которых вам нужно знать, это **nArithmetic** и **nMacroParameters**. Они определяются в следующих двух строках кода в файле macro\_utils.tt:

```
<#int nArithmetic=1024;#>
<#int nMacroParameters=124;/*127 parameters in one macro deﬁnition in C99 in chapter 5.2.4.1 Translation limits*/#>

```

Указанные выше значения являются стандартными для пакета SDK. Параметры означают следующее:

-   nMacroParameters — определяет количество параметров в одном определении макроса DECLARE\_MODEL.

-   nArithmetic — *общее* разрешенное количество элементов в модели.

Важность этих параметров объясняется тем, что с их помощью можно управлять размером модели. Например, возьмем следующее определение модели:

```
DECLARE_MODEL(MyModel,
WITH_DATA(int, MyData)
);
```

Как говорилось ранее, **DECLARE\_MODEL** является простым макросом C. Имя модели и инструкция **WITH\_DATA** (еще один макрос) являются параметрами макроса **DECLARE\_MODEL**. **nMacroParameters** определяет, сколько параметров можно включить в макрос **DECLARE\_MODEL**. Фактически, этот параметр определяет максимальное количество событий, инициируемых изменением данных, и объявлений действий. Таким образом, ограничение в 124 элемента означает возможность определения модели, в которой будет приблизительно по 60 действий и событий, инициируемых изменением данных. Если превысить этот предел, вы получите следующую ошибку компиляции:

  ![](media/iot-hub-device-sdk-c-serializer/02-nMacroParametersCompilerErrors.PNG)

Параметр **NArithmetic** в большей степени предназначен для настройки внутренних механизмов макроязыка, чем приложения. Грубо говоря, он управляет *максимальным* количеством элементов в модели, включая макрос **DECLARE\_STRUCT**. Поэтому если при компиляции программы вы начнете получать подобные сообщения об ошибках, попробуйте увеличить значение **nArithmetic**.

   ![](media/iot-hub-device-sdk-c-serializer/03-nArithmeticCompilerErrors.PNG)

Чтобы изменить параметры, отредактируйте соответствующие значения в файле macro\_utils.tt. После этого повторно скомпилируйте решение macro\_utils\_h\_generator.sln и запустите скомпилированную программу. Будет создан новый файл macro\_utils.h, который помещается в каталог .\\common\\inc.

При это помните о том, что установка слишком большого значения может привести к превышению ограничений компилятора. Поэтому лучше сосредоточиться на параметре **nMacroParameters**. В спецификации C99 сказано, что в определении макроса допускается не менее 127 параметров. Компилятор Майкрософт точно следует этой спецификации (с ограничением в 127 параметров), поэтому вы не сможете изменить значение **nMacroParameters** ниже допустимого. Однако другие компиляторы могут позволить сделать это (например, компилятор GNU поддерживает более высокое ограничение).

Таким образом, мы рассмотрели практически все, что нужно знать о написании кода при использовании библиотеки **serializer**. Прежде чем закончить, давайте вернемся к некоторым темам из предыдущих статей, которые могут вызвать у вас вопросы.

## Интерфейсы API нижнего уровня

В этой статье мы рассмотрели пример приложения **simplesample\_amqp**. В этом примере для отправки событий и получения сообщений используется API высокого уровня (не LL). При использовании таких API запускается фоновый поток, который отвечает и за отправку событий, и за получение сообщений. Однако при необходимости мы можем использовать API низкого уровня (LL), чтобы остановить этот фоновый поток и явно управлять отправкой событий или получением сообщений из облака.

Как сказано в [предыдущей статье](iot-hub-device-sdk-c-iothubclient.md), существует набор функций, которые включают API высокого уровня:

-   IoTHubClient\_CreateFromConnectionString

-   IoTHubClient\_SendEventAsync

-   IoTHubClient\_SetMessageCallback

-   IoTHubClient\_Destroy

В примере **simplesample\_amqp** показывается, как использовать эти методы:

Но существует аналогичный набор API нижнего уровня.

-   IoTHubClient\_LL\_CreateFromConnectionString;

-   IoTHubClient\_LL\_SendEventAsync;

-   IoTHubClient\_LL\_SetMessageCallback;

-   IoTHubClient\_LL\_Destroy.

Главное то, что API низкого уровня работают точно так же, как это описано в предыдущих статьях. Первый набор API используется, когда вам нужно управлять операциями отправки событий и получения сообщений с помощью фонового потока. Но если вы хотите явно управлять отправкой и получением данных из центра IoT, вам следует использовать второй набор API. Любой из этих наборов API работает с библиотекой **serializer** одинаково хорошо.

Пример использования API низкого уровня с библиотекой **serializer** см. в приложении **simplesample\_http**.

## Дополнительные разделы

Также стоит упомянуть об обработке свойств, параметрах конфигурации и использовании дополнительных учетных данных устройства. Все эти вопросы рассматриваются в [предыдущей статье](iot-hub-device-sdk-c-iothubclient.md). Самое главное, что все эти возможности работают при использовании библиотеки **serializer** точно так же, как и при использовании библиотеки **IoTHubClient**. Например, если вы хотите присоединить свойства к событию из модели, вы можете воспользоваться функциями **IoTHubMessage\_Properties** и **Map**\_**AddorUpdate** в соответствии с ранее приведенным описанием:

```
MAP_HANDLE propMap = IoTHubMessage_Properties(message.messageHandle);
sprintf_s(propText, sizeof(propText), "%d", i);
Map_AddOrUpdate(propMap, "SequenceNumber", propText);
```

Не имеет значения, было ли создано событие вручную с помощью библиотеки **IoTHubClient** или автоматически с помощью библиотеки **serializer**.

В случае с дополнительными учетными данными для устройства функция **IoTHubClient\_LL\_Create** для выделения **IOTHUB\_CLIENT\_HANDLE** работает точно так же, как функция **IoTHubClient\_CreateFromConnectionString**.

Наконец, используя библиотеку **serializer**, вы можете настраивать параметры конфигурации с помощью функции **IoTHubClient\_LL\_SetOption** точно так же, как при использовании библиотеки **IoTHubClient**.

Единственным небольшим отличием возможностей библиотеки **serializer** является наличие API инициализации. Перед началом работы с библиотекой вам нужно вызвать **serializer\_init**:

```
serializer_init(NULL);
```

Это делается непосредственно перед вызовом метода **IoTHubClient\_CreateFromConnectionString**.

Соответственно, после завершения работы с библиотекой обычно вызывается метод **serializer\_deinit**:

```
serializer_deinit();
```

Или все прочие описанные выше функции работают при использовании библиотеки **serializer** точно так же, как и при использовании библиотеки **IoTHubClient**. Дополнительную информацию см. в [предыдущей статье](iot-hub-device-sdk-c-iothubclient.md) этого цикла.

## Дальнейшие действия

В этой статье подробно рассматриваются уникальные возможности библиотеки **serializer**, включенной в **пакет SDK для устройств Azure IoT для C**. Прочитав эту статью, вы узнаете, как использовать модели для отправки событий и получения сообщений из центра IoT.

Эта статья завершает состоящий из трех частей цикл, посвященный разработке приложений с помощью **пакета SDK для устройств Azure IoT для C**. Приведенной информации должно быть достаточно для того, чтобы вы могли не только приступить к работе, но и лучше понять принципы работы API. Если вам все еще нужны дополнительные сведения, изучите примеры из пакета SDK, которые здесь не рассматриваются. Также отличным источником дополнительной информации является [документация по пакету SDK](https://github.com/Azure/azure-iot-sdks).

<!---HONumber=Oct15_HO3-->