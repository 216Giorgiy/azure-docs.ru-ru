---
title: Знакомство с библиотекой управления устройствами | Microsoft Docs
description: Клиентская библиотека управления устройствами для центра Azure IoT
services: iot-hub
documentationcenter: ''
author: juanjperez
manager: timlt
editor: ''

ms.service: iot-hub
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 04/29/2016
ms.author: juanpere

---
# Знакомство с клиентской библиотекой управления устройствами для центра Azure IoT.
## Обзор
Клиентская библиотека управления устройствами для центра Azure IoT позволяет управлять устройствами IoT с помощью центра Azure IoT. Под управлением понимаются такие действия, как перезагрузка, сброс настроек фабрики и обновление встроенного ПО. Сейчас доступна независимая от платформы библиотека на C, но скоро мы добавим поддержку других языков. Как описано в статье [Общие сведения об управлении устройствами с помощью центра IoT Azure (предварительная версия)][lnk-dm-overview], управление устройствами в центре IoT включает три основных понятия.

* Двойники устройства
* Задания устройства
* Запросы устройства

Если вы не знакомы с данными понятиями, советуем изучить этот обзор, прежде чем продолжать работу с руководством. Все они тесно связаны с клиентской библиотекой.

Клиентская библиотека управления устройствами решает две основные задачи по управлению.

* Синхронизация свойств на физическом устройстве с соответствующим близнецом устройства в центре IoT.
* Управление заданиями устройства, отправленными на устройство из центра IoT.

Свойства физического устройства (например, уровень заряда батарей и серийный номер) периодически синхронизируются на двойник устройства, размещенного в облаке. Таким образом центр IoT получает актуальные данные обо всех физических устройствах (пока они подключены).

Основной способ взаимодействия службы с физическим устройством реализован через задания устройства и двойник устройства. В центре IoT доступны следующие типы заданий. Клиентская библиотека управления устройствами берет на себя основную часть задач по управлению заданиями устройства. Но вам как разработчику следует реализовать на устройстве все необходимые обратные вызовы для поддержки всех типов заданий.

1. **Обновление встроенного ПО**: обновляет встроенное ПО (или образ операционной системы) на физическом устройстве.
2. **Перезагрузка**: перезагружает физическое устройство.
3. **Сброс к параметрам по умолчанию**: восстанавливает встроенное ПО (или образ операционной системы) физического устройства к резервному образу, сохраненному на устройстве производителем.
4. **Обновление конфигурации**: настраивает для центра IoT агент клиента, запущенный на физическом устройстве.
5. **Чтение свойства устройства**: возвращает актуальное значение свойства для физического устройства.
6. **Запись свойства устройства:** изменяет свойство физического устройства.

В следующих разделах содержится пошаговое описание архитектуры клиентской библиотеки. Там же вы найдете рекомендации по реализации на устройстве разных объектов устройства.

## Принципы разработки клиентской библиотеки управления устройствами и описание функций
Клиентская библиотека управления устройствами создавалась для обеспечения переносимости и интеграции между различными платформами. Эти цели достигнуты следующими методами.

1. За основу взят стандартный протокол LWM2M/COAP; это обеспечивает возможности расширения для самых разных устройств.
2. Использован стандарт языка ANSI C99; это упрощает перенос на различные платформы.
3. Для защиты реализован механизм проверки подлинности TCP/TLS и центра IoT Azure (маркеры SAS), который можно использовать в сценариях с высоким уровнем безопасности.
4. Разработка на базе проекта OSS [Eclipse Wakaama][lnk-Wakaama]; это позволяет использовать существующий код и поддерживать развитие сообщества.

### Основные понятия, связанные с LWM2M
Мы выбрали протокол LWM2M/COAP, чтобы обеспечить расширяемость для самых разных устройств. Чтобы упростить разработку, для большей части протокола создан уровень абстракции. Тем не менее важно понимать базовую архитектуру библиотеки, представленную, в первую очередь, моделью данных и способом передачи данных.

#### Объекты и ресурсы: модель данных в LWM2M
В модели данных LWM2M используются следующие понятия, представляющие объекты и ресурсы.

* **Объекты** описывают набор согласованных функциональных сущностей в системе, включая устройства или обновления встроенного ПО.
* **Ресурсы** описывают атрибуты или действия для этих объектов, например данные об уровне заряда аккумулятора и действие перезагрузки.

Обратите внимание, что модель использует два типа связей "один ко многим".

* **Устройства и объекты**: каждое устройство может иметь несколько объектов. Например, у устройства Contoso должен быть объект устройства и объект сервера (подробнее эти объекты мы опишем в следующем разделе).
* **Объекты и ресурсы**: каждый объект может иметь несколько ресурсов. Например, объект может содержать ресурсы обновления встроенного ПО для устройства Contoso, например URI-адрес пакета с образом для обновления.

#### Модель наблюдения и уведомления: как передаются данные в LWM2M
Кроме этих понятий важно иметь представления о правилах передачи данных от устройства к службе. Для этой задачи в LWM2M определена модель наблюдения и уведомления. Если физическое устройство подключается к службе, центр IoT инициирует наблюдение за свойствами выбранного устройства. Затем физическое устройство уведомляет центр IoT об изменениях в этих свойствах устройства.

В нашей клиентской библиотеке модель наблюдения и уведомления реализована как способ отправки от устройства в центр IoT данных для управления устройством. Поведение модели определяют два параметра.

* **Минимальный период**: период времени, на который устройство задерживает отправку обновленных данных для наблюдаемых свойств. Этот период равен 5 минутам. Таким образом, устройство отправляет обновленные данные о наблюдаемых свойствах не чаще, чем каждые 5 минут, даже если значения изменяются чаще. Например, если свойство изменяется каждую минуту, служба увидит только последнее изменение, произошедшее на 5-й минуте.
* **Максимальный период**: период времени, за который устройство должно отправить значение для наблюдаемого свойства, независимо от того, изменялось ли это значение. Этот период равен 6 часам. Таким образом, устройство отправляет информацию о наблюдаемых свойствах не реже, чем раз в 6 часов, даже если значения не изменяются.

> [!NOTE]
> Есть одно исключение: для свойств, которые используются заданием обновления встроенного ПО, минимальный период равен 30 секундам. Это связано с тем, что при выполнении задания эти свойства изменяются очень часто. Сокращение минимального периода позволяет ускорить процесс обновления.
> 
> 

## Функции и архитектура клиентской библиотеки
Как уже было сказано в обзоре, клиентские библиотеки выполняют две основные задачи.

* Синхронизация физического устройства с соответствующим близнецом устройства в центре IoT.
* Управление заданиями устройства, отправленными на устройство из центра IoT.

Ниже мы подробно рассмотрим обе эти задачи.

### Синхронизация физического устройства с близнецом устройства
Клиентская библиотека использует модель наблюдения и уведомления, чтобы обновлять свойства близнеца устройства. Как вы помните, близнец устройства — это представление физического устройства на стороне службы. Синхронизация выполняется следующим образом.

1. Устройство регистрируется в службе, обычно во время инициализации. Пример сообщения: "Я — устройство с идентификатором Contoso и маркером доступа Y".
2. Служба наблюдает за ресурсами на объектах. Пример сообщения: "Извещай меня об изменении уровня заряда аккумулятора на устройстве Contoso".
3. Устройство уведомляет службу об актуальных параметрах ресурса. Частота этих уведомлений зависит от настроек минимального и максимального периода. Примеры сообщений: "В 17:00 уровень заряда батареи составляет 99 %", "В 17:05 уровень заряда батареи составляет 90 %" и т. д.

### Управление заданиями устройства: совместная работа физического устройства и его двойника
Чтобы выполнить действие на физическом устройстве, службе нужно найти его двойник. Для этого можно выполнить запрос по свойствам или поиск по идентификатору устройства. Зная идентификатор двойника устройства (который совпадает с идентификатором физического устройства), служба может запустить на физическом устройстве задание устройства.

Задание устройства — это набор различных команд для выполнения нужного нам процесса (например, для обновления встроенного ПО). Задание устройства может состоять из нескольких этапов.

1. Двойник устройства имеет свойства, которые отражают состояние задания устройства.
2. Чтобы обеспечить выполнение процессов в рамках задания устройства, свойства на двойнике устройства должны получить определенные значения. Физическое устройство задает нужные значения свойств, которые затем синхронизируются на двойник устройства, и выполнение задания продолжается.

Эта последовательность повторяется столько раз, сколько шагов есть в процессе задания (например, при обновлении встроенного ПО двойник устройства многократно меняет свои свойства по мере выполнения процесса, прежде чем задание будет считаться выполненным).

## Рекомендации по реализации управления устройствами на клиенте
В предыдущих разделах мы узнали о функциях клиентской библиотеки для управления устройствами, о ее конструктивных особенностях, а также об использовании протокола LWM2M. Теперь мы перейдем к описанию того, как эти элементы взаимодействуют в среде выполнения.

Клиентская библиотека отвечает за взаимодействие между устройством и службой; вам остается только реализовать логику работы устройства. Эта процедура состоит из двух этапов.

1. **Реализация поведения конкретного устройства** — включение в функции обратного вызова кода логики для выполнения нужных службе действий на конкретном устройстве (например, загрузки пакета обновления встроенного ПО). Ниже приводится пример кода обратного вызова для пакета обновления встроенного ПО. Обратные вызовы можно найти в С-файлах [в этой папке][lnk-github1].
   
         object_firmwareupdate *obj = get_firmwareupdate_object(0);
         obj->firmwareupdate_packageuri_write_callback =     start_firmware_download;
         // platform specific code
         obj->firmwareupdate_update_execute_callback = start_firmware_update;
         //platform specific code
2. **Информирование клиентской библиотеки об изменениях свойств** — вызов соответствующих функций, расположенных в Н-файле [в этой папке][lnk-github2].
   
     IOTHUB_CLIENT_RESULT set_firmwareupdate_state(uint16_t instanceId, int value);

### Объекты, которые необходимо реализовать в клиентской библиотеке управления устройствами
Только что мы объяснили, как следует реализовать логику выполнения заданий устройства для конкретного устройства. Теперь мы расскажем, какие объекты вы можете использовать.

Некоторые из этих объектов являются обязательными, то есть вам необходимо реализовать в них определенную логику для конкретного устройства, чтобы это устройство стало частью процесса управления устройствами в центре IoT. Другие являются необязательными, и их вы можете выбирать в зависимости от потребностей службы (например, не обязательно обновлять встроенное ПО с помощью центра IoT). Далее описаны эти объекты.

* **Объект устройства (обязательный)**: предоставляет сведения об устройстве, например данные об изготовителе, номер модели, серийный номер, время устройства. Служба может читать эту информацию, а в некоторых случаях и обновлять ее. Также объект определяет два действия, которые служба может выполнять на устройстве: перезагрузка и сброс к параметрам по умолчанию.
* **Объект сервера (обязательный)**: содержит параметры и настройки для подключения к центру IoT, например время существования регистрации и привязки транспорта. Служба может только считывать эти сведения.
* **Объект конфигурации (необязательный)**: содержит пользовательские сведения о конфигурации, которые можно получить от устройства или передать на устройство, чтобы служба могла выполнять настройку устройства. Служба может читать и обновлять эти сведения.
* **Объект обновления встроенного ПО (необязательный)**: предоставляет действие обновления встроенного ПО, который служба может вызывать. Он также предоставляет некоторые сведения, например расположение пакета встроенного ПО и состояние текущей операции обновления встроенного ПО.

Каждый из этих объектов имеет набор связанных ресурсов (мы упоминали их, когда рассказывали о связях "один ко многим"). В конце этой статьи вы найдете полный список объектов LWM2M и связанных ресурсов, которые поддерживаются центром Azure IoT.

> [!NOTE]
> В текущей версии системы не поддерживаются пользовательские свойства устройства, несколько экземпляров ресурса и несколько экземпляров объекта.
> 
> 

### Сборка
На приведенной ниже схеме все описанные элементы собраны в единую систему. С правой стороны синим цветом обозначены различные компоненты клиентской библиотеки управления устройствами: объекты, обработчики и методы уведомления. Слева зеленым цветом обозначены логические блоки, которые вам нужно создать для устройства на уровне приложения. Клиентская библиотека связывает логику приложения с центром IoT и обеспечивает правильную обработку связей и процессов управления.

На следующей схеме представлены компоненты клиентской библиотеки управления устройствами.

![][img-library-overview]

## Дальнейшие действия: практический опыт
В этой статье рассматриваются основы работы с клиентской библиотекой (на языке C) управления устройствами для центра IoT.

Следующие ресурсы помогут вам получить практический опыт ее использования.

* Пример обновления встроенного ПО для Intel Edison, в котором реализованы функции управления устройствами для устройства Intel Edison. См. пример [iotdm\_edison\_sample][lnk-edison-sample].
* Пример имитации устройств: независимая от платформы реализация, которая работает на устройствах Windows и Linux. См. пример [iotdm\_simple\_sample][lnk-simple-sample].
* Дополнительные сведения об объектах LWM2M см. в [реестре объектов и ресурсов OMA LWM2M][lnk-oma].

## Приложение: поддерживаемые сейчас объекты и ресурсы LWM2M
### Объект устройства
| Имя ресурса | Допустимая удаленная операция для этого ресурса | Тип | Единицы измерения и диапазоны | Описание |
| --- | --- | --- | --- | --- |
| Производитель |чтение |Строка | |Имя производителя. |
| ModelNumber |чтение |Строковый | |Идентификатор модели (строка, определяемая производителем). |
| DeviceType |чтение |Строковый | |Тип устройства (строка, определяемая производителем).<br/>Примечание: сопоставляется со свойством **SystemPropertyNames.DeviceDescription** серверного API. |
| SerialNumber |чтение |Строка | |Серийный номер устройства. |
| FirmwareVersion |чтение |Строковый | |Текущая версия встроенного ПО на устройстве. |
| HardwareVersion |чтение |Строка | |Текущая версия аппаратной модели устройства. |
| Reboot |Выполнить | | |Перезагрузка устройства. |
| FactoryReset |Выполнить | | |Сброс устройства к установкам по умолчанию. После этой операции устройство будет иметь такую же конфигурацию, как после первичного развертывания. |
| CurrentTime |Чтение<br/>Запись |Время | |Текущее время UNIX устройства. Клиент должен увеличивать это значение каждую секунду.<br/>Сервер управления устройствами может записывать значение в этот ресурс, чтобы синхронизировать время клиента с временем на сервере. |
| UTCOffset |Чтение<br/>Запись |Строка | |Действующее смещение от UTC. |
| Часовой пояс |Чтение<br/>Запись |Строковый | |Указывает, в каком часовом поясе находится устройство. |
| MemoryFree |чтение |Число |КБ |Оценка текущей доступной памяти для хранения данных и программного обеспечения на устройстве. |
| MemoryTotal |чтение |Число |КБ |Общий объем дискового пространства для хранения данных и программного обеспечения на устройстве. |
| BatteryLevel |чтение |Число |0–100 % |Текущий уровень заряда аккумулятора в процентах (от 0 до 100). |
| BatteryStatus |чтение |Число |0–6 |**0**: аккумулятор работает правильно, питание не поступает.<br/>**1**: аккумулятор заряжается.<br/>**2**: аккумулятор полностью заряжен, устройство работает от сети.<br/>**3**: аккумулятор поврежден.<br/>**4**: низкий заряд аккумулятора.<br/>**5**: аккумулятор отсутствует.<br/> **6**: сведения об аккумуляторе недоступны. |

### Объект обновления встроенного ПО
| Имя ресурса | Операция | Тип | Единицы измерения и диапазоны | Описание |
| --- | --- | --- | --- | --- |
| Package |запись |Непрозрачный | |Пакет обновления встроенного ПО в двоичном формате.<br/>Сопоставляется с параметром <br/>**SystemPropertyNames.FirmwarePackage** API службы. |
| PackageURI |запись |Строковый |0–255 байт |URI-адрес, по которому устройство может получить пакет встроенного ПО.<br/>Сопоставляется с параметром **SystemPropertyNames.FirmwarePackageUri** API службы. |
| Блокировка изменений |Выполнить | | |Обновление встроенного ПО с помощью пакета встроенного ПО, хранящиеся в объекте Package или загружаемого с URI-адреса пакета.<br/>Сопоставляется с параметром <br/>**ScheduleFirmwareUpdateAsync** API службы. |
| Состояние |чтение |Число |1–3 |Состояние процесса обновления встроенного ПО.<br/>**1**: не выполняется. Такое значение может быть до начала загрузки пакета или после применения пакета встроенного ПО.<br/>**2**: загрузка пакета встроенного ПО.<br/>**3**: пакет встроенного ПО загружен.<br/> Сопоставляется с параметром **SystemPropertyNames.FirmwareUpdateState** API службы. |
| UpdateResult |чтение |Число |0–6 |Результат загрузки или обновления встроенного ПО.<br/>**0**: значение по умолчанию.<br/>**1**: успешное обновление встроенного ПО.<br/>**2**: недостаточно памяти для нового пакета встроенного ПО.<br/>**3**: закончилась память при загрузке пакета.<br/>**4**: подключение разорвано во время загрузки пакета встроенного ПО.<br/>**5**: ошибка при проверке контрольной суммы CRC для загруженного пакета.<br/>**6**: неподдерживаемый тип пакета встроенного ПО.<br/>**7**: недопустимый URI. Сопоставляется с параметром **SystemPropertyNames.FirmwareUpdateResult** API службы. |
| PkgName |чтение |Строка |0–255 байт |Описательное имя пакета встроенного ПО, на который ссылается ресурс **Package** <br/>Сопоставляется с параметром <br/>**SystemPropertyNames.FirmwarePackageName** API службы. |
| PackageVersion |чтение |Строка |0–255 байт |Номер версии пакета встроенного ПО, на который ссылается ресурс **Package** <br/>Сопоставляется с параметром <br/>**SystemPropertyNames.FirmwarePackageVersion** API службы. |

### Объект сервера LWM2M
| Имя ресурса | Операция | Тип | Единицы измерения и диапазоны | Описание |
| --- | --- | --- | --- | --- |
| Минимальный период по умолчанию |Чтение Запись |Число |Секунды |Период времени, на который устройство задерживает отправку обновленных данных для наблюдаемых свойств. Например, если параметр **DefaultMinPeriod** имеет значение 5 минут, устройство отправляет обновленные данные о наблюдаемых свойствах не чаще, чем каждые 5 минут, даже если значения изменяются чаще. Сопоставляется с параметром **SystemPropertyNames.DefaultMinPeriod** API службы. |
| Максимальный период по умолчанию |Чтение Запись |Число |Секунды |Период времени (в секундах), за который устройство должно отправить значение для наблюдаемого свойства, независимо от того, изменялось ли это значение. Например, если **DefaultMaxPeriod** имеет значение 6 часов, устройство отправляет информацию о наблюдаемых свойствах не реже, чем раз в 6 часов, даже если значения не изменяются.<br/>Сопоставляется с параметром <br/>**SystemPropertyNames.DefaultMaxPeriod** API службы. |
| Срок действия |Чтение Запись |Число |Секунды |Время существования регистрации устройства. В течение этого времени существования от устройства должен быть получен запрос на новую регистрацию или на обновление регистрации; в противном случае регистрация устройства в службе отменяется.<br/>Сопоставляется с параметром <br/>**SystemPropertyNames.RegistrationLifetime** API службы. |

### Объект конфигурации
| Имя ресурса | Операция | Тип | Единицы измерения и диапазоны | Описание |
| --- | --- | --- | --- | --- |
| Имя |Чтение Запись |Строка | |Уникальное имя конфигурации устройства для чтения или обновления. |
| Значение |Чтение Запись |Строковый | |Однозначно определяет значение конфигурации для чтения или обновления. |
| Применить |Выполнить | | |Применяет изменения конфигурации на устройстве. |

## Дальнейшие действия
Для дальнейшего изучения возможностей центра IoT см. следующие статьи:

* [Разработка решения][lnk-design]
* [Руководство разработчика по центру Azure IoT (IoT — Интернет вещей)][lnk-devguide]
* [Пакет SDK для шлюза IoT (бета-версия): отправка сообщений с устройства в облако через виртуальное устройство с помощью Linux][lnk-gateway]
* [Управление центрами IoT через портал Azure][lnk-portal]

[img-library-overview]: media/iot-hub-device-management-library/library.png
[lnk-dm-overview]: iot-hub-device-management-overview.md
[lnk-get-started]: iot-hub-device-management-get-started.md
[lnk-simple-sample]: https://github.com/Azure/azure-iot-sdks/tree/dmpreview/c/iotdm_client/samples/iotdm_simple_sample
[lnk-edison-sample]: https://github.com/Azure/azure-iot-sdks/tree/dmpreview/c/iotdm_client/samples/iotdm_edison_sample
[Azure IoT Hub device SDK]: https://github.com/Azure/azure-iot-sdks/tree/dmpreview/c
[Azure IoT Hub]: Link%20to%20DM%20Overview
[Lightweight M2M]: http://openmobilealliance.org/about-oma/work-program/m2m-enablers/
[CoAP]: https://tools.ietf.org/html/rfc7252
[Wakaama]: https://github.com/eclipse/wakaama
[OMA LWM2M Object and resource registry]: http://technical.openmobilealliance.org/Technical/technical-information/omna/lightweight-m2m-lwm2m-object-registry

[lnk-Wakaama]: https://github.com/eclipse/wakaama
[lnk-github1]: https://github.com/Azure/azure-iot-sdks/tree/dmpreview/c/iotdm_client/lwm2m_objects
[lnk-github2]: https://github.com/Azure/azure-iot-sdks/tree/dmpreview/c/iotdm_client/lwm2m_objects
[lnk-oma]: http://technical.openmobilealliance.org/Technical/technical-information/omna/lightweight-m2m-lwm2m-object-registry

[lnk-design]: iot-hub-guidance.md
[lnk-devguide]: iot-hub-devguide.md
[lnk-gateway]: iot-hub-linux-gateway-sdk-simulated-device.md
[lnk-portal]: iot-hub-manage-through-portal.md

<!---HONumber=AcomDC_0810_2016-->