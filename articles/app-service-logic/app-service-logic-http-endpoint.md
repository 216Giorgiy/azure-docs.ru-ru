<properties
   pageTitle="Приложения логики как вызываемые конечные точки"
   description="Как создать и настроить конечные точки триггера и использовать их в приложении логики в службе приложений Azure"
   services="app-service\logic"
   documentationCenter=".net,nodejs,java"
   authors="jeffhollan"
   manager="erikre"
   editor=""/>

<tags
   ms.service="app-service-logic"
   ms.devlang="multiple"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="integration"
   ms.date="04/25/2016"
   ms.author="jehollan"/>


# Приложения логики как вызываемые конечные точки

В предыдущей версии схемы приложений логики (*2014-12-01-preview*) для доступа к конечной точке HTTP с возможностью синхронного вызова требовалось приложение API под названием **Прослушиватель HTTP**. В новой схеме (*2015-08-01-preview*) приложения логики могут обращаться к синхронной конечной точке HTTP самостоятельно. Можно также использовать схему вызываемых конечных точек для вызова приложений логики в качестве вложенного рабочего процесса с помощью действия "рабочего процесса" в приложении логики.

Существует три типа триггеров, которые могут получать запросы:

* manual,
* apiConnectionWebhook,
* httpWebhook.

В этой статье для примера используется триггер **manual**. Все описанные принципы точно так же применяются и к двум остальным типам триггеров.

## Добавление триггера в определение
Первый шаг — это добавить триггер в определение приложения логики, способное принимать входящие запросы. Можно выполнить поиск "HTTP Request" в конструкторе, чтобы добавить карту триггера. Вы можете определить схему JSON текста запроса, а конструктор создаст маркеры для анализа и передачи данных из триггера manual посредством рабочего процесса. Я рекомендую использовать такой инструмент, как [jsonschema.net](http://jsonschema.net), для создания схемы JSON из примера полезных данных текста.

![][2]

После сохранения определения приложения логики будет создан URL-адрес обратного вызова следующим образом.
 
```
https://prod-03.eastus.logic.azure.com:443/workflows/080cb66c52ea4e9cabe0abf4e197deff/triggers/myendpointtrigger?...
```

Эту конечную точку также можно получить на портале Azure.

![][1]

Также можно вызвать следующий метод:

```
POST https://management.azure.com/{resourceID of your logic app}/triggers/myendpointtrigger/listCallbackURL?api-version=2015-08-01-preview
```

## Вызов конечной точки триггера для приложения логики
Созданную конечную точку триггера можно сохранить в серверной системе и вызывать с помощью метода `POST` по полному URL-адресу. В текст можно включать дополнительные параметры запроса, заголовки и любое другое содержимое.

Тип содержимого `application/json` позволяет ссылаться на свойства из самого запроса. При использовании других типов содержимого запрос считается отдельной двоичной единицей, которая может передаваться в другие API, но недоступна для ссылок внутри рабочего процесса без преобразования содержимого. Например, чтобы передать содержимое `application/xml`, можно использовать `@xpath()` для извлечения XPath или `@json()` для преобразования XML в JSON (см. [полную документацию здесь](http://aka.ms/logicappsdocs)).

Кроме того, в определении можно указать схему JSON. Тогда конструктор создаст маркеры, которые затем можно будет передать в действия. Например, следующий код делает маркеры `title` и `name` доступными в конструкторе.

```
{
    "properties":{
        "title": {
            "type": "string"
        },
        "name": {
            "type": "string"
        }
    },
    "required": [
        "title",
        "name"
    ],
    "type": "object"
}
```

## Ссылка на содержимое входящего запроса
Функция `@triggerOutputs()` выводит содержимое входящего запроса. Это может выглядеть следующим образом:

```
{
    "headers" : {
        "content-type" : "application/json"
    },
    "body" : {
        "myprop" : "a value"
    }
}
```

Для доступа непосредственно к свойству `body` можно использовать сокращенный вариант `@triggerBody()`.

Это небольшое отличие от версии *2014-12-01-preview*, где доступ к тексту прослушивателя HTTP осуществлялся с помощью функции вида `@triggerOutputs().body.Content`.

## Ответ на запрос
Некоторые запросы, запускающие приложение логики, подразумевают определенный ответ. Для составления кода состояния, текста и заголовков ответа можно использовать новый тип действия под названием **response**. Обратите внимание на то, что при отсутствии формы **response** конечная точка приложения логики *мгновенно* отвечает сообщением **202 Запрос принят** (эквивалент действия *Отправлять ответ автоматически* в прослушивателе HTTP).

![][3]

```
"Response": {
            "conditions": [],
            "inputs": {
                "body": {
                    "name": "@{triggerBody()['name']}",
                    "title": "@{triggerBody()['title']}"
                },
                "headers": {
                    "content-type": "application/json"
                },
                "statusCode": 200
            },
            "type": "Response"
        }
```

Ответы содержат следующее:

| свойства; | Описание |
| -------- | ----------- |
| statusCode | Код состояния HTTP для ответа на входящий запрос. Это может быть любой допустимый код состояния, который начинается с 2xx, 4xx или 5xx. Коды состояния 3xx не допускаются. | 
| body | Тело ответа. Это может быть строка, объект JSON и даже двоичное содержимое из предыдущего шага. | 
| headers | В ответ можно включить любое число заголовков. | 

Чтобы исходный запрос получил ответ, все необходимые для этого действия в приложении логики должны быть выполнены в течение *60 секунд*, **если только рабочий процесс не вызывается как вложенное приложение логики**. Если в течение 60 секунд ответное действие выполнено не будет, срок действия входящего запроса истечет и будет получен ответ HTTP **408 время ожидания клиента истекло**. Для вложенных приложений логики родительское приложение логики будет продолжать ожидать ответ до конца, независимо от того, сколько это потребует времени.

## Расширенная настройка конечной точки
Приложения логики имеют встроенную поддержку конечной точки прямого доступа и для запуска выполнения приложения логики всегда используют метод `POST`. Ранее приложение API **Прослушиватель HTTP** также поддерживало изменение сегментов URL-адреса и метода HTTP. Можно даже настроить дополнительную защиту или пользовательский домен, добавив его в узел приложения API (веб-приложение, в котором находится приложения API).

Эти функции доступны через **управление API**.
* [Изменение метода запроса](https://msdn.microsoft.com/library/azure/dn894085.aspx#SetRequestMethod)
* [Изменение сегментов URL-адреса запроса](https://msdn.microsoft.com/library/azure/7406a8ce-5f9c-4fae-9b0f-e574befb2ee9#RewriteURL)
* Настройка доменов управления API на вкладке **Настройка** классического портала Azure
* Настройка политики для применения обычной проверки подлинности (**требуется ссылка**)

## Отличия от версии 2014-12-01-preview

| 2014-12-01-preview | 2015-08-01-preview |
|---------------------|--------------------|
| Щелкните приложение API **Прослушиватель HTTP**. | Щелкните параметр **Активация вручную** (приложение API не требуется). |
| Параметр прослушивателя HTTP *Sends response automatically* (Отправляет ответ автоматически). | Добавьте действие **response** в определение рабочего процесса или не делайте этого. |
| Настройка базовой проверки подлинности или OAuth | через управление API |
| Настройка метода HTTP | через управление API |
| Настройка относительного пути | через управление API |
| Ссылка на текст входящего ответа через `@triggerOutputs().body.Content`. | Ссылка через `@triggerOutputs().body`. |
| Действие **Отправка HTTP-ответа** для прослушивателя HTTP. | Щелкните **Respond to HTTP request** (Ответить на HTTP-запрос) (приложение API не требуется).


[1]: ./media/app-service-logic-http-endpoint/manualtriggerurl.png
[2]: ./media/app-service-logic-http-endpoint/manualtrigger.png
[3]: ./media/app-service-logic-http-endpoint/response.png

<!---HONumber=AcomDC_0504_2016-->