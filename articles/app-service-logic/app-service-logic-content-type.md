<properties
   pageTitle="Обработка типов содержимого в приложениях логики | Microsoft Azure"
   description="Узнайте, как работают приложения логики с типами содержимого в среде разработки и в среде выполнения"
   services="app-service\logic"
   documentationCenter=".net,nodejs,java"
   authors="jeffhollan"
   manager="dwrede"
   editor=""/>

<tags
   ms.service="app-service-logic"
   ms.devlang="multiple"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="integration"
   ms.date="05/03/2016"
   ms.author="jehollan"/>

# Обработка типов содержимого в приложениях логики

Через приложение логики могут проходить различные типы содержимого, включая JSON, XML, неструктурированные файлы и двоичные данные. Поддерживаются все типы содержимого; одни типы распознаются обработчиком приложений логики изначально, другие могут потребовать преобразования. В следующей статье описывается, как обработчик работает с различными типами содержимого и как добиться их корректной обработки, если потребуется.

## Заголовок Content-Type

Для начала рассмотрим два варианта `Content-Types`, не требующих конверсии или преобразования для использования в приложении логики — `application/json` и `text/plain`.

### Application/json

Обработчик рабочего процесса определяет способ обработки по заголовку `Content-Type` в HTTP-вызовах. Любой запрос с типом содержимого `application/json` будет храниться и обрабатываться как объект JSON. Кроме того, содержимое JSON может быть проанализировано по умолчанию без преобразования. В связи с этим запрос с заголовком Content-Type `application/json ` следующего вида:

```
{
    "data": "a",
    "foo": [
        "bar"
    ]
}
```

может быть проанализирован в рабочем процессе с помощью выражения вида `@body('myAction')['foo'][0]` для получения значения (в данном случае `bar`). Дополнительное преобразование не требуется. При работе с данными в формате JSON, но без указанного заголовка их можно преобразовать в формат JSON вручную с помощью функции `@json()` (например, `@json(triggerBody())['foo']`).

### Text/plain

Аналогично `application/json`, HTTP-сообщения, полученные с заголовком `Content-Type` `text/plain`, будут сохранены в исходном виде. Кроме того, при включении в последующие действия без какого-либо преобразования запрос будет передан без заголовка `Content-Type`: `text/plain`. Например, при работе с неструктурированным файлом можно получить следующее HTTP-содержимое:

```
Date,Name,Address
Oct-1,Frank,123 Ave.
```

как `text/plain`. Если в следующем действии оно отправляется как тело другого запроса (`@body('flatfile')`), запрос получает заголовок Content-Type `text/plain`. При работе с данными в виде простого текста, но без указанного заголовка их можно преобразовать в текстовый формат вручную с помощью функции `@string()` (например, `@string(triggerBody())`).

### Application/xml и Application/octet-stream и функции преобразователя

Обработчик приложений логики всегда сохраняет `Content-Type`, полученный с HTTP-запросом или ответом. Это значит, при получении содержимого с `Content-Type` из `application/octet-stream`, в том числе при последующим действии без преобразования, будет создан исходящий запрос с `Content-Type`: `application/octet-stream`. Таким образом, обработчик может гарантировать, что при прохождении через рабочий процесс данные не будут потеряны. При этом состояние действия (входные и выходные данные) хранятся в объекте JSON, пока он проходит через рабочий процесс. Это означает, что для сохранения некоторых типов данных обработчик преобразует содержимое в двоичную строку в кодировке Base64 с соответствующими метаданными, сохраняя и `$content`, и `$content-type`, преобразование которых выполняется автоматически. Типы содержимого можно также преобразовывать вручную, используя встроенные функции преобразователя:

* `@json()` преобразует данные в `application/json`
* `@xml()` преобразует данные в `application/xml`
* `@binary()` преобразует данные в `application/octet-stream`
* `@string()` преобразует данные в `text/plain`
* `@base64()` преобразует содержимое в строку Base64
* `@base64toString()` преобразует строку в кодировке Base64 в `text/plain`
* `@base64toBinary()` преобразует строку в кодировке Base64 в `application/octet-stream`
* `@encodeDataUri()` кодирует строку как массив байтов dataUri
* `@decodeDataUri()` декодирует dataUri в массив байтов

Например, при получении HTTP-запроса с `Content-Type`: `application/xml` вида:

```
<?xml version="1.0" encoding="UTF-8" ?>
<CustomerName>Frank</CustomerName>
```

можно выполнить преобразование, а затем использовать функцию вида `@xml(triggerBody())` либо сделать это из функции вида `@xpath(xml(triggerBody()), '/CustomerName')`.

### Другие типы содержимого

Другие типы содержимого поддерживаются и будут работать с приложением логики, но для этого может потребоваться извлечение тела запроса вручную путем декодирования `$content`. Например, при запуске запроса `application/x-www-url-formencoded`, который выглядит как:

```
CustomerName=Frank&Address=123+Avenue
```

так как запрос не имеет формат простого текста или JSON, он сохраняется в действии в следующем виде:

```
...
"body": {
    "$content-type": "application/x-www-url-formencoded",
    "$content": "AAB1241BACDFA=="
}
```

где `$content` — это полезная нагрузка, закодированная в виде строки Base64 для сохранения всех данных. Так как в настоящее время встроенной функции для формирования данных нет, эти данные можно использовать в рабочем процессе, обращаясь к ним вручную с помощью функции вида `@string(body('formdataAction'))`. Если исходящий запрос должен также иметь заголовок content-type `application/x-www-url-formencoded`, можно просто добавить его в тело действия без преобразования, например: `@body('formdataAction')`. Однако это сработает, только если тело запроса является единственным параметром входных данных `body`. Если вы попытаетесь сделать `@body('formdataAction')` внутри запроса `application/json`, вы получите ошибку среды выполнения, так как тело запроса будет отправлено в закодированном виде.

<!---HONumber=AcomDC_0525_2016-->