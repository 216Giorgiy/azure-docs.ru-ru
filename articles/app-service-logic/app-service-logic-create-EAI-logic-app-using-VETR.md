<properties
   pageTitle="Создание приложения логики EAI с помощью VETR в приложениях логики в службе приложений Azure | Microsoft Azure"
   description="Функции проверки, кодирования и преобразования в XML-службах BizTalk"
   services="app-service\logic"
   documentationCenter=".net,nodejs,java"
   authors="rajeshramabathiran"
   manager="dwrede"
   editor=""/>

<tags
   ms.service="app-service-logic"
   ms.devlang="multiple"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="02/18/2016"
   ms.author="rajram"/>


# Создание приложения логики EAI с помощью VETR

>[AZURE.NOTE] Эта версия статьи предназначена для приложений логики со схемой версии 2014-12-01-preview.

Большинство сценариев интеграции приложений (EAI) преобразовывают данные между источником и назначением. Такие сценарии часто имеют общий набор требований.

- Проверка правильности формата данных из разных систем.
- «Просмотр» входящих данных для принятия решений.
- Преобразование данных из одного формата в другой (например, из формата данных системы CRM в формат данных системы ERP).
- Маршрутизация данных в нужное приложение или систему.

В данной статье рассказывается о стандартном шаблоне интеграции "одностороннее преобразование сообщений" или VETR — Validate (проверка), Enrich (обогащение), Transform (преобразование), Route (маршрутизация). Шаблон VETR преобразует данные между исходной сущностью и целевой сущностью. Обычно источник и назначение представляют собой источники данных.

Рассмотрим веб-сайт, который принимает заказы. Пользователи размещают заказы в системе с помощью HTTP. За кулисами система проверяет правильность входных данных, нормализует их и сохраняет их в очереди служебной шины для дальнейшей обработки. Система принимает заказы из очереди, ожидая их в определенном формате. Таким образом, сквозной поток следующий:

**HTTP** → **Проверка** → **Преобразование** → **Служебная шина**.

![Основной поток VETR][1]

Этот шаблон помогают построить следующие приложения API BizTalk:

* **триггер HTTP** — источник для активации события сообщения;
* **проверка** — проверяет правильность входящих данных;
* **преобразование** — преобразует данные из входящего формата в формат, который требует нисходящая система;
* **соединитель служебной шины** — целевая сущность, куда отправляются данные.


## Построение базового шаблона VETR
### Основные сведения

На портале Azure последовательно выберите **+Создать**, **Интернет + мобильные устройства**, **Приложение логики**. Выберите имя, расположение, подписку, группу ресурсов и рабочее расположение. Группы ресурсов выполняют роль контейнеров для приложений. Все ресурсы для приложения помещаются в одну группу ресурсов.

Теперь давайте добавим триггеры и действия.


## Добавление триггера HTTP
1. В разделе **Шаблоны приложения логики** выберите **Создать с нуля**.
1. Выберите в коллекции элемент **Прослушиватель HTTP**, чтобы создать новый прослушиватель. Назовите его **HTTP1**.
2. Задайте для параметра **Отправлять ответ автоматически?** значение False. Настройте действие триггера, задав для параметра _Метод HTTP_ значение _POST_, а для параметра _Относительный URL-адрес_ — значение _/OneWayPipeline_.  
	![Триггер HTTP][2]
3. Щелкните зеленый флажок, чтобы завершить добавление триггера.

## Добавление действия проверки

Теперь давайте зададим действия, которые будут выполняться при каждом срабатывании триггера, то есть всякий раз, когда в конечной точке HTTP принимается вызов.

1. Добавьте элемент **Средство проверки XML BizTalk** из коллекции и дайте ему имя _(Validate1)_, чтобы создать экземпляр.
2. Настройте схему XSD для проверки входящих сообщений XML. Выберите действие _Проверить_ и выберите _\_triggers(‘httplistener’).outputs.Content_ в качестве значения параметра _inputXml_.

Теперь действие проверки — первое действие после прослушивателя HTTP.

![Средство проверки XML BizTalk][3]

Аналогично добавим остальные действия.

## Добавление действия преобразования
Давайте настроим преобразования для нормализации входящих данных.

1. Добавьте из коллекции **службу преобразования BizTalk**.
2. Чтобы настроить преобразование входящих сообщений XML, выберите действие **Преобразовать**, которое будет выполняться при вызове этого API. Задайте для параметра _inputXml_ значение ```triggers(‘httplistener’).outputs.Content```. *Сопоставление* — необязательный параметр, так как входящие данные соответствуют всем настроенным преобразованиям, а используются только те, которые соответствуют схеме.
3. Наконец, преобразование выполняется только в том случае, если проверка завершается успешно. Чтобы настроить это условие, щелкните значок шестеренки в правом верхнем углу и выберите _Добавить условие для выполнения_. В качестве условия задайте ```equals(actions('xmlvalidator').status,'Succeeded')```.  

![Преобразования BizTalk][4]


## Добавление соединителя служебной шины
Теперь добавим назначение (очередь служебной шины) для записи в него данных.

1. Добавьте элемент **Соединитель служебной шины** из коллекции. Задайте для свойства **Имя** значение _Servicebus1_, в свойстве **Строка подключения** укажите строку подключения к экземпляру служебной шины, в свойстве **Имя сущности** задайте _Queue_ и пропустите свойство **Имя подписки**.
2. Выберите действие **Отправить сообщение**, а затем в поле **Содержимое** введите значение _actions('transformservice').outputs.OutputXml_.
3. В поле **Тип содержимого** задайте значение *application/xml*.  

![Service Bus][5]


## Отправка HTTP-ответа
После завершения конвейерной обработки мы отправляем обратно HTTP-ответ как для успешной, так и для неудачной обработки с помощью следующих действий.

1. Добавьте элемент **Прослушиватель HTTP** из коллекции и выберите действие **Отправить HTTP-ответ**.
2. Укажите в поле **Идентификатор ответа** значение *Отправить сообщение*.
2. Укажите в поле **Содержимое ответа** значение *Конвейерная обработка завершена*.
3. Укажите в поле **Код состояния ответа** значение *200*, чтобы задать для HTTP значение 200, и нажмите кнопку «ОК».
4. Вверху справа щелкните раскрывающееся меню и выберите пункт **Добавить условие для выполнения**. Укажите в качестве условия следующее выражение: ```@equals(actions('azureservicebusconnector').status,'Succeeded')``` <br/>
5. Повторите эти действия для отправки HTTP-откликов при сбоях. Замените значение в поле **Условие** следующим выражением: ```@not(equals(actions('azureservicebusconnector').status,'Succeeded'))``` <br/>
6. Нажмите кнопку **ОК**, а затем — **Создать**.



## Выполнение
Каждый раз, когда кто-либо отправляет сообщение в конечную точку HTTP, он активирует приложение и выполняет действия, которые мы только что создали. Для управления любыми другими созданными вами приложениями логики нажмите кнопку **Обзор** на портале Azure и выберите **Приложения логики**. Щелкните ваше приложение, чтобы отобразить дополнительные сведения.

Ниже перечислены некоторые полезные статьи.

[Управление встроенными приложениями API и соединителями, а также их мониторинг](app-service-logic-monitor-your-connectors.md) <br/> [Мониторинг приложений логики](app-service-logic-monitor-your-logic-apps.md)

<!--image references -->
[1]: ./media/app-service-logic-create-EAI-logic-app-using-VETR/BasicVETR.PNG
[2]: ./media/app-service-logic-create-EAI-logic-app-using-VETR/HTTPListener.PNG
[3]: ./media/app-service-logic-create-EAI-logic-app-using-VETR/BizTalkXMLValidator.PNG
[4]: ./media/app-service-logic-create-EAI-logic-app-using-VETR/BizTalkTransforms.PNG
[5]: ./media/app-service-logic-create-EAI-logic-app-using-VETR/AzureServiceBus.PNG

<!---HONumber=AcomDC_0302_2016-->