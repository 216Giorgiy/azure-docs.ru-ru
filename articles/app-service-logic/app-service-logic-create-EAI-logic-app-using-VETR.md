<properties
   pageTitle="Создание приложения логики EAI с помощью VETR | Microsoft Azure"
   description="Функции проверки, кодирования и преобразования в XML-службах BizTalk"
   services="app-service\logic"
   documentationCenter=".net,nodejs,java"
   authors="rajeshramabathiran"
   manager="dwrede"
   editor=""/>

<tags
   ms.service="app-service-logic"
   ms.devlang="multiple"
   ms.topic="get-started-article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="09/29/2015"
   ms.author="rajram"/>


# Создание приложения логики EAI с помощью VETR

Большинство сценариев интеграции приложений (EAI) преобразовывают данные между источником и назначением. Такие сценарии часто имеют общий набор требований.

- Проверка правильность формата данных из разных систем
- Выполнение «просмотра» входящих данных для принятия решений.
- Преобразование данных из одного формата в другой (например, из формата данных системы CRM в формат данных системы ERP).
- Маршрутизация данных в нужное приложение или систему.

В данной статье рассказывается о стандартном шаблоне интеграции "одностороннее преобразование сообщений" или VETR — Validate (проверка), Enrich (обогащение), Transform (преобразование), Route (маршрутизация). Шаблон VETR преобразует данные между исходной сущностью и целевой сущностью. Обычно источник и назначение представляют собой источники данных.

Рассмотрим веб-сайт, который принимает заказы. Пользователи размещают заказы в системе с помощью HTTP. За кулисами система проверяет правильность входных данных, нормализует их и сохраняет их в очереди служебной шины для дальнейшей обработки. Система принимает заказы из очереди, ожидая их в определенном формате. Таким образом, сквозной поток следующий:

**HTTP** -> **Проверка** -> **Преобразование** -> **Служебная шина**

![Основной поток VETR][1]

Этот шаблон помогают построить следующие приложения API BizTalk:

* **триггер HTTP** — источник для активации события сообщения;
* **проверка** — проверяет правильность входящих данных;
* **преобразование** — преобразует данные из входящего формата в формат, который требует нисходящая система;
* **соединитель служебной шины** — целевая сущность, куда отправляются данные.


## Построение базового шаблона VETR
### Основные сведения

На портале управления Azure нажмите кнопку **+Создать** в нижнем левом углу экрана и выберите **Приложение логики**. Выберите имя, расположение, подписку, группу ресурсов и рабочее расположение. Группы ресурсов действуют как контейнеры для приложений, и все ресурсы для приложения должны быть в одной группе ресурсов.

Теперь давайте добавим триггеры и действия.


## Добавление триггера HTTP

1. Выберите в коллекции элемент **Прослушиватель HTTP**, чтобы создать новый прослушиватель. Назовите его **HTTP1**.
2. Оставьте в параметре **Отправлять ответ автоматически?** значение false. Настройте действие триггера, задав для параметра _Метод HTTP_ значение _POST_, а для параметра _Относительный URL-адрес_ — значение _/OneWayPipeline_.  

	![Триггер HTTP][2]


## Добавление действия проверки

Теперь давайте зададим действия, которые будут выполняться при каждом срабатывании триггера, то есть всякий раз, когда в конечной точке HTTP принимается вызов.

1. Добавьте элемент **Средство проверки XML BizTalk** из коллекции и дайте ему имя _(Validate1)_, чтобы создать экземпляр.
2. Настройте схему XSD для проверки входящих сообщений XML. Выберите действие _Проверить_ и выберите _\_triggers(‘httplistener’).outputs.Content_ в качестве значения параметра _inputXml_.

Теперь действие проверки — первое действие после прослушивателя HTTP.

![Средство проверки XML BizTalk][3]

Аналогично добавим остальные действия.

## Добавление действия преобразования
Давайте настроим преобразования для нормализации входящих данных.

1. Добавьте действие **Преобразовать** из коллекции.
2. Чтобы настроить преобразование входящих сообщений XML, выберите действие **Преобразовать** в качестве действия? которое необходимо выполнить при вызове этого API, а затем в качестве значения для _inputXml_ выберите ```triggers(‘httplistener’).outputs.Content```. *Сопоставление* — это необязательный параметр, так как входящие данные соответствуют всем настроенным преобразованиям и применяются только те, которые соответствуют схеме.
3. Наконец, преобразование выполняется только в том случае, если проверка завершается успешно. Чтобы настроить это условие, щелкните значок шестеренки в правом верхнем углу и выберите _Добавить условие для выполнения_. В качестве условия задайте ```equals(actions('xmlvalidator').status,'Succeeded')```.  

![Преобразования BizTalk][4]


## Добавление соединителя служебной шины
Теперь добавим назначение (очередь служебной шины) для записи в него данных.

1. Добавьте элемент **Соединитель служебной шины** из коллекции. Задайте для свойства **Имя** значение _Servicebus1_, в свойстве **Строка подключения** укажите строку подключения к экземпляру служебной шины, в свойстве **Имя сущности** задайте _Queue_ и пропустите свойство **Имя подписки**.
2. Выберите действие **Отправить сообщение**, а затем для него в поле **Сообщение** задайте значение _actions('transformservice').outputs.OutputXml_.

![Service Bus][5]


## Отправка HTTP-ответа
После завершения конвейерной обработки мы отправляем обратно HTTP-ответ как для успешной, так и для неудачной обработки с помощью следующих действий.

1. Добавьте элемент **Прослушиватель HTTP** из коллекции и выберите действие **Отправить HTTP-ответ**.
2. В поле **Содержимое отклика** задайте значение *Конвейерная обработка завершена*, в поле **Код состояния отклика** задайте значение *200*, чтобы указать код HTTP 200 ОК, и в поле **Условие** задайте выражение ```@equals(actions('servicebusconnector').status,'Succeeded')``` <br/>.


Повторите эти действия для отправки HTTP-откликов при сбоях. Замените значение в поле **Условие** выражением ```@not(equals(actions('servicebusconnector').status,'Succeeded'))``` <br/>


## Выполнение
Каждый раз, когда кто-либо отправляет сообщение в конечную точку HTTP, он активирует приложение и выполняет действия, которые мы только что создали. Чтобы управлять любыми подобными созданными вами приложениями логики, нажмите кнопку **Обзор** на портале Azure и выберите **Приложения логики**. Щелкните ваше приложение, чтобы отобразить дополнительные сведения.

Ниже перечислены некоторые полезные статьи.

[Управление встроенными приложениями API и соединителями, а также их мониторинг](app-service-logic-monitor-your-connectors.md) <br/> [Мониторинг приложений логики](app-service-logic-monitor-your-logic-apps.md)

<!--image references -->
[1]: ./media/app-service-logic-create-EAI-logic-app-using-VETR/BasicVETR.PNG
[2]: ./media/app-service-logic-create-EAI-logic-app-using-VETR/HTTPListener.PNG
[3]: ./media/app-service-logic-create-EAI-logic-app-using-VETR/BizTalkXMLValidator.PNG
[4]: ./media/app-service-logic-create-EAI-logic-app-using-VETR/BizTalkTransforms.PNG
[5]: ./media/app-service-logic-create-EAI-logic-app-using-VETR/AzureServiceBus.PNG

<!---HONumber=Oct15_HO3-->