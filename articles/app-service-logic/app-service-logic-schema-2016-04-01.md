<properties 
	pageTitle="Новая версия схемы 2016-06-01 | Microsoft Azure" 
	description="Отсюда вы узнаете, как создать определение JSON для приложений логики последней версии." 
	authors="jeffhollan" 
	manager="dwrede" 
	editor="" 
	services="app-service\logic" 
	documentationCenter=""/>

<tags
	ms.service="logic-apps"
	ms.workload="integration"
	ms.tgt_pltfrm="na"
	ms.devlang="na"
	ms.topic="article"
	ms.date="07/25/2016"
	ms.author="jehollan"/>
	
# Новая версия схемы 2016-06-01

Новая версия схемы и API для приложений логики содержит ряд улучшений, которые повышают надежность и простоту использования приложений логики. Три основных отличия новой версии:

1. Добавлены области. Это действия, которые содержат в себе ряд других действий.
1. Условия и циклы — это действия первого класса.
1. Более точный порядок выполнения с помощью свойства `runAfter` (которое заменяет свойство `dependsOn`).

Сведения об обновлении приложений логики со схемы версии 2015-08-01-preview до схемы версии 2016-06-01 см. в [соответствующем разделе ниже](#upgrading-to-2016-06-01-schema).


## 1\. Области действия

Одно из самых существенных изменений в этой схеме — добавление областей и возможность вкладывать одно действие в другое. Это полезно в ситуациях, когда нужно сгруппировать несколько действий или вложить одно действие в другое (например, чтобы одно условие содержало в себе другое условие). Дополнительные сведения о синтаксисе областей доступны [здесь](app-service-logic-loops-and-scopes.md), а простой образец области приведен ниже.


```
{
    "actions": {
        "My_Scope": {
            "type": "scope",
            "actions": {                
                "Http": {
                    "inputs": {
                        "method": "GET",
                        "uri": "http://www.bing.com"
                    },
                    "runAfter": {},
                    "type": "Http"
                }
            }
        }
    }
}
```

## 2\. Изменения в условиях и циклах

В предыдущих версиях схемы условия и циклы были параметрами, связанными с каким-то одним действием. В текущей версии этого ограничения нет, поэтому условия и циклы отображаются как тип действия. Дополнительные сведения доступны [в этой статье](app-service-logic-loops-and-scopes.md), а простой пример условия показан ниже.

```
{
    "If_trigger_is_foo": {
        "type": "If",
        "expression": "@equals(triggerBody(), 'foo')",
        "runAfter": { },
        "actions": {
            "Http_2": {
                "inputs": {
                    "method": "GET",
                    "uri": "http://www.bing.com"
                },
                "runAfter": {},
                "type": "Http"
            }
        },
        "else": 
        {
            "if_trigger_is_bar": "..."
        }      
    }
}
```

## 3\. Свойство RunAfter

Новое свойство `runAfter` заменяет свойство `dependsOn`, делая порядок запусков более точным. Свойство `dependsOn` означало "действие запущено и успешно выполнено" независимо от того, сколько раз нужно выполнить действие и каким было завершение предыдущего действия: успешным, неудавшимся или пропущенным. Свойство `runAfter` обеспечивает нужную гибкость. Это объект, который указывает все имена действия и задает массив статусов, которые делают возможным активацию. Например, если вы хотите выполнить активацию после успешного завершения действия A и успешного завершения или сбоя действия B, требуется такое свойство `runAfter`:

```
{
    "...",
    "runAfter": {
        "A": ["Succeeded"],
        "B": ["Succeeded", "Failed"]
    }
}
```

## Обновление до схемы 2016-06-01

Выполнить обновление до схемы 2016-06-01 очень просто. Информацию об изменениях в этой схеме можно найти [в этой статье](app-service-logic-schema-2016-04-01.md). Вот что входит в процесс обновления: запуск сценария обновления, сохранение в качестве нового приложения логики и, если нужно, перезапись старого приложения логики.

1. Откройте текущее приложение логики.
1. Нажмите кнопку **Схема обновления** на панели инструментов.
   
    ![][1]
   
    Будет возвращено обновленное определение. Если нужно, скопируйте его в определение ресурса. Но мы **настоятельно рекомендуем** нажать кнопку **Сохранить как**, чтобы в обновленном приложении логики все ссылки на подключение были рабочими.
1. Нажмите кнопку **Сохранить как** на панели инструментов обновленной колонки.
1. Введите имя и укажите статус приложения логики, затем щелкните **Создать**, чтобы развернуть обновленное приложение логики.
1. Убедитесь, что это приложение работает так, как нужно.

    >[AZURE.NOTE] Если вы используете триггер запуска вручную или триггер запроса, в новом приложении логики URL-адрес обратного вызова будет новым. С помощью нового URL-адреса проверьте, работает ли приложение полноценно. Кроме того, вы можете клонировать существующее приложение логики, чтобы сохранить предыдущие URL-адреса.

1. *Необязательно*. Чтобы перезаписать предыдущее приложение логики, заменив его новой версией схемы, нажмите кнопку **Клонировать** на панели инструментов (это возле значка **Обновить схему** на рисунке выше). Делайте это, только если хотите сохранить код ресурса или URL-адрес триггера запроса вашего приложения логики.

### Примечания о средстве обновления

#### Сопоставление состояний

Это средство максимально эффективно собирает вместе действия ветвления true и false в области в обновленном определении. В частности, шаблон конструктора `@equals(actions('a').status, 'Skipped')` должен отображаться как действие `else`. Но если средство обнаруживает шаблоны, которые оно не может распознать, оно создает отдельные условия для ветвей true и false. Действия можно повторно сопоставить после обновления, если нужно.

#### ForEach с условием
  
Предыдущий шаблон цикла ForEach с одним условием на элемент можно реплицировать в новой схеме с помощью действия фильтра. Это должно произойти автоматически после обновления. Условие становится действием фильтра до запуска цикла ForEach (чтобы вернулся только массив элементов, которые соответствуют условию). Этот массив передается в действие ForEach. Пример можно просмотреть [в этой статье](app-service-logic-loops-and-scopes.md).

#### Теги ресурсов

Теги ресурсов удаляются после обновления, поэтому их нужно задавать заново для обновленного рабочего процесса.

## Другие изменения

### Триггер запуска вручную стал называться триггером запроса

Тип `manual` устарел и получил имя `request` и вид `http`. Это лучше соответствуют типу шаблона, для построения которого используется триггер.

### Новое действие "фильтр"

Если вы работаете с большим массивом, а нужно небольшое количество элементов, вы можете воспользоваться новым типом "фильтр". Он принимает массив и условие, оценивает соответствие каждого элемента условию и возвращает только те элементы, которые соответствуют условию.

### Ограничения действий ForEach и Until

Циклы ForEach и Until ограничены одним действием.

### Свойства TrackedProperties действий

У действий теперь может быть дополнительное свойство (элемент того же уровня, что и `runAfter` и `type`) с именем `trackedProperties`. Это объект, который указывает, что некоторые выходные или входные данные действия нужно включить в телеметрию службы диагностики Azure. Эта телеметрия отправляется в рамках рабочего процесса. Например:

```
{                
    "Http": {
        "inputs": {
            "method": "GET",
            "uri": "http://www.bing.com"
        },
        "runAfter": {},
        "type": "Http",
        "trackedProperties": {
            "responseCode": "@action().outputs.statusCode",
            "uri": "@action().inputs.uri"
        }
    }
}
```

## Дальнейшие действия
- [Создание определений приложений логики](app-service-logic-author-definitions.md)
- [Создание шаблона развертывания приложения логики](app-service-logic-create-deploy-template.md)


<!-- Image references -->
[1]: ./media/app-service-logic-schema-2016-04-01/upgradeButton.png

<!---HONumber=AcomDC_0727_2016-->