---
title: "Создание API для приложений логики"
description: "Создание пользовательского API для приложений логики"
author: jeffhollan
manager: dwrede
editor: 
services: logic-apps
documentationcenter: 
ms.assetid: bd229179-7199-4aab-bae0-1baf072c7659
ms.service: logic-apps
ms.workload: integration
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 10/18/2016
ms.author: jehollan
translationtype: Human Translation
ms.sourcegitcommit: 219dcbfdca145bedb570eb9ef747ee00cc0342eb
ms.openlocfilehash: eb382850f8a64c18864e6717b62cee530cdf56d0


---
# <a name="creating-a-custom-api-to-use-with-logic-apps"></a>Создание пользовательского API для приложений логики
Чтобы расширить платформу приложений логики, вы можете разными способами вызывать API-интерфейсы или системы, которые не входят в наш набор стандартных соединителей.  Один из таких способов — создание приложения API, к которому можно обращаться в рамках рабочего процесса приложения логики.

## <a name="helpful-tools"></a>Полезные инструменты
Чтобы обеспечить оптимальное взаимодействие между API-интерфейсами и приложениями логики, мы рекомендуем создать документ [swagger](http://swagger.io) с подробным описанием поддерживаемых операций и параметров API.  Есть много библиотек (например, [Swashbuckle](https://github.com/domaindrivendev/Swashbuckle)), которые могут автоматически создавать файл swagger.  С этой же целью вы также можете использовать библиотеку [TRex](https://github.com/nihaue/TRex) для создания заметок к файлу swagger (отображаемые имена, типы свойств и т. д.).  Некоторые примеры приложений API, созданных для работы с приложениями логики, вы найдете в нашем [репозитории GitHub](http://github.com/logicappsio) и [блоге](http://aka.ms/logicappsblog).

## <a name="actions"></a>Действия
Базовый сценарий взаимодействия с приложением логики таков: контроллер принимает HTTP-запрос и возвращает ответ (обычно 200).  Но есть несколько способов расширить этот сценарий в зависимости от конкретных задач.

По умолчанию обработчик приложения логики сбрасывает запрос через одну минуту ожидания.  Но если API выполняет более продолжительные действия, вы можете сделать так, чтобы обработчик ожидал их завершения. Это можно сделать с помощью асинхронной модели или модели с использованием веб-перехватчика, которые описаны ниже.

Для стандартных действий просто напишите метод HTTP-запроса в API, который предоставляется через Swagger.  Примеры приложений API, которые работают с Logic Apps, доступны в [репозитории GitHub](https://github.com/logicappsio).  Ниже описаны ситуации, в которых применяется пользовательский соединитель.

### <a name="long-running-actions---async-pattern"></a>Длительные действия — асинхронная модель
Когда выполняется долгий процесс или длительное задание, прежде всего следует сообщить обработчику, что процесс еще выполняется. Также нужно, чтобы обработчик знал, как вы сообщите ему о завершении процесса. И наконец, нужно вернуть в обработчик соответствующие данные, чтобы он мог продолжить рабочий процесс. Все это можно реализовать через API, выполнив следующие действия. Все шаги выполняются в контексте пользовательского API.

1. При получении запроса ответ должен быть немедленно возвращен (до выполнения работы). Это и будет ответ `202 ACCEPTED` , который сообщит обработчику, что вы получили все данные (включая полезные данные), которые сейчас обрабатываются. Ответ 202 должен содержать следующие заголовки: 
   
   * `location` (обязательный): абсолютный путь к URL-адресу, с помощью которого служба Logic Apps может проверить состояние задания;
   * `retry-after` (необязательный, для действий по умолчанию установлено значение 20). Это время ожидания (в секундах) для обработчика, по истечении которого он может запускать опрос URL-адреса в заголовке расположения для проверки состояния.
2. При проверке состояния задания возможны следующие варианты: 
   
   * если задание выполнено, должен вернуться ответ `200 OK` с полезными данными ответа;
   * если задание еще обрабатывается, должен вернуться еще один ответ `202 ACCEPTED` с такими же заголовками, как и в первоначальном ответе.

Такая модель позволяет выполнять очень длительные задачи в потоке пользовательского API. При этом сохраняется обмен данными с обработчиком приложения логики, который не сбрасывает запрос и не продолжает рабочий процесс раньше времени. Обратите внимание: когда вы добавляете эту модель в свое приложение логики, вам не нужно изменять определения, чтобы приложение логики продолжало выполнять опрос и проверку состояния. Когда обработчик получает ответ "202 ACCEPTED" с правильным заголовком расположения, он переходит в асинхронный режим работы, продолжая обращаться к этому заголовку до тех пор, пока не получит другой ответ (кроме 202).

С примером реализации этой модели на GitHub можно ознакомиться [здесь](https://github.com/jeffhollan/LogicAppsAsyncResponseSample)

### <a name="webhook-actions"></a>Действия веб-перехватчика
При выполнении рабочего процесса вы можете приостановить приложение логики, чтобы дождаться обратного вызова для продолжения.  Такой обратный вызов поступает в виде HTTP-запроса POST.  Чтобы реализовать эту модель, следует создать на контроллере две конечные точки — для подписки и отмены подписки.

При обращении к конечной точке подписки приложение логики создает и регистрирует URL-адрес обратного вызова, который API может хранить, а также обратный вызов, как только получает HTTP-запрос POST.  Все заголовки и содержимое передаются в приложение логики и могут быть использованы в рабочем процессе.  Обработчик приложения логики обратится к конечной точке подписки, как только достигнет этого этапа процесса.

Если выполнение процесса отменить, обработчик приложения логики обратится к конечной точке отмены подписки.  Тогда API при необходимости сможет отменить регистрацию URL-адреса обратного вызова.

Сейчас конструктор приложений логики не поддерживает обнаружение конечной точки веб-перехватчика с помощью swagger. Следовательно, для использования этой модели нужно вручную добавить действие веб-перехватчика и указать URL-адрес, заголовки и тело запроса.  Чтобы передать любое из этих полей в URL-адрес обратного вызова, можно использовать функцию рабочего процесса `@listCallbackUrl()`.

С примером реализации этой модели с использованием веб-перехватчика на GitHub можно ознакомиться [здесь](https://github.com/jeffhollan/LogicAppTriggersExample/blob/master/LogicAppTriggers/Controllers/WebhookTriggerController.cs)

## <a name="triggers"></a>триггеры;
Помимо действий, пользовательский API может выполнять роль триггера для приложения логики.  Ниже описаны два способа активации приложения логики.

### <a name="polling-triggers"></a>Опрашивающие триггеры
Опрашивающие триггеры действуют примерно так же, как описанная выше асинхронная модель выполнения длительных действий.  Обработчик приложения логики обращается к конечной точке триггера по истечении определенного периода времени (зависит от класса SKU: 15 секунд для уровня "Премиум", 1 минута для уровня "Стандартный", 1 час для уровня "Бесплатный").

Если нет доступных данных, триггер возвращает ответ `202 ACCEPTED` с заголовками `location` и `retry-after`.  Для триггеров рекомендуется включать в заголовок `location` параметр запроса `triggerState`.  Это идентификатор, который позволяет API узнать время последнего запуска приложения логики.  Если есть доступные данные, триггер возвращает ответ `200 OK` с полезными данными содержимого.  Это запустит приложение логики.

Например, если нужно получить информацию о доступности файла, вы можете создать опрашивающий триггер, который выполняет следующие действия.

* Если запрос получен без параметра triggerState, API возвращает ответ `202 ACCEPTED` с заголовком `location` и параметром triggerState, в котором указано текущее время и параметр `retry-after` со значением 15.
* Если в запросе есть параметр triggerState:
  * Проверьте, были ли добавлены файлы начиная с даты и времени, указанных в параметре triggerState. 
  * Если есть один такой файл, должен быть возвращен ответ `200 OK` с полезными данными содержимого. При этом значение параметра triggerState должно увеличиться в соответствии с датой и временем (DateTime) возвращаемого файла, а параметр `retry-after` должен иметь значение 15.
  * Если есть несколько файлов, их можно возвращать поочередно в виде ответов `200 OK` с увеличением значения triggerState в заголовке `location` и указанием для параметра `retry-after` значения 0.  Так мы сообщим обработчику, что есть и другие доступные данные, которые он немедленно запросит по адресу, указанному в заголовке `location` .
  * Если доступных файлов нет, должен быть возвращен ответ `202 ACCEPTED` с прежним значением параметра triggerState в заголовке `location`.  Для параметра `retry-after` задайте значение 15.

С примером реализации модели опрашивающего триггера на GitHub можно ознакомиться [здесь](https://github.com/jeffhollan/LogicAppTriggersExample/tree/master/LogicAppTriggers)

### <a name="webhook-triggers"></a>Триггеры веб-перехватчика
Триггеры веб-перехватчика работают так же, как и действия веб-перехватчика, описанные выше.  Обработчик приложения логики вызывает конечную точку подписки каждый раз, когда добавляется и сохраняется триггер веб-перехватчика.  API может зарегистрировать URL-адрес веб-перехватчика и обратиться к нему с HTTP-запросом POST, когда данные будут доступны.  Полезные данные содержимого и заголовки будут переданы в процесс приложения логики.

Если триггер веб-перехватчика удаляется (удаляется приложение логики целиком или только триггер веб-перехватчика), обработчик обратится по URL-адресу отмены подписки, а API сможет отменить регистрацию URL-адреса обратного вызова и при необходимости остановить все связанные с процессы.

Сейчас конструктор приложений логики не поддерживает обнаружение триггера точки веб-перехватчика с помощью swagger. Следовательно, для использования этой модели нужно вручную добавить триггер веб-перехватчика и указать URL-адрес, заголовки и тело запроса.  Чтобы передать любое из этих полей в URL-адрес обратного вызова, можно использовать функцию рабочего процесса `@listCallbackUrl()`.

С примером реализации модели триггера веб-перехватчика на GitHub можно ознакомиться [здесь](https://github.com/jeffhollan/LogicAppTriggersExample/tree/master/LogicAppTriggers)




<!--HONumber=Nov16_HO3-->


