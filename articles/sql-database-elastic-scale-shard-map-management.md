<properties 
	pageTitle="Управление картой сегментов" 
	description="Как использовать ShardMapManager, API эластичного масштабирования для .NET" 
	services="sql-database" 
	documentationCenter="" 
	manager="stuartozer" 
	authors="Joseidz" 
	editor=""/>

<tags 
	ms.service="sql-database" 
	ms.workload="sql-database" 
	ms.tgt_pltfrm="na" 
	ms.devlang="na" 
	ms.topic="article" 
	ms.date="02/16/2015" 
	ms.author="Joseidz@microsoft.com"/>

# Управление картой сегментов 
**Сопоставление сегментов** в среде сегментированной базы данных осуществляет информационную поддержку и позволяет приложениям подключаться к нужной базе данных с учетом **ключа сегментирования**. Для управления сегментами в предварительной версии эластичного масштабирования важно понимать принцип создания этих сопоставлений.

## Карты сегментов и сопоставление сегментов 
### Поддержка типов .Net для ключей сегментирования
Средство эластичного масштабирования поддерживает следующие типы .Net Framework в качестве ключей сегментирования.

* целое число
* длинное целое число
* guid
* byte[].  

### Списки и диапазоны сопоставления сегментов
Сопоставления сегментов создаются с использованием **списков отдельных ключей сегментирования** и **диапазонов значений ключей сегментирования**. 

###Сопоставление шардлетов и сегментов по списку
**Сегменты** содержат **шардлеты**, а сопоставление шардлетов с сегментами осуществляется с помощью сопоставления сегментов. **Сопоставление шардлетов и сегментов по списку** устанавливает соответствие между отдельными ключами, которые идентифицируют шардлеты, и базами данных, которые используются как сегменты.  **Сопоставление по списку** задается в явном виде (например, ключ 1 соответствует базе данных А), причем разные ключи могут быть сопоставлены с одной базой данных (например, оба ключа 3 и 6 сопоставляются базе данных Б).
<table>
   <tr>
    <td>Ключ</td>
     <td>Расположение сегмента</td>
   </tr>
   <tr>
    <td>1</td>
     <td>БазаДанных_А</td>
   </tr>
  <tr>
    <td>3</td>
     <td>БазаДанных_Б</td>
   </tr>
  <tr>
    <td>4</td>
     <td>БазаДанных_В</td>
   </tr>
  <tr>
    <td>6</td>
     <td>БазаДанных_Б</td>
   </tr>
  <tr>
    <td>...</td>
     <td>...</td>
   </tr>
</table> 

### Сопоставление сегментов по диапазону 
В **сопоставлении сегментов по диапазону** диапазон ключей определяется парой **[Low Value, High Value)**, где *Low Value* - это наименьший ключ диапазона, а *High Value* - это первое значение ключа, превышающее наибольшее значение диапазона. 

Например, диапазон **[0, 100)** охватывает все целые числа, которые больше или равны 0 и меньше 100. Обратите внимание, что несколько диапазонов могут указывать на одну базу данных. Кроме того, поддерживаются не пересекающиеся диапазоны (например, диапазоны [100,200) и [400,600) указывают на одну и ту же Базу_данных_В в примере ниже.)
<table>
   <tr>
    <td><b>Диапазон ключей</b></td>
     <td><b>Расположение сегмента</b></td>
   </tr>
   <tr>
    <td>[1, 50)</td>
     <td>БазаДанных_А</td>
   </tr>
  <tr>
    <td>[50, 100)</td>
     <td>БазаДанных_Б</td>
   </tr>
  <tr>
    <td>[100, 200)</td>
     <td>БазаДанных_В</td>
   </tr>
  <tr>
    <td>[400, 600)</td>
     <td>БазаДанных_В</td>
   </tr>
  <tr>
    <td>...</td>
     <td>...</td>
   </tr>
</table> 

Каждая из приведенных выше таблиц - это концептуальный пример объекта **ShardMap**.  Каждая строка - упрощенный пример отдельного объекта **PointMapping** (для сопоставления шардлетов и сегментов по списку) или **RangeMapping** (для сопоставления по диапазону).

## Диспетчер сопоставления сегментов 

Диспетчер сопоставления сегментов (Shard Map Manager) в составе API эластичного масштабирования представляет собой набор карт сегментов. Данные, управляемые объектом платформы .Net **ShardMapManager**, хранятся в трех местах. 

1. **Глобальное сопоставление сегментов(GSM)**. При создании **ShardMapManager** указывается база данных для хранения всех сопоставлений сегментов и прочих сопоставлений. Для управления этой информацией автоматически создаются специальные таблицы и хранимые процедуры. Обычно это небольшая и база данных с простым доступом, но её не рекомендуется использовать для других прикладных задач. Таблицы находятся в особой схеме **__ShardManagement**. 

2. **Локальное сопоставление сегментов(LSM)**. В каждую указанную вами в качестве сегмента базу данных будут добавлены несколько небольших таблиц и специальных хранимых процедур, которые содержат информацию о карте сопоставлении сегментов и управляет этой информацией. Эта информация повторяет информация, размещенную в GSM, но позволяет приложению проверять кэшированные данные карты сегментов без нагрузки на GSM; при помощи LSM приложение проверяет правильность кэшированного сопоставления. Таблицы, соответствующие LSM для каждого сегмента, расположены в схеме **__ShardManagement**.

3. **Кэш приложения**. Каждый экземпляр приложения, обращающийся к объекту **ShardMapManager**, сохраняет в локальной памяти копию этих сопоставлений. Хранятся использованные за последнее время сведения о маршрутизации. 

## Создание объекта ShardMapManager
Экземпляр объекта **ShardMapManager** создается в приложении с применением стандартного шаблона. Метод **ShardMapManagerFactory.GetSqlShardMapManager** принимает учетные данные(имя сервера и имя базы данных с GSM) в формате **ConnectionString** и возвращает экземпляр объекта **ShardMapManager**.  

Объект **ShardMapManager** следует объявлять в коде инициализации приложения и не более одного раза для каждого домена приложения. Объект **ShardMapManager** может содержать неограниченное число сопоставлений сегментов. Многим приложениям достаточно одной карты сегментов, но в некоторых случаях применяются разные наборы баз данных, которые используются в разных схемах или имеют уникальное назначение. В таком случае желательно использовать несколько карт сегментов. 

В следующем коде приложение пытается открыть существующий **ShardMapManager**.  Если объектов, представляющих глобальный **ShardMapManager** (GSM), еще нет в базе данных, то клиентская библиотека создаст их в этой базе данных.

    // Try to get a reference to the Shard Map Manager via the Shard Map Manager database.  
    // If it doesn't already exist, then create it. 
    ShardMapManager shardMapManager; 
    bool shardMapManagerExists = ShardMapManagerFactory.TryGetSqlShardMapManager(
                                        connectionString, 
                                        ShardMapManagerLoadPolicy.Lazy, 
                                        out shardMapManager); 

    if (shardMapManagerExists) 
     { 
        Console.WriteLine("Shard Map Manager already exists");
    } 
    else
    {
        // Create the Shard Map Manager. 
        ShardMapManagerFactory.CreateSqlShardMapManager(connectionString);
        Console.WriteLine("Created SqlShardMapManager"); 

        shardMapManager = ShardMapManagerFactory.GetSqlShardMapManager(
            connectionString, 
            ShardMapManagerLoadPolicy.Lazy);

        // The connectionString contains server name, database name, and admin credentials 
        // for privileges on both the GSM and the shards themselves.
    } 
 

### Учетные данные администратора карты сегментов

Как правило, приложения для администрирования и обработки карт сегментов отличаются от приложений, использующих карты сегментов для маршрутизации подключений. 

Для приложений администрирования сопоставления сегментов (добавление и изменение сегментов, сопоставлений сегментов, сопоставлений отдельных сегментов и т. д.)необходимо объявлять **ShardMapManager**, пользуясь **учетными данными с правами чтения и записи как для базы данных GSM, так и для базы данных, выступающей в роли сегмента**. Учетные данные должны давать право записи в таблицы в GSM и LSM при вводе или изменения информации карт сегментов, а также право создавать таблицы LSM в новых сегментах.  

### Изменяются только метаданные 

Для заполнения и изменения данных объекта **ShardMapManager** используются методы, не изменяющие пользовательские данные, хранящиеся в самих сегментах. Например, такие методы как **CreateShard**, **DeleteShard**, **UpdateMapping** и др. изменяют только метаданные сопоставления сегментов, но не удаляют, не добавляют и не изменяют пользовательские данные в этих сегментах. На самом деле, эти методы предназначены для использования с отдельными операциями, с помощью которых вы создаете и удаляете фактические базы данных, либо перемещаете строки между сегментами для выравнивания сегментированной среды.  (Служба **Split/Merge**, включенная в приложение эластичного масштабирования, применяет эти интерфейсы API наряду с оркестрацией перемещения данных между сегментами.) 

## Заполнение сопоставления сегментов. Пример 
Ниже приведен пример последовательности операций для заполнения конкретной карты сегментов. Этот код выполняет делает следующее: 

1. При помощи диспетчера сопоставления сегментов создается новое сопоставление сегментов. 
2. В сопоставление сегментов добавляются метаданные двух разных сегментов. 
3. Добавляется ряд сопоставлений диапазонов ключей, отображается все содержимое сопоставление сегментов. 

Код программы написан таким образом, что весь метод можно безопасно повторить при возникновении неизвестной ошибки: перед попыткой создания сегмента или сопоставления при каждом запросе проверяется наличие такого сегмента или сопоставления. Приведенный ниже код написан с тем допущением, что базы данных **sample_shard_0**, **sample_shard_1** и **sample_shard_2** уже существуют на сервере **shardServer**. 

    public void CreatePopulatedRangeMap(ShardMapManager smm, string mapName) 
        {            
            RangeShardMap<long> sm = null; 

            // check if shardmap exists and if not, create it 
            if (!smm.TryGetRangeShardMap(mapName, out sm)) 
            { 
                sm = smm.CreateRangeShardMap<long>(mapName); 
            } 

            Shard shard0 = null, shard1=null; 
            // check if shard exists and if not, 
            // create it (Idempotent / tolerant of re-execute) 
            if (!sm.TryGetShard(new ShardLocation(shardServer, "sample_shard_0"), out shard0)) 
            { 
                Shard0 = sm.CreateShard(new ShardLocation(shardServer, "sample_shard_0")); 
            } 

            if (!sm.TryGetShard(new ShardLocation(shardServer, "sample_shard_1"), out shard1)) 
            { 
                Shard1 = sm.CreateShard(new ShardLocation(shardServer, "sample_shard_1"));  
            } 

            RangeMapping<long> rmpg=null; 

            // Check if mapping exists and if not,
            // create it (Idempotent / tolerant of re-execute) 
            if (!sm.TryGetMappingForKey(0, out rmpg)) 
            { 
                sm.CreateRangeMapping(new RangeMappingCreationInfo<long> 
                    (new Range<long>(0, 50), shard0, MappingStatus.Online)); 
            } 

            if (!sm.TryGetMappingForKey(50, out rmpg)) 
            { 
                sm.CreateRangeMapping(new RangeMappingCreationInfo<long> 
                    (new Range<long>(50, 100), shard1, MappingStatus.Online)); 
            } 

            if (!sm.TryGetMappingForKey(100, out rmpg)) 
            { 
                sm.CreateRangeMapping(new RangeMappingCreationInfo<long> 
                    (new Range<long>(100, 150), shard0, MappingStatus.Online)); 
            } 

            if (!sm.TryGetMappingForKey(150, out rmpg)) 
            { 
                sm.CreateRangeMapping(new RangeMappingCreationInfo<long> 
                    (new Range<long>(150, 200), shard1, MappingStatus.Online)); 
            } 

            if (!sm.TryGetMappingForKey(200, out rmpg)) 
            { 
               sm.CreateRangeMapping(new RangeMappingCreationInfo<long> 
                   (new Range<long>(200, 300), shard0, MappingStatus.Online)); 
            } 

            // List the shards and mappings 
            foreach (Shard s in sm.GetShards()
                                    .OrderBy(s => s.Location.DataSource)
                                    .ThenBy(s => s.Location.Database))
            { 
               Console.WriteLine("shard: "+ s.Location); 
            } 

            foreach (RangeMapping<long> rm in sm.GetMappings()) 
            { 
                Console.WriteLine("range: [" + rm.Value.Low.ToString() + ":" 
                        + rm.Value.High.ToString()+ ")  ==>" +rm.Shard.Location); 
            } 
        } 
 
В качестве альтернативы для достижения такого же результата можно использовать скрипты PowerShell.     

После заполнения карт сегментов можно создавать приложения для доступа к данным, либо приспособить для работы с этими картами существующие приложения. Дальнейшего заполнения или обработки сопоставлений не требуется до момента внесения изменений в **структуру сопоставления**.  

## Маршрутизация, управляемая данными 

Основная польза диспетчера карт сегментов проявляется при работе приложений, которым требуются подключения к базам данных для выполнения особых действий. В сегментированном приложении эти подключения должны устанавливаться с правильной целевой базой данных. Это называется **маршрутизацией, зависящей от данных**.  Для таких приложений необходимо объявить объект диспетчера карт сегментов в фабричном режиме, пользуясь учетными данными с доступом к базе данных GSM только для чтения. Учетные данные для подключения к нужной базе данных сегмента впоследствии будут передаваться в отдельных запросах подключения.

Учитывайте, что эти приложения (использующие **ShardMapManager** с правом доступа только для чтения) не смогут внести изменения ни в сопоставления сегментов, ни в прочие сопоставления.  Для этого создайте специальные административные приложения или сценарии PowerShell, которые будут передавать учетные данные с более высокими правами доступа, как об этом говорилось ранее.   

Более подробная информация приводится в разделе [Маршрутизация, зависящая от данных](./sql-database-elastic-scale-data-dependent-routing.md). 

## Изменение карты сегментов 

Карту сегментов можно изменять различными способами. Любым из приведенных способов можно изменить метаданные сегментов и сопоставления сегментов, но нельзя изменить данные самих сегментов, создать или удалить базу данных.  Некоторые из описанных ниже операций над сопоставлениями сегментов необходимо выполнять согласованно с административными действиями для физического перемещения данных, добавления и удаления баз данных, выступающих в качестве сегментов.

Эти методы работают совместно, как строительные блоки, доступные для изменения общего распределения данных в среде сегментированной базы данных.  

* Чтобы добавлять и удалять сегменты, используйте **CreateShard** и **DeleteShard**. 
    
    Для успешного выполнения этих операций необходимо указать существующие сервер и базу данных, которая играет роль целевого сегмента. Эти методы не изменяют сами базы данных, они изменяют только метаданные в сопоставлении сегментов.

* Чтобы создать или удалить точки и диапазоны, которые указывают на сегменты, используйте **CreateRangeMapping**, **DeleteMapping**, **CreatePointMapping**. 
    
    Один сегмент может быть сопоставлен со множеством разных точек или диапазонов. Эти методы изменяют только метаданные, но не изменяют данные, хранящиеся в сегментах. Чтобы удалить данные из базы данных для согласованного выполнения операций **DeleteMapping**, понадобится запускать каждую операцию самостоятельно и делать это совместно с применением этих методов.  

* Чтобы разбить существующий диапазон на две части, объединить соседние диапазоны в один, используйте **SplitMapping** и **MergeMappings**.  

    Учтите, что операции разбиения и объединения **не изменяют привязку сегментов и ключей**. Функция разбиения разделяет существующий диапазон на две части, но оставляет их обе привязанными к одному сегменту. Функция объединения соединяет два соседних диапазона, привязанных к одному сегменту, в один целый диапазон.  Перемещение точек или диапазонов между сегментами при помощи метода **UpdateMapping** необходимо выполнять совместно с перемещением данных.  При необходимости перемещения данных, для координации изменений сопоставления сегментов и перемещения данных используйте службу **Split/Merge**, входящую в состав приложения эластичного масштабирования. 

* Повторное сопоставление (или перемещение) отдельных точек или диапазонов с другими сегментами: используйте **UpdateMapping**.  

    При необходимости перемещения данных между сегментами для обеспечения согласованности операций **UpdateMapping** необходимо выполнять перемещение данных отдельной операцией, но совместно с использованием этих методов.

* Чтобы сопоставлять данные в интерактивном и автономном режимах, используйте методы **MarkMappingOffline** и **MarkMappingOnline** для контроля интерактивного состояния сопоставления. 

    Некоторые операции с сопоставлениями сегментов, включая UpdateMapping и DeleteMapping, можно выполнять только тогда, когда сопоставления находятся в автономном режиме (offline). Если сопоставление находится в автономном режиме, то запрос данных с ключом, указывающим на это сопоставление, возвратит ошибку. Кроме того, при первом переходе диапазона в автономный режим все соединения с соответствующим сегментом автоматически разрываются с целью предотвращения сбоев и обрыва результатов запросов, направленных на изменяемые диапазоны. 

## Добавление сегмента 

Часто необходимо, чтобы приложение просто добавило в существующую карту сегментов новые сегменты для обработки данных, поступление которых ожидается из новых ключей и диапазонов ключей. Например, приложение с сегментированием по идентификатору клиента должно подготовить новый сегмент для нового клиента, или при обработке данных с сегментированием по месяцам требуется создание нового сегмента перед началом следующего месяца. 

Если новый диапазон ключей не входит в существующую карту и нет необходимости перемещения данных, добавление сегментов и привязка к нему нового ключа или диапазона становится довольно простой задачей. Подробнее см. в статье [Добавление нового сегмента](./sql-database-elastic-scale-add-a-shard.md).

Для сценариев, требующих перемещения данных, тем не менее, необходимо использовать службу разбиения/объединения для координации перемещения данных совместно с обновлением карты сегментов. Подробнее об этой службе см. в разделе [Обзор службы разбиения и объединения](./sql-database-elastic-scale-overview-split-and-merge.md) 

[AZURE.INCLUDE [elastic-scale-include](../includes/elastic-scale-include.md)]

<!--HONumber=47-->
