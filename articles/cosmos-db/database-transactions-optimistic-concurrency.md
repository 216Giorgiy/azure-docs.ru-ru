---
title: Транзакции базы данных и оптимистическая блокировка в Azure Cosmos DB
description: Эта статья содержит сведения о транзакциях базы данных и оптимистической блокировке в Azure Cosmos DB
author: markjbrown
ms.service: cosmos-db
ms.topic: conceptual
ms.date: 11/14/2018
ms.author: mjbrown
ms.reviewer: sngun
ms.openlocfilehash: cbd09f141128f9103af88b695baf717eaa3c99d5
ms.sourcegitcommit: 8330a262abaddaafd4acb04016b68486fba5835b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/04/2019
ms.locfileid: "54038842"
---
# <a name="database-transactions-and-optimistic-concurrency-control"></a>Транзакции базы данных и оптимистическая блокировка

Транзакции базы данных обеспечивают безопасную и предсказуемую модель программирования для работы с одновременными изменениями данных. В традиционных реляционных базах данных, таких как SQL Server, вы можете создавать бизнес-логику на основе хранимых процедур и (или) триггеров, которые отправляются на сервер для выполнения непосредственно в ядре СУБД. В традиционных реляционных базах данных вы вынуждены иметь дело с двумя языками программирования — обычный (нетранзакционный) язык приложений, например JavaScript, Python, C#, Java, и отдельный язык для транзакций (T-SQL), который поддерживается базой данных.

Ядро СУБД Azure Cosmos DB поддерживает транзакции с полной совместимостью с ACID (атомарность, согласованность, изоляция, устойчивость) и изоляцией моментального снимка. Все операции базы данных в области действия логических разделов контейнера выполняются транзакционно в ядре СУБД, которое размещено в реплике раздела. К ним относятся операции записи (обновление одного или нескольких элементов в логическом разделе) и операции чтения. В следующей таблице перечислены различные операции и типы транзакции:

| **Операция**  | **Тип операции** | **Транзакция для одного или нескольких элементов** |
|---------|---------|---------|
| INSERT (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| INSERT (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| REPLACE (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| REPLACE (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| UPSERT (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| UPSERT (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| DELETE (без предшествующего и последующего триггера) | запись | Транзакция для одного элемента |
| DELETE (с предшествующим или последующим триггером) | Запись и чтение | Транзакции для нескольких элементов |
| Выполнение хранимой процедуры | Запись и чтение | Транзакции для нескольких элементов |
| Выполнение процедуры слияния, инициируемое системой | запись | Транзакции для нескольких элементов |
| Удаление элементов, у которых истек срок жизни (TTL), инициируемое системой | запись | Транзакции для нескольких элементов |
| чтение | чтение | Транзакция для одного элемента |
| Канал изменений | чтение | Транзакции для нескольких элементов |
| Чтение с разбивкой на страницы | чтение | Транзакции для нескольких элементов |
| Запрос с разбивкой на страницы | чтение | Транзакции для нескольких элементов |
| Выполнение определяемой пользователем функции в составе запроса с разбивкой на страницы | чтение | Транзакции для нескольких элементов |

## <a name="multi-item-transactions"></a>Транзакции для нескольких элементов

Azure Cosmos DB позволяет создавать хранимые процедуры, предшествующие и последующие триггеры, определяемые пользователем функции и процедуры слияния на языке JavaScript. Ядро СУБД Azure Cosmos DB имеет встроенную поддержку выполнения JavaScript. Вы можете зарегистрировать в контейнере хранимые процедуры, предшествующие и последующие триггеры, определяемые пользователем функции и процедуры слияния, чтобы позднее выполнять их транзакционно в ядре СУБД Azure Cosmos. Создание логики приложения на JavaScript допускает естественное выражение потока управления, области видимости переменных, присвоения, а также интеграцию примитивов обработки исключений с транзакциями базы данных непосредственно на JavaScript.

Хранимые процедуры, триггеры, определяемые пользователем функции и процедуры слияния на JavaScript помещаются в контекстные транзакции ACID с изоляцией моментального снимка для всех элементов в логическом разделе. Если при выполнении такой транзакции код JavaScript создает исключение, то вся транзакция прерывается и откатывается к прежнему состоянию. Полученная модель программирования является простой, но эффективной. Разработчики JavaScript получают надежную модель программирования, сохраняя привычные языковые конструкции и библиотечные примитивы.

Возможность выполнить код JavaScript непосредственно в ядре СУБД повышает производительность операций над элементами контейнера в базе данных и обеспечивает поддержку транзакций. Кроме того, встроенная поддержка JSON и JavaScript в ядре СУБД Azure Cosmos устраняет несоответствия между системами типов в приложении и базе данных.

## <a name="optimistic-concurrency-control"></a>Оптимистичное управление параллелизмом 

Оптимистическая блокировка позволяет предотвратить потери операций обновления и удаления. Для конфликтующих одновременных операций применяется обычная пессимистическая блокировка ядра СУБД, размещенного в том же логическом разделе, что и обрабатываемый элемент. Когда две параллельные операции пытаются обновить элемент в логическом разделе до последней версии, одна из них "победит", а вторая завершится ошибкой. Но если одна или обе из таких операций ранее считали старое значение обновляемого элемента, база данных не может проверить актуальность считанных значений для любой из конфликтующих операций. К счастью, с этой ситуации помогает справиться оптимистическая блокировка, которая не позволит двум операциям одновременно выполнять транзакции в ядре СУБД. Оптимистическая блокировка защищает от случайной перезаписи данные, внесенные другими пользователями. Она также не позволит другим процессам случайно перезаписать ваши изменения.

Для одновременных обновлений элемента Azure Cosmos DB применяет оптимистическую блокировку на уровне протокола связи. База данных Azure Cosmos следит за тем, чтобы версия обновляемого (или удаляемого) элемента на стороне клиента точно совпадала с версией этого же элемента в контейнере Azure Cosmos. Это гарантирует защиту операций записи от случайного изменения чужими записями, и наоборот. В среде с несколькими пользователями оптимистическая блокировка не позволит вам случайно удалить или изменить элемент с неправильной версией. Это обеспечивает защиту от печально известных проблем "потерянного обновления" и "потерянного удаления".

Для каждого элемента в контейнере Azure Cosmos определено системное свойство `_etag`. Значение `_etag` создается и обновляется на сервере автоматически при каждом обновлении элемента. Вы можете включить `_etag` в заголовок if-match клиентского запроса, чтобы сервер контролировал возможность условного обновления элемента. Если значение заголовка if-match совпадает со значением `_etag` на сервере, элемент обновляется. Если значение в заголовке запроса if-match потеряло актуальность, сервер отклоняет операцию и выводит ответное сообщение "HTTP 412: необходимое условие не выполнено". Клиент в этом случае может повторно получить от сервера текущую версию элемента или переопределить сохраненную на сервере версию элемента своим значением `_etag` для этого элемента. Кроме того, `_etag` в сочетании с заголовком if-none-match позволяет определить, требуется ли повторное извлечение ресурса. 

Значение _etag изменяется для элемента при каждом его обновлении. В операциях замены элемента значение if-match следует явным образом включить в параметры запроса. Пример такого кода можно найти на [GitHub](https://github.com/Azure/azure-documentdb-dotnet/blob/master/samples/code-samples/DocumentManagement/Program.cs#L398-L446). Значения `_etag` неявно проверяются для всех записываемых элементов, которые затрагиваются в хранимой процедуре. При любом конфликте хранимая процедура выполнит откат транзакции и создаст исключение. Такой метод гарантирует, что операции записи хранимой процедуры применяются атомарным образом, то есть "все или ничего". Приложение получает сигнал о необходимости повторно применить обновления и повторить исходный запрос клиента.

## <a name="next-steps"></a>Дополнительная информация

Дополнительные сведения о транзакциях базы данных и оптимистической блокировке вы можете получить в следующих статьях.

- [Работа с базами данных, контейнерами и элементами Azure Cosmos](databases-containers-items.md)
- [Уровни согласованности](consistency-levels.md)
- [Типы конфликтов и политики их устранения](conflict-resolution-policies.md)
