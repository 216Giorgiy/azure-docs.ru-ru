---
title: Политики индексирования Azure Cosmos DB | Документация Майкрософт
description: Сведения об осуществлении индексации в Azure Cosmos DB. Узнайте, как настроить и изменить политику индексирования для автоматического индексирования и повышения производительности.
keywords: принцип работы индексирования, автоматическое индексирование, индексирование базы данных
services: cosmos-db
author: rafats
manager: kfile
ms.service: cosmos-db
ms.devlang: na
ms.topic: conceptual
ms.date: 03/26/2018
ms.author: rafats
ms.openlocfilehash: d867079b9a5546dc9555697a9066472e4e470977
ms.sourcegitcommit: 6f6d073930203ec977f5c283358a19a2f39872af
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/11/2018
ms.locfileid: "35298303"
---
# <a name="how-does-azure-cosmos-db-index-data"></a>Как работает индексирование данных в Azure Cosmos DB?

По умолчанию все данные Azure Cosmos DB индексируются. Хотя многие клиенты с удовольствием позволяют Azure Cosmos DB автоматически регулировать все параметры индексирования, Azure Cosmos DB также поддерживает задание пользовательской *политики индексирования* для коллекций во время создания. Политики индексирования Azure Cosmos DB обладают большей гибкостью и возможностями, чем дополнительные индексы, предлагаемые на других платформах баз данных. В Azure Cosmos DB можно разработать и настроить форму индекса без ущерба для гибкости схемы. 

Чтобы узнать, как в Azure Cosmos DB работает индексация, необходимо понять, почему, управляя политикой индексирования, можно найти точный компромисс между дополнительными затратами на хранение индекса, пропускной способностью записи и запросов и согласованностью запросов.  

В следующем видео руководитель программы Azure Cosmos DB Эндрю Лю (Andrew Liu) продемонстрирует возможности автоматического индексирования в Azure Cosmos DB и покажет, как настроить политику индексирования в контейнере Azure Cosmos DB. 

>[!VIDEO https://www.youtube.com/embed/uFu2D-GscG0]

В этой статье мы подробнее рассмотрим политики индексирования Azure Cosmos DB, настройку политики индексирования и связанные с ней компромиссы. 

Ознакомившись с данной статьей, вы сможете ответить на следующие вопросы.

* Как переопределить свойства, которые необходимо включить в индексацию или исключить из нее?
* Как настроить индекс для возможных обновлений?
* Как настроить индексацию для выполнения предложений ORDER BY или запросов в диапазоне?
* Как внести изменения в политику индексирования коллекции?
* Как сравнить затраты на хранение и производительность различных политик индексирования?

## Настройка политики индексирования коллекции <a id="CustomizingIndexingPolicy"></a>  
Вы можете настроить компромиссы между хранилищем, производительностью записи или запросов и согласованностью запросов, переопределяя политику индексирования по умолчанию для коллекции Azure Cosmos DB. Можно настроить следующие аспекты:

* **Включение или исключение документов и путей к индексу и из него**. Можно включить конкретные документы в индекс или извлечь их из него во время вставки или замены документов в коллекции. Также можно включить или исключить определенные свойства JSON, также называемые *путями*, для индексации в документах, включенных в индекс. Пути включают шаблоны с подстановочными знаками.
* **Настройка различных типов индекса**. Для каждого включенного пути можно указать тип индекса, который требуется пути для коллекции. Можно указать тип индекса на основе данных пути, ожидаемой рабочей нагрузки запроса и числовой или строковой точности.
* **Настройка режимов обновления индекса**. Azure Cosmos DB поддерживает три режима индексирования: Consistent, Lazy и None. Режимы индексирования можно настроить с помощью политики индексирования в коллекции Azure Cosmos DB. 

В следующем фрагменте кода Microsoft .NET показано, как задать пользовательскую политику индексирования во время создания коллекции. Здесь мы с максимальной точностью задаем политику с индексом диапазона для строк и чисел. Эта политика позволяет выполнять запросы ORDER BY к строкам.

    DocumentCollection collection = new DocumentCollection { Id = "myCollection" };

    collection.IndexingPolicy = new IndexingPolicy(new RangeIndex(DataType.String) { Precision = -1 });
    collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;

    await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("db"), collection);   


> [!NOTE]
> С выпуском REST API версии 2015-06-03 схема JSON для политики индексирования изменилась. Теперь она поддерживает диапазонные индексы для строковых значений. Новую схему политики поддерживают пакет .NET SDK 1.2.0 и Java, Python и пакеты Node.js SDK 1.1.0. В более ранних версиях пакета SDK используется REST API версии 2015-04-08. Эти версии поддерживают более раннюю схему политики индексирования.
> 
> По умолчанию Azure Cosmos DB согласованно индексирует все свойства строк в документах с помощью хэш-индекса, а числовые свойства — с помощью диапазонного индекса.  
> 
> 

### <a name="customize-the-indexing-policy-in-the-portal"></a>Настройка политики индексирования на портале

На портале Azure можно изменить политику индексирования коллекции. 

1. На портале перейдите в учетную запись Azure Cosmos DB, а затем выберите свою коллекцию. 
2. В левом меню навигации выберите **Параметры**, а затем — **Политика индексации**. 
3. В **политике индексации** измените политику, а затем нажмите кнопку **ОК**. 

### Режимы индексирования базы данных <a id="indexing-modes"></a>  
Azure Cosmos DB поддерживает три режима индексирования, которые можно настроить с помощью политики индексирования для коллекции Azure Cosmos DB — согласованный, асинхронный и невидимый.

**Consistent** (Согласованный). Если для коллекции Azure Cosmos DB указана политика Consistent, запросы к данной коллекции Azure Cosmos DB соответствуют уровню согласованности, указанному для точечных операций чтения (т. е. строгий, ограниченный с запаздыванием, сеанса и окончательный). Индекс обновляется синхронно при обновлении документа (т. е. при вставке, замене, обновлении и удалении документа в коллекции Azure Cosmos DB).

Согласованное индексирование поддерживает согласованность запросов за счет возможного сокращения пропускной способности записи. Это сокращение является функцией уникальных путей, которые должны быть проиндексированы, и "уровня согласованности". Режим согласованного индексирования предназначен для рабочих нагрузок типа "быстрая запись, немедленный запрос".

**Lazy** (Асинхронное индексирование). Индекс обновляется асинхронно, когда коллекция Azure Cosmos DB не загружена, т. е. когда пропускная способность коллекции не используется полностью для обслуживания запросов пользователя.  Обратите внимание, что результаты могут быть противоречивыми, так как данные медленно принимаются и индексируются. Это означает, что результаты запросов COUNT или результаты других запросов могут быть несогласованными или отличаться в зависимости от времени их получения. 

Во время получения данных индекс обычно находится в режиме наверстывания. В асинхронном индексировании изменения срока жизни (TTL) приводят к удалению индекса и его последующему повторному созданию. Этим объясняется несогласованность запроса COUNT и результатов в течение некоторого периода времени. В большинстве учетных записей Azure Cosmos DB нужно использовать согласованный режим индексирования.

**None** (Нет). У коллекции с режимом индексирования None нет связанного индекса. Обычно это применимо для тех случаев, когда Azure Cosmos DB используется как хранилище пары "ключ — значение", а доступ к документам осуществляется только по свойству их идентификатора. 

> [!NOTE]
> Настройка политики индексирования с режимом индексирования None имеет побочный эффект — удаляется любой имеющийся индекс. Используйте этот режим, если шаблонам доступа требуется только идентификатор или ссылка self-link.
> 
> 

В следующей таблице показана согласованность запросов на основе режима индексирования (Consistent и Lazy), настроенного для коллекции, и уровня согласованности, указанного для запроса. Это относится к запросам, выполняемым с помощью любого интерфейса — REST API, пакетов SDK или из хранимых процедур и триггеров. 

|Целостность|Режим индексирования: согласованный|Режим индексирования: асинхронный|
|---|---|---|
|Уровень согласованности Strong (сильная)|Уровень согласованности Strong (сильная)|Уровень согласованности Eventual (в конечном счете)|
|Ограниченная с запаздыванием|Ограниченная с запаздыванием|Уровень согласованности Eventual (в конечном счете)|
|Сеанс|Сеанс|Уровень согласованности Eventual (в конечном счете)|
|Уровень согласованности Eventual (в конечном счете)|Уровень согласованности Eventual (в конечном счете)|Уровень согласованности Eventual (в конечном счете)|

Azure Cosmos DB возвращает ошибку для запросов к коллекциям, для которых задан режим индексирования None. Запросы можно выполнять как сканирования с помощью явного заголовка **x-ms-documentdb-enable-scans** в REST API или параметра запроса **EnableScanInQuery** с помощью пакета SDK для .NET. Некоторые функции запроса, например ORDER BY, не поддерживаются как сканирования с помощью параметра **EnableScanInQuery**.

В следующей таблице показана согласованность запросов на основе режима индексирования (Consistent, Lazy или None), если указан параметр **EnableScanInQuery**.

|Целостность|Режим индексирования: согласованный|Режим индексирования: асинхронный|Режим индексирования: нет|
|---|---|---|---|
|Уровень согласованности Strong (сильная)|Уровень согласованности Strong (сильная)|Уровень согласованности Eventual (в конечном счете)|Уровень согласованности Strong (сильная)|
|Ограниченная с запаздыванием|Ограниченная с запаздыванием|Уровень согласованности Eventual (в конечном счете)|Ограниченная с запаздыванием|
|Сеанс|Сеанс|Уровень согласованности Eventual (в конечном счете)|Сеанс|
|Уровень согласованности Eventual (в конечном счете)|Уровень согласованности Eventual (в конечном счете)|Уровень согласованности Eventual (в конечном счете)|Уровень согласованности Eventual (в конечном счете)|

В следующем примере кода показано, как создать коллекцию Azure Cosmos DB с помощью пакета SDK для .NET с согласованным индексированием всех операций вставки документа.

     // Default collection creates a Hash index for all string fields and a Range index for all numeric    
     // fields. Hash indexes are compact and offer efficient performance for equality queries.

     var collection = new DocumentCollection { Id ="defaultCollection" };

     collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;

     collection = await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("mydb"), collection);


### <a name="index-paths"></a>Пути индекса
Azure Cosmos DB представляет документы JSON и индексы в виде деревьев и позволяет настраивать политики для путей в дереве. В документах можно выбрать пути для включения в политику индексирования или исключения из нее. Такой подход может обеспечить повышение производительности при записи и понижение требований к хранилищу индекса в сценариях, когда шаблоны запросов известны заранее.

Пути индекса начинаются с корня (/) и, как правило, заканчиваются оператором подстановочного знака (?), обозначающего, что есть несколько возможных значений префикса. Например, чтобы обслуживать запрос SELECT * FROM Families F WHERE F.familyName = "Andersen", вам нужно включить путь индекса для /familyName/? в политику индекса коллекции.

В путях индекса можно также использовать оператор подстановочного знака \* для задания алгоритма пути рекурсивно по префиксу. Например, /payload/* можно использовать для исключения из индексации всего, что находится по свойству payload.

Вот распространенные шаблоны задания путей индекса:

| Путь                | Описание/вариант использования                                                                                                                                                                                                                                                                                         |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| /                   | Путь коллекции по умолчанию. Является рекурсивным и применяется ко всему дереву документа.                                                                                                                                                                                                                                   |
| /prop/?             | Путь индекса, необходимый для обслуживания следующих запросов (с типами хэш, диапазон, соответственно):<br><br>SELECT FROM collection c WHERE c.prop = "value"<br><br>SELECT FROM collection c WHERE c.prop > 5<br><br>SELECT FROM collection c ORDER BY c.prop                                                                       |
| /prop/*             | Путь индекса для всех путей по заданной метке. Работает со следующими запросами<br><br>SELECT FROM collection c WHERE c.prop = "value"<br><br>SELECT FROM collection c WHERE c.prop.subprop > 5<br><br>SELECT FROM collection c WHERE c.prop.subprop.nextprop = "value"<br><br>SELECT FROM collection c ORDER BY c.prop         |
| /props/[]/?         | Путь индекса, необходимый для обслуживания запросов с итерацией и соединения, отправляемых в массивы скалярных выражений, например, ["a", "b", "c"]:<br><br>SELECT tag FROM tag IN collection.props WHERE tag = "value"<br><br>SELECT tag FROM collection c JOIN tag IN c.props WHERE tag > 5                                                                         |
| /props/[]/subprop/? | Путь индекса, необходимый для обслуживания запросов с итерацией и соединения, отправляемых в массивы объектов, например, [{subprop: "a"}, {subprop: "b"}]:<br><br>SELECT tag FROM tag IN collection.props WHERE tag.subprop = "value"<br><br>SELECT tag FROM collection c JOIN tag IN c.props WHERE tag.subprop = "value"                                  |
| /prop/subprop/?     | Путь индекса, необходимый для обслуживания запросов (с типами хэш, диапазон, соответственно):<br><br>SELECT FROM collection c WHERE c.prop.subprop = "value"<br><br>SELECT FROM collection c WHERE c.prop.subprop > 5                                                                                                                    |

> [!NOTE]
> При задании путей пользовательского индекса необходимо выбрать правило индексации по умолчанию для всего дерева документа, указав специальный путь "/*". 
> 
> 

В следующем примере показана настройка конкретного пути с диапазонной индексацией и пользовательским значением точности в 20 байт:

    var collection = new DocumentCollection { Id = "rangeSinglePathCollection" };    

    collection.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/Title/?", 
            Indexes = new Collection<Index> { 
                new RangeIndex(DataType.String) { Precision = 20 } } 
            });

    // Default for everything else
    collection.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/*" ,
            Indexes = new Collection<Index> {
                new HashIndex(DataType.String) { Precision = 3 }, 
                new RangeIndex(DataType.Number) { Precision = -1 } 
            }
        });

    collection = await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("db"), pathRange);


### <a name="index-data-types-kinds-and-precisions"></a>Типы данных, виды и степени точности индекса
Есть несколько способов настройки политики индексирования для пути. Можно указать одно или несколько определений индексирования для каждого пути.

* **Тип данных**: String, Number, Point, Polygon или LineString (может содержать только одну запись для каждого типа данных и пути).
* **Вид индекса**: хэш-индекс (запросы равенства), диапазонный индекс (запросы равенства, диапазона или ORDER BY) или пространственный индекс (пространственные запросы).
* **Точность**: в хэш-индексе это значение для строк и чисел находится в диапазоне от 1 до 8. По умолчанию используется значение 3. Для диапазонного индекса это значение может быть равно -1 (максимальная точность). Для строковых или числовых значений оно может находиться в диапазоне от 1 до 100 (максимальная точность).

#### <a name="index-kind"></a>Вид индекса
Azure Cosmos DB поддерживает хэш-индексы и диапазонные индексы для каждого пути, который можно настроить для типов данных String или Number или для двух типов данных.

* **Хэш-индекс** поддерживает эффективные запросы равенства и запросы JOIN. Для большинства случаев использования хэш-индексов не требуется более высокая точность, чем разрядность по умолчанию, т. е. 3 байта. Тип данных может иметь значение String или Number.
* **Диапазонный индекс** поддерживает эффективные запросы равенства и диапазона (с использованием >, <, >=, <=, !=) и запросы ORDER BY. Запросы ORDER BY по умолчанию также требуют максимальной точности индекса (-1). Тип данных может иметь значение String или Number.

Azure Cosmos DB также поддерживает вид пространственного индекса для каждого пути, который может быть указан для типов данных Point, Polygon и LineString. Значение по указанному пути должно быть действительным фрагментом объекта GeoJSON, например `{"type": "Point", "coordinates": [0.0, 10.0]}`.

* **Пространственный** индекс обеспечивает эффективность выполнения пространственных запросов (запросов нахождения в пределах и расстояния). Тип данных может иметь значение Point, Polygon или LineString.

> [!NOTE]
> Azure Cosmos DB поддерживает автоматическое индексирование типов данных Point, Polygon и LineString.
> 
> 

Ниже приведены виды поддерживаемых индексов и примеры запросов, для обслуживания которых их можно использовать:

| Вид индекса | Описание/вариант использования                                                                                                                                                                                                                                                                                                                                                                                                              |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Хэш       | Хэш-индекс по over/prop/? (или /) позволяет эффективно обрабатывать следующие запросы:<br><br>SELECT FROM collection c WHERE c.prop = "value"<br><br>Хэш-индекс по over /props/[]/? (или / или /props/) позволяет эффективно обрабатывать следующие запросы:<br><br>SELECT tag FROM collection c JOIN tag IN c.props WHERE tag = 5                                                                                                                       |
| Диапазонный индекс      | Диапазонный индекс по /prop/? (или /) позволяет эффективно обрабатывать следующие запросы:<br><br>SELECT FROM collection c WHERE c.prop = "value"<br><br>SELECT FROM collection c WHERE c.prop > 5<br><br>SELECT FROM collection c ORDER BY c.prop                                                                                                                                                                                                              |
| пространственный индекс     | Диапазонный индекс по /prop/? (или /) позволяет эффективно обрабатывать следующие запросы:<br><br>SELECT FROM collection c<br><br>WHERE ST_DISTANCE(c.prop, {"type": "Point", "coordinates": [0.0, 10.0]}) < 40<br><br>SELECT FROM collection c WHERE ST_WITHIN(c.prop, {"type": "Polygon", ... }) --с индексированием точек<br><br>SELECT FROM collection c WHERE ST_WITHIN({"type": "Point", ... }, c.prop) --с индексированием многоугольников              |

По умолчанию возвращается сообщение об ошибке для запросов с операторами диапазона, например > =, если отсутствует диапазонный индекс (любой точности), чтобы указать, что для обслуживания запроса может потребоваться проверка. Запросы диапазона можно выполнять без диапазонного индекса с помощью заголовка **x-ms-documentdb-enable-scans** в REST API или параметра запроса **EnableScanInQuery** с помощью пакета SDK для .NET. Если в запросе есть какие-либо другие фильтры, по которым Azure Cosmos DB может отфильтровать индекс, сообщение об ошибке не появится.

Те же правила применяются для пространственных запросов. По умолчанию ошибка возвращается для пространственных запросов в случае отсутствия пространственного индекса и отсутствия фильтров, которые могут быть получены из индекса. Они могут выполняться как сканирование с помощью заголовка **x-ms-documentdb-enable-scan** или параметра запроса **EnableScanInQuery**.

#### <a name="index-precision"></a>Точность индекса
Можно использовать точность индекса для обеспечения компромисса между дополнительными затратами на хранение индекса и производительностью запросов. Для чисел рекомендуется использовать конфигурацию точности по умолчанию (-1, максимальная точность). Так как числа включают 8 байт в JSON, это эквивалентно 8-байтовой конфигурации. Выбор меньшего значения точности, например 1–7, означает, что значения в некоторых диапазонах соответствуют той же записи индекса. Таким образом, можно уменьшить место хранения индекса, но при выполнении запроса может возникнуть необходимость обработки большего количества документов, в результате чего потребуется более высокая пропускная способность, т. е. больше единиц запроса.

Конфигурацию точности индекса практичнее использовать с диапазонами строки. Так как строки могут быть любой длины, выбор точности индекса может повлиять на производительность запросов диапазона строки и на объем требуемого для индекса хранилища. Для индексов диапазона строки можно настроить значения 100–1 или -1 (максимум). Если вы хотите выполнить запросы ORDER BY к строковым свойствам, необходимо указать точность -1 для соответствующих путей.

Пространственные индексы всегда используют точность индекса по умолчанию для всех типов данных (Point, LineString и Polygon), и переопределить ее нельзя. 

В следующем примере показано, как повысить точность для диапазонных индексов в коллекции с помощью пакета SDK для .NET. 

**Создание коллекции с пользовательской точностью индекса**

    var rangeDefault = new DocumentCollection { Id = "rangeCollection" };

    // Override the default policy for strings to Range indexing and "max" (-1) precision
    rangeDefault.IndexingPolicy = new IndexingPolicy(new RangeIndex(DataType.String) { Precision = -1 });

    await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("db"), rangeDefault);   


> [!NOTE]
> Azure Cosmos DB возвращает ошибку, если запрос использует предложение ORDER BY, но не имеет диапазонного индекса для запрашиваемого пути с максимальной точностью. 
> 
> 

Аналогичным образом можно полностью исключить пути из индексирования. В следующем примере показано, как с помощью оператора подстановочного знака \* исключить из индексации целый раздел документов (*поддерево*).

    var excluded = new DocumentCollection { Id = "excludedPathCollection" };
    excluded.IndexingPolicy.IncludedPaths.Add(new IncludedPath { Path = "/*" });
    excluded.IndexingPolicy.ExcludedPaths.Add(new ExcludedPath { Path = "/nonIndexedContent/*" });

    await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("db"), excluded);



## <a name="opt-in-and-opt-out-of-indexing"></a>Индексирование: включение и отключение
Вы можете выбрать, хотите ли вы, чтобы коллекция автоматически индексировала все документы. По умолчанию все документы автоматически индексируются, но вы можете отключить эту функцию. При выключенном индексировании документы могут быть доступны только через собственные ссылки или запросы, использующие идентификатор документа.

При выключенном автоматическом индексировании вы все равно можете выборочно добавлять в индекс только некоторые документы. И наоборот, вы можете оставить включенным автоматическое индексирование и выборочно указать, какие документы необходимо исключить. Настройка включения или выключения индексирования полезна, когда у вас есть только подмножество документов, к которым требуется выполнить запрос.

Так, в следующем примере показано, как добавить документ явным образом с помощью [пакета SDK для .NET для API SQL](https://docs.microsoft.com/azure/cosmos-db/sql-api-sdk-dotnet) и свойство [RequestOptions.IndexingDirective](http://msdn.microsoft.com/library/microsoft.azure.documents.client.requestoptions.indexingdirective.aspx).

    // If you want to override the default collection behavior to either
    // exclude (or include) a document in indexing,
    // use the RequestOptions.IndexingDirective property.
    client.CreateDocumentAsync(UriFactory.CreateDocumentCollectionUri("db", "coll"),
        new { id = "AndersenFamily", isRegistered = true },
        new RequestOptions { IndexingDirective = IndexingDirective.Include });

## <a name="modify-the-indexing-policy-of-a-collection"></a>Изменение политики индексирования коллекции
Azure Cosmos DB позволяет внести изменения в политику индексирования коллекции в режиме реального времени. Изменение в политике индексирования в коллекции Azure Cosmos DB может привести к изменению в формы индекса. Это изменение затрагивает индексируемые пути, их точность, а также модель согласованности самого индекса. Изменение политики индексирования фактически требует преобразования старого индекса в новый. 

**Преобразование индексов в сети**

![Как работает индексирование — преобразование индексов Azure Cosmos DB в сети](./media/indexing-policies/index-transformations.png)

Преобразования индексов выполняются в сети. Это означает, что документы, индексированные по старой политике, эффективно преобразуются согласно новой политике *без ущерба доступности для записи или подготовленной пропускной способности* коллекции. Согласованность операций чтения и записи, выполняемых с помощью REST API, пакетов SDK или изнутри хранимых процедур и триггеров, не затрагивается во время преобразования индекса. При изменении политики индексирования производительность не падает и отсутствует простой приложений.

Тем не менее, во время преобразования индекса запросы являются в конечном счете согласованными вне зависимости от конфигурации режима индексирования (Consistent или Lazy). Это также относится к запросам из всех интерфейсов: REST API, пакетов SDK и из хранимых процедур и триггеров. Как и индексирование в асинхронном режиме, преобразование индекса выполняется асинхронно в фоновом режиме в репликах с помощью запасных ресурсов, доступных для заданной реплики. 

Преобразования индексов также выполняются на месте. Azure Cosmos DB не хранит две копии индекса и не заменяет старый индекс новым. Это означает, что при выполнении преобразования индекса не требуется использовать дополнительное место на диске или в коллекции.

При изменении политики индексирования то, как применяются изменения для перехода от старого индекса к новому, больше зависит от конфигураций режима индексирования, чем от других значений, таких как включенные или исключенные пути, типы индекса и точность. 

Если в старой и новой политиках используется согласованное индексирование, то Azure Cosmos DB выполняет преобразование индекса в сети. Во время выполнения преобразования нельзя применить другое изменение политики индексирования с согласованным режимом индексирования. Однако во время преобразования можно перейти в режим индексирования Lazy или None. 

* При переходе в режим Lazy изменение политики индексирования вступает в силу немедленно, и Azure Cosmos DB начинает асинхронно повторно создавать индекс. 
* При переходе в невидимый режим индексирования индекс немедленно удаляется. Переход в режим индексирования None удобен, если необходимо отменить выполняемое преобразование и начать "с нуля" с другой политикой индексирования. 

В фрагменте кода ниже показано, как изменить режим политики индексирования коллекции с Consistent на Lazy. При использовании пакета SDK для .NET можно запустить изменение политики индексирования с помощью нового метода **ReplaceDocumentCollectionAsync**.

**Изменение режима политики индексирования с Consistent на Lazy**

    // Switch to Lazy indexing mode.
    Console.WriteLine("Changing from Default to Lazy IndexingMode.");

    collection.IndexingPolicy.IndexingMode = IndexingMode.Lazy;

    await client.ReplaceDocumentCollectionAsync(collection);

**Отслеживание хода выполнения преобразования индекса**

Можно отслеживать ход выполнения преобразования индекса в процентах с помощью свойства ответа **IndexTransformationProgress** из вызова **ReadDocumentCollectionAsync**. Другие пакеты SDK и REST API поддерживают эквивалентные свойства и методы для изменения политики индексирования. Можно проверить ход выполнения преобразования индекса в индекс Consistent, вызвав метод **ReadDocumentCollectionAsync**: 

    long smallWaitTimeMilliseconds = 1000;
    long progress = 0;

    while (progress < 100)
    {
        ResourceResponse<DocumentCollection> collectionReadResponse = await client.ReadDocumentCollectionAsync(
            UriFactory.CreateDocumentCollectionUri("db", "coll"));

        progress = collectionReadResponse.IndexTransformationProgress;

        await Task.Delay(TimeSpan.FromMilliseconds(smallWaitTimeMilliseconds));
    }

> [!NOTE]
> * Свойство **IndexTransformationProgress** применимо только при преобразовании в индекс Consistent. Используйте свойство **ResourceResponse.LazyIndexingProgress** для отслеживания преобразований в индекс Lazy.
> * Свойства **IndexTransformationProgress** и **LazyIndexingProgress** заполняются только для несекционированной коллекции, которая представляет собой коллекцию, созданную без ключа секции.
>

Можно удалить индекс для коллекции, перейдя в режим индексирования None. Это может быть удобным рабочим инструментом, если требуется отменить выполняющееся преобразование и немедленно начать новое.

**Удаление индекса для коллекции**

    // Switch to Lazy indexing mode.
    Console.WriteLine("Dropping index by changing to to the None IndexingMode.");

    collection.IndexingPolicy.IndexingMode = IndexingMode.None;

    await client.ReplaceDocumentCollectionAsync(collection);

Когда вы вносите изменения в политики индексирования для своих коллекций Azure Cosmos DB? Ниже перечислены наиболее распространенные случаи использования:

* при обеспечении согласованных результатов во время обычной работы, но возвращении к режиму индексирования Lazy при массовом импорте данных.
* Вы начинаете использовать новые функции индексирования для своих текущих коллекций Azure Cosmos DB, например геопространственных запросов, для которых необходим пространственный индекс, для запросов ORDER BY и запросов диапазона строки, для которых необходим индекс диапазона строки.
* Вручную выбираете свойства для индексирования и со временем меняете их.
* Настраиваете точность индексирования для повышения производительности запросов или уменьшения объема используемого хранилища.

> [!NOTE]
> Для изменения политики индексирования с помощью метода **ReplaceDocumentCollectionAsync** требуется версия пакета SDK для .NET не ниже 1.3.0.
> 
> Чтобы успешно завершить преобразование индекса, в коллекции должно быть достаточно свободного места. Если коллекция достигает своей квоты хранилища, преобразование индекса будет приостановлено. Преобразование индекса автоматически возобновится при появлении доступного места, например, если вы удалите некоторые документы.
> 
> 

## <a name="performance-tuning"></a>Настройка производительности
API SQL предоставляют сведения о метриках производительности, таких как используемое хранилище индекса и стоимость пропускной способности (единицы запроса) для каждой операции. Эту информацию можно использовать для сравнения различных политик индексирования и настройки производительности.

Чтобы оценить квоты хранения и использования коллекции, запустите запрос **HEAD** или **GET** для ресурсов коллекции и выберите заголовки запросов **x-ms-request-quota** и **x-ms-request-usage**. В пакете SDK для .NET свойства [DocumentSizeQuota](http://msdn.microsoft.com/library/dn850325.aspx) и [DocumentSizeUsage](http://msdn.microsoft.com/library/azure/dn850324.aspx) на вкладке [ResourceResponse<T\>](http://msdn.microsoft.com/library/dn799209.aspx) содержат соответствующие значения.

     // Measure the document size usage (which includes the index size) against   
     // different policies.
     ResourceResponse<DocumentCollection> collectionInfo = await client.ReadDocumentCollectionAsync(UriFactory.CreateDocumentCollectionUri("db", "coll"));  
     Console.WriteLine("Document size quota: {0}, usage: {1}", collectionInfo.DocumentQuota, collectionInfo.DocumentUsage);


Для оценки расходов на индексирование в каждой операции записи (создание, обновление или удаление) выберите заголовок **x-ms-request-charge** (или эквивалентное свойство [RequestCharge](http://msdn.microsoft.com/library/dn799099.aspx) на вкладке [ResourceResponse<T\>](http://msdn.microsoft.com/library/dn799209.aspx) в пакете SDK для .NET), чтобы измерить число единиц запроса, используемых такими операциями.

     // Measure the performance (request units) of writes.     
     ResourceResponse<Document> response = await client.CreateDocumentAsync(UriFactory.CreateDocumentCollectionUri("db", "coll"), myDocument);              
     Console.WriteLine("Insert of document consumed {0} request units", response.RequestCharge);

     // Measure the performance (request units) of queries.    
     IDocumentQuery<dynamic> queryable =  client.CreateDocumentQuery(UriFactory.CreateDocumentCollectionUri("db", "coll"), queryString).AsDocumentQuery();

     double totalRequestCharge = 0;
     while (queryable.HasMoreResults)
     {
        FeedResponse<dynamic> queryResponse = await queryable.ExecuteNextAsync<dynamic>(); 
        Console.WriteLine("Query batch consumed {0} request units",queryResponse.RequestCharge);
        totalRequestCharge += queryResponse.RequestCharge;
     }

     Console.WriteLine("Query consumed {0} request units in total", totalRequestCharge);

## <a name="changes-to-the-indexing-policy-specification"></a>Изменения в спецификации политики индексации
Изменение в схеме для политики индексации было представлено 7 июля 2015 года с помощью интерфейса REST API версии 2015-06-03. Представленные классы в версиях пакетов SDK имеют новые реализации, соответствующие схеме. 

В спецификации JSON были реализованы следующие изменения:

* Политика индексации поддерживает диапазонные индексы для строк.
* Каждый путь может иметь несколько определений индекса, по одному для каждого типа данных.
* Поддерживаемая точность индексации: 1–8 для чисел, 1–100 для строк и -1 (максимальная точность).
* Двойные кавычки в сегментах путей для экранирования каждого пути не требуются. Например, вы можете добавить путь для **/title/?** вместо **/"title"/?**.
* Корневой путь, представляющий "все пути", можно указать в виде **/\*** (в дополнение к **/**).

Если у вас имеется код, который подготавливает коллекции с пользовательской политикой индексации, написанный с помощью пакета SDK .NET версии 1.1.0 или более ранней, необходимо изменить код приложения, чтобы обработать эти изменения с целью переноса в пакет SDK версии 1.2.0. Если у вас нет кода, который настраивает политику индексации, или если вы планируете продолжить использование старой версии пакета SDK, изменения не требуются.

Для практического сравнения ниже приведен пример пользовательской политики индексирования, написанный с помощью REST API версии 2015-06-03 и предыдущей версии 2015-04-08.

**Текущая политика индексации JSON (REST API версии 2015-06-03)**

    {
       "automatic":true,
       "indexingMode":"Consistent",
       "includedPaths":[
          {
             "path":"/*",
             "indexes":[
                {
                   "kind":"Hash",
                   "dataType":"String",
                   "precision":3
                },
                {
                   "kind":"Hash",
                   "dataType":"Number",
                   "precision":7
                }
             ]
          }
       ],
       "ExcludedPaths":[
          {
             "path":"/nonIndexedContent/*"
          }
       ]
    }


**Текущая политика индексации JSON (REST API версии 2015-04-08)**

    {
       "automatic":true,
       "indexingMode":"Consistent",
       "IncludedPaths":[
          {
             "IndexType":"Hash",
             "Path":"/",
             "NumericPrecision":7,
             "StringPrecision":3
          }
       ],
       "ExcludedPaths":[
          "/\"nonIndexedContent\"/*"
       ]
    }


## <a name="next-steps"></a>Дополнительная информация
Используйте ссылки ниже для примеров управления политиками индексации и получения дополнительных сведений о языке запросов Azure Cosmos DB.

* [Примеры кода управления индексами для API SQL для .NET](https://github.com/Azure/azure-documentdb-net/blob/master/samples/code-samples/IndexManagement/Program.cs)
* [Операции с коллекциями для API REST для SQL](https://msdn.microsoft.com/library/azure/dn782195.aspx)
* [SQL-запросы для API DocumentDB в Azure Cosmos DB](sql-api-sql-query.md)

