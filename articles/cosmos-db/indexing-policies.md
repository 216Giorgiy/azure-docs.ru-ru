---
title: "Политики индексирования Azure Cosmos DB | Документация Майкрософт"
description: "Сведения об осуществлении индексации в Azure Cosmos DB. Узнайте, как настроить и изменить политику индексирования для автоматического индексирования и повышения производительности."
keywords: "принцип работы индексирования, автоматическое индексирование, индексирование базы данных"
services: cosmos-db
documentationcenter: 
author: arramac
manager: jhubbard
editor: monicar
ms.assetid: d5e8f338-605d-4dff-8a61-7505d5fc46d7
ms.service: cosmos-db
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: data-services
ms.date: 05/22/2017
ms.author: arramac
ms.translationtype: HT
ms.sourcegitcommit: 141270c353d3fe7341dfad890162ed74495d48ac
ms.openlocfilehash: 2d840f1c70e9668ae0a8b76cd9623258c2563d98
ms.contentlocale: ru-ru
ms.lasthandoff: 07/25/2017

---
# <a name="how-does-azure-cosmos-db-index-data"></a>Как работает индексирование данных в Azure Cosmos DB?

По умолчанию все данные Azure Cosmos DB индексируются. Хотя многие клиенты с удовольствием позволяют Azure Cosmos DB автоматически регулировать все параметры индексирования, Azure Cosmos DB также поддерживает задание пользовательской **политики индексирования** для коллекций во время создания. Политики индексирования Azure Cosmos DB обладают большей гибкостью и возможностями, чем дополнительные индексы, предлагаемые на других платформах баз данных, так как они позволяют разрабатывать и настраивать формы индекса без ущерба для гибкости схемы. Чтобы узнать, как индексация работает в Azure Cosmos DB, необходимо понять, почему, управляя политикой индексирования, можно найти точный компромисс между дополнительными затратами на хранение индекса, пропускной способностью записи и запросов и согласованностью запросов.  

В этой статье мы подробнее рассмотрим политики индексирования Azure Cosmos DB, настройку политики индексирования и связанные с ней компромиссы. 

Ознакомившись с данной статьей, вы сможете ответить на следующие вопросы.

* Как переопределить свойства, которые необходимо включить в индексацию или исключить из нее?
* Как настроить индекс для возможных обновлений?
* Как настроить индексацию для выполнения предложений Order By или запросов в диапазоне?
* Как внести изменения в политику индексирования коллекции?
* Как сравнить затраты на хранение и производительность различных политик индексирования?

## <a id="CustomizingIndexingPolicy"></a> Настройка политики индексирования коллекции
Разработчики могут регулировать компромиссы между хранилищем, производительностью записи или запросов и согласованностью запросов, переопределяя политику индексирования по умолчанию для коллекции Azure Cosmos DB и настраивая следующие аспекты.

* **Включение документов и путей в индекс и исключение их из него**. Разработчики могут выбрать определенные документы, чтобы исключить из индекса или включить их в него во время вставки или замены этих документов в коллекции. Разработчики могут также включить или исключить определенные свойства JSON. Это так называемые пути (включая шаблоны с подстановочными знаками), индексируемые в документах, которые включены в индекс.
* **Настройка различных типов индекса**. Для каждого включенного пути разработчики могут также указать требуемый тип индекса для коллекции на основе их данных, ожидаемой рабочей нагрузки запросов и числовой или строковой "точности" каждого пути.
* **Настройка режимов обновления индекса**. Azure Cosmos DB поддерживает три режима индексирования, которые могут быть настроены с помощью политики индексирования для коллекции Azure Cosmos DB — Consistent, Lazy и None. 

В следующем фрагменте кода .NET показано, как задать пользовательскую политику индексирования во время создания коллекции. Здесь мы задаем политику с диапазонным индексом для строк и чисел с максимальной точностью. Эта политика позволяет выполнять запросы Order By к строкам.

    DocumentCollection collection = new DocumentCollection { Id = "myCollection" };

    collection.IndexingPolicy = new IndexingPolicy(new RangeIndex(DataType.String) { Precision = -1 });
    collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;

    await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("db"), collection);   


> [!NOTE]
> Схема JSON для политики индексации была изменена с помощью выпуска REST API (версия 2015-06-03), чтобы поддержать диапазонные индексы для строковых значений. Новую схему политики поддерживают пакет .NET SDK 1.2.0 и Java, Python и пакеты Node.js SDK 1.1.0. Более старые пакеты SDK используют REST API версии 2015-04-08 и поддерживают старую схему политики индексации.
> 
> По умолчанию Azure Cosmos DB согласованно индексирует все свойства строк в документах с помощью хэш-индекса, а числовые свойства — с помощью диапазонного индекса.  
> 
> 

### <a id="indexing-modes"></a>Режимы индексирования базы данных
Azure Cosmos DB поддерживает три режима индексирования, которые могут быть настроены с помощью политики индексирования для коллекции Azure Cosmos DB — Consistent, Lazy и None.

**Consistent** (Согласованный). Если для коллекции Azure Cosmos DB указана политика Consistent, запросы к данной коллекции Azure Cosmos DB соответствуют уровню согласованности, указанному для точечных операций чтения (т. е. strong (строгая), bounded-staleness (ограниченная с запаздыванием), session (сеанса) и eventual (окончательная)). Индекс обновляется синхронно при обновлении документа (т. е. при вставке, замене, обновлении и удалении документа в коллекции Azure Cosmos DB).  Согласованное индексирование поддерживает согласованность запросов за счет возможного сокращения пропускной способности записи. Это сокращение является функцией уникальных путей, которые должны быть проиндексированы, и "уровня согласованности". Режим согласованного индексирования предназначен для рабочих нагрузок типа "быстрая запись, немедленный запрос".

**Lazy** (Асинхронный). Чтобы обеспечить максимальную пропускную способность приема документов, для коллекции Azure Cosmos DB можно настроить асинхронную согласованность, то есть когда запросы являются согласованными в конечном счете. Индекс обновляется асинхронно, когда коллекция Azure Cosmos DB не загружена, т. е. когда пропускная способность коллекции не используется полностью для обслуживания запросов пользователя. Для рабочих нагрузок типа "прием сейчас, запрос позже", требующих беспрепятственного приема документов, может подойти асинхронный режим индексирования.

**None** (Нет). У коллекции с режимом индексирования None нет связанного индекса. Обычно это применимо для тех случаев, когда Azure Cosmos DB используется как хранилище пар "ключ — значение", а доступ к документам осуществляется только по свойству их идентификатора. 

> [!NOTE]
> Настройка политики индексирования None имеет побочный эффект — удаляется любой существующий индекс. Используйте этот режим, если шаблонам доступа требуются только идентификатор и (или) самоссылающаяся ссылка.
> 
> 

В следующем примере показано, как создать коллекцию Azure Cosmos DB с помощью пакета SDK для .NET с согласованным автоматическим индексированием всех операций вставки документа.

В следующей таблице показана согласованность запросов на основе режима индексирования (Consistent и Lazy), настроенного для коллекции, и уровня согласованности, указанного для запроса. Это относится к запросам, выполняемых с помощью любого интерфейса — интерфейс REST API, пакетов SDK или из хранимых процедур и триггеров. 

|Целостность|Режим индексирования: согласованный|Режим индексирования: асинхронный|
|---|---|---|
|Уровень согласованности Strong (сильная)|Уровень согласованности Strong (сильная)|Уровень согласованности Eventual (в конечном счете)|
|Ограниченное устаревание|Ограниченное устаревание|Уровень согласованности Eventual (в конечном счете)|
|Сеанс|Сеанс|Уровень согласованности Eventual (в конечном счете)|
|В конечном счете|В конечном счете|Уровень согласованности Eventual (в конечном счете)|

Azure Cosmos DB возвращает ошибку для запросов к коллекциям, для которых задан режим индексирования None. Запросы по-прежнему могут выполняться как сканирование с помощью явного заголовка `x-ms-documentdb-enable-scan` в REST API или параметра запроса `EnableScanInQuery` с помощью пакета SDK для .NET. Некоторые функции запроса, например ORDER BY, не могут выполняться как сканирование с помощью `EnableScanInQuery`.

В следующей таблице показана согласованность запросов на основе режима индексирования (Consistent, Lazy и None), если указан параметр EnableScanInQuery.

|Целостность|Режим индексирования: согласованный|Режим индексирования: асинхронный|Режим индексирования: нет|
|---|---|---|---|
|Уровень согласованности Strong (сильная)|Уровень согласованности Strong (сильная)|В конечном счете|Уровень согласованности Strong (сильная)|
|Ограниченное устаревание|Ограниченное устаревание|В конечном счете|Ограниченное устаревание|
|Сеанс|Сеанс|В конечном счете|Сеанс|
|Уровень согласованности Eventual (в конечном счете)|В конечном счете|В конечном счете|Уровень согласованности Eventual (в конечном счете)|

В следующем примере кода показано, как создать коллекцию Azure Cosmos DB с помощью пакета SDK для .NET с согласованным автоматическим индексированием всех операций вставки документа.

     // Default collection creates a hash index for all string fields and a range index for all numeric    
     // fields. Hash indexes are compact and offer efficient performance for equality queries.

     var collection = new DocumentCollection { Id ="defaultCollection" };

     collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;

     collection = await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("mydb"), collection);


### <a name="index-paths"></a>Пути индекса
Azure Cosmos DB представляет документы JSON и индексы в виде деревьев и позволяет настраивать политики для путей в дереве. В документах вы можете выбрать, какие пути необходимо включить или исключить из индексирования. Такой подход может обеспечить повышение производительности при записи и понижение требований к хранилищу индекса при сценариях, когда шаблоны запросов известны заранее.

Пути индекса начинаются с корня (/) и, как правило, заканчиваются оператором подстановочного знака (?), обозначающего, что существует несколько возможных значений префикса. Например, чтобы обслуживать запрос SELECT * FROM Families F WHERE F.familyName = "Andersen", вам нужно включить путь индекса для /familyName/? в политику индекса коллекции.

В путях индекса можно также использовать оператор подстановочного знака * для задания алгоритма пути рекурсивно по префиксу. Например, /payload/* можно использовать для исключения из индексации всего, что находится по свойству payload.

Вот распространенные шаблоны задания путей индекса:

| Путь                | Описание/вариант использования                                                                                                                                                                                                                                                                                         |
| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| /                   | Путь коллекции по умолчанию. Рекурсивный и применяется ко всему дереву документа.                                                                                                                                                                                                                                   |
| /prop/?             | Путь индекса, необходимый для обслуживания следующих запросов (с типами хэш, диапазон, соответственно):<br><br>SELECT FROM collection c WHERE c.prop = "value"<br><br>SELECT FROM collection c WHERE c.prop > 5<br><br>SELECT FROM collection c ORDER BY c.prop                                                                       |
| /prop/*             | Путь индекса для всех путей по заданной метке. Работает со следующими запросами<br><br>SELECT FROM collection c WHERE c.prop = "value"<br><br>SELECT FROM collection c WHERE c.prop.subprop > 5<br><br>SELECT FROM collection c WHERE c.prop.subprop.nextprop = "value"<br><br>SELECT FROM collection c ORDER BY c.prop         |
| /props/[]/?         | Путь индекса, необходимый для обслуживания запросов с итерацией и соединения, отправляемых в массивы скалярных выражений, например, ["a", "b", "c"]:<br><br>SELECT tag FROM tag IN collection.props WHERE tag = "value"<br><br>SELECT tag FROM collection c JOIN tag IN c.props WHERE tag > 5                                                                         |
| /props/[]/subprop/? | Путь индекса, необходимый для обслуживания запросов с итерацией и соединения, отправляемых в массивы объектов, например, [{subprop: "a"}, {subprop: "b"}]:<br><br>SELECT tag FROM tag IN collection.props WHERE tag.subprop = "value"<br><br>SELECT tag FROM collection c JOIN tag IN c.props WHERE tag.subprop = "value"                                  |
| /prop/subprop/?     | Путь индекса, необходимый для обслуживания запросов (с типами хэш, диапазон, соответственно):<br><br>SELECT FROM collection c WHERE c.prop.subprop = "value"<br><br>SELECT FROM collection c WHERE c.prop.subprop > 5                                                                                                                    |

> [!NOTE]
> При задании пути пользовательского индекса необходимо выбрать правило индексации по умолчанию для всего дерева документов, указав специальный путь "/*". 
> 
> 

В следующем примере показана настройка конкретного пути с диапазонной индексацией и пользовательским значением точности в 20 байт:

    var collection = new DocumentCollection { Id = "rangeSinglePathCollection" };    

    collection.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/Title/?", 
            Indexes = new Collection<Index> { 
                new RangeIndex(DataType.String) { Precision = 20 } } 
            });

    // Default for everything else
    collection.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/*" ,
            Indexes = new Collection<Index> {
                new HashIndex(DataType.String) { Precision = 3 }, 
                new RangeIndex(DataType.Number) { Precision = -1 } 
            }
        });

    collection = await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("db"), pathRange);


### <a name="index-data-types-kinds-and-precisions"></a>Типы данных, виды и степени точности индекса
Теперь, когда мы изучили способы указания путей, рассмотрим параметры, которые можно использовать для настройки политики индексирования пути. Можно указать одно или несколько определений индексирования для каждого пути.

* Тип данных: **String**, **Number**, **Point**, **Polygon** или **LineString** (может содержать только одну запись для каждого типа данных и пути).
* Вид индекса: **хэш-индекс** (запросы равенства), **диапазонный индекс** (запросы равенства, диапазона или ORDER BY) или **пространственный индекс** (пространственные запросы). 
* Точность: в хэш-индексе это значение для строк и чисел находится в диапазоне от 1 до 8. По умолчанию используется значение 3. В индексе диапазона может использоваться значение -1 (максимальная точность). Для строк и чисел значение может меняться в диапазоне от 1 до 100 (максимальная точность).

#### <a name="index-kind"></a>Вид индекса
Azure Cosmos DB поддерживает хэш-индексы и диапазонные индексы для каждого пути (их можно настроить для чисел, строк или и того и другого).

* **Хэш-индекс** поддерживает эффективные запросы равенства и запросы JOIN. Для большинства случаев использования хэш-индексов не требуется более высокая точность, чем разрядность по умолчанию, т. е. 3 байта. DataType может иметь значение String или Number.
* **Диапазонный индекс** поддерживает эффективные запросы равенства, запросы диапазона (с использованием >, <, >=, <=, !=) и запросы ORDER BY. Запросы Order By по умолчанию также требуют максимальной точности индекса (-1). DataType может иметь значение String или Number.

Azure Cosmos DB также поддерживает вид пространственного индекса для каждого пути, который может быть указан для типов данных Point, Polygon и LineString. Значение по указанному пути должно быть действительным фрагментом объекта GeoJSON, например `{"type": "Point", "coordinates": [0.0, 10.0]}`.

* **Пространственный** индекс обеспечивает эффективность выполнения пространственных запросов (запросов нахождения в пределах и расстояния). DataType может иметь значение Point, Polygon или LineString.

> [!NOTE]
> Azure Cosmos DB поддерживает автоматическое индексирование данных типа Point, Polygon и LineString.
> 
> 

Ниже приведены виды поддерживаемых индексов и примеры запросов, для обслуживания которых их можно использовать:

| Вид индекса | Описание/вариант использования                                                                                                                                                                                                                                                                                                                                                                                                              |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Хэш       | Хэш-индекс по over/prop/? (или /) позволяет эффективно обрабатывать следующие запросы:<br><br>SELECT FROM collection c WHERE c.prop = "value"<br><br>Хэш-индекс по over /props/[]/? (или / или /props/) позволяет эффективно обрабатывать следующие запросы:<br><br>SELECT tag FROM collection c JOIN tag IN c.props WHERE tag = 5                                                                                                                       |
| Диапазонный индекс      | Диапазонный индекс по /prop/? (или /) позволяет эффективно обрабатывать следующие запросы:<br><br>SELECT FROM collection c WHERE c.prop = "value"<br><br>SELECT FROM collection c WHERE c.prop > 5<br><br>SELECT FROM collection c ORDER BY c.prop                                                                                                                                                                                                              |
| пространственный индекс     | Диапазонный индекс по /prop/? (или /) позволяет эффективно обрабатывать следующие запросы:<br><br>SELECT FROM collection c<br><br>WHERE ST_DISTANCE(c.prop, {"type": "Point", "coordinates": [0.0, 10.0]}) < 40<br><br>SELECT FROM collection c WHERE ST_WITHIN(c.prop, {"type": "Polygon", ... }) --с индексированием точек<br><br>SELECT FROM collection c WHERE ST_WITHIN({"type": "Point", ... }, c.prop) --с индексированием многоугольников              |

По умолчанию возвращается сообщение об ошибке для запросов с операторами диапазона, например > =, если отсутствует диапазонный индекс (любой точности), чтобы указать, что для обслуживания запроса может потребоваться проверка. Диапазонные запросы можно выполнять без диапазонного индекса с помощью заголовка x-ms-documentdb-enable-scans в REST API или параметра запроса EnableScanInQuery посредством пакета SDK для .NET. Если в запросе есть какие-либо другие фильтры, по которым Azure Cosmos DB может отфильтровать индекс, сообщение об ошибке не появится.

Те же правила применяются для пространственных запросов. По умолчанию ошибка возвращается для пространственных запросов в случае отсутствия пространственного индекса и отсутствия фильтров, которые могут быть получены из индекса. Они могут выполняться как сканирование с использованием x-ms-documentdb-enable-scan/EnableScanInQuery.

#### <a name="index-precision"></a>Точность индекса
Точность индекса обеспечивает компромисс между дополнительными затратами на хранение индекса и производительностью запросов. Для чисел рекомендуется использовать конфигурацию точности по умолчанию (-1, максимальная точность). Поскольку числа включают 8 байт в JSON, это эквивалентно 8-байтовой конфигурации. Выбор меньшего значения точности, например 1–7, означает, что значения в некоторых диапазонах соответствуют той же записи индекса. Таким образом, можно уменьшить место хранения индекса, но при выполнении запроса может возникнуть необходимость обработки большего количества документов, в результате чего потребуется более высокая пропускная способность, т. е. больше единиц запроса.

Конфигурацию точности индекса практичнее использовать с диапазонами строки. Поскольку строки могут быть любой длины, выбор точности индекса может повлиять на производительность запросов диапазона строки и повлиять на объем требуемого для индекса хранилища. Для индексов диапазона строки можно настроить значения 1–100 или -1 (максимум). Если вы хотите выполнить запросы ORDER BY с строковыми свойствами, необходимо указать точность -1 для соответствующих путей.

Пространственные индексы всегда используют точность индекса по умолчанию для всех типов данных (Point, LineString и Polygon), и переопределить ее нельзя. 

В следующем примере показывается, как повысить точность для диапазонных индексов в коллекции с использованием .NET SDK. 

**Создание коллекции с пользовательской точностью индекса**

    var rangeDefault = new DocumentCollection { Id = "rangeCollection" };

    // Override the default policy for Strings to range indexing and "max" (-1) precision
    rangeDefault.IndexingPolicy = new IndexingPolicy(new RangeIndex(DataType.String) { Precision = -1 });

    await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("db"), rangeDefault);   


> [!NOTE]
> Azure Cosmos DB возвращает ошибку, если запрос использует предложение Order By, но не имеет диапазонного индекса для запрашиваемого пути с максимальной точностью. 
> 
> 

Аналогичным образом пути можно полностью исключить из индексации. В следующем примере показано, как исключить из индексации раздел сущностей документов (так называемое поддерево) с помощью подстановочного знака "*".

    var collection = new DocumentCollection { Id = "excludedPathCollection" };
    collection.IndexingPolicy.IncludedPaths.Add(new IncludedPath { Path = "/*" });
    collection.IndexingPolicy.ExcludedPaths.Add(new ExcludedPath { Path = "/nonIndexedContent/*" });

    collection = await client.CreateDocumentCollectionAsync(UriFactory.CreateDatabaseUri("db"), excluded);



## <a name="opting-in-and-opting-out-of-indexing"></a>Включение индексирования и отказ от него
Вы можете выбрать, хотите ли вы, чтобы коллекция автоматически индексировала все документы. По умолчанию все документы автоматически индексируются, но вы можете отключить эту функцию. При выключенном индексировании документы могут быть доступны только через свои собственные ссылки или запросы, использующие идентификатор.

При выключенном автоматическом индексировании вы все равно можете выборочно добавлять в индекс только некоторые документы. И наоборот, вы можете оставить включенным автоматическое индексирование и выборочно указать, какие документы необходимо исключить. Настройка включения или выключения индексирования полезна, когда у вас есть только подмножество документов, к которым требуется выполнить запрос.

Так, следующий пример показывает, как добавить документ явным образом с помощью [пакета SDK .NET для API DocumentDB](https://docs.microsoft.com/en-us/azure/cosmos-db/documentdb-sdk-dotnet) и свойства [RequestOptions.IndexingDirective](http://msdn.microsoft.com/library/microsoft.azure.documents.client.requestoptions.indexingdirective.aspx).

    // If you want to override the default collection behavior to either
    // exclude (or include) a Document from indexing,
    // use the RequestOptions.IndexingDirective property.
    client.CreateDocumentAsync(UriFactory.CreateDocumentCollectionUri("db", "coll"),
        new { id = "AndersenFamily", isRegistered = true },
        new RequestOptions { IndexingDirective = IndexingDirective.Include });

## <a name="modifying-the-indexing-policy-of-a-collection"></a>Изменение политики индексирования коллекции
Azure Cosmos DB позволяет внести изменения в политику индексирования коллекции в режиме реального времени. Изменение политики индексирования коллекции Azure Cosmos DB может привести к изменению в формы индекса, включая индексируемые пути, их точность, а также модель согласованности самого индекса. Таким образом изменение политики индексирования фактически требует преобразования старого индекса в новый. 

**Преобразование индексов в сети**

![Как работает индексирование — преобразование индексов Azure Cosmos DB в сети](./media/indexing-policies/index-transformations.png)

Преобразования индексов выполняются в сети. Это означает, что документы, индексированные по старой политике, эффективно преобразуются согласно новой политике **без ущерба доступности для записи или подготовленной пропускной способности** коллекции. Согласованность операций чтения и записи, выполняемых с помощью API REST, пакетов SDK или изнутри хранимых процедур и триггеров, не затрагивается во время преобразования индекса. Это означает, что при изменении политики индексирования производительность не падает и отсутствует простой приложений.

Тем не менее, во время преобразования индекса запросы являются в конечном счете согласованными вне зависимости от конфигурации режима индексирования (Consistent или Lazy). Это также относится к запросам из всех интерфейсов: REST API, пакетов SDK и из хранимых процедур и триггеров. Как и индексирование в режиме Lazy, преобразование индекса выполняется асинхронно в фоновом режиме на репликах с помощью запасных ресурсов, доступных для заданной реплики. 

Преобразование индекса также выполняется **на месте**, т. е. Azure Cosmos DB не хранит две копии индекса и не заменяет старый индекс новым. Это означает, что при выполнении преобразования индекса не требуется использовать дополнительное место на диске или в коллекции.

При изменении политики индексирования то, как применяются изменения для перехода от старого индекса к новому, больше зависит от конфигураций режима индексирования, чем от других значений, таких как включенные или исключенные пути, типы индекса и точности. Если в старой и новой политике используется согласованное индексирование, то Azure Cosmos DB выполняет преобразование индекса в сети. Во время выполнения преобразования нельзя применить другое изменение политики индексирования с согласованным режимом индексирования.

Однако во время преобразования можно перейти в режим индексирования Lazy или None. 

* При переходе в режим Lazy изменение политики индексирования вступает в силу немедленно, и Azure Cosmos DB начинает асинхронно повторно создавать индекс. 
* При переходе в режим None индекс немедленно удаляется. Переход в режим None удобен, если необходимо отменить выполняемое преобразование и начать "с нуля" с другой политикой индексирования. 

При использовании пакета SDK для .NET можно запустить изменение политики индексирования с помощью нового метода **ReplaceDocumentCollectionAsync** и отслеживать ход выполнения преобразования индекса в процентах с помощью свойства ответа **IndexTransformationProgress** из вызова **ReadDocumentCollectionAsync**. Другие пакеты SDK и REST API поддерживают эквивалентные свойства и методы для изменения политики индексирования.

Вот фрагмент кода, который показывает, как изменить режим политики индексирования коллекции с Consistent на Lazy.

**Изменение режима политики индексирования с Consistent на Lazy**

    // Switch to lazy indexing.
    Console.WriteLine("Changing from Default to Lazy IndexingMode.");

    collection.IndexingPolicy.IndexingMode = IndexingMode.Lazy;

    await client.ReplaceDocumentCollectionAsync(collection);


Можно проверить ход выполнения преобразования индекса, вызвав, например, ReadDocumentCollectionAsync, как показано ниже.

**Отслеживание хода выполнения преобразования индекса**

    long smallWaitTimeMilliseconds = 1000;
    long progress = 0;

    while (progress < 100)
    {
        ResourceResponse<DocumentCollection> collectionReadResponse = await client.ReadDocumentCollectionAsync(
            UriFactory.CreateDocumentCollectionUri("db", "coll"));

        progress = collectionReadResponse.IndexTransformationProgress;

        await Task.Delay(TimeSpan.FromMilliseconds(smallWaitTimeMilliseconds));
    }

Можно удалить индекс для коллекции, перейдя в режим индексирования None. Это может быть удобным рабочим инструментом, если требуется отменить выполняющееся преобразование и немедленно начать новое.

**Удаление индекса для коллекции**

    // Switch to lazy indexing.
    Console.WriteLine("Dropping index by changing to to the None IndexingMode.");

    collection.IndexingPolicy.IndexingMode = IndexingMode.None;

    await client.ReplaceDocumentCollectionAsync(collection);

Когда вы вносите изменения в политики индексирования для своих коллекций Azure Cosmos DB? Ниже перечислены наиболее распространенные случаи использования:

* Обеспечиваете согласованные результаты во время обычной работы, но возвращаетесь к режиму индексирования Lazy при массовом импорте данных.
* Вы начинаете использовать новые функции индексирования для своих текущих коллекций Azure Cosmos DB, например геопространственных запросов, для которых необходим пространственный индекс, для запросов ORDER BY и запросов диапазона строки, для которых необходим индекс диапазона строки.
* Вручную выбираете свойства для индексирования и со временем меняете их.
* Настраиваете точность индексирования для повышения производительности запросов или уменьшения используемого хранилища.

> [!NOTE]
> Для изменения политики индексирования с помощью ReplaceDocumentCollectionAsync требуется версия пакета SDK для .NET не ниже 1.3.0.
> 
> Для преобразования индекса для успешного завершения необходимо убедиться, что в коллекции достаточно доступного свободного места. Если коллекция достигает своей квоты хранилища, преобразование индекса будет приостановлено. Преобразование индекса автоматически возобновится при появлении доступного места, например, если вы удалите некоторые документы.
> 
> 

## <a name="performance-tuning"></a>Настройка производительности
API DocumentDB предоставляют сведения о метриках производительности, таких как используемое хранилище индекса и стоимость пропускной способности (единицы запроса) для каждой операции. Эту информацию можно использовать для сравнения различных политик индексирования и настройки производительности.

Чтобы оценить квоты хранения и использования коллекции, запустите запрос HEAD или GET для ресурсов коллекции и выберите заголовки запросов x-ms-request-quota и x-ms-request-usage. В пакете SDK для .NET свойства [DocumentSizeQuota](http://msdn.microsoft.com/library/dn850325.aspx) и [DocumentSizeUsage](http://msdn.microsoft.com/library/azure/dn850324.aspx) на вкладке [ResourceResponse<T\>](http://msdn.microsoft.com/library/dn799209.aspx) содержат соответствующие значения.

     // Measure the document size usage (which includes the index size) against   
     // different policies.
     ResourceResponse<DocumentCollection> collectionInfo = await client.ReadDocumentCollectionAsync(UriFactory.CreateDocumentCollectionUri("db", "coll"));  
     Console.WriteLine("Document size quota: {0}, usage: {1}", collectionInfo.DocumentQuota, collectionInfo.DocumentUsage);


Для оценки расходов на индексирование в каждой операции записи (создание, обновление или удаление) выберите заголовок x-ms-request-charge (или эквивалентное свойство [RequestCharge](http://msdn.microsoft.com/library/dn799099.aspx) на вкладке [ResourceResponse<T\>](http://msdn.microsoft.com/library/dn799209.aspx) в пакете SDK для .NET), чтобы измерить число единиц запроса, используемых такими операциями.

     // Measure the performance (request units) of writes.     
     ResourceResponse<Document> response = await client.CreateDocumentAsync(UriFactory.CreateDocumentCollectionUri("db", "coll"), myDocument);              
     Console.WriteLine("Insert of document consumed {0} request units", response.RequestCharge);

     // Measure the performance (request units) of queries.    
     IDocumentQuery<dynamic> queryable =  client.CreateDocumentQuery(UriFactory.CreateDocumentCollectionUri("db", "coll"), queryString).AsDocumentQuery();

     double totalRequestCharge = 0;
     while (queryable.HasMoreResults)
     {
        FeedResponse<dynamic> queryResponse = await queryable.ExecuteNextAsync<dynamic>(); 
        Console.WriteLine("Query batch consumed {0} request units",queryResponse.RequestCharge);
        totalRequestCharge += queryResponse.RequestCharge;
     }

     Console.WriteLine("Query consumed {0} request units in total", totalRequestCharge);

## <a name="changes-to-the-indexing-policy-specification"></a>Изменения в спецификации политики индексации
Изменение в схеме для политики индексации было представлено 7 июля 2015 года с помощью интерфейса API REST версии 2015-06-03. Представленные классы в версиях пакетов SDK имеют новые реализации, соответствующие схеме. 

В спецификации JSON были реализованы следующие изменения:

* Политика индексации поддерживает диапазонные индексы для строк.
* Каждый путь может иметь несколько определений индекса, по одному для каждого типа данных.
* Поддерживаемая точность индексации: 1–8 для чисел, 1–100 для строк и –1 (максимальная точность).
* Двойные кавычки в сегментах путей для экранирования каждого пути не требуются. Например, вы можете добавить путь для /title/? вместо /"title"/?
* Корневой путь, представляющий "все пути", можно указать в виде "/*" (в дополнение к "/").

Если у вас имеется код, который подготавливает коллекции с пользовательской политикой индексации, написанный с помощью пакета SDK .NET версии 1.1.0 или более ранней, необходимо изменить код приложения, чтобы обработать эти изменения с целью переноса в пакет SDK версии 1.2.0. Если у вас нет кода, который настраивает политику индексации, или если вы планируете продолжить использование старой версии пакета SDK, изменения не требуются.

Для практического сравнения ниже приведен один пример пользовательской политики индексирования, написанный с помощью API REST версии 2015-06-03 и предыдущей версии 2015-04-08.

**Предыдущая политика индексации JSON**

    {
       "automatic":true,
       "indexingMode":"Consistent",
       "IncludedPaths":[
          {
             "IndexType":"Hash",
             "Path":"/",
             "NumericPrecision":7,
             "StringPrecision":3
          }
       ],
       "ExcludedPaths":[
          "/\"nonIndexedContent\"/*"
       ]
    }

**Текущая политика индексации JSON**

    {
       "automatic":true,
       "indexingMode":"Consistent",
       "includedPaths":[
          {
             "path":"/*",
             "indexes":[
                {
                   "kind":"Hash",
                   "dataType":"String",
                   "precision":3
                },
                {
                   "kind":"Hash",
                   "dataType":"Number",
                   "precision":7
                }
             ]
          }
       ],
       "ExcludedPaths":[
          {
             "path":"/nonIndexedContent/*"
          }
       ]
    }

## <a name="next-steps"></a>Дальнейшие действия
Используйте ссылки ниже для примеров управления политиками индексации и получения дополнительных сведений о языке запросов Azure Cosmos DB.

1. [Примеры кода управления индексами для API DocumentDB .NET](https://github.com/Azure/azure-documentdb-net/blob/master/samples/code-samples/IndexManagement/Program.cs)
2. [Collections](https://msdn.microsoft.com/library/azure/dn782195.aspx) (Коллекции)
3. [SQL-запросы для API DocumentDB в Azure Cosmos DB](documentdb-sql-query.md)


