---
title: Запросы SQL для Azure Cosmos DB
description: Сведения о синтаксисе SQL, основных понятиях баз данных и запросах SQL для Azure Cosmos DB. SQL можно использовать в качестве языка запросов JSON в Azure Cosmos DB.
author: markjbrown
ms.service: cosmos-db
ms.topic: sample
ms.date: 11/15/2018
ms.author: mjbrown
ms.openlocfilehash: d101931fb2a4184ff9ffffc0aed4fc90fee2cbd5
ms.sourcegitcommit: 9b6492fdcac18aa872ed771192a420d1d9551a33
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/22/2019
ms.locfileid: "54452961"
---
# <a name="sql-query-examples-to-query-data-from-azure-cosmos-db"></a>Примеры запросов SQL для запроса данных из Azure Cosmos DB

Azure Cosmos DB поддерживает элементы запросов на SQL (язык структурированных запросов) в качестве языка запросов JSON в учетных записях API SQL. При разработке языка запросов для Azure Cosmos DB рассматриваются следующие две цели.

* Вместо того чтобы изобретать новый язык запросов, был создан Azure Cosmos DB, поддерживающий SQL, один из наиболее знакомых и популярных языков запросов. SQL в Azure Cosmos DB предоставляет формальную модель программирования для выполнения многофункциональных запросов к элементам JSON.  

* Azure Cosmos DB в качестве основы языка запросов использует модель программирования JavaScript. SQL API основывается на системе типов, вычисления выражений и вызовов функций JavaScript. Это, в свою очередь, обеспечивает естественную модель программирования для реляционных проекций, иерархической навигации по элементам JSON, внутренних соединений, пространственных данных и вызовов определяемых пользователем функций (UDF), написанных полностью на JavaScript, наряду с другими особенностями.

В этой статье описаны некоторые примеры SQL-запросов с использованием простых элементов JSON. Дополнительные сведения о синтаксисе языка SQL Azure Cosmos DB см. в статье [Справочник по синтаксису SQL в Azure Cosmos DB](sql-api-query-reference.md).

## <a id="GettingStarted"></a>Приступая к работе с командами SQL

Давайте создадим два элемента JSON и запрос к этим данным. Рассмотрим два элемента JSON со сведениями о семействах, вставим их в контейнер, а затем запросим данные. Мы имеем простой элемент JSON для семейств Андерсен и Вейкфилд, содержащий сведения о родителях, детях (и их домашних животных), адреса и регистрационные данные. В элементе есть строки, числа, логические значения, массивы и вложенные свойства.

**Элемент 1**

```JSON
{
  "id": "AndersenFamily",
  "lastName": "Andersen",
  "parents": [
     { "firstName": "Thomas" },
     { "firstName": "Mary Kay"}
  ],
  "children": [
     {
         "firstName": "Henriette Thaulow",
         "gender": "female",
         "grade": 5,
         "pets": [{ "givenName": "Fluffy" }]
     }
  ],
  "address": { "state": "WA", "county": "King", "city": "seattle" },
  "creationDate": 1431620472,
  "isRegistered": true
}
```

Это второй элемент с одним небольшим отличием: вместо `firstName` и `lastName` используются `givenName` и `familyName`.

**Элемент 2**

```json
{
  "id": "WakefieldFamily",
  "parents": [
      { "familyName": "Wakefield", "givenName": "Robin" },
      { "familyName": "Miller", "givenName": "Ben" }
  ],
  "children": [
      {
        "familyName": "Merriam",
        "givenName": "Jesse",
        "gender": "female", "grade": 1,
        "pets": [
            { "givenName": "Goofy" },
            { "givenName": "Shadow" }
        ]
      },
      { 
        "familyName": "Miller",
         "givenName": "Lisa",
         "gender": "female",
         "grade": 8 }
  ],
  "address": { "state": "NY", "county": "Manhattan", "city": "NY" },
  "creationDate": 1431620462,
  "isRegistered": false
}
```

Теперь давайте выполним несколько запросов к этим данным, чтобы понять некоторые ключевые аспекты языка запросов SQL в Azure Cosmos DB.

**Запрос 1**. Например, указанный ниже запрос вернет элементы, в которых поле идентификатора совпадает с `AndersenFamily`. Так как это запрос `SELECT *`, то его вывод является полным элементом JSON. Дополнительные сведения о синтаксисе см. в разделе [Запрос SELECT](sql-api-query-reference.md#select-query).

```sql
    SELECT *
    FROM Families f
    WHERE f.id = "AndersenFamily"
```

**Результаты**

```json
    [{
        "id": "AndersenFamily",
        "lastName": "Andersen",
        "parents": [
           { "firstName": "Thomas" },
           { "firstName": "Mary Kay"}
        ],
        "children": [
           {
               "firstName": "Henriette Thaulow", "gender": "female", "grade": 5,
               "pets": [{ "givenName": "Fluffy" }]
           }
        ],
        "address": { "state": "WA", "county": "King", "city": "seattle" },
        "creationDate": 1431620472,
        "isRegistered": true
    }]
```

**Запрос 2**. Теперь рассмотрим случай, когда нам необходимо переформатировать вывод JSON в другую форму. Этот запрос создает новый объект JSON с двумя выбранными полями, Имя и Город, если название города совпадает с названием штата. В этом случае совпадут NY и NY.

```sql
    SELECT {"Name":f.id, "City":f.address.city} AS Family
    FROM Families f
    WHERE f.address.city = f.address.state
```

**Результаты**

```json
    [{
        "Family": {
            "Name": "WakefieldFamily",
            "City": "NY"
        }
    }]
```

**Запрос 3**. Этот запрос возвращает все заданные имена детей в семействе, идентификатор которого соответствует `WakefieldFamily`, упорядоченному по городу проживания.

```sql
    SELECT c.givenName
    FROM Families f
    JOIN c IN f.children
    WHERE f.id = 'WakefieldFamily'
    ORDER BY f.address.city ASC
```

**Результаты**

```json
    [
      { "givenName": "Jesse" },
      { "givenName": "Lisa"}
    ]
```

Ниже приведены несколько аспектов языка запросов Cosmos DB с примерами, которые уже были показаны.  

* Так как SQL API работает со значениями JSON, он имеет дело с сущностями в виде деревьев, а не со строками и столбцами. Таким образом, язык позволяет обращаться к узлам дерева любой произвольной вложенности, как `Node1.Node2.Node3…..Nodem`, что похоже на реляционный SQL со ссылкой, состоящей из двух частей `<table>.<column>`.

* Язык SQL работает с данными без схемы. Таким образом, система типов должна быть динамически связанной. Одно и то же выражение может возвращать различные типы у разных элементов. Результатом запроса является допустимое значение JSON, но оно не обязательно будет иметь фиксированную схему.  

* Azure Cosmos DB поддерживает только элементы, строго соответствующие JSON. Это означает, что система типов и выражения могут обрабатывать только типы JSON. Дополнительные сведения см. в статье [Спецификации JSON](http://www.json.org/).  

* Контейнер Cosmos DB является коллекцией элементов JSON, не имеющей схемы. Отношения между сущностями данных внутри элементов и между элементами в этом контейнере неявным образом отражены в иерархии, а не задаются связями между первичными и внешними ключами. Это является важным аспектом в контексте внутренних соединений элемента, которые будут обсуждаться позже в этой статье.

## <a id="SelectClause"></a>Предложение SELECT

Каждый запрос состоит из предложения SELECT и необязательных предложений FROM и WHERE в соответствии со стандартами ANSI-SQL. Как правило, в каждом запросе источник в предложении FROM является перечислимым. Затем к исходному множеству применяется предложение WHERE, чтобы извлечь подмножество элементов JSON. И наконец, предложение SELECT используется для проекции запрошенных значений JSON в списке выборки. Дополнительные сведения о синтаксисе см. в разделе [Предложение SELECT](sql-api-query-reference.md#bk_select_query).

Пример ниже иллюстрирует типичный запрос SELECT.

**Запрос**

```sql
    SELECT f.address
    FROM Families f
    WHERE f.id = "AndersenFamily"
```

**Результаты**

```json
    [{
      "address": {
        "state": "WA",
        "county": "King",
        "city": "seattle"
      }
    }]
```

### <a name="nested-properties"></a>Вложенные свойства

В следующем примере мы отображаем два вложенных свойства — `f.address.state` and `f.address.city`.

**Запрос**

```sql
    SELECT f.address.state, f.address.city
    FROM Families f
    WHERE f.id = "AndersenFamily"
```

**Результаты**

```json
    [{
      "state": "WA",
      "city": "seattle"
    }]
```

Проекция также поддерживает выражения JSON, как показано в следующем примере:

**Запрос**

```sql
    SELECT { "state": f.address.state, "city": f.address.city, "name": f.id }
    FROM Families f
    WHERE f.id = "AndersenFamily"
```

**Результаты**

```json
    [{
      "$1": {
        "state": "WA",
        "city": "seattle",
        "name": "AndersenFamily"
      }
    }]
```

Давайте посмотрим, какую роль играет `$1`. `SELECT` необходим для создания объекта JSON, и, так как ни один из ключей не предоставлен, мы используем имена неявных переменных аргументов, начиная с `$1`. Например, этот запрос возвращает две неявные переменные аргументов, помеченные как `$1` and `$2`.

**Запрос**

```sql
    SELECT { "state": f.address.state, "city": f.address.city },
           { "name": f.id }
    FROM Families f
    WHERE f.id = "AndersenFamily"
```

**Результаты**

```json
    [{
      "$1": {
        "state": "WA",
        "city": "seattle"
      }, 
      "$2": {
        "name": "AndersenFamily"
      }
    }]
```

## <a id="FromClause"></a>Предложение FROM

Предложение "FROM <from_specification>" является необязательным, если далее в запросе источник не фильтруется и не отображается. Дополнительные сведения о синтаксисе см. в разделе [Предложение FROM](sql-api-query-reference.md#bk_from_clause). Запрос вида `SELECT * FROM Families` определяет, что источником для перечисления является весь контейнер Families. Специальный идентификатор ROOT позволяет указать на сам контейнер, не используя его имя.
Следующий список содержит правила, которые применяются для запроса:

* Контейнер может иметь псевдоним, например `SELECT f.id FROM Families AS f` или просто `SELECT f.id FROM Families f`. Здесь `f` является эквивалентом `Families`. `AS` — необязательное ключевое слово для создания псевдонима идентификатора.  

* После создания псевдонима оригинальный источник связывать нельзя. Например, выражение `SELECT Families.id FROM Families f` является синтаксически неверным, так как идентификатор Families уже не может быть разрешен.  

* Все свойства, на которые необходимо ссылаться, должны иметь полное название. В отсутствие строгого следования схеме это реализуется для того, чтобы избежать любых неоднозначных привязок. Это значит, что `SELECT id FROM Families f` синтаксически неверен, так как свойство `id` не имеет привязки.

### <a name="get-subitems-using-from-clause"></a>Получение вложенных элементов с помощью предложения FROM

Исходные документы могут быть включены в еще меньшее подмножество. Например, если нужно перечисление только вложенного дерева в каждом элементе, корень вложенного дерева может стать источником, как в приведенном ниже примере.

**Запрос**

```sql
    SELECT *
    FROM Families.children
```

**Результаты**

```json
    [
      [
        {
            "firstName": "Henriette Thaulow",
            "gender": "female",
            "grade": 5,
            "pets": [
              {
                  "givenName": "Fluffy"
              }
            ]
        }
      ],
      [
        {
            "familyName": "Merriam",
            "givenName": "Jesse",
            "gender": "female",
            "grade": 1
        },
        {
            "familyName": "Miller",
            "givenName": "Lisa",
            "gender": "female",
            "grade": 8
        }
      ]
    ]
```

В то время как в приведенном выше примере используется массив в качестве источника, объект также может быть использован в качестве источника, как показано в следующем примере: Любое допустимое значение JSON (кроме неопределенного), которое обнаружится в источнике, будет рассматриваться для включения в результат запроса. Если в некоторых семействах отсутствует значение `address.state`, они исключаются из результатов запроса.

**Запрос**

```sql
    SELECT *
    FROM Families.address.state
```

**Результаты**

```json
    [
      "WA",
      "NY"
    ]
```

## <a id="WhereClause"></a>Предложение WHERE

Предложение WHERE (**`WHERE <filter_condition>`**) не является обязательным. Оно определяет условие (условия) для включения исходных элементов JSON в результат. Любой элемент JSON должен при вычислении указанных условий возвращать значение true, чтобы быть включенным в результат. Выражение WHERE используется слоем индексирования, чтобы определить наименьшее подмножество исходных элементов, которые могут входить в результат. Дополнительные сведения о синтаксисе см. в разделе [Предложение WHERE](sql-api-query-reference.md#bk_where_clause).

Ниже приведен запрос элементов, содержащих имя свойства, значение которого равно `AndersenFamily`. Все остальные элементы, у которых нет свойства имени или в которых значение не соответствует `AndersenFamily`, исключаются.

**Запрос**

```sql
    SELECT f.address
    FROM Families f
    WHERE f.id = "AndersenFamily"
```

**Результаты**

```json
    [{
      "address": {
        "state": "WA",
        "county": "King",
        "city": "seattle"
      }
    }]
```

В предыдущем примере показан простой запрос с условием равенства. SQL API также поддерживает различные скалярные выражения. Наиболее часто используются бинарные и унарные выражения. Ссылки на свойства исходного объекта JSON также являются допустимыми выражениями.

В настоящий момент поддерживаются следующие двоичные операторы, они могут быть использованы в запросах, как показано в следующих примерах:  

|**Тип оператора**  | **Значения** |
|---------|---------|
|Арифметические | +,-,*,/,% |
|Побитовые    | \|, &, ^, <<, >>, >>> (сдвиг вправо с заполнением нулями) |
|Логические    | AND, OR, NOT      |
|Сравнение | =, !=, &lt;, &gt;, &lt;=, &gt;=, <> |
|Строка     |  \|\| (объединение) |

Давайте рассмотрим примеры запросов с двоичными операторами.

```sql
    SELECT *
    FROM Families.children[0] c
    WHERE c.grade % 2 = 1     -- matching grades == 5, 1

    SELECT *
    FROM Families.children[0] c
    WHERE c.grade ^ 4 = 1    -- matching grades == 5

    SELECT *
    FROM Families.children[0] c
    WHERE c.grade >= 5     -- matching grades == 5
```

Унарные операторы +, -, ~ и NOT также поддерживаются и могут использоваться в запросах, как показано в следующих примерах.

```sql
    SELECT *
    FROM Families.children[0] c
    WHERE NOT(c.grade = 5)  -- matching grades == 1

    SELECT *
    FROM Families.children[0] c
    WHERE (-c.grade = -5)  -- matching grades == 5
```

Кроме бинарных и унарных операторов, также разрешены ссылки на свойства. Например, `SELECT * FROM Families f WHERE f.isRegistered` возвращает элемент JSON, содержащий свойство `isRegistered`, значение которого равно значению `true` для JSON. Любые другие значения (false, null, Undefined, `<number>`, `<string>`, `<object>`, `<array>` и т. д.) приводят к тому, что исходный элемент исключается из результата. 

### <a name="equality-and-comparison-operators"></a>Операторы равенства и сравнения

Ниже приведена таблица, в которой собраны результаты сравнения равенства в SQL API между любыми двумя типами JSON.

| **Оператор** | **Неопределенное** | **Null** | **Логический** | **Число** | **Строка** | **Объект** | **Массив** |
|---|---|---|---|---|---|---|---|
| **Неопределенное** | Не определено | Не определено | Не определено | Не определено | Не определено | Не определено | Не определено |
| **Null** | Не определено | **Допустимо** | Не определено | Не определено | Не определено | Не определено | Не определено |
| **Логический** | Не определено | Не определено | **Допустимо** | Не определено | Не определено | Не определено | Не определено |
| **Число** | Не определено | Не определено | Не определено | **Допустимо** | Не определено | Не определено | Не определено |
| **Строка** | Не определено | Не определено | Не определено | Не определено | **Допустимо** | Не определено | Не определено |
| **Объект** | Не определено | Не определено | Не определено | Не определено | Не определено | **Допустимо** | Не определено |
| **Массив** | Не определено | Не определено | Не определено | Не определено | Не определено | Не определено | **Допустимо** |

Для других операторов сравнения, например >, >=, !=, < и <=, применяются следующие правила.

* Сравнение типов приводит к неопределенному результату.  
* Сравнение двух объектов или двух массивов приводит к неопределенному результату.

Если результат скалярного выражения в фильтре — Undefined (не определен), соответствующий элемент не будет включен в результат, так как Undefined логически не равно значению true.

## <a name="between-keyword"></a>Ключевое слово BETWEEN (МЕЖДУ)
Можно также использовать ключевое слово BETWEEN для выражения запросов к диапазонам значений, как в ANSI SQL. BETWEEN может использоваться для строк или чисел.

Например, этот запрос возвращает все элементы семейств, в которых первый ребенок учится в 1–5 классах (включительно).

```sql
    SELECT *
    FROM Families.children[0] c
    WHERE c.grade BETWEEN 1 AND 5
```

В отличие от ANSI-SQL можно также использовать предложение BETWEEN в предложении FROM, как в следующем примере.

```sql
    SELECT (c.grade BETWEEN 0 AND 10)
    FROM Families.children[0] c
```

Основное различие между использованием BETWEEN в API SQL и ANSI SQL состоит в том, что можно выражать запросы в диапазоне для свойств различного типа. Например, можно использовать свойство grade (класс) в виде числа (5) в одних элементах и в виде строк в других (grade4). В таких случаях (как и в JavaScript) сравнение между результатами двух различных типов даст результат "undefined" и элемент будет пропущен.

> [!NOTE]
> Чтобы сократить время выполнения запросов, не забудьте создать политику индексации, использующую тип индекса диапазона для любых числовых свойств и путей, которые фильтруются в предложении BETWEEN.

### <a name="logical-and-or-and-not-operators"></a>Логические операторы (AND, OR или NOT)
Логические операторы работают над значениями типа Boolean. Таблицы истинности для данных операторов приведены в следующих таблицах.

**Оператор OR**

| Или | Истина | Ложь | Не определено |
| --- | --- | --- | --- |
| Истина |Истина |Истина |Истина |
| Ложь |Истина |Ложь |Не определено |
| Не определено |Истина |Не определено |Не определено |

**Оператор AND**

| И | Истина | Ложь | Не определено |
| --- | --- | --- | --- |
| Истина |Истина |Ложь |Не определено |
| Ложь |Ложь |Ложь |Ложь |
| Не определено |Не определено |Ложь |Не определено |

**Оператор NOT**

| НЕ |  |
| --- | --- |
| Истина |Ложь |
| Ложь |Истина |
| Не определено |Не определено |

## <a name="in-keyword"></a>Ключевое слово IN

Ключевое слово IN может использоваться, чтобы проверить, соответствует ли указанное значение любому значению в списке. Например, этот запрос возвращает все элементы семейств, где идентификатор равен "WakefieldFamily" или "AndersenFamily".

```sql
    SELECT *
    FROM Families
    WHERE Families.id IN ('AndersenFamily', 'WakefieldFamily')
```

Этот пример возвращает все элементы, поле state которых соответствует любому из указанных значений.

```sql
    SELECT *
    FROM Families
    WHERE Families.address.state IN ("NY", "WA", "CA", "PA", "OH", "OR", "MI", "WI", "MN", "FL")
```

## <a name="ternary--and-coalesce--operators"></a>Операторы Ternary (?) и Coalesce (??)

Операторы Ternary (тройной) и Coalesce (объединение) могут использоваться для построения условных выражений, аналогичных тем, которые создаются в популярных языках программирования, например C# и JavaScript. Оператор Ternary (?) может быть полезен при создании новых свойств JSON в режиме реального времени. Например, теперь можно писать запросы для классификации уровней класса в удобочитаемой форме, скажем, уровень Beginner/Intermediate/Advanced (начинающий, средний, продвинутый), как показано ниже.

```sql
     SELECT (c.grade < 5)? "elementary": "other" AS gradeLevel
     FROM Families.children[0] c
```

Можно также вложить вызовы операторов, как в следующем запросе.

```sql
    SELECT (c.grade < 5)? "elementary": ((c.grade < 9)? "junior": "high")  AS gradeLevel
    FROM Families.children[0] c
```

Как и при использовании других операторов запроса, если свойства, на которые добавлены ссылки в условных выражениях, отсутствуют в любом элементе, или если сравниваемые типы различны, указанные элементы исключаются из результатов запроса.

Оператор Coalesce (??) может использоваться для выполнения эффективной проверки наличия свойства у элемента. Этот оператор удобно использовать при запросах к частично структурированным данным или данным разных типов. Например, этот запрос возвращает свойство "lastName" при его наличии или "surname", если оно отсутствует.

```sql
    SELECT f.lastName ?? f.surname AS familyName
    FROM Families f
```

## <a id="EscapingReservedKeywords"></a>Доступ к свойству, заключенному в кавычки
Также можно использовать свойства с помощью оператора заключенного в кавычки свойства `[]`. Например, выражение `SELECT c.grade` and `SELECT c["grade"]` являются эквивалентными. Этот синтаксис полезен, когда необходимо экранировать свойство, которое содержит пробелы, специальные символы или совместно использует имя, совпадающее с именем ключевого слова SQL или зарезервированного слова.

```sql
    SELECT f["lastName"]
    FROM Families f
    WHERE f["id"] = "AndersenFamily"
```

## <a name="aliasing"></a>Псевдонимы

Теперь давайте расширим пример выше с явным использованием псевдонимов. AS – ключевое слово, используемое для создания псевдонимов. Оно не является обязательным, как это показано при отображении второго значения в виде `NameInfo`.

Если в запросе имеются два свойства с совпадающими именами, то должны использоваться псевдонимы для переименования одного или обоих свойств, чтобы устранить неоднозначность в отображаемом результате.

**Запрос**

```sql
    SELECT 
           { "state": f.address.state, "city": f.address.city } AS AddressInfo,
           { "name": f.id } NameInfo
    FROM Families f
    WHERE f.id = "AndersenFamily"
```

**Результаты**

```json
    [{
      "AddressInfo": {
        "state": "WA",
        "city": "seattle"
      },
      "NameInfo": {
        "name": "AndersenFamily"
      }
    }]
```

## <a name="scalar-expressions"></a>Скалярные выражения

Кроме ссылок на свойства, выражение SELECT также поддерживает скалярные выражения, такие как константы, арифметические выражения, логические выражения и т. д. Например, вот простой запрос "Hello World".

**Запрос**

```sql
    SELECT "Hello World"
```

**Результаты**

```json
    [{
      "$1": "Hello World"
    }]
```

Вот более сложный пример с использованием скалярного выражения:

**Запрос**

```sql
    SELECT ((2 + 11 % 7)-2)/3
```

**Результаты**

```json
    [{
      "$1": 1.33333
    }]
```

В следующем примере результатом скалярного выражения является логическое.

**Запрос**

```sql
    SELECT f.address.city = f.address.state AS AreFromSameCityState
    FROM Families f
```

**Результаты**

```json
    [
      {
        "AreFromSameCityState": false
      },
      {
        "AreFromSameCityState": true
      }
    ]
```

## <a name="object-and-array-creation"></a>Создание объектов и массивов

Другая ключевая возможность в API SQL — создание объекта или массива. Обратите внимание, что вы создали новый объект JSON в предыдущем примере. Кроме того, можно также создавать массивы, как показано ниже:

**Запрос**

```sql
    SELECT [f.address.city, f.address.state] AS CityState
    FROM Families f
```

**Результаты**

```json
    [
      {
        "CityState": [
          "seattle",
          "WA"
        ]
      },
      {
        "CityState": [
          "NY", 
          "NY"
        ]
      }
    ]
```

## <a id="ValueKeyword"></a>Ключевое слово VALUE

Ключевое слово **VALUE** обеспечивает способ для возврата значения JSON. Например, показанный ниже запрос возвращает скалярное значение `"Hello World"` вместо `{$1: "Hello World"}`.

**Запрос**

```sql
    SELECT VALUE "Hello World"
```

**Результаты**

```json
    [
      "Hello World"
    ]
```

Следующий запрос возвращает значение JSON без метки `"address"` в результатах.

**Запрос**

```sql
    SELECT VALUE f.address
    FROM Families f
```

**Результаты**

```json
    [
      {
        "state": "WA",
        "county": "King",
        "city": "seattle"
      }, 
      {
        "state": "NY", 
        "county": "Manhattan",
        "city": "NY"
      }
    ]
```

В следующем расширенном примере показано, как вернуть примитивные значения JSON (конечный уровень дерева JSON).

**Запрос**

```sql
    SELECT VALUE f.address.state
    FROM Families f
```

**Результаты**

```json
    [
      "WA",
      "NY"
    ]
```

## <a name="-operator"></a>Оператор *
Поддерживается специальный оператор *, который выводит элемент в виде "как есть". При его использовании должно быть единственное отображаемое поле. Хотя запрос наподобие `SELECT * FROM Families f` допустим, `SELECT VALUE * FROM Families f` и `SELECT *, f.id FROM Families f` недопустимы.

**Запрос**

```sql
    SELECT * 
    FROM Families f
    WHERE f.id = "AndersenFamily"
```

**Результаты**

```json
    [{
        "id": "AndersenFamily",
        "lastName": "Andersen",
        "parents": [
           { "firstName": "Thomas" },
           { "firstName": "Mary Kay"}
        ],
        "children": [
           {
               "firstName": "Henriette Thaulow", "gender": "female", "grade": 5,
               "pets": [{ "givenName": "Fluffy" }]
           }
        ],
        "address": { "state": "WA", "county": "King", "city": "seattle" },
        "creationDate": 1431620472,
        "isRegistered": true
    }]
```

## <a id="TopKeyword"></a>Оператор TOP

Ключевое слово TOP можно использовать для ограничения числа значений, получаемых из запроса. Если TOP используется в сочетании с предложением ORDER BY, результирующий набор ограничен первыми N упорядоченными значениями; в противном случае возвращается N первых результатов в неопределенном порядке. В инструкции SELECT рекомендуется всегда использовать предложение ORDER BY с предложением TOP. Сочетание этих двух предложений — единственный способ, который позволяет предсказуемо указать, на какие строки распространяется действие TOP. 

**Запрос**

```sql
    SELECT TOP 1 *
    FROM Families f
```

**Результаты**

```json
    [{
        "id": "AndersenFamily",
        "lastName": "Andersen",
        "parents": [
           { "firstName": "Thomas" },
           { "firstName": "Mary Kay"}
        ],
        "children": [
           {
               "firstName": "Henriette Thaulow", "gender": "female", "grade": 5,
               "pets": [{ "givenName": "Fluffy" }]
           }
        ],
        "address": { "state": "WA", "county": "King", "city": "seattle" },
        "creationDate": 1431620472,
        "isRegistered": true
    }]
```

TOP можно использовать с постоянным значением (как показано выше) или с переменным значением посредством параметризованных запросов. Дополнительные сведения см. в описании параметризованных запросов ниже.

## <a id="Aggregates"></a>Статистические функции

Можно также выполнить статистическую обработку в предложении `SELECT`. Статистические функции выполняют вычисление на наборе значений и возвращают одиночное значение. Например, приведенный ниже запрос возвращает число элементов семей в контейнере.

**Запрос**

```sql
    SELECT COUNT(1)
    FROM Families f
```

**Результаты**

```json
    [{
        "$1": 2
    }]
```

Также можно вернуть скалярное значение статического вычисления, используя ключевое слово `VALUE`. Например следующий запрос возвращает число значений как одно число:

**Запрос**

```sql
    SELECT VALUE COUNT(1)
    FROM Families f
```

**Результаты**

```json
    [ 2 ]
```

Также можно выполнять статистические вычисления в сочетании с фильтрами. Например, приведенный ниже запрос возвращает число элементов с адресом в штате Вашингтон.

**Запрос**

```sql
    SELECT VALUE COUNT(1)
    FROM Families f
    WHERE f.address.state = "WA"
```

**Результаты**

```json
    [ 1 ]
```

В указанной ниже таблице представлен список поддерживаемых статистических функций в SQL API. `SUM`и `AVG` выполняются над числовыми значениями, тогда как `COUNT`, `MIN` и `MAX` можно выполнять над числами, строками, логическими значениями и значениями NULL.

| Использование | ОПИСАНИЕ |
|-------|-------------|
| COUNT | Возвращает число элементов в выражении. |
| SUM   | Возвращает сумму всех элементов в выражении. |
| MIN   | Возвращает минимальное значение в выражении. |
| MAX   | Возвращает максимальное значение в выражении. |
| AVG   | Возвращает среднее арифметическое значений в выражении. |

Статистические вычисления также могут быть выполнены над результатом итерации массива. Дополнительные сведения см. в разделе [Итерация](#Iteration).

> [!NOTE]
> При использовании обозревателя данных на портале Azure обратите внимание, что статистические запросы могут возвращать частично агрегированные результаты на странице запроса. Пакеты SDK создают одно совокупное значение для всех страниц.
>
> Для выполнения статистических запросов с помощью кода, требуется пакет SDK версии 1.12.0 для .NET, пакет SDK версии 1.1.0 для .NET Core или пакет SDK версии 1.9.5 или выше для Java.
>

## <a id="OrderByClause"></a>Предложение ORDER BY

Как и в ANSI-SQL, вы можете включить в запрос необязательное предложение ORDER BY. Предложение может включать необязательный аргумент ASC/DESC, указывающий порядок, в котором должны быть получены результаты.

Например, ниже приведен запрос, возвращающий семьи, отсортированные по городу проживания.

**Запрос**

```sql
    SELECT f.id, f.address.city
    FROM Families f
    ORDER BY f.address.city
```

**Результаты**

```json
    [
      {
        "id": "WakefieldFamily",
        "city": "NY"
      },
      {
        "id": "AndersenFamily",
        "city": "Seattle"
      }
    ]
```

А в этом запросе возвращаются семьи, отсортированные по полю даты создания, которое хранится в виде числа и представляет собой время, прошедшее с начала эпохи, т. е. количество секунд, прошедшее с 1 января 1970 года.

**Запрос**

```sql
    SELECT f.id, f.creationDate
    FROM Families f
    ORDER BY f.creationDate DESC
```

**Результаты**

```json
    [
      {
        "id": "WakefieldFamily",
        "creationDate": 1431620462
      },
      {
        "id": "AndersenFamily",
        "creationDate": 1431620472
      }
    ]
```

## <a id="Advanced"></a>Дополнительные понятия базы данных и SQL-запросов

### <a id="Iteration"></a>Итерация

Мы добавили новую конструкцию, чтобы обеспечить поддержку перебора массивов JSON с помощью ключевого слова **IN** в SQL API. Исходное выражение FROM поддерживает итерацию. Начнем с такого примера:

**Запрос**

```sql
    SELECT *
    FROM Families.children
```

**Результаты**

```json
    [
      [
        {
          "firstName": "Henriette Thaulow",
          "gender": "female",
          "grade": 5,
          "pets": [{ "givenName": "Fluffy"}]
        }
      ], 
      [
        {
            "familyName": "Merriam",
            "givenName": "Jesse",
            "gender": "female",
            "grade": 1
        }, 
        {
            "familyName": "Miller",
            "givenName": "Lisa",
            "gender": "female",
            "grade": 8
        }
      ]
    ]
```

Теперь давайте посмотрим на другой запрос, который предназначен для итерации по членам контейнера. Обратите внимание на различия в результирующем массиве. Этот пример разбивает `children` и собирает результаты в единый массив.  

**Запрос**

```sql
    SELECT *
    FROM c IN Families.children
```

**Результаты**

```json
    [
      {
          "firstName": "Henriette Thaulow",
          "gender": "female",
          "grade": 5,
          "pets": [{ "givenName": "Fluffy" }]
      },
      {
          "familyName": "Merriam",
          "givenName": "Jesse",
          "gender": "female",
          "grade": 1
      },
      {
          "familyName": "Miller",
          "givenName": "Lisa",
          "gender": "female",
          "grade": 8
      }
    ]
```

Это можно в дальнейшем использовать для фильтрации каждой конкретной записи массива, как показано в следующем примере:

**Запрос**

```sql
    SELECT c.givenName
    FROM c IN Families.children
    WHERE c.grade = 8
```

**Результаты**

```json
    [{
      "givenName": "Lisa"
    }]
```

Можно также выполнить статистическую обработку результатов итерации массива. Например, следующий запрос подсчитывает число детей во всех семьях.

**Запрос**

```sql
    SELECT COUNT(child)
    FROM child IN Families.children
```

**Результаты**

```json
    [
      {
        "$1": 3
      }
    ]
```

### <a id="Joins"></a>Соединения

В реляционных базах данных возможность соединения таблиц является важной. Это всего логическое следствие проектирования нормализованных схем. В противоположность этому API SQL работает с денормализованной моделью данных элементов без схемы, которая является логическим эквивалентом "самосоединения".

`<from_source1> JOIN <from_source2> JOIN ... JOIN <from_sourceN>` — это синтаксис, который поддерживает язык. Этот запрос будет возвращать набор **N**-кортежей (кортежей, у которых число значений равно **N**). Каждый кортеж будет со значениями, полученными путем итерации всех псевдонимов контейнера среди их наборов. Другими словами, этот запрос выполняет полное векторное произведение множеств, участвующих в соединении.

Ниже приведены примеры, иллюстрирующие работу соединений. В приведенном ниже примере результат пуст, так как векторное произведение каждого элемента из исходного и пустого множества дает пустое множество.

**Запрос**

```sql
    SELECT f.id
    FROM Families f
    JOIN f.NonExistent
```

**Результаты**

```json
    [{
    }]
```

В приведенном ниже примере показано соединение между корнем элемента и подкорнем `children`. Это векторное произведение между двумя объектами JSON. Дочерние элементы этого массива не оказывают влияния в JOIN, так как мы имеем дело с одним корнем, который является массивом дочерних элементов. Мы получаем только два результата, так как векторное произведение каждого элемента с массивом дает только один элемент.

**Запрос**

```sql
    SELECT f.id
    FROM Families f
    JOIN f.children
```

**Результаты**

```json
    [
      {
        "id": "AndersenFamily"
      },
      {
        "id": "WakefieldFamily"
      }
    ]
```

Следующий пример является более традиционным присоединением:

**Запрос**

```sql
    SELECT f.id
    FROM Families f
    JOIN c IN f.children
```

**Результаты**

```json
    [
      {
        "id": "AndersenFamily"
      },
      {
        "id": "WakefieldFamily"
      },
      {
        "id": "WakefieldFamily"
      }
    ]
```

Прежде всего, следует помнить, что `from_source` из предложения **JOIN** является итератором. В этом случае поток выглядит следующим образом.  

* Развернуть все дочерние элементы **c** в массиве.
* Примените векторное произведение корня элемента **f** с каждым дочерним элементом **c**, развернутым на первом шаге.
* В конце выполните проецирование только для имени **f** свойства объекта корневого документа.

Первый элемент (`AndersenFamily`) содержит только один дочерний элемент, так что результирующий набор содержит только один соответствующий этому элементу объект. Второй элемент (`WakefieldFamily`) имеет два дочерних элемента. Таким образом, векторное произведение создает отдельный объект для каждого дочернего элемента, в результате получаются два объекта — по одному для каждого дочернего элемента, соответствующего этому элементу. Корневые поля в обоих этих элементах будут такими же, как и ожидаемые при векторном произведении.

Реальное применение соединения заключается в формировании кортежей из векторного произведения в форме, которую отобразить иначе сложно. Кроме того, как мы увидим в следующем примере, можно фильтровать сочетания кортежа, что позволяет пользователю выбрать условие, которому удовлетворяют кортежи в целом.

**Запрос**

```sql
    SELECT 
        f.id AS familyName,
        c.givenName AS childGivenName,
        c.firstName AS childFirstName,
        p.givenName AS petName
    FROM Families f
    JOIN c IN f.children
    JOIN p IN c.pets
```

**Результаты**

```json
    [
      {
        "familyName": "AndersenFamily",
        "childFirstName": "Henriette Thaulow",
        "petName": "Fluffy"
      },
      {
        "familyName": "WakefieldFamily",
        "childGivenName": "Jesse",
        "petName": "Goofy"
      }, 
      {
       "familyName": "WakefieldFamily",
       "childGivenName": "Jesse",
       "petName": "Shadow"
      }
    ]
```

Этот пример является естественным продолжением предыдущего и выполняет двойное соединение. Таким образом, перекрестное произведение можно рассматривать как следующий псевдокод:

```
    for-each(Family f in Families)
    {
        for-each(Child c in f.children)
        {
            for-each(Pet p in c.pets)
            {
                return (Tuple(f.id AS familyName,
                  c.givenName AS childGivenName,
                  c.firstName AS childFirstName,
                  p.givenName AS petName));
            }
        }
    }
```

`AndersenFamily` имеется один ребенок, у которого один питомец. Векторное произведение представляет собой одну строку (1\*1\*1) в случае этого семейства. Однако семейство Wakefield включает двух детей, но только у одного ребенка «Джесси» есть питомцы. У Джесси два питомца. Векторное произведение представляет собой две строки (1\*1\*2 = 2) в случае этого семейства.

В приведенном ниже примере есть дополнительный фильтр для `pet`, исключающий все кортежи, у которых имя питомца не "Shadow". Обратите внимание, что мы можем построить кортежи из массивов, установить фильтр на любой из элементов набора и проецировать любую комбинацию из элементов.

**Запрос**

```sql
    SELECT 
        f.id AS familyName,
        c.givenName AS childGivenName,
        c.firstName AS childFirstName,
        p.givenName AS petName
    FROM Families f
    JOIN c IN f.children
    JOIN p IN c.pets
    WHERE p.givenName = "Shadow"
```

**Результаты**

```json
    [
      {
       "familyName": "WakefieldFamily",
       "childGivenName": "Jesse",
       "petName": "Shadow"
      }
    ]
```

## <a id="JavaScriptIntegration"></a>Интеграция JavaScript

Azure Cosmos DB предоставляет модель программирования, позволяющую выполнять логику приложения на языке JavaScript непосредственно в контейнерах в виде хранимых процедур и триггеров. Такой метод позволяет делать следующее:

* Создавать высокопроизводительные транзакционные операции CRUD и запросы к элементам в контейнере благодаря глубокой интеграции среды выполнения JavaScript в ядро СУБД.
* Добиться естественного моделирования потока управления, областей видимости переменных, присвоения и интеграции обработки исключений примитивов с транзакциями базы данных. Дополнительные сведения о поддержке интеграции JavaScript в Azure Cosmos DB см. в документации по программированию JavaScript на стороне сервера.

### <a id="UserDefinedFunctions"></a>Определяемые пользователем функции (UDF)

Наряду с уже указанными в статье типами SQL API обеспечивает поддержку определяемых пользователем функций (UDF). В частности, поддерживаются скалярные пользовательские функции, где разработчики могут передавать или ни одного, или несколько аргументов и получить один результат. Каждый из этих аргументов проверяется на соответствие допустимым значениям JSON.  

Синтаксис SQL расширяется за счет использования этих определяемых пользователем функций для поддержки настраиваемой логики приложения. Пользовательские функции можно зарегистрировать в SQL API, а затем на них можно ссылаться как на часть SQL-запроса. На самом деле пользовательские функции специально предназначены для вызовов из запросов. Как следствие этого выбора, UDF не имеют доступа к объекту контекста, какой имеется у других типов JavaScript (хранимых процедуры, триггеров). Поскольку запросы выполняются только для чтения, они могут работать как на первичной, так на вторичной репликах. Поэтому UDF предназначены для работы на вторичных репликах, в отличие от других типов JavaScript.

Ниже приведен пример регистрации определяемых пользователем функций в базе данных Cosmos DB, а точнее в контейнере элементов.

```javascript
       UserDefinedFunction regexMatchUdf = new UserDefinedFunction
       {
           Id = "REGEX_MATCH",
           Body = @"function (input, pattern) {
                       return input.match(pattern) !== null;
                   };",
       };

       UserDefinedFunction createdUdf = client.CreateUserDefinedFunctionAsync(
           UriFactory.CreateDocumentCollectionUri("myDatabase", "families"),
           regexMatchUdf).Result;  
```

В предыдущем примере создается определяемая пользователем функция с именем `REGEX_MATCH`. Она принимает два строковых значения JSON — `input` and `pattern` — и проверяет, совпадает ли значение первого поля с шаблоном, указанным во втором поле, с помощью функции string.match() JavaScript.

Теперь мы можем использовать эту определяемую пользователем функцию в запросе в проекции. При вызовах внутри запросов определяемые пользователем функции следует дополнять префиксом udf. с учетом регистра.

> [!NOTE]
> До 17 марта 2015 года компонент Cosmos DB поддерживал вызовы UDF без префикса udf., например SELECT REGEX_MATCH(). Теперь этот метод выполнения вызовов устарел.  
>

**Запрос**

```sql
    SELECT udf.REGEX_MATCH(Families.address.city, ".*eattle")
    FROM Families
```

**Результаты**

```json
    [
      {
        "$1": true
      },
      {
        "$1": false
      }
    ]
```

Определяемая пользователем функция также может быть использована внутри фильтра при условии дополнения префиксом udf., как показано в примере ниже.

**Запрос**

```sql
    SELECT Families.id, Families.address.city
    FROM Families
    WHERE udf.REGEX_MATCH(Families.address.city, ".*eattle")
```

**Результаты**

```json
    [{
        "id": "AndersenFamily",
        "city": "Seattle"
    }]
```

В сущности, определяемые пользователем функции являются корректными скалярными выражениями и могут быть использованы в проекциях и фильтрах.

Для расширения понимания возможностей пользовательских функций, давайте посмотрим на другой пример с условной логикой:

```javascript
       UserDefinedFunction seaLevelUdf = new UserDefinedFunction()
       {
           Id = "SEALEVEL",
           Body = @"function(city) {
                   switch (city) {
                       case 'seattle':
                           return 520;
                       case 'NY':
                           return 410;
                       case 'Chicago':
                           return 673;
                       default:
                           return -1;
                    }"
            };

            UserDefinedFunction createdUdf = await client.CreateUserDefinedFunctionAsync(
                UriFactory.CreateDocumentCollectionUri("myDatabase", "families"),
                seaLevelUdf);
```

Ниже приведен пример осуществления UDF.

**Запрос**

```sql
    SELECT f.address.city, udf.SEALEVEL(f.address.city) AS seaLevel
    FROM Families f
```

**Результаты**

```json
     [
      {
        "city": "seattle",
        "seaLevel": 520
      },
      {
        "city": "NY",
        "seaLevel": 410
      }
    ]
```

Как показывают приведенные выше примеры, определяемые пользователем функции объединяют мощь языка JavaScript и SQL API, чтобы обеспечить богатый программируемый интерфейс для реализации сложной процедурной, условной логики с помощью встроенных возможностей исполнения JavaScript.

На современном этапе обработки UDF API SQL передает аргументы в определяемые пользователем функции для каждого элемента в источнике (выражение WHERE или SELECT). Результаты включены в общий поток выполнения. Если свойства, на которые ссылаются параметры UDF, недоступны в значениях JSON, параметр рассматривается как неопределенный, и, следовательно, вызов UDF полностью пропускается. Аналогично, если результат определяемой пользователем функции не определен, он не включается в результат.

Таким образом, определяемые пользователем функции являются отличным средством для реализации сложной бизнес-логики в составе запроса.

### <a name="operator-evaluation"></a>Оценивание операторов

Cosmos DB, в силу того что это база данных JSON, проводит параллели с операторами JavaScript и его оценочной семантикой. В то время как Cosmos DB старается сохранить семантику JavaScript в плане поддержки JSON, оценка операторов в некоторых случаях не совпадает.

В SQL API, в отличие от традиционного SQL, типы значений зачастую неизвестны до тех пор, пока значения не будут извлечены из базы данных. Для того чтобы эффективно выполнять запросы, большинство операторов имеют строгие требования к типам.

SQL API не выполняет неявные преобразования в отличие от JavaScript. Например, запрос `SELECT * FROM Person p WHERE p.Age = 21` соответствует элементам, которые содержат свойство "возраст" со значением 21. Любой другой элемент, свойство "возраст" в котором соответствует строке "21" или другим вариациям, таким как "021", "21.0", "0021", "00021" и т. д., не будет возвращен. Это вступает в противоречие с JavaScript, в котором значения строк приведены к цифрам (в зависимости от оператора, например: ==). Этот выбор имеет решающее значение для эффективного согласования индексов в SQL API.

## <a name="parameterized-sql-queries"></a>Параметризованные SQL-запросы

Cosmos DB поддерживает запросы с параметрами, выраженными с помощью привычной нотации \@. Параметризованный SQL обеспечивает надежную обработку и экранирование пользовательского ввода, предотвращая случайное раскрытие данных через внедрение кода SQL.

Например, можно написать запрос, который принимает в качестве параметров фамилию и состояние адреса, а затем выполнить его для различных значений параметров фамилия и состояние адреса на основе ввода пользователя.

```sql
    SELECT *
    FROM Families f
    WHERE f.lastName = @lastName AND f.address.state = @addressState
```

Этот запрос далее можно отправить в Cosmos DB в качестве параметризованного запроса JSON, как показано ниже.

```sql
    {
        "query": "SELECT * FROM Families f WHERE f.lastName = @lastName AND f.address.state = @addressState",
        "parameters": [
            {"name": "@lastName", "value": "Wakefield"},
            {"name": "@addressState", "value": "NY"},
        ]
    }
```

Аргумент для TOP можно задать с помощью параметризованных запросов, например, таких, как показано ниже.

```sql
    {
        "query": "SELECT TOP @n * FROM Families",
        "parameters": [
            {"name": "@n", "value": 10},
        ]
    }
```

Значениями параметров могут быть любые допустимые JSON (строки, числа, логические значения, значения null, даже массивы или вложенные JSON). Кроме этого, так как Cosmos DB не имеет схемы, параметры не проверяются на соответствие типам.

## <a id="BuiltinFunctions"></a>Встроенные функции

Cosmos DB также поддерживает несколько встроенных функций для общих операций, которые можно использовать в запросах как определяемые пользователем функции.

| Группа функций | Операции |
|---------|----------|
| Математические функции | ABS, CEILING, EXP, FLOOR, LOG, LOG10, POWER, ROUND, SIGN, SQRT, SQUARE, TRUNC, ACOS, ASIN, ATAN, ATN2, COS, COT, DEGREES, PI, RADIANS, SIN, TAN |
| Функции проверки типа | IS_ARRAY, IS_BOOL, IS_NULL, IS_NUMBER, IS_OBJECT, IS_STRING, IS_DEFINED, IS_PRIMITIVE |
| Строковые функции | CONCAT, CONTAINS, ENDSWITH, INDEX_OF, LEFT, LENGTH, LOWER, LTRIM, REPLACE, REPLICATE, REVERSE, RIGHT, RTRIM, STARTSWITH, SUBSTRING, UPPER |
| Функции массивов | ARRAY_CONCAT, ARRAY_CONTAINS, ARRAY_LENGTH и ARRAY_SLICE |
| Пространственные функции | ST_DISTANCE, ST_WITHIN, ST_INTERSECTS, ST_ISVALID, ST_ISVALIDDETAILED |

Если вы сейчас используете определяемую пользователем функцию (UDF), для которой теперь появилась встроенная функция, следует использовать соответствующую встроенную функцию, так как она будет выполняться быстрее и гораздо эффективнее.

### <a name="mathematical-functions"></a>Математические функции

Математические функции выполняют вычисление, которое основано на входных значениях, предоставляемых в форме аргументов, и возвращают числовое значение. Здесь приведен список поддерживаемых встроенных математических функций.

| Использование | ОПИСАНИЕ |
|----------|--------|
| [[ABS (num_expr)](#bk_abs) | Возвращает модуль (положительное значение) указанного числового выражения. |
| [CEILING (num_expr)](#bk_ceiling) | Возвращает наименьшее целочисленное значение, которое больше или равно указанному числовому выражению. |
| [FLOOR (num_expr)](#bk_floor) | Возвращает наибольшее целочисленное значение, которое меньше или равно указанному числовому выражению. |
| [EXP (num_expr)](#bk_exp) | Возвращает значение экспоненты для указанного числового выражения. |
| [LOG (num_expr [,base])](#bk_log) | Возвращает натуральный логарифм от указанного числового выражения либо логарифм по заданному основанию |
| [LOG10 (num_expr)](#bk_log10) | Возвращает десятичный логарифм от указанного числового выражения. |
| [ROUND (num_expr)](#bk_round) | Возвращает числовое значение, округленное до ближайшего целого значения в большую сторону. |
| [TRUNC (num_expr)](#bk_trunc) | Возвращает числовое значение, округленное до ближайшего целого значения в меньшую сторону. |
| [SQRT (num_expr)](#bk_sqrt) | Возвращает квадратный корень из указанного числового выражения. |
| [SQUARE (num_expr)](#bk_square) | Возвращает указанное числовое выражение, возведенное в квадрат. |
| [POWER (num_expr, num_expr)](#bk_power) | Возвращает указанное числовое выражение, возведенное в заданную степень. |
| [SIGN (num_expr)](#bk_sign) | Возвращает значение, обозначающее знак (-1, 0, 1) указанного числового выражения. |
| [ACOS (num_expr)](#bk_acos) | Возвращает угол в радианах, косинус которого равен указанному числовому выражению; также называется арккосинусом. |
| [ASIN (num_expr)](#bk_asin) | Возвращает угол в радианах, синус которого равен указанному числовому выражению. Также называется арксинусом. |
| [ATAN (num_expr)](#bk_atan) | Возвращает угол в радианах, тангенс которого равен указанному числовому выражению. Также называется арктангенсом. |
| [ATN2 (num_expr)](#bk_atn2) | Возвращает угол в радианах между положительным направлением оси x и лучом, проведенным из начала координат в точку (y, x), где x и y — значения двух заданных выражений с плавающей запятой. |
| [COS (num_expr)](#bk_cos) | Возвращает тригонометрический косинус указанного угла в радианах в указанном выражении. |
| [COT (num_expr)](#bk_cot) | Возвращает тригонометрический котангенс указанного угла в радианах в указанном числовом выражении. |
| [DEGREES (num_expr)](#bk_degrees) | Возвращает соответствующее значение угла в градусах для угла, указанного в радианах. |
| [PI ()](#bk_pi) | Возвращает значение константы "пи". |
| [RADIANS (num_expr)](#bk_radians) | Возвращает значение угла в радианах для числового значения, указанного в градусах. |
| [SIN (num_expr)](#bk_sin) | Возвращает тригонометрический синус заданного угла в радианах для указанного выражения. |
| [TAN (num_expr)](#bk_tan) | Возвращает тангенс угла для указанного выражения. |

Например, теперь можно выполнять запросы, как показано в этом примере.

**Запрос**

```sql
    SELECT VALUE ABS(-4)
```

**Результаты**

```json
    [4]
```

Основное отличие функций Cosmos DB от ANSI SQL заключается в том, что они предназначены для работы с данными, не имеющими схемы или имеющими смешанную схему. Если есть элемент, в котором свойство Size отсутствует или имеет нечисловое значение, например unknown (неизвестно), такой элемент будет пропущен без сообщения об ошибке.

### <a name="type-checking-functions"></a>Функции проверки типа

Функции проверки типа позволяют проверять тип выражения в запросах SQL. Функции проверки типа можно использовать для оперативного определения типа свойств в элементах, если он представлен переменной или неизвестен. Здесь приведен список поддерживаемых встроенных функций проверки типа.

| **Использование** | **Описание** |
|-----------|------------|
| [IS_ARRAY (expr)](sql-api-query-reference.md#bk_is_array) | Возвращает логическое значение, указывающее, является ли значение массивом. |
| [IS_BOOL (expr)](sql-api-query-reference.md#bk_is_bool) | Возвращает логическое значение, указывающее, является ли значение логическим выражением. |
| [IS_NULL (expr)](sql-api-query-reference.md#bk_is_null) | Возвращает логическое значение, указывающее, имеет ли значение тип NULL. |
| [IS_NUMBER (expr)](sql-api-query-reference.md#bk_is_number) | Возвращает логическое значение, указывающее, является ли значение числом. |
| [IS_OBJECT (expr)](sql-api-query-reference.md#bk_is_object) | Возвращает логическое значение, указывающее, является ли значение объектом JSON. |
| [IS_STRING (expr)](sql-api-query-reference.md#bk_is_string) | Возвращает логическое значение, указывающее, является ли значение строкой. |
| [IS_DEFINED (expr)](sql-api-query-reference.md#bk_is_defined) | Возвращает логическое значение, указывающее, назначено ли свойству значение. |
| [IS_PRIMITIVE (expr)](sql-api-query-reference.md#bk_is_primitive) | Возвращает логическое значение, указывающее, является ли тип значения строковым, числовым, логическим или null. |

С помощью этих функций можно выполнять запросы, как показано в приведенном ниже примере.

**Запрос**

```sql
    SELECT VALUE IS_NUMBER(-4)
```

**Результаты**

```json
    [true]
```

### <a name="string-functions"></a>Строковые функции

Следующие скалярные функции выполняют операцию над входным строковым значением и возвращают строковое, числовое или логическое значение. Ниже приведена таблица встроенных строковых функций:

| Использование | ОПИСАНИЕ |
| --- | --- |
| [LENGTH (str_expr)](sql-api-query-reference.md#bk_length) | Возвращает число символов указанного строкового выражения. |
| [CONCAT (str_expr, str_expr [, str_expr])](sql-api-query-reference.md#bk_concat) | Возвращает строку, являющуюся результатом объединения двух или более строковых значений. |
| [SUBSTRING (str_expr, num_expr, num_expr)](sql-api-query-reference.md#bk_substring) | Возвращает часть строкового выражения. |
| [STARTSWITH (str_expr, str_expr)](sql-api-query-reference.md#bk_startswith) | Возвращает значение логического типа, указывающее, начинается ли первое строковое выражение вторым. |
| [ENDSWITH (str_expr, str_expr)](sql-api-query-reference.md#bk_endswith) | Возвращает значение логического типа, указывающее, начинается ли первое строковое выражение вторым |
| [CONTAINS (str_expr, str_expr)](sql-api-query-reference.md#bk_contains) | Возвращает значение логического типа, указывающее, содержит ли первое строковое выражение второе. |
| [INDEX_OF (str_expr, str_expr)](sql-api-query-reference.md#bk_index_of) | Возвращает начальную позицию первого вхождения второго строкового выражения в первое указанное строковое выражение или –1, если строка не найдена. |
| [LEFT (str_expr, num_expr)](sql-api-query-reference.md#bk_left) | Возвращает левую часть строки с указанным количеством символов. |
| [RIGHT (str_expr, num_expr)](sql-api-query-reference.md#bk_right) | Возвращает правую часть строки с указанным количеством символов. |
| [LTRIM (str_expr)](sql-api-query-reference.md#bk_ltrim) | Возвращает строковое выражение после удаления начальных пробелов. |
| [RTRIM (str_expr)](sql-api-query-reference.md#bk_rtrim) | Возвращает строковое выражение после усечения всех конечных пробелов. |
| [LOWER (str_expr)](sql-api-query-reference.md#bk_lower) | Возвращает строковое выражение после преобразования символов верхнего регистра в нижний. |
| [UPPER (str_expr)](sql-api-query-reference.md#bk_upper) | Возвращает строковое выражение после преобразования символов нижнего регистра в верхний. |
| [REPLACE (str_expr, str_expr, str_expr)](sql-api-query-reference.md#bk_replace) | Заменяет все вхождения указанного строкового значения другим строковым значением. |
| [REPLICATE (str_expr, num_expr)](https://docs.microsoft.com/azure/cosmos-db/sql-api-sql-query-reference#bk_replicate) | Повторяет строковое значение указанное число раз. |
| [REVERSE (str_expr)](sql-api-query-reference.md#bk_reverse) | Возвращает обратный порядок строкового значения. |

С помощью этих функций можно выполнять запросы следующего вида: Например, вот таким образом можно возвратить имя семьи в верхнем регистре:

**Запрос**

```sql
    SELECT VALUE UPPER(Families.id)
    FROM Families
```

**Результаты**

```json
    [
        "WAKEFIELDFAMILY",
        "ANDERSENFAMILY"
    ]
```

Или объединить строки, как в этом примере:

**Запрос**

```sql
    SELECT Families.id, CONCAT(Families.address.city, ",", Families.address.state) AS location
    FROM Families
```

**Результаты**

```json
    [{
      "id": "WakefieldFamily",
      "location": "NY,NY"
    },
    {
      "id": "AndersenFamily",
      "location": "seattle,WA"
    }]
```

Кроме того, строковые функции можно использовать в предложении WHERE для фильтрации результатов, как это показано в следующем примере:

**Запрос**

```sql
    SELECT Families.id, Families.address.city
    FROM Families
    WHERE STARTSWITH(Families.id, "Wakefield")
```

**Результаты**

```json
    [{
      "id": "WakefieldFamily",
      "city": "NY"
    }]
```

### <a name="array-functions"></a>Функции массивов

Приведенные ниже скалярные функции выполняют операцию над входным массивом и возвращают числовое или логическое значение либо же массив. Ниже приведена таблица встроенных функций над массивом:

| Использование | ОПИСАНИЕ |
| --- | --- |
| [ARRAY_LENGTH (arr_expr)](sql-api-query-reference.md#bk_array_length) |Возвращает число элементов массива, указанного в выражении. |
| [ARRAY_CONCAT (arr_expr, arr_expr [, arr_expr])](sql-api-query-reference.md#bk_array_concat) |Возвращает массив, который является результатом объединения значений двух или более массивов. |
| [ARRAY_CONTAINS (arr_expr, expr [, bool_expr])](sql-api-query-reference.md#bk_array_contains) |Возвращает логическое значение, указывающее, содержит ли массив указанное значение. Можно указать, будет ли сопоставление полным или частичным. |
| [ARRAY_SLICE (arr_expr, num_expr [, num_expr])](sql-api-query-reference.md#bk_array_slice) |Возвращает часть выражения массива. |

Функции массивов могут использоваться для обработки массивов в JSON. Например, приведенный ниже запрос возвращает все элементы, в которых присутствует родительский элемент "Robin Wakefield". 

**Запрос**

```sql
    SELECT Families.id 
    FROM Families 
    WHERE ARRAY_CONTAINS(Families.parents, { givenName: "Robin", familyName: "Wakefield" })
```

**Результаты**

```json
    [{
      "id": "WakefieldFamily"
    }]
```

Можно указать часть фрагмента для сопоставления элементов в массиве. Следующий запрос находит все родительские элементы, где для параметра `givenName` указано значение `Robin`.

**Запрос**

```sql
    SELECT Families.id 
    FROM Families 
    WHERE ARRAY_CONTAINS(Families.parents, { givenName: "Robin" }, true)
```

**Результаты**

```json
    [{
      "id": "WakefieldFamily"
    }]
```

Вот другой пример, использующий функцию ARRAY_LENGTH для получения числа потомков каждого семейства.

**Запрос**

```sql
    SELECT Families.id, ARRAY_LENGTH(Families.children) AS numberOfChildren
    FROM Families 
```

**Результаты**

```json
    [{
      "id": "WakefieldFamily",
      "numberOfChildren": 2
    },
    {
      "id": "AndersenFamily",
      "numberOfChildren": 1
    }]
```

### <a name="spatial-functions"></a>Пространственные функции

Cosmos DB поддерживает следующие встроенные функции Открытого геопространственного консорциума (OGC) для выполнения запросов к геопространственным данным. 

| Использование | ОПИСАНИЕ |
| --- | --- |
| ST_DISTANCE (point_expr, point_expr) | Возвращает расстояние между двумя выражениями точек GeoJSON, многоугольников или объектов LineString. |
| T_WITHIN (point_expr, polygon_expr) | Возвращает логическое выражение, указывающее, располагается ли первый объект GeoJSON (точка, многоугольник или LineString) внутри второго объекта GeoJSON (точка, многоугольник или LineString). |
| ST_INTERSECTS (spatial_expr, spatial_expr) | Возвращает логическое выражение, указывающее, пересекаются ли два объекта GeoJSON (точка, многоугольник или LineString). |
| ST_ISVALID | Возвращает логическое значение, указывающее, является ли действительным выражение GeoJSON (точка, многоугольник или LineString). |
| ST_ISVALIDDETAILED | Возвращает значение JSON, содержащее логическое значение, указывающее, является ли выражение GeoJSON (точка, многоугольник или LineString) действительным. Если оно является недействительным, то возвращаемое значение также содержит строку с описанием причины. |

Пространственные функции могут использоваться для выполнения запросов близости к пространственным данным. Например, приведенный ниже запрос возвращает все элементы семейств, которые находятся в пределах 30 км от заданного расположения, с помощью встроенной функции ST_DISTANCE.

**Запрос**

```sql
    SELECT f.id
    FROM Families f
    WHERE ST_DISTANCE(f.location, {'type': 'Point', 'coordinates':[31.9, -4.8]}) < 30000
```

**Результаты**

```json
    [{
      "id": "WakefieldFamily"
    }]
```

Дополнительные сведения см. в статье о [работе с геопространственными данными в Azure Cosmos DB](geospatial.md). Он связывает пространственные функции и синтаксис SQL для Cosmos DB. Теперь давайте рассмотрим схему работы запросов LINQ и их взаимодействие с синтаксисом, который мы уже видели.

## <a id="Linq"></a>API LINQ to SQL

LINQ является моделью программирования .NET, которая выражает вычисления в виде запросов потоков объектов. Cosmos DB обеспечивает клиентскую библиотеку для взаимодействия с LINQ путем облегчения преобразования между JSON и объектами .NET и сопоставления подмножества запросов LINQ с запросами Cosmos DB.

На рисунке ниже показана архитектура поддержки запросов LINQ при использовании Cosmos DB.  Используя клиент Cosmos DB, разработчики могут создать объект **IQueryable**, который будет направлять запросы к поставщику запросов Cosmos DB, который затем транслирует запросы LINQ в запросы Cosmos DB. Затем запрос передается на сервер Cosmos DB для получения набора результатов в формате JSON. Возвращенные результаты десериализуются в поток объектов .NET на стороне клиента.

![Архитектура поддержки запросов LINQ с помощью SQL API — синтаксис SQL, язык запросов JSON, основные понятия баз данных и SQL-запросы][1]

### <a name="net-and-json-mapping"></a>Сопоставление .NET и JSON

Сопоставление между объектами .NET и элементами JSON естественно: каждый член поля данных сопоставляется с объектом JSON, в котором имя поля сопоставляется с "ключевой" частью объекта, а часть "значений" рекурсивно сопоставляется с частью значений объекта. Рассмотрим следующий пример. Созданный объект Family сопоставлен с элементом JSON, как показано ниже. И наоборот, элемент JSON, в свою очередь, сопоставлен с объектом .NET.

**Класс C#**

```csharp
    public class Family
    {
        [JsonProperty(PropertyName="id")]
        public string Id;
        public Parent[] parents;
        public Child[] children;
        public bool isRegistered;
    };

    public struct Parent
    {
        public string familyName;
        public string givenName;
    };

    public class Child
    {
        public string familyName;
        public string givenName;
        public string gender;
        public int grade;
        public List<Pet> pets;
    };

    public class Pet
    {
        public string givenName;
    };

    public class Address
    {
        public string state;
        public string county;
        public string city;
    };

    // Create a Family object.
    Parent mother = new Parent { familyName= "Wakefield", givenName="Robin" };
    Parent father = new Parent { familyName = "Miller", givenName = "Ben" };
    Child child = new Child { familyName="Merriam", givenName="Jesse", gender="female", grade=1 };
    Pet pet = new Pet { givenName = "Fluffy" };
    Address address = new Address { state = "NY", county = "Manhattan", city = "NY" };
    Family family = new Family { Id = "WakefieldFamily", parents = new Parent [] { mother, father}, children = new Child[] { child }, isRegistered = false };
```

**JSON**

```json
    {
        "id": "WakefieldFamily",
        "parents": [
            { "familyName": "Wakefield", "givenName": "Robin" },
            { "familyName": "Miller", "givenName": "Ben" }
        ],
        "children": [
            {
                "familyName": "Merriam",
                "givenName": "Jesse",
                "gender": "female",
                "grade": 1,
                "pets": [
                    { "givenName": "Goofy" },
                    { "givenName": "Shadow" }
                ]
            },
            { 
              "familyName": "Miller",
              "givenName": "Lisa",
              "gender": "female",
              "grade": 8
            }
        ],
        "address": { "state": "NY", "county": "Manhattan", "city": "NY" },
        "isRegistered": false
    };
```


### <a name="linq-to-sql-translation"></a>Трансляция из LINQ в SQL

Поставщик запросов Cosmos DB пытается как можно правильнее отобразить соответствие запроса LINQ запросу SQL Cosmos DB. В дальнейшем мы предполагаем, что у читателя имеются базовые знания о LINQ.

Во-первых, для системы типов; мы поддерживаем все примитивные типы JSON: числовые типы, логические, строковые и NULL. Поддерживаются только эти типы JSON. Поддерживаются следующие скалярные выражения.

* Постоянные значения. Включают в себя постоянные значения примитивных типов данных, которые вычисляются на момент.
* Выражения свойств/индексов массивов. Относятся к свойствам объекта или элемента массива.
  
     family.Id;    family.children[0].familyName;    family.children[0].grade;    family.children[n].grade; //n — это целочисленная переменная
* Арифметические выражения. К ним относятся общие арифметические выражения на основе численных и логических значений. Для получения полного списка обратитесь к спецификации SQL, указанной выше.
  
     2 * family.children[0].grade;    x + y;
* Выражение сравнения строк. Включает сравнение строкового значения с некоторым постоянным строковым значением.  
  
     mother.familyName == "Smith";    child.givenName == s; //s — это строковая переменная
* Выражение создания объекта/массива. Возвращают объект комбинированного типа, или анонимного типа, или массив таких объектов. Эти значения могут быть вложенными.
  
     new Parent { familyName = "Smith", givenName = "Joe" }; new { first = 1, second = 2 }; //анонимный тип с двумя полями              
     new int[] { 3, child.grade, 5 };

### <a id="SupportedLinqOperators"></a>Список поддерживаемых операторов LINQ

Ниже приведен список поддерживаемых операторов LINQ в поставщике LINQ, входящем в состав пакета SDK SQL .NET.

* **Select**. Проекции преобразуются в SQL SELECT, включая создание объектов.
* **Where**. Фильтры преобразовываются в инструкцию SQL WHERE, а также поддерживают преобразование &&, || и ! в операторы SQL.
* **SelectMany**. Позволяет выполнять очистку массивов в предложение SQL JOIN. Может использоваться для вложения выражений или объединения их в цепочку для фильтрации по элементам массива.
* **OrderBy и OrderByDescending**. Выполняет упорядочение (ORDER BY) по возрастанию или по убыванию.
* Операторы для агрегирования **Count**, **Sum**, **Min**, **Max**, **Average** и их асинхронные эквиваленты **CountAsync**, **SumAsync**, **MinAsync**, **MaxAsync** и **AverageAsync**.
* **CompareTo**. Выполняет преобразование в сравнение диапазонов. Обычно используется для строк, так как их нельзя сравнивать в .NET.
* **Take**. Выполняет преобразование в SQL TOP для ограничения результатов запроса.
* **Математические функции**. Поддерживает преобразование из Abs, Acos, Asin, Atan, Ceiling, Cos, Exp, Floor, Log, Log10, Pow, Round, Sign, Sin, Sqrt, Tan, Truncate платформы .NET в эквивалентные встроенные функции SQL.
* **Строковые функции**. Поддерживает преобразование из Concat, Contains, EndsWith, IndexOf, Count, ToLower, TrimStart, Replace, Reverse, TrimEnd, StartsWith, SubString, ToUpper платформы .NET в эквивалентные встроенные функции SQL.
* **Функции массивов**. Поддерживает преобразование из Concat, Contains и Count платформы .NET в эквивалентные встроенные функции SQL.
* **Функции геопространственных расширений**. Поддерживает преобразование из операторов Distance, Within, IsValid и IsValidDetailed методов заглушки в эквивалентные встроенные функции SQL.
* **Функция расширения определяемой пользователем функции**. Поддерживает преобразование из оператора UserDefinedFunctionProvider.Invoke метода заглушки в соответствующую определяемую пользователем функцию.
* **Miscellaneous**. Поддерживает преобразование операторов объединения и условных операторов. Позволяет преобразовать Contains в строку CONTAINS, ARRAY_CONTAINS или SQL IN в зависимости от контекста.

### <a name="sql-query-operators"></a>Операторы SQL-запросов

Вот несколько примеров, которые иллюстрируют, как некоторые из стандартных операторов запросов LINQ транслируются в запросы Cosmos DB.

#### <a name="select-operator"></a>Оператор Select

Синтаксис: `input.Select(x => f(x))`, где `f` — скалярное выражение.

**Лямбда-выражение LINQ**

```csharp
    input.Select(family => family.parents[0].familyName);
```

**SQL** 

```sql
    SELECT VALUE f.parents[0].familyName
    FROM Families f
```

**Лямбда-выражение LINQ**

```csharp
    input.Select(family => family.children[0].grade + c); // c is an int variable
```

**SQL**

```sql
    SELECT VALUE f.children[0].grade + c
    FROM Families f
```

**Лямбда-выражение LINQ**

```csharp
    input.Select(family => new
    {
        name = family.children[0].familyName,
        grade = family.children[0].grade + 3
    });
```

**SQL** 

```sql
    SELECT VALUE {"name":f.children[0].familyName,
                  "grade": f.children[0].grade + 3 }
    FROM Families f
```


#### <a name="selectmany-operator"></a>Оператор SelectMany

Синтаксис: `input.SelectMany(x => f(x))`, где `f` — скалярное выражение, возвращающее тип контейнера.

**Лямбда-выражение LINQ**

```csharp
    input.SelectMany(family => family.children);
```

**SQL**

```sql
    SELECT VALUE child
    FROM child IN Families.children
```

#### <a name="where-operator"></a>Оператор Where

Синтаксис: `input.Where(x => f(x))`, где `f` — скалярное выражение, возвращающее логическое значение.

**Лямбда-выражение LINQ**

```csharp
    input.Where(family=> family.parents[0].familyName == "Smith");
```

**SQL**

```sql
    SELECT *
    FROM Families f
    WHERE f.parents[0].familyName = "Smith"
```

**Лямбда-выражение LINQ**

```csharp
    input.Where(
        family => family.parents[0].familyName == "Smith" &&
        family.children[0].grade < 3);
```

**SQL**

```sql
    SELECT *
    FROM Families f
    WHERE f.parents[0].familyName = "Smith"
    AND f.children[0].grade < 3
```

### <a name="composite-sql-queries"></a>Составные SQL-запросы

Вышеуказанные операторы могут комбинироваться, чтобы формировать более расширенные запросы. Так как Cosmos DB поддерживает вложенные контейнеры, такая композиция может быть либо объединением, либо вложением.

#### <a name="concatenation"></a>Объединение

Синтаксис: `input(.|.SelectMany())(.Select()|.Where())*`. Объединенный запрос может начинаться с необязательного запроса `SelectMany`, за которым идет несколько операторов `Select` или `Where`.

**Лямбда-выражение LINQ**

```csharp
    input.Select(family=>family.parents[0])
        .Where(familyName == "Smith");
```

**SQL**

```sql
    SELECT *
    FROM Families f
    WHERE f.parents[0].familyName = "Smith"
```

**Лямбда-выражение LINQ**

```csharp
    input.Where(family => family.children[0].grade > 3)
        .Select(family => family.parents[0].familyName);
```

**SQL**

```sql
    SELECT VALUE f.parents[0].familyName
    FROM Families f
    WHERE f.children[0].grade > 3
```

**Лямбда-выражение LINQ**

```csharp
    input.Select(family => new { grade=family.children[0].grade}).
        Where(anon=> anon.grade < 3);
```

**SQL**

```sql
    SELECT *
    FROM Families f
    WHERE ({grade: f.children[0].grade}.grade > 3)
```

**Лямбда-выражение LINQ**

```csharp
    input.SelectMany(family => family.parents)
        .Where(parent => parents.familyName == "Smith");
```

**SQL**

```sql
    SELECT *
    FROM p IN Families.parents
    WHERE p.familyName = "Smith"
```

#### <a name="nesting"></a>Вложенные операторы

Синтаксис: `input.SelectMany(x=>x.Q())`, где Q — оператор `Select`, `SelectMany` или `Where`.

Во вложенных запросах внутренний запрос применяется к каждому элементу внешнего контейнера. Одной из важных особенностей является то, что внутренний запрос может ссылаться на поля элементов во внешнем контейнере как на самосоединения.

**Лямбда-выражение LINQ**

```csharp
    input.SelectMany(family=>
        family.parents.Select(p => p.familyName));
```

**SQL**

```sql
    SELECT VALUE p.familyName
    FROM Families f
    JOIN p IN f.parents
```

**Лямбда-выражение LINQ**

```csharp
    input.SelectMany(family =>
        family.children.Where(child => child.familyName == "Jeff"));
```

**SQL**

```sql
    SELECT *
    FROM Families f
    JOIN c IN f.children
    WHERE c.familyName = "Jeff"
```

**Лямбда-выражение LINQ**

```csharp
    input.SelectMany(family => family.children.Where(
        child => child.familyName == family.parents[0].familyName));
```

**SQL**

```sql
    SELECT *
    FROM Families f
    JOIN c IN f.children
    WHERE c.familyName = f.parents[0].familyName
```

## <a id="ExecutingSqlQueries"></a>Выполнение SQL-запросов

Cosmos DB предоставляет ресурсы через REST API, который можно вызвать с помощью любого языка, позволяющего отправлять запросы HTTP или HTTPS. Кроме того, Cosmos DB предлагает программные библиотеки для некоторых популярных языков программирования, таких как NET, Node.js, JavaScript и Python. Интерфейс REST API и различные библиотеки поддерживают запросы через SQL. Пакет SDL .NET помимо SQL поддерживает запросы LINQ.

Следующие примеры показывают, как создать запрос и выполнить его в учетной записи базы данных Cosmos DB.

### <a id="RestAPI"></a>REST API

Cosmos DB предлагает простую и открытую модель программирования RESTful поверх HTTP. Учетные записи баз данных могут быть подготовлены с использованием подписки Azure. Модель ресурсов Cosmos DB состоит из набора ресурсов в учетной записи базы данных, каждый из которых доступен по логическому постоянному универсальному коду ресурса (URI). Набор ресурсов в данном элементе называется каналом. Учетная запись базы данных состоит из набора баз данных, в каждой из которых размещено несколько контейнеров, содержащих хранимые процедуры, триггеры, определяемые пользователем функции и ресурсы других типов.

Базовая модель взаимодействия с этими ресурсами осуществляется через команды HTTP GET, PUT, POST и DELETE в их стандартной интерпретации. Команда POST используется как для создания ресурса, выполнения хранимой процедуры, так и для выполнения запроса Cosmos DB. Запросы всегда включают только операции чтения без побочных эффектов.

В приведенных ниже примерах показано, как сформировать запрос POST с запросом к API SQL по контейнеру с двумя тестовыми элементами, которые мы рассматривали ранее. Запрос имеет простой фильтр по свойству имени JSON. Обратите внимание на использование `x-ms-documentdb-isquery` и Content-Type — заголовков `application/query+json` для обозначения того, что выполняемая операция является запросом.

**Запрос**
```
    POST https://<REST URI>/docs HTTP/1.1
    ...
    x-ms-documentdb-isquery: True
    Content-Type: application/query+json

    {
        "query": "SELECT * FROM Families f WHERE f.id = @familyId",
        "parameters": [
            {"name": "@familyId", "value": "AndersenFamily"}
        ]
    }
```

**Результаты**

```
    HTTP/1.1 200 Ok
    x-ms-activity-id: 8b4678fa-a947-47d3-8dd3-549a40da6eed
    x-ms-item-count: 1
    x-ms-request-charge: 0.32

    <indented for readability, results highlighted>

    {  
       "_rid":"u1NXANcKogE=",
       "Documents":[  
          {  
             "id":"AndersenFamily",
             "lastName":"Andersen",
             "parents":[  
                {  
                   "firstName":"Thomas"
                },
                {  
                   "firstName":"Mary Kay"
                }
             ],
             "children":[  
                {  
                   "firstName":"Henriette Thaulow",
                   "gender":"female",
                   "grade":5,
                   "pets":[  
                      {  
                         "givenName":"Fluffy"
                      }
                   ]
                }
             ],
             "address":{  
                "state":"WA",
                "county":"King",
                "city":"seattle"
             },
             "_rid":"u1NXANcKogEcAAAAAAAAAA==",
             "_ts":1407691744,
             "_self":"dbs\/u1NXAA==\/colls\/u1NXANcKogE=\/docs\/u1NXANcKogEcAAAAAAAAAA==\/",
             "_etag":"00002b00-0000-0000-0000-53e7abe00000",
             "_attachments":"_attachments\/"
          }
       ],
       "count":1
    }
```

Второй пример показывает более сложный запрос, который возвращает несколько соединенных результатов.

**Запрос**
```
    POST https://<REST URI>/docs HTTP/1.1
    ...
    x-ms-documentdb-isquery: True
    Content-Type: application/query+json

    {
        "query": "SELECT
                     f.id AS familyName,
                     c.givenName AS childGivenName,
                     c.firstName AS childFirstName,
                     p.givenName AS petName
                  FROM Families f
                  JOIN c IN f.children
                  JOIN p in c.pets",
        "parameters": [] 
    }
```

**Результаты**

```
    HTTP/1.1 200 Ok
    x-ms-activity-id: 568f34e3-5695-44d3-9b7d-62f8b83e509d
    x-ms-item-count: 1
    x-ms-request-charge: 7.84

    <indented for readability, results highlighted>

    {  
       "_rid":"u1NXANcKogE=",
       "Documents":[  
          {  
             "familyName":"AndersenFamily",
             "childFirstName":"Henriette Thaulow",
             "petName":"Fluffy"
          },
          {  
             "familyName":"WakefieldFamily",
             "childGivenName":"Jesse",
             "petName":"Goofy"
          },
          {  
             "familyName":"WakefieldFamily",
             "childGivenName":"Jesse",
             "petName":"Shadow"
          }
       ],
       "count":3
    }
```

Если результаты запроса не помещаются на одной странице результатов, то API REST возвращает токен продолжения в заголовке ответа `x-ms-continuation-token`. Клиенты могут разбивать результаты на страницы, включая заголовок в последующие результаты. Количеством результатов на одной странице также можно управлять через число в заголовке `x-ms-max-item-count`. Если указанный запрос содержит статистическую функцию как `COUNT`, страница запроса может возвращать частично агрегированное значение на странице результатов. Клиенты должны выполнить статистическую обработку второго уровня этих результатов, чтобы получить окончательные результаты, например, сумму чисел, возвращенных на отдельных страницах, для получения общего числа.

Для управления политикой согласованности данных используйте заголовок `x-ms-consistency-level`, как во всех запросах API REST. В целях согласованности сеансов также обязательно нужно вернуть последний заголовок cookie `x-ms-session-token` в запросе. Политика индексации запрашиваемого контейнера также может повлиять на согласованность результатов запроса. Если для контейнера действует используемая по умолчанию политика индексации, индекс всегда актуален и соответствует содержанию элементов, а согласованность результатов запроса соответствует той, которая выбрана для данных. Если задействована политика отложенной индексации, запросы могут возвращать устаревшие результаты. Дополнительные сведения см. в статье [Настраиваемые уровни согласованности данных в Azure Cosmos DB][consistency-levels].

Если настроенная политика индексации в контейнере не поддерживает полученный запрос, сервер Azure Cosmos DB возвращает код ошибки 400 (недопустимый запрос). Это сообщение об ошибке возвращается для запросов к путям, сконфигурированным для поиска по значениям хэшей (равенство), а также к путям, явно исключенным из индексации. Заголовок `x-ms-documentdb-query-enable-scan` можно задать для разрешения запросу проводить сканирование в случае отсутствия индекса.

Можно получить подробные метрики выполнения запроса, задав заголовку `x-ms-documentdb-populatequerymetrics` значение `True`. Дополнительные сведения см. в статье [Tuning query performance with Azure Cosmos DB](sql-api-query-metrics.md) (Настройка производительности запросов с помощью Azure Cosmos DB).

### <a id="DotNetSdk"></a>Пакет SDK для C# (.NET)

Пакет .NET SDK поддерживает запросы как LINQ, так и SQL. В приведенном ниже примере показано, как выполнить запрос фильтра, сформированный ранее в этом элементе.
```csharp
    foreach (var family in client.CreateDocumentQuery(containerLink,
        "SELECT * FROM Families f WHERE f.id = \"AndersenFamily\""))
    {
        Console.WriteLine("\tRead {0} from SQL", family);
    }

    SqlQuerySpec query = new SqlQuerySpec("SELECT * FROM Families f WHERE f.id = @familyId");
    query.Parameters = new SqlParameterCollection();
    query.Parameters.Add(new SqlParameter("@familyId", "AndersenFamily"));

    foreach (var family in client.CreateDocumentQuery(containerLink, query))
    {
        Console.WriteLine("\tRead {0} from parameterized SQL", family);
    }

    foreach (var family in (
        from f in client.CreateDocumentQuery(containerLink)
        where f.Id == "AndersenFamily"
        select f))
    {
        Console.WriteLine("\tRead {0} from LINQ query", family);
    }

    foreach (var family in client.CreateDocumentQuery(containerLink)
        .Where(f => f.Id == "AndersenFamily")
        .Select(f => f))
    {
        Console.WriteLine("\tRead {0} from LINQ lambda", family);
    }
```

В приведенном ниже примере два свойства сравниваются на предмет равенства в каждом элементе и используются анонимные проекции.

```csharp
    foreach (var family in client.CreateDocumentQuery(containerLink,
        @"SELECT {""Name"": f.id, ""City"":f.address.city} AS Family
        FROM Families f
        WHERE f.address.city = f.address.state"))
    {
        Console.WriteLine("\tRead {0} from SQL", family);
    }

    foreach (var family in (
        from f in client.CreateDocumentQuery<Family>(containerLink)
        where f.address.city == f.address.state
        select new { Name = f.Id, City = f.address.city }))
    {
        Console.WriteLine("\tRead {0} from LINQ query", family);
    }

    foreach (var family in
        client.CreateDocumentQuery<Family>(containerLink)
        .Where(f => f.address.city == f.address.state)
        .Select(f => new { Name = f.Id, City = f.address.city }))
    {
        Console.WriteLine("\tRead {0} from LINQ lambda", family);
    }
```

Следующий пример демонстрирует объединение, выражаемое через LINQ SelectMany.

```csharp
    foreach (var pet in client.CreateDocumentQuery(containerLink,
          @"SELECT p
            FROM Families f
                 JOIN c IN f.children
                 JOIN p in c.pets
            WHERE p.givenName = ""Shadow"""))
    {
        Console.WriteLine("\tRead {0} from SQL", pet);
    }

    // Equivalent in Lambda expressions
    foreach (var pet in
        client.CreateDocumentQuery<Family>(containerLink)
        .SelectMany(f => f.children)
        .SelectMany(c => c.pets)
        .Where(p => p.givenName == "Shadow"))
    {
        Console.WriteLine("\tRead {0} from LINQ lambda", pet);
    }
```

Клиент .NET автоматически перебирает все страницы результатов запроса в блоках FOREACH, как показано выше. Параметры запроса, введенные в разделе API REST, также доступны в пакете SDK для .NET с помощью классов `FeedOptions` и `FeedResponse` в методе CreateDocumentQuery. Количеством страниц можно управлять через настройку `MaxItemCount`.

Можно также явно управлять разбиением на страницы, создав `IDocumentQueryable` с помощью объекта `IQueryable`, а затем считывая значения ` ResponseContinuationToken` и передавая их обратно как `RequestContinuationToken` в `FeedOptions`. `EnableScanInQuery` можно настроить на включение сканирования, когда подобный запрос не поддерживается настроенной политикой индексации. Если используется контейнер с разделами, с помощью `PartitionKey` можно выполнить запрос к одному разделу (хотя Azure Cosmos DB может автоматически извлекать этот ключ из текста запроса) или с помощью `EnableCrossPartitionQuery` создать запрос, для которого могут потребоваться несколько разделов.

В разделе с [примерами .NET для Azure Cosmos DB](https://github.com/Azure/azure-cosmosdb-dotnet) имеются дополнительные примеры, содержащие запросы.

### <a id="JavaScriptServerSideApi"></a>Интерфейс API для серверного JavaScript

Cosmos DB предоставляет модель программирования, которая позволяет выполнять логику приложения на языке JavaScript непосредственно в коллекциях, используя хранимые процедуры и триггеры. Логика JavaScript, зарегистрированная на уровне контейнера, позволяет выполнять операции в базе данных с элементами указанного контейнера. Эти операции оборачиваются транзакциями ACID.

В следующем примере показано, как использовать queryDocuments в интерфейсе API JavaScript для сервера, чтобы выполнять запросы из хранимых процедур и триггеров.

```javascript
    function businessLogic(name, author) {
        var context = getContext();
        var containerManager = context.getCollection();
        var containerLink = containerManager.getSelfLink()

        // create a new item.
        containerManager.createDocument(containerLink,
            { name: name, author: author },
            function (err, documentCreated) {
                if (err) throw new Error(err.message);

                // filter items by author
                var filterQuery = "SELECT * from root r WHERE r.author = 'George R.'";
                containerManager.queryDocuments(containerLink,
                    filterQuery,
                    function (err, matchingDocuments) {
                        if (err) throw new Error(err.message);
    context.getResponse().setBody(matchingDocuments.length);

                        // Replace the author name for all items that satisfied the query.
                        for (var i = 0; i < matchingDocuments.length; i++) {
                            matchingDocuments[i].author = "George R. R. Martin";
                            // we don't need to execute a callback because they are in parallel
                            containerManager.replaceDocument(matchingDocuments[i]._self,
                                matchingDocuments[i]);
                        }
                    })
            });
    }
```

## <a id="References"></a>Справочные материалы

1. [Знакомство со службой Azure Cosmos DB. API DocumentDB][introduction]
2. [DocumentDB SQL Syntax](https://go.microsoft.com/fwlink/p/?LinkID=510612) (Синтаксис SQL в DocumentDB)
3. [Примеры .NET для Azure Cosmos DB](https://github.com/Azure/azure-cosmosdb-dotnet)
4. [Настраиваемые уровни согласованности данных в Azure Cosmos DB][consistency-levels]
5. ANSI SQL 2011 — [https://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681](https://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681).
6. JSON — [https://json.org/](https://json.org/).
7. Спецификация Javascript — [https://www.ecma-international.org/publications/standards/Ecma-262.htm](https://www.ecma-international.org/publications/standards/Ecma-262.htm). 
8. LINQ — [https://msdn.microsoft.com/library/bb308959.aspx](https://msdn.microsoft.com/library/bb308959.aspx). 
9. Методы оценки запроса для больших баз данных — [https://dl.acm.org/citation.cfm?id=152611](https://dl.acm.org/citation.cfm?id=152611).
10. Обработка запросов в параллельных реляционных СУБД (Query Processing in Parallel Relational Database Systems), IEEE Computer Society Press, 1994
11. Lu, Ooi, Tan, Обработка запросов в параллельных реляционных СУБД (Query Processing in Parallel Relational Database Systems), IEEE Computer Society Press, 1994
12. Кристофер Олстон (Christopher Olston), Бенджамин Рид (Benjamin Reed), Уткарш Шривастава (Utkarsh Srivastava), Рави Кумар (Ravi Kumar), Эндрю Томкинс (Andrew Tomkins). Язык Pig. Не такой уж и незнакомый язык для обработки данных (Pig Latin: A Not-So-Foreign Language for Data Processing), SIGMOD 2008 г.
13. Ж. Графе (G. Graefe). Каскадные платформы для оптимизации запросов. IEEE Data Eng. Bull., 18(3): 1995 г.

[1]: ./media/how-to-sql-query/sql-query1.png
[introduction]: introduction.md
[consistency-levels]: consistency-levels.md
