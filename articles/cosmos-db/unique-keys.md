---
title: Уникальные ключи в Azure Cosmos DB | Документация Майкрософт
description: Узнайте, как использовать уникальные ключи в базе данных Azure Cosmos DB.
services: cosmos-db
keywords: ограничение уникального ключа, нарушение ограничения уникального ключа
author: rafats
manager: kfile
editor: monicar
ms.service: cosmos-db
ms.devlang: na
ms.topic: conceptual
ms.date: 08/08/2018
ms.author: rafats
ms.openlocfilehash: 796971ff541b62a22a70df4022ab78817e7158e9
ms.sourcegitcommit: d0ea925701e72755d0b62a903d4334a3980f2149
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/09/2018
ms.locfileid: "40003323"
---
# <a name="unique-keys-in-azure-cosmos-db"></a>Уникальные ключи в Azure Cosmos DB

Уникальные ключи предоставляют разработчикам возможность добавить слой целостности данных в базу данных. Создавая политику уникальных ключей при создании контейнера, вы гарантируете уникальность одного или нескольких значений [ключа секции](partition-data.md). После создания контейнера с политикой уникальных ключей он предотвращает создание любых новых или обновленных элементов со значениями, которые дублируют значения, заданные с помощью уникального ограничения ключа.   

> [!NOTE]
> Уникальные ключи поддерживаются последними версиями пакетов SDK SQL для [.NET](sql-api-sdk-dotnet.md) и [.NET Core](sql-api-sdk-dotnet-core.md), а также [API MongoDB](mongodb-feature-support.md#unique-indexes). API таблицы и API Graph в текущее время не поддерживают уникальные ключи. 
> 
>

## <a name="use-case"></a>Вариант использования 

Например, рассмотрим как пользовательская база данных, связанная с приложением [социальных сетей](use-cases.md#web-and-mobile-applications), может получить преимущества от политики уникальных ключей для адресов электронной почты. Сделав адрес электронной почты пользователя уникальным ключом, убедитесь, что каждая запись имеет уникальный адрес электронной почты и что невозможно создать запись с дублирующимся адресом электронной почты. 

Если нужно, чтобы пользователи могли для создавать нескольких записей с одним адресом электронной почты, но не с тем же именем, фамилией и адресом электронной почты, можно добавить другие пути для политики уникальных ключей. Поэтому вместо создания уникального ключа на основе адреса электронной почты можно создать уникальный ключ, который представляет собой комбинацию имени, фамилии и электронной почты. В этом случае каждая уникальная комбинация из трех путей разрешена, поэтому база данных может содержать элементы, которые имеют следующие значения пути. Каждая из этих записей передала бы политику уникальных ключей.  

**Допустимые значения для уникального ключа столбцов firstName, lastName и адрес электронной почты**

|Имя|Фамилия|Адрес электронной почты|
|---|---|---|
|Гэби|Дюперре|gaby@contoso.com |
|Гэби|Дюперре|gaby@fabrikam.com|
|Иван|Дюперре|gaby@fabrikam.com|
|    |Дюперре|gaby@fabrikam.com|
|    |       |gaby@fabraikam.com|

При попытке вставить другую запись с любым сочетанием, которые перечислены в приведенной выше таблице, вы получите сообщение об ошибке, указывающее, что ограничение уникального ключа не выполнено. Azure Cosmos DB возвращает ошибку "Ресурс с указанными идентификатором или именем уже существует" или "Ресурс с определенным идентификатором, именем или уникальным индексом уже существует". 

## <a name="using-unique-keys"></a>Использование уникальных ключей

Уникальные ключи должны быть определены при создании контейнера, а уникальный ключ привязан к ключу секции. Чтобы использовать предыдущий пример, если секция основана на почтовом индексе, можно получить записи из таблицы, которые дублируются в каждой секции.

Невозможно обновить имеющиеся контейнеры для использования уникальных ключей.

После создания контейнера с политикой уникальных ключей политику можно изменить только при повторном создании контейнера. При наличии данных, в которых нужно реализовать уникальные ключи, создайте контейнер и используйте соответствующее средство миграции данных, чтобы перенести данные в новый контейнер. Для контейнеров SQL используйте [средство миграции данных](import-data.md). Для контейнеров MongoDB используйте [mongoimport.exe или mongorestore.exe](mongodb-migrate.md).

В каждый уникальный ключ можно включить до 16 значений путей (например, /firstName, /lastName, /address/zipCode и т. д.) 

Каждая политика уникальных ключей может иметь не более 10 ограничений уникальных ключей или сочетаний. А комбинированные пути для всех свойств уникальных индексов не должны содержать более 60 символов. Таким образом пример выше, который использует имя, фамилию и адрес электронной почты, является только одним ограничением и использует три из 16 возможных путей. 

Затраты единиц запросов для создания, обновления и удаления элемента значительно выше при наличии в контейнере политики уникальных ключей. 

Разреженные уникальные ключи не поддерживаются. Если значения для некоторых уникальных путей отсутствуют, они рассматриваются как имеющие специальное значение null, которое принимает участие в ограничении уникальности.

## <a name="sql-api-sample"></a>Пример API SQL

В следующем примере кода показано, как создать новый контейнер SQL с двумя ограничениями уникального ключа. Первое ограничение — это ограничение по firstName, lastName, адресу электронной почты, описанное в примере выше. Второе ограничение — это адрес или почтовый индекс пользователей. Пример файла JSON, который использует пути в этой политике уникальных ключей, следует примеру кода. 

```csharp
// Create a collection with two separate UniqueKeys, one compound key for /firstName, /lastName,
// and /email, and another for /address/zipCode.
private static async Task CreateCollectionIfNotExistsAsync(string dataBase, string collection)
{
    try
    {
        await client.ReadDocumentCollectionAsync(UriFactory.CreateDocumentCollectionUri(dataBase, collection));
    }
    catch (DocumentClientException e)
    {
        if (e.StatusCode == System.Net.HttpStatusCode.NotFound)
        {
            DocumentCollection myCollection = new DocumentCollection();
            myCollection.Id = collection;
            myCollection.PartitionKey.Paths.Add("/pk");
            myCollection.UniqueKeyPolicy = new UniqueKeyPolicy
            {
                UniqueKeys =
                new Collection<UniqueKey>
                {
                    new UniqueKey { Paths = new Collection<string> { "/firstName" , "/lastName" , "/email" }}
                    new UniqueKey { Paths = new Collection<string> { "/address/zipcode" } },
          }
            };
            await client.CreateDocumentCollectionAsync(
                UriFactory.CreateDatabaseUri(dataBase),
                myCollection,
                new RequestOptions { OfferThroughput = 2500 });
        }
        else
        {
            throw;
        }
    }
```

Пример документа JSON.

```json
{
    "id": "1",
    "pk": "1234",
    "firstName": "Gaby",
    "lastName": "Duperre",
    "email": "gaby@contoso.com",
    "address": 
        {            
            "line1": "100 Some Street",
            "line2": "Unit 1",
            "city": "Seattle",
            "state": "WA",
            "zipcode": 98012
        }
    
}
```
> [!NOTE]
> Обратите внимание, что уникальное имя ключа определяется с учетом регистра. Как показано в приведенном выше примере, для /address/zipcode задано уникальное имя. Если данные содержат ZipCode, тогда в уникальный ключ будет вставлено значение null, поскольку zipcode не равен ZipCode. Во всех других записях, которые содержат ZipCode, в уникальный ключ невозможно будет вставить еще одно значение null, поскольку это нарушит требование уникальности ключа.

## <a name="mongodb-api-sample"></a>Пример API MongoDB

В следующем примере команды показано, как создать уникальный индекс для полей firstName, lastName и электронной почты коллекции пользователей для MongoDB API. Это гарантирует уникальность комбинации во всех трех полях во всех документах в коллекции. Для коллекций API MongoDB уникальный индекс создается после создания коллекции, но перед ее заполнением.

> [!NOTE]
> Уникальный формат ключа для учетных записей API MongoDB отличается от формата ключа для учетных записей API SQL, где отсутствует возможность указать символ обратной косой черты (/) перед именем поля. 

```
db.users.createIndex( { firstName: 1, lastName: 1, email: 1 }, { unique: true } )
```
## <a name="configure-unique-keys-by-using-azure-portal"></a>Настройка уникальных ключей с помощью портала Microsoft Azure

В разделах выше предоставлены примеры кода, в которых показано, как можно определить ограничения уникального ключа при создании коллекции с помощью API SQL или API MongoDB. Также уникальные ключи можно определить при создании коллекции с помощью веб-интерфейса на портале Microsoft Azure. 

- Откройте **обозреватель данных** учетной записи Cosmos DB
- В заголовке коллекции щелкните **Новая коллекция**
- В разделе "Уникальные ключи"** можно добавить нужные ограничения уникального ключа, щелкнув **Добавить уникальный ключ**

![Определение уникальных ключей в обозревателе данных](./media/unique-keys/unique-keys-azure-portal.png)

- Если нужно создать ограничение уникального ключа по пути lastName, добавьте `/lastName`.
- Если нужно создать ограничение уникального ключа для комбинации lastName firstName, добавьте `/lastName,/firstName`

По завершении нажмите кнопку **ОК**, чтобы создать коллекцию.

## <a name="next-steps"></a>Дополнительная информация

В этой статье вы узнали, как создавать уникальные ключи для элементов в базе данных. При создании контейнера в первый раз ознакомьтесь со статьей о [секционировании данных в Azure Cosmos DB](partition-data.md), чтобы узнать, как уникальные ключи и ключи секций зависят друг от друга. 


