---
title: Секционирование в API Graph | Документация Майкрософт
description: Узнайте, как использовать секционированный граф в Azure Cosmos DB.
services: cosmos-db
author: luisbosquez
manager: kfile
ms.service: cosmos-db
ms.component: cosmosdb-graph
ms.devlang: na
ms.topic: conceptual
ms.date: 02/28/2018
ms.author: lbosq
ms.openlocfilehash: 202c575a917cfb24436d86881e5368b61f216d42
ms.sourcegitcommit: 0b4da003fc0063c6232f795d6b67fa8101695b61
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/05/2018
ms.locfileid: "37861464"
---
# <a name="using-a-partitioned-graph-in-azure-cosmos-db"></a>Использование секционированного графа в Azure Cosmos DB

Одной из основных функций API Graph в Azure Cosmos DB является обработка крупномасштабных графов с помощью горизонтального масштабирования. Это возможно благодаря [функциям секционирования в Azure Cosmos DB](partition-data.md#how-does-partitioning-work). При этом используются контейнеры, которые можно независимо масштабировать в плане ресурсов хранения и пропускной способности. Azure Cosmos DB поддерживает такие типы контейнеров во всех API:

- **Фиксированный контейнер**: эти контейнеры могут хранить базы данных графов размером до 10 ГБ с числом выделенных единиц запросов в секунду не более 10 000. Для создания фиксированного контейнера в данных не требуется указывать свойство ключа секции.

- **Неограниченный контейнер**: эти контейнеры могут автоматически масштабироваться для хранения графа свыше лимита в 10 ГБ за счет горизонтального секционирования. Каждая секция будет хранить 10 ГБ данных. Данные будут автоматически распределяться на основе **указанного ключа секции**, который является обязательным параметром при использовании неограниченного контейнера. Этот тип контейнера может хранить неограниченный объем данных и разрешать до 100 000 единиц запросов в секунду. Это число можно увеличить, [обратившись в службу поддержки](https://aka.ms/cosmosdbfeedback?subject=Cosmos%20DB%20More%20Throughput%20Request).

В этом документе описаны особенности секционирования базы данных графов, а также его влияние на вершины (или узлы) и ребра.

## <a name="requirements-for-partitioned-graph"></a>Требования к секционированному графу

Ниже приведены сведения, которые нужно учитывать при создании контейнера секционированного графа.
- **Настройка секционирования необходима**, если ожидаемый размер контейнера превышает 10 ГБ и (или) потребуется выделение более 10 000 единиц запросов в секунду (ЕЗ/с).
- **И вершины, и ребра хранятся в виде документов JSON** внутри контейнера API Graph Azure Cosmos DB.
- **Для вершин требуется ключ секции**. Этот ключ определяет, в какой секции будет храниться вершина, с использованием алгоритма хэширования. Имя этого ключа секции представляет собой однословную строку без пробелов или специальных символов, и оно присваивается в формате `/partitioning-key-name` при создании нового контейнера на портале.
- **Ребра будут храниться вместе с их исходной вершиной**. Другими словами, ключ секции каждой вершины определяет, где она будет храниться вместе с ее исходящими ребрами. Это делается во избежание межсекционных запросов при использовании кратности `out()` в запросах графа.
- **В запросах графа необходимо задавать ключ секции**. Чтобы воспользоваться всеми преимуществами горизонтального секционирования в Azure Cosmos DB, ключ секции необходимо по возможности указывать всякий раз, когда выбирается одна вершина. Ниже приведены запросы для выбора одной или нескольких вершин в секционированном графе:

    - Выбор вершины по идентификатору, затем **использование шага `.has()` для указания свойства ключа секции**: 
    
        ```
        g.V('vertex_id').has('partitionKey', 'partitionKey_value')
        ```
    
    - Выбор вершины путем **указания кортежа, включая значение ключа секции и идентификатор**: 
    
        ```
        g.V(['partitionKey_value', 'vertex_id'])
        ```
        
    - Указание **массива кортежей значений ключей секций и идентификаторов**:
    
        ```
        g.V(['partitionKey_value0', 'verted_id0'], ['partitionKey_value1', 'vertex_id1'], ...)
        ```
        
    - Выбор набора вершин и **определение списка значений ключей секций**: 
    
        ```
        g.V('vertex_id0', 'vertex_id1', 'vertex_id2', …).has('partitionKey', within('partitionKey_value0', 'partitionKey_value01', 'partitionKey_value02', …)
        ```

## <a name="best-practices-when-using-a-partitioned-graph"></a>Рекомендации при использовании секционированного графа

Ниже приведены рекомендации, которые следует выполнить для обеспечения оптимальной производительности и масштабируемости при использовании секционированных графов в неограниченных контейнерах.
- **Всегда указывайте значение ключа секции при запросе вершины**. Получение вершины из известной секции является самым эффективным способом с точки зрения производительности.
- **По возможности используйте исходящее направление при запросе ребер**. Как упоминалось выше, ребра хранятся с их исходными вершинами в исходящем направлении. Это означает, что вероятность повторной сортировки межсекционных запросов сведена к минимуму, когда данные и запросы разработаны с ориентацией на этот шаблон.
- **Выберите ключ секции, который равномерно распределяет данные по секциям**. Это решение сильно зависит от модели данных решения. Дополнительные сведения о создании соответствующего ключа секции см. в статье [Секционирование и масштабирование в Azure Cosmos DB](partition-data.md).
- **По возможности оптимизируйте запросы для получения данных в пределах секции**. Оптимальной стратегией секционирования является согласование с шаблонами запросов. Запросы для получения данных из одной секции обеспечивают наилучшую производительность.

## <a name="next-steps"></a>Дополнительная информация
В этой статье мы предоставили обзор концепций и рекомендации для секционирования с использованием API Graph Azure Cosmos DB. 

* Дополнительные сведения о [секционировании и масштабировании в Azure Cosmos DB](partition-data.md).
* Дополнительные сведения о [поддержке Gremlin в API Graph](gremlin-support.md).
* [Общие сведения об API Graph](graph-introduction.md).
