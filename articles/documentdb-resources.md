<properties title="DocumentDB resource model and concepts" pageTitle="Модель ресурсов и понятия DocumentDB | Azure" description="DocumentDB nosql document database manages resources, uniquely identified by logical URIs developers can interact with using HTTP verbs, request/response headers, and status codes." metaKeywords="" services="documentdb" solutions="data-management" documentationCenter="" authors="spelluru" manager="jhubbard" editor="monicar" videoId="" scriptId="" />

<tags ms.service="documentdb" ms.workload="data-services" ms.tgt_pltfrm="na" ms.devlang="na" ms.topic="article" ms.date="08/20/2014" ms.author="spelluru" />

#Модель ресурсов и понятия DocumentDB

NoSQL-cлужба баз данных документов DocumentDB предлагает простую и открытую модель программирования с использованием API REST и протокола HTTP. Сущности, которыми управляет DocumentDB, называются **ресурсами**, которые однозначно идентифицируются своими логическими URI. Разработчики могут взаимодействовать с ресурсами, используя стандартные команды HTTP, заголовки запросов/ответов и коды состояний. Как показано на рисунке ниже, **модель ресурсов** DocumentDB состоит из наборов ресурсов под учетной записью базы данных, каждый из которых адресуется логическим постоянным URI.  

>[AZURE.NOTE] Кроме того, DocumentDB предлагает высокоэффективный протокол TCP, который также использует метод REST в своей коммуникационной модели, доступной через пакет SDK клиента .NET.

![][1]  
**Иерархическая модель ресурсов под учетной записью базы данных**   

Начните с подготовки **учетной записи базы данных** DocumentDB с помощью подписки Azure. Учетная запись базы данных может состоять из набора **баз данных**, каждая из которых содержит несколько **коллекций**, каждая из которых, в свою очередь, содержит **хранимые процедуры, триггеры, определяемые пользователем функции, документы** и соответствующие **вложения**. База данных также имеет связанных с ней **пользователей**, каждый из которых обладает набором **разрешений** для доступа к коллекциям, хранимым процедурам, триггерам, определяемым пользователем функциям (UDF), документам или вложениям. В то время как базы данных, пользователи, разрешения и коллекции являются определяемыми системой ресурсами с известными схемами, документы и вложения содержат произвольный, определяемый пользователем контент в формате JSON.  

<table width = "400">
    <tbody>
        <tr>
            <td width="84" valign="top">
                <p>
                    <strong>Ресурс </strong>
                </p>
            </td>
            <td width="540" valign="top">
                <p>
                    <strong>Описание</strong>
                </p>
            </td>
        </tr>
        <tr>
            <td width="84" valign="top">
                <p>
                    <strong>База данных</strong>
                </p>
                <p>
                    <strong>Учетная запись</strong>
                </p>
            </td>
            <td width="540" valign="top">
                <p>
                    Учетная запись базы данных связана с одним или несколькими единицами объема, представляющими подготовленное хранилище документов и пропускную способность,
                    набор баз данных и хранилище BLOB-объектов. Вы можете создать одну или несколько учетных записей базы данных с помощью подписки Azure. Каждая учетная запись базы данных
                    имеет уникальное имя DNS.
                </p>
            </td>
        </tr>
        <tr>
            <td width="84" valign="top">
                <p>
                    <strong>База данных</strong>
                </p>
            </td>
            <td width="540" valign="top">
                <p>
                    База данных представляет собой логический контейнер для хранения документов, разделенных между коллекциями. Кроме того, это контейнер для пользователей.
                </p>
            </td>
        </tr>
        <tr>
            <td width="84" valign="top">
                <p>
                    <strong>Пользователь</strong>
                </p>
            </td>
            <td width="540" valign="top">
                <p>
                    Логическое пространство имен для ограничений разрешений.
                </p>
            </td>
        </tr>
        <tr>
            <td width="84" valign="top">
                <p>
                    <strong>Разрешение</strong>
                </p>
            </td>
            <td width="540" valign="top">
                <p>
                    Метка авторизации, связанная с пользователем, имеющим право на доступ к определенному ресурсу.
                </p>
            </td>
        </tr>
        <tr>
            <td width="84" valign="top">
                <p>
                    <strong>Коллекция</strong>
                </p>
            </td>
            <td width="540" valign="top">
                <p>
                    Коллекция представляет собой контейнер документов JSON и связанную с ними логику приложения JavaScript. Запросы и транзакции ограничены
                    коллекциями.
                </p>
            </td>
        </tr>
    </tbody>
</table>
##Системные и пользовательские ресурсы
Ресурсы, такие как учетные записи баз данных, базы данных, коллекции, пользователи, разрешения, хранимые процедуры, триггеры и определяемые пользователем функции (UDF), имеют фиксированную схему и называются системными ресурсами. В отличие от таких ресурсов, как документы и вложения, не имеющих ограничений по схеме, которые являются примерами пользовательских ресурсов. В DocumentDB и системные, и пользовательские ресурсы представляются и управляются как стандартные, совместимые с JSON объекты.  

#Учетные записи базы данных
![][2]  

Вы можете подготовить одну или несколько учетных записей базы данных DocumentDB с помощью подписки Azure. Для своей учетной записи вы можете приобрести наращиваемые единицы хранилища документов на базе SSD и пропускную способность в виде единиц емкости (CU).  В зависимости от масштаба приложения и необходимой производительности вы можете постепенно добавлять или удалять CU. Каждая CU включает набор гибких коллекций, подготовленное хранилище документов на базе SSD и подготовленную пропускную способность. Подготовленное хранилище и пропускная способность, связанные с CU, распределяются по коллекции DocumentDB, которую вы создаете, среди баз данных, относящихся к вашей учетной записи базы данных. Емкость, подготовленная для учетной записи базы данных, доступна для всех баз данных и коллекций, которые уже существуют или будут созданы в учетной записи. Практически не существует никакого ограничения масштабирования для размера учетной записи базы данных. Любое количество единиц емкости может быть добавлено в течение неограниченного времени при условии соблюдения ограничений. Ресурсы, управляемые в рамках CU, масштабируются с помощью разделов и дублируются для обеспечения высокой доступности.   

Вы можете создавать учетные записи базы данных DocumentDB и управлять ими с помощью портала Azure на сайте [http://portal.azure.com/](http://portal.azure.com/). Создание и управление учетной записью базы данных требует наличия административного доступа и может быть выполнено только для вашей подписки Azure. В рамках подготовки учетной записи базы данных и управления ею можно настроить следующие свойства и ознакомиться с ними:  

<table border="1" cellspacing="0" cellpadding="0" > 
<tbody>
<tr>
<td valign="top" ><p><b>Имя свойства</b></p></td>
<td valign="top" ><p><b>Описание</b></p></td>
</tr>

<tr>
<td valign="top" ><p>Политика согласованности</p></td>
<td valign="top" ><p>Установите это свойство, чтобы настроить уровень согласованности по умолчанию для всех коллекций под вашей учетной записью базы данных. Вы можете переопределить уровень согласованности для каждого запроса, используя заголовок запроса [x-ms-consistency-level]. В будущем, возможно, будет реализована поддержка переопределения уровня согласованности на уровне коллекции. </p>

<p>Обратите внимание, что это свойство применяется только к <i>пользовательским ресурсам</i>. Все системные ресурсы настроены для поддержки чтения и запросов с сильной согласованностью.</p></td>
</tr>

<tr>
<td valign="top" ><p>Первичный и вторичный мастер-ключи</p></td>
<td valign="top" ><p>Существуют первичный и вторичный мастер-ключи, которые обеспечивают административный доступ ко всем ресурсам учетной записи базы данных.</p></td>
</tr>

<tr>
<td valign="top" ><p>MaxMediaStorageUsageInMB (ЧТЕНИЕ)</p></td>
<td valign="top" ><p>Максимальный объем хранимых данных, доступный для учетной записи базы данных</p></td>
</tr>

<tr>
<td valign="top" ><p>CurrentMediaStorageUsageInMB (ЧТЕНИЕ)</p></td>
<td valign="top" ><p>Текущий объем хранимых данных, доступный для учетной записи базы данных</p></td>
</tr>

<tr>
<td valign="top" ><p>CapacityUnitsProvisioned</p></td>
<td valign="top" ><p>Общее количество единиц объема, подготовленных в учетной записи базы данных</p></td>
</tr>

<tr>
<td valign="top" ><p>CapacityUnitsConsumed (ЧТЕНИЕ)</p></td>
<td valign="top" ><p>Общее количество единиц объема, используемых в текущий момент в учетной записи базы данных</p></td>
</tr>

<tr>
<td valign="top" ><p>ProvisionedDocumentStorageInMB (ЧТЕНИЕ)</p></td>
<td valign="top" ><p>Общий объем для хранения документов (в МБ), подготовленный во всех единицах емкости учетной записи базы данных.</p></td>
</tr>

<tr>
<td valign="top" ><p>ReservedDocumentStorageInMB (ЧТЕНИЕ)</p></td>
<td valign="top" ><p>Общий объем для хранения документов (в МБ), зарезервированный во всех единицах емкости под данной учетной записью базы данных. Объем считается зарезервированным для хранения документов, если коллекция содержит документы. </p></td>
</tr>

<tr>
<td valign="top" ><p>ConsumedDocumentStorageInMB (ЧТЕНИЕ)</p></td>
<td valign="top" ><p>Общий объем для хранения документов (в МБ), фактически занятый во всех единицах емкости под данной учетной записью базы данных. Это размер фактических документов и индекса, объединенных в различных коллекциях под учетной записью базы данных.</p></td>
</tr>

</tbody>
</table>


Обратите внимание, что в дополнение к подготовке, настройке вашей учетной записи базы данных на портале Azure и управления ею вы также можете программно создавать учетные записи базы данных DocumentDB и управлять ими через [интерфейсы Azure DocumentDB REST API](http://go.microsoft.com/fwlink/p/?LinkID=402413), а также клиентские пакеты SDK.  

 
#Базы данных
База данных в DocumentDB является логическим контейнером из одного или нескольких коллекций и пользователей. Вы можете создать любое количество баз данных под учетной записью базы данных DocumentDB с учетом предложенных ограничений.  
![][3]  
**База данных представляет собой логический контейнер пользователей и коллекций**

База данных может содержать практически неограниченный объем для хранения документов, разделенный на коллекции, которые формируют домены транзакций для документов, содержащихся в них. База данных DocumentDB по умолчанию обладает гибкостью, ее размер может меняться от нескольких гигабайт до потенциально петабайт хранилищ документов на базе SSD и подготовленной пропускной способности. В отличие от традиционных реляционных СУБД базы данных в DocumentDB не ограничены одним узлом. С DocumentDB по мере роста масштабов потребностей вашего приложения вы можете создать несколько коллекций или баз данных, либо и то и другое. Действительно, различные собственные приложения корпорации Майкрософт уже используют DocumentDB в потребительском масштабе путем создания чрезвычайно больших баз данных DocumentDB, каждая из которых содержит тысячи коллекций с терабайтами хранимых документов. Вы можете увеличить или уменьшить базу данных, добавляя или удаляя коллекции для удовлетворения требований масштабности вашего приложения. Вы можете создать любое количество коллекций в пределах субъекта базы данных, чтобы обеспечить доступность и количество единиц емкости, которые вы покупаете. Хранилища на базе SSD и пропускная способность, подготовленные путем покупки единиц емкости, могут быть распределены по коллекциям под базами данных в вашей учетной записи базы данных.   

База данных DocumentDB является также контейнером для пользователей. Пользователь, в свою очередь, является логическим пространством имен для набора разрешений, который обеспечивает детальный уровень авторизации и доступа к коллекциям, документам и вложениям.  
 
Как и другие ресурсы в модели DocumentDB, базы данных могут быть с легкостью созданы, заменены, удалены, прочитаны или перечислены с помощью [интерфейсов Azure DocumentDB REST API](http://go.microsoft.com/fwlink/p/?LinkID=402413) или любых клиентских пакетов SDK. DocumentDB гарантирует строгую согласованность для чтения или запроса метаданных ресурса базы данных. Удаление базы данных автоматически означает, что вы больше не сможете получить доступ к любой из коллекций или пользователям, содержащимся в ней. Несмотря на то что DocumentDB восстанавливает хранилище и пропускную способность в фоновом режиме, подготовленные хранилище и пропускная способность, использовавшиеся удаленной базой данных, сразу доступны для использования.   
 

#Коллекции
Коллекция DocumentDB - контейнер для документов JSON. Коллекция также является единицей масштабирования, транзакций и запросов. Вы можете масштабировать базу данных DocumentDB, добавив дополнительные коллекции. Если ваше приложение нуждается в масштабировании, вы можете подготовить больший объем хранилища документов на базе SSD (а также пропускную способность) и распределить их по всем коллекциям одной или нескольких баз данных под вашей учетной записью базы данных.
 
##Гибкое хранилище документов на базе SSD
Коллекция гибкая сама по себе: она автоматически увеличивается и уменьшается при добавлении или удалении документов. Хотя первоначально DocumentDB тестировалась с тысячами коллекций в базе данных с размерами от нескольких гигабайт до терабайт, в настоящее время для стандартного режима предварительной версии DocumentDB гибкость коллекции ограничивается 10 ГБ. 

##Автоматическое индексирование
DocumentDB - система баз данных без схемы. Она не подразумевает и не требует указания каких-либо схем для документов JSON. По мере добавления документов в коллекции DocumentDB автоматически индексирует их, и они становятся доступны для выполнения запросов. Автоматическая индексация документов, не требующая указания схемы или вторичных индексов, является ключевой возможностью DocumentDB и доступна благодаря оптимизации записи, безблокировочной и оптимизированной журнально-структурированной технологии обслуживания индексов. DocumentDB поддерживает устойчивый объем чрезвычайно быстрых операций записи и в то же время обслуживает согласованные запросы. Хранилище и документов и индекса используется для расчета объема хранения, потребляемого каждой коллекцией. Вы можете управлять соотношениями объема и производительности, связанными с индексацией, настраивая политики индексирования для коллекции. 

##Конфигурация политики индексирования коллекции
Политика индексирования каждой коллекции позволяет настраивать соотношения производительности и объема, связанные с индексацией. Для конфигурации индексирования доступны следующие параметры:  

-	Укажите, будет ли коллекция автоматически индексировать все документы или нет. По умолчанию все документы индексируются автоматически. Можно отключать автоматическое индексирование и добавлять только выбранные документы в индекс. И наоборот, вы можете выборочно указать, какие документы необходимо исключить из индексирования. Вы можете добиться этого путем установки автоматического логического свойства indexingPolicy коллекции и с помощью заголовка запроса [x-ms-indexingdirective] при вставке, замене или удалении документа.  
-	Укажите, следует ли включить или исключить определенные пути или шаблоны в документах из индекса. Вы можете добиться этого путем установки includedPaths и excludedPaths на indexingPolicy коллекции соответственно. Кроме того, вы можете настроить соотношения объема и производительности для интервала и хэш-запросов для конкретных шаблонов пути. 
-	Выберите между синхронными (согласованными) и асинхронными (отложенными) обновлениями индекса. По умолчанию, индекс обновляется синхронно при каждой операции вставки, заменить или удаления документа в коллекции. Это позволяет выполнять запросы с уровнем согласованности, как и в документе. В то время как DocumentDB оптимизирован для операций записи и поддерживает устойчивые объемы записей документов вместе с синхронным обслуживанием индекса и обслуживанием согласованных запросов, вы можете настроить определенные коллекции для отложенного обновления своих ​​индексов. Отложенное индексирование еще больше повышает производительность операций записи и идеально подходит для сценариев пакетной вставки, прежде всего для чтения больших коллекций.

Для выпуска предварительной версии DocumentDB политика индексации может быть настроена только во время создания коллекции. После создания коллекции обновить политику уже не удастся.

##Запросы к коллекции
Документы в коллекции могут иметь произвольные схемы, и вы можете запрашивать их без предварительного предоставления любой схемы или вторичных индексов. Вы можете формировать запросы к коллекции с помощью языка запросов SQL DocumentDB который обеспечивает богатую иерархию и операторы отношения, а также расширяемость через пользовательские функции на JavaScript. Грамматика JSON позволяет моделировать документы JSON в форме деревьев с метками в качестве узлов. Этим часто пользуются для автоматических методов индексации DocumentDB, а также для запросов на диалекте SQL DocumentDB. Язык запросов DocumentDB построен на трех основных принципах:   

1.	Небольшой набор операций запросов, которые естественным образом отображаются в древовидной структуре в том числе иерархических запросов и проекций. 
2.	Подмножество реляционных операций, включая композиции, фильтры, проекции, агрегатов и внутренние соединения. 
3.	Пользовательские функции на основе чистого JavaScript, которые сопоставляются с (1) и (2)  

Модель запросов DocumentDB пытается найти баланс между функциональностью, эффективностью и простотой. Ядро базы данных DocumentDB непосредственно компилирует и выполняет операторы SQL-запросов. Вы можете сформировать запрос к коллекции с помощью интерфейса [API REST Azure DocumentDB](http://go.microsoft.com/fwlink/p/?LinkID=402413) или любого из клиентских пакетов SDK. В комплект пакета .NET SDK входит поставщик LINQ. В будущих версиях будут предоставлены собственные сопоставления, которые могут быть использованы в пакетах JavaScript SDK на клиентской стороне, а также на стороне сервера в хранимых процедурах и триггерах.   


##Операции над несколькими документами
Транзакции в базах данных обеспечивают безопасную и предсказуемую модель программирования для работы с одновременными изменениями данных. В РСУБД традиционный способ написать бизнес-логику заключается в том, чтобы написать **хранимые процедуры** и/или **триггеры** и загрузить их на сервер базы данных для выполнения в транзакциях. В РСУБД, прикладному программисту приходится иметь дело с двумя разнородными языками программирования: (а) (нетранзакционные) язык прикладного программирования (например, JavaScript, Python, C#, Java и т. д.) и (б) T-SQL, транзакционный язык программирования, который изначально выполняется в базе данных. В силу своей глубокой приверженности JavaScript и JSON непосредственно внутри базы данных, DocumentDB обеспечивает интуитивную модель программирования для выполнения логики приложения на основе JavaScript непосредственно в коллекциях в виде хранимых процедур и триггеров. Это позволяет получить а) эффективную реализацию управления параллелизмом, восстановлением, автоматической индексацией графов объектов JSON прямо в ядре СУБД, а также б) естественно выраженный поток управления, область видимости переменной, присвоение и интеграцию обработки исключений примитивов с транзакциями базы данных непосредственно в терминах языка программирования JavaScript.   

Логика JavaScript, регистрируемая на уровне коллекции, может выполнять операции с базами данных на документах данной коллекции. DocumentDB неявно обертывает хранимые процедуры и триггеры на основе JavaScript с соблюдением ACID и изоляцией моментальных снимков документов в коллекции. В ходе его исполнения, если код JavaScript генерирует исключение, то вся транзакция прерывается. Полученная модель программирования является очень простой, но мощной. Разработчики JavaScript получают "надежную" модель программирования, при этом используя привычные языковые конструкции и библиотечные примитивы.   

Возможность выполнить JavaScript непосредственно в ядре СУБД в том же адресном пространстве, что буферный пул, позволяет выполнять эффективные транзакционные операции с базами данных над документами коллекции. В дополнение к этому, поскольку ядро СУБД DocumentDB ориентировано на JSON и JavaScript, исключается любая потеря соответствия между системами типов приложения и базы данных.   

После создания коллекции вы можете зарегистрировать хранимые процедуры, триггеры и пользовательские функции в коллекции, используя DocumentDB REST API или любой клиентский пакет SDK. После регистрации вы можете использовать и выполнять их. Рассмотрим следующую хранимую процедуру, написанную полностью на JavaScript, которая принимает два аргумента (имя книги и имя автора) и создает новый документ, запросы для документа, а затем обновляет его и все в пределах неявной транзакции ACID. Транзакция будет прервана в любой момент выполнения, если будет выдано исключение JavaScript.

	function businessLogic(name, author) {
	    var context = getContext();
	    var collectionManager = context.getCollection();        
	    var collectionLink = collectionManager.getSelfLink()
	        
	    // create a new document.
	    collectionManager.createDocument(collectionLink,
	        {id: name, author: author},
	        function(err, documentCreated) {
	            if(err) throw new Error(err.message);
	            
	            // filter documents by author
	            var filterQuery = "SELECT * from root r WHERE r.author = 'George R.'";
	            collectionManager.queryDocuments(collectionLink,
	                filterQuery,
	                function(err, matchingDocuments) {
	                    if(err) throw new Error(err.message);
	                    
	                    context.getResponse().setBody(matchingDocuments.length);
	                   
	                    // Replace the author name for all documents that satisfied the query.
	                    for (var i = 0; i < matchingDocuments.length; i++) {
	                        matchingDocuments[i].author = "George R. R. Martin";
	                        // we don't need to execute a callback because they are in parallel
	                        collectionManager.replaceDocument(matchingDocuments[i]._self,
	                            matchingDocuments[i]);   
	                    }
	                })
	        })
	};

Клиент может "грузить" вышеуказанную JavaScript логику в базу данных для транзакционного исполнения через HTTP POST.  

	client.createStoredProcedureAsync(collection._self, {id: "CRUDProc", body: businessLogic})
	   .then(function(createdStoredProcedure) {
	        return client.executeStoredProcedureAsync(createdStoredProcedure.resource._self,
	            "NoSQL Distilled",
	            "Martin Fowler");
	    })
	    .then(function(result) {
	        console.log(result);
	    },
	    function(error) {
	        console.log(error);
	    });


Обратите внимание, что поскольку база данных изначально понимает JSON и JavaScript, нет проблемы несоответствия типов, нет "отображения ИЛИ" или генерации "магического" кода.   

Хранимые процедуры и триггеры взаимодействуют с коллекцией и документами в коллекции через четко определенную объектную модель, которая предоставляет текущий контекст коллекции.  

Коллекции в DocumentDB можно создавать, удалять, читать или перечислять, используя [Azure DocumentDB REST API](http://go.microsoft.com/fwlink/p/?LinkID=402413) или любой клиентский пакет SDK. DocumentDB всегда обеспечивает сильную согласованность для чтения или запроса метаданных коллекции. Удаление коллекции автоматически гарантирует, что вы не сможете получить доступ к любому из документов, вложений, хранимых процедур, триггеров и пользовательских функций, содержащихся в ней. Подготовленные хранилища и пропускная способность, использовавшиеся удаленной базой данных, сразу доступны для использования, несмотря на то что DocumentDB восстанавливает хранилище и пропускную способность в фоновом режиме.   

 
#Хранимые процедуры, триггеры и определяемые пользователем функции
Как описано в предыдущем разделе, вы можете реализовать логику приложения для непосредственного исполнения в рамках транзакции ядра СУБД. Логика приложения может быть полностью написана на JavaScript и смоделирована в виде хранимой процедуры, триггера или определяемой пользователем функции. Код JavaScript в хранимой процедуре или триггере может вставлять, заменять, удалять, читать или формировать запросы к документам коллекции. С другой стороны, код JavaScript в определяемой пользователем функции может выполнять только расчет без побочных эффектов путем перечисления документов результирующего набора запроса и получения другого набора результатов. Для многопользовательской аренды DocumentDB проводит в жизнь управление ресурсами на основе строгого бронирования. Для каждой хранимой процедуры, триггера или пользовательской функции выделяется фиксированный квант ресурсов операционной системы, чтобы выполнить свою задачу. Кроме того, хранимые процедуры, триггеры или пользовательские функции не могут связываться с внешними библиотеками JavaScript и попадают в "черный список", если они превышают бюджеты ресурсов, выделяемых на них. Вы можете зарегистрировать хранимые процедуры, триггеры или пользовательские функции в коллекции или отменить их регистрацию через API REST.  При регистрации хранимая процедура, триггер или пользовательская функция предварительно компилируются и хранятся в виде байт-кода, который выполняется позже. В следующем разделе показано, как можно использовать пакет JavaScript SDK DocumentDB для регистрации, выполнения, отмены регистрации хранимой процедуры, триггера и пользовательской функции. JavaScript SDK - простая программа-оболочка над DocumentDB REST API. 

##Регистрация хранимой процедуры
Регистрация хранимой процедуры - это создание нового ресурса хранимой процедуры ресурса в коллекции через HTTP POST.  

	var storedProc = {
	    id: "validateAndCreate",
	    body: function (documentToCreate) {
	        documentToCreate.id = documentToCreate.id.toUpperCase();
	        
	        var collectionManager = getContext().getCollection();
	        collectionManager.createDocument(collectionManager.getSelfLink(),
	            documentToCreate,
	            function(err, documentCreated) {
	                if(err) throw new Error('Error while creating document: ' + err.message;
	                getContext().getResponse().setBody('success - created ' + 
	                        documentCreated.name);
	            });
	    }
	};
	
	client.createStoredProcedureAsync(collection._self, storedProc)
	    .then(function (createdStoredProcedure) {
	        console.log("Successfully created stored procedure");
	    }, function(error) {
	        console.log("Error");
	    });

##Выполнение хранимой процедуры
Выполнение хранимой процедуры осуществляется с помощью команды HTTP POST, запускаемой для существующего ресурса хранимой процедуры, передавая параметры в теле запроса.

	var inputDocument = {id : "document1", author: "G. G. Marquez"};
	client.executeStoredProcedureAsync(createdStoredProcedure.resource._self, inputDocument)
	    .then(function(executionResult) {
	        assert.equal(executionResult, "success - created DOCUMENT1");
	    }, function(error) {
	        console.log("Error");
	    });

##Отмена регистрации хранимой процедуры
Отмена регистрации хранимой процедуры осуществляется просто с помощью команды HTTP DELETE, запускаемой для существующего ресурса хранимой процедуры.   

	client.deleteStoredProcedureAsync(createdStoredProcedure.resource._self)
	    .then(function (response) {
	        return;
	    }, function(error) {
	        console.log("Error");
	    });


##Регистрация триггера со срабатыванием до наступления события
Регистрация триггера осуществляется путем создания ресурса триггера в коллекции через команду HTTP POST. Вы можете указать тип срабатывания триггера (до или после события) и тип операции, с которой он может быть связан (например, создание, замена, удаление или все типы).   

	var preTrigger = {
	    id: "upperCaseId",
	    body: function() {
	            var item = getContext().getRequest().getBody();
	            item.id = item.id.toUpperCase();
	            getContext().getRequest().setBody(item);
	    },
	    triggerType: TriggerType.Pre,
	    triggerOperation: TriggerOperation.All
	}
	
	client.createTriggerAsync(collection._self, preTrigger)
	    .then(function (createdPreTrigger) {
	        console.log("Successfully created trigger");
	    }, function(error) {
	        console.log("Error");
	    });

##Запуск триггера со срабатыванием до наступления события
Выполнение триггера производится путем указания в заголовке запроса имени существующего триггера в момент выдачи запроса POST/PUT/DELETE к ресурсу документа.  
 
	client.createDocumentAsync(collection._self, { id: "doc1", key: "Love in the Time of Cholera" }, { preTriggerInclude: "upperCaseId" })
	    .then(function(createdDocument) {
	        assert.equal(createdDocument.resource.id, "DOC1");
	    }, function(error) {
	        console.log("Error");
	    });

##Отмена регистрации триггера со срабатыванием до наступления события
Отмена регистрации триггера осуществляется просто с помощью команды HTTP DELETE, запускаемой для существующего ресурса триггера.  

	client.deleteTriggerAsync(createdPreTrigger._self);
	    .then(function(response) {
	        return;
	    }, function(error) {
	        console.log("Error");
	    });

##Регистрация определяемой пользователем функции
Регистрация определяемой пользователем функции осуществляется путем создания нового ресурса UDF в коллекции или через команду HTTP POST.  

	var udf = { 
	    id: "mathSqrt",
	    body: function(number) {
	            return Math.sqrt(number);
	    },
	};
	client.createUserDefinedFunctionAsync(collection._self, udf)
	    .then(function (createdUdf) {
	        console.log("Successfully created stored procedure");
	    }, function(error) {
	        console.log("Error");
	    });



##Выполнение определяемой пользователем функции как части запроса
Определяемая пользователем функция (UDF) может быть указана как часть SQL-запроса и использоваться в качестве способа расширения языка SQL-запросов ядра DocumentDB. Более подробную информации о написании UDF в языке запросов SQL в DocumentDB можно найти в спецификации языка запросов SQL DocumentDB.  

	var filterQuery = "SELECT mathSqrt(r.Age) AS sqrtAge FROM root r WHERE r.FirstName='John'";
	client.queryDocuments(collection._self, filterQuery).toArrayAsync();
	    .then(function(queryResponse) {
	        var queryResponseDocuments = queryResponse.feed;
	    }, function(error) {
	        console.log("Error");
	    });

##Отмена регистрации определяемой пользователем функции 
Отмена регистрации определяемой пользователем функции осуществляется командой HTTP DELETE, выполняемой для существующего ресурса UDF.  

	client.deleteUserDefinedFunctionAsync(createdUdf._self)
	    .then(function(response) {
	        return;
	    }, function(error) {
	        console.log("Error");
	    });

Хотя примеры, указанные выше, используют команды для регистрации (POST), отмены регистрации (PUT), чтения/получения списка (GET) и выполнения (POST) через пакет JavaScript SDK DocumentDB, вы также можете использовать интерфейсы API REST или другие клиентские пакеты SDK. 

 
#Документы
Вы можете вставлять, заменять, удалять, читать, перечислять и запрашивать произвольные документы JSON в коллекции. DocumentDB не требует указывать схему и создавать вторичные индексы для поддержки запросов к документам в коллекции.   

Будучи действительно открытой службой базы данных, DocumentDB не создает какие-то специализированные типы данных (например, date time) или особые кодировки для документов JSON. Обратите внимание, что DocumentDB не требует никаких специальных условных обозначений JSON для кодирования связей между различными документами; язык запросов SQL из DocumentDB предоставляет чрезвычайно мощные иерархические и реляционные операторы для запросов и документов проектов без специальных примечаний или необходимости кодировать отношения между документами с помощью отличительных свойств.  
 
Как и для всех других ресурсов, документы могут быть созданы, заменены, удалены, прочитаны, перечислены и запрошены с использованием REST API или любого клиентского пакета SDK. Удаление документа мгновенно освобождает квоту, соответствующую всем его вложениям. Уровень согласованности для чтения документов соответствует политике согласованности для учетной записи базы данных. Эта политика может быть переопределена для каждого запроса в зависимости от требований к согласованности данных для вашего приложения. При запросе документов согласованность чтения соответствует режиму индексирования, который задан в коллекции. Понятие "согласованность" следует политике согласованности для учетной записи. 

#Вложения и накопители
DocumentDB позволяет хранить двоичные BLOB-объекты/медиафайлы либо непосредственно в DocumentDB, либо в удаленном хранилище файлов. Она также позволяет представлять метаданные медиафайлов в виде особого документа под названием "вложение". Вложение в DocumentDB - это специальный (JSON) документ, который ссылается на медиафайлы/BLOB, хранящиеся в другом месте. Вложение представляет собой специальный документ, который фиксирует метаданные (например, расположение, автора и т. д.) медиафайлов, хранящихся в удаленном хранилище. 

Рассмотрим социальное приложения для чтения, которое использует DocumentDB для хранения заметок и метаданных, включая комментарии, выделения, закладки, рейтинги, пометки "нравится/не нравится" и т. д., связанных с электронной книгой данного пользователя.   

-	Содержание самой книги хранится в хранилище, доступном в виде части учетной записи базы данных DocumentDB или удаленного хранилища. 
-	Приложение может хранить метаданные каждого пользователя в виде отдельного документа. Например, метаданные пользователя Джо для книги Book1 можно хранить в документе, имеющем ссылку /colls/joe/docs/book1. 
-	Вложения, указывающие на страницы содержимого данной книги пользователя, хранятся в соответствующем документе, например /colls/joe/docs/book1/chapter1, /colls/joe/docs/book1/chapter2 и т. д. 

Обратите внимание, что в примерах используются мнемонические идентификаторы для передачи иерархии ресурсов. Ресурсы доступны через REST API по уникальным идентификаторам ресурсов. 

Для медиафайла, который управляется DocumentDB, свойство вложения _media будет ссылаться на медиафайл по его URI. DocumentDB запустит уборку мусора, когда все находящиеся в коллекции ссылки на медиафайл будут удалены. DocumentDB автоматически генерирует вложение, когда вы загружаете новые медиафайлы, и заполняет _media ссылками на вновь добавленные файлы. Если вы решите хранить медиафайлы в удаленном хранилище больших двоичных объектов, управляемом вами (например, OneDrive, хранилище Azure, DropBox и т. д.), вы можете использовать вложения для хранения ссылок. В этом случае вам придется создавать вложение и заполнять его свойство _media самостоятельно.   

Как и все прочие ресурсы, вложения могут быть созданы, заменены, удалены, прочитаны или перечислены с помощью REST API либо любого клиентского пакета SDK. Как и для документов, уровень согласованности для чтения вложений соответствует политике согласованности для учетной записи базы данных. Эта политика может быть переопределена для каждого запроса в зависимости от требований к согласованности данных для вашего приложения. При запросе вложений согласованность чтения соответствует режиму индексирования, который задан в коллекции. Понятие "согласованность" следует политике согласованности для учетной записи. 

 
#Пользователи
Пользователь в DocumentDB представляет собой логическое пространство имен для группировки разрешений. Пользователю в DocumentDB может соответствовать пользователь в системе управления удостоверениями или предопределенной роли приложения. В рамках DocumentDB пользователь представляет собой абстракцию для группировки набора разрешений под базой данных.   

Чтобы реализовать для приложения многопользовательскую среду, вы можете создавать пользователей в DocumentDB, которые будут соответствовать фактическим пользователям или клиентам вашего приложения. Затем можно создать разрешения для заданного пользователя, которые соответствуют управлению доступом к различным коллекциям, документам, приложениям и т. д.   

По мере масштабирования вашего приложения с ростом количества пользователей вы можете использовать различные способы для сегментирования данных. Вы можете смоделировать каждого из ваших пользователей следующим образом:   

-	каждый пользователь сопоставлен базе данных
-	каждый пользователь сопоставлен коллекции, 
-	документы, соответствующие нескольким пользователям выделенной коллекции, или 
-	модели документов, соответствующих нескольким пользователям выделенной коллекции   

Независимо от конкретной стратегии сегментирования, вы можете моделировать реальных пользователей в качестве пользователей в базе данных DocumentDB и присваивать точные разрешения каждому пользователю.  

![][4]  
**Стратегии сегментирования и моделирования пользователей**

Как и все прочие ресурсы, пользователи в DocumentDB могут быть созданы, заменены, удалены, прочитаны или перечислены с помощью REST API либо любого клиентского пакета SDK.  DocumentDB всегда обеспечивает сильную согласованность для чтения или запроса метаданных ресурса пользователя. Стоит отметить, что при удалении пользователя гарантируется, что вы не сможете получить доступ к любому из разрешений, входящих в его состав. Удаленные разрешения станут сразу доступны для повторного использования, несмотря на то что DocumentDB восстанавливает квоту разрешений удаленного пользователя в фоновом режиме.  


#Разрешения
С точки зрения управления доступом ресурсы, такие как учетные записи баз данных, базы данных, пользователи и разрешения, считаются *административными* ресурсами, так как они требуют права администратора. С другой стороны, ресурсы, включая коллекции, документы, вложения, хранимые процедуры, триггеры и пользовательские функции, находятся в области видимости данной базы данных и рассматриваются как *ресурсы приложения*. В соответствии с двумя типами ресурсов и ролями, которые обращаются к ним (администратора и пользователей), модель авторизации определяет два типа *ключей доступа*: *мастер-ключ *и *ключ ресурса*. Мастер-ключ является частью учетной записи базы данных и предоставляется разработчику (или администратору), который подготавливает учетную запись базы данных. Этот мастер-ключ имеет семантику администратора, в том смысле, что он может быть использован для того, чтобы разрешить доступ как к административным, так и к прикладным ресурсам. В отличие от этого, ключ ресурса является разделенным ключом доступа, который позволяет получить доступ к *определенному* ресурсу приложения. Таким образом, он охватывает отношения между пользователем базы данных и разрешениями пользователя, которые он имеет для определенного ресурса (например, коллекции, документа, вложения, хранимой процедуры, триггера или пользовательской функции).   

Единственный способ получить ключ ресурса - создать разрешение для ресурса под конкретного пользователя. Обратите внимание, что для создания или получения разрешения мастер-ключ должен быть представлен в заголовке авторизации. Разрешение ресурса связывает ресурс, доступ к нему и пользователя. После создания разрешения ресурса пользователю нужно только предоставить ключ, связанный с ресурсами, для того чтобы получить доступ к соответствующему ресурсу. Таким образом, ключ ресурса можно рассматривать как логическое и компактное представление разрешения ресурса.  

Как и все прочие ресурсы, разрешения могут быть созданы, заменены, удалены, прочитаны или перечислены с помощью REST API либо любого клиентского пакета SDK. DocumentDB всегда обеспечивает сильную согласованность для чтения или запроса метаданных какого-либо разрешения. 




[1]: ./media/documentdb-resources/resources1.png
[2]: ./media/documentdb-resources/resources2.png
[3]: ./media/documentdb-resources/resources3.png
[4]: ./media/documentdb-resources/resources4.png
