<properties title="Quick start guide to R for Azure Machine Learning Studio" pageTitle="Краткое руководство по R для Студии машинного обучения Microsoft Azure" description="Использование R в Studio обучения машины Azure" metaKeywords="R azure, r machine learning, azure r machin elearning" services="machine-learning" solutions="" documentationCenter="" authors="larryfr" manager="paulettm" editor="cgronlun"  videoId="" scriptId="" />

<tags ms.service="machine-learning" ms.workload="data-services" ms.tgt_pltfrm="na" ms.devlang="na" ms.topic="article" ms.date="10/14/2014" ms.author="larryfr" />

#Краткое руководство по использованию языка R в Студии машинного обучения Microsoft Azure

Доктор наук Стивен Ф. Элстон

##  Введение

Студия машинного обучения Microsoft Azure содержит множество модулей машинного обучения и обработки данных.  Высокоэффективный язык R считается универсальным языком аналитики.  К счастью, возможности аналитики и обработки данных, которыми располагает Студия машинного обучения Microsoft Azure, можно расширить благодаря использованию языка R. Это сочетание позволяет объединить масштабируемость при развертывании Студии машинного обучения с гибкостью и глубиной аналитики языка R.

Настоящий документ поможет вам научиться применять язык R для расширения возможностей машинного обучения Microsoft Azure. Это руководство содержит сведения, необходимые для создания, тестирования и выполнения кода на R в среде машинного обучения Microsoft Azure. Выполняя шаги руководства, вы создадите полноценное решение прогнозной аналитики, используя язык R в среде машинного обучения Microsoft Azure.  

###Прогнозирование и набор данных

Прогнозирование - широко распространенный и чрезвычайно полезный метод аналитики. Сфера его применения охватывает широкий диапазон: от прогноза объема продаж сезонных товаров, определяющего уровень заполнения склада, до расчета макроэкономических переменных. Преимущественно при прогнозировании используются модели временных рядов.

Данные временных рядов - данные, значения которых имеют индекс времени. Значение индекса времени может быть регулярным (например, помесячным или поминутным), или нерегулярным. Модель временных рядов основана на данных временных рядов. Язык R располагает гибкой структурой и широкими возможностями аналитики для временных данных.

В этом руководстве мы будем использовать данные по производству молочных продуктов в Калифорнии и ценам на них.  Эти данные включают сведения о производстве нескольких молочных продуктов и цену молочного жира - эталонного товара.

Данные, использующиеся в этой статье, а также скрипты на языке R, можно [скачать здесь][download]. Эти данные основаны на информации, собранной университетом Висконсина и доступной по адресу http://future.aae.wisc.edu/tab/production.html.

###	План

Вам потребуется несколько шагов, чтобы научиться создавать, тестировать и выполнять код на R для анализа и обработки данных в среде машинного обучения Microsoft Azure.  

* Сначала мы изучим основы использования языка R в Студии машинного обучения Microsoft Azure.

* Затем рассмотрим различные аспекты ввода и вывода данных, кода на R и графики в среде машинного обучения Microsoft Azure.

* После этого мы построим первую часть прогнозного решения, создав код для очистки и преобразования данных.

* Подготовив данные, мы проанализируем корреляцию нескольких переменных нашего набора данных.

* Наконец, мы создадим прогнозную модель сезонного временного ряда для молочного производства.

##Оглавление

* [Взаимодействие с языком R в Студии машинного обучения Microsoft Azure](#mlstudio)

* [Ввод и вывод данных модуля "Выполнение скрипта R"](#scriptmodule)

* [Фильтрация и преобразование данных](#filtering)

* [Объекты временного ряда и анализ корреляций](#timeseries)

* [Пример временного ряда: сезонное прогнозирование](#seasonalforecasting)

* [Приложение 1. Руководство по RStudio](#appendixa)

* [Приложение 2. Дополнительная литература](#appendixb)

##<a id="mlstudio"></a>Взаимодействие с языком R в Студии машинного обучения Microsoft Azure

В этом разделе вы познакомитесь с основами взаимодействия с языком R в среде Студии машинного обучения Microsoft Azure.  Язык R - мощный инструмент для создания настраиваемых модулей анализа и обработки данных в среде машинного обучения Microsoft Azure.

Для разработки, тестирования и отладки небольших фрагментов кода на языке R мы будем использовать RStudio.  Впоследствии мы вставим эти готовые фрагменты в модуль "Выполнение скрипта R" в Студии машинного обучения Microsoft Azure.  

###Модуль "Выполнение скрипта R"

В Студии машинного обучения Microsoft Azure скрипты на языке R выполняются в модуле "Выполнение скрипта R".  Пример этого модуля в Студии машинного обучения показан на рисунке 1.

 ![The ML Studio environment showing the Execute R Script module selected][1]

*Рисунок 1. Среда Студии машинного обучения Microsoft Azure с выбранным модулем "Выполнение скрипта R".*

Используя рисунок 1, рассмотрим основные элементы среды Студии машинного обучения для работы с модулем "Выполнение скрипта R".

- Модули эксперимента отображаются на центральной панели.

- В верхней части правой панели находится окно просмотра и изменения скриптов R.  

- В нижней части правой панели отображаются свойства этого скрипта. Журнал ошибок и журнал выходных данных можно просмотреть, щелкнув соответствующие элементы панели.

Разумеется, в оставшейся части этого документа мы рассмотрим модуль "Выполнение скрипта R" подробнее.

При работе с более сложными функциями R для изменения, тестирования и отладки кода я рекомендую использовать RStudio. Как и в случае разработки любого программного обеспечения, создавайте код пошагово, отдельными фрагментами, и тестируйте его на небольших, простых проверочных примерах. Затем вырезайте и вставляйте готовые функции в окно скрипта модуля "Выполнение скрипта R".  Такой подход позволяет в полной мере использовать как интегрированную среду разработки RStudio, так и возможности машинного обучения Microsoft Azure.  

####Выполнение кода на языке R

Любой код на R в модуле "Выполнение скрипта R" выполняется при запуске эксперимента нажатием кнопки **Запуск**.  Когда код выполнен, на значке модуля "Выполнение скрипта R" появляется отметка о выполнении.

####Защищенное программирование на R для машинного обучения Microsoft Azure

При разработке кода на R для, скажем, какой-нибудь веб-службы с помощью машинного обучения Microsoft Azure необходимо предусмотреть, как ваш код будет реагировать на непредвиденные входные данные и исключения. Чтобы не усложнять, я не стал добавлять проверку или обработку исключений во все примеры кода.  Однако далее я приведу несколько примеров функций, использующих возможности языка R для обработки исключений.  

Если вас интересует более подробная информация об обработке исключений на R, рекомендую прочитать соответствующие разделы книги Викхема из списка [дополнительной литературы в приложении 2](#appendixb).


####Отладка и тестирование фрагментов кода на языке R в Студии машинного обучения Microsoft Azure

Повторюсь: я рекомендую использовать RStudio для отладки и тестирования небольших фрагментов кода на R.  Однако бывают случаи, когда необходимо отслеживать проблемы кода непосредственно в модуле "Выполнение скрипта R".  Кроме того, это неплохая привычка - проверять результаты работы в Студии машинного обучения Microsoft Azure.

Большая часть выходных данных при выполнении кода на R на платформе машинного обучения Microsoft Azure находится в файле output.log. Дополнительные сведения отображаются в файле error.log.  

Если происходит сбой при выполнении вашего кода в Студии машинного обучения, в первую очередь нужно просмотреть файл error.log. В этом файле могут быть полезные сообщения об ошибках, которые помогут вам понять и исправить свою ошибку.  Чтобы просмотреть файл error.log, выберите элемент **Просмотр журнала ошибок** на **панели свойств** модуля "Выполнение скрипта R", содержащего ошибку.

Например, запустим этот код на R с неопределенной переменной y в модуле "Выполнение скрипта R":

```r
x <- 1.0
z <- x + y
```

Выполнить этот код не удается, возникает условие ошибки. После нажатия элемента **Просмотр журнала ошибок** на **панели свойств** появляется всплывающее окно (см. рис. 2):

  ![Error message pop up][2]

*Рисунок 2. Всплывающее окно сообщения об ошибке.*

Похоже, нужно просмотреть файл output.log, чтобы прочитать сообщение об ошибке в коде на R. Щелкнем "Выполнение скрипта R", а затем - элемент **Просмотр журнала ошибок** на **панели свойств** справа. Откроется новое окно браузера, где мы видим следующее:


	[ModuleOutput] [1] 14000
	[ModuleOutput]
	[ModuleOutput] Loading objects:
	[ModuleOutput]
	[ModuleOutput]   port1
	[ModuleOutput]
	[ModuleOutput] [1] "Loading variable port1..."
	[ModuleOutput]
	[ModuleOutput] Error in eval(expr, envir, enclos) : object 'y' not found

В сообщении об ошибке нет ничего неожиданного: проблема четко определена.

Чтобы проверить значение любого объекта в коде на R, можно обеспечить вывод этих значений в файл output.log.  Правила проверки значений объектов в принципе те же, что и при интерактивном сеансе работы с R.  Например, если ввести в строке имя переменной, значение объекта выводится в файл output.log.  

####Пакеты в Студии машинного обучения Microsoft Azure

Служба машинного обучения Microsoft Azure содержит более 350 предустановленных пакетов на R.  Чтобы увидеть список предустановленных пакетов, используйте приведенный ниже код в модуле "Выполнение скрипта R".

```r
data.set <- data.frame(installed.packages())
maml.mapOutputPort("data.set")
```

Если вам пока не понятна последняя строка кода, не останавливайтесь.  Далее в этом документе мы подробно рассмотрим использование R в среде машинного обучения Microsoft Azure.

###	Общие сведения об RStudio

RStudio - широко распространенная интегрированная среда разработки для языка R. Я буду использовать RStudio для изменения, тестирования и отладки фрагментов кода на R, использующихся в этом руководстве.  Когда код готов и проверен, его можно просто вырезать из редактора RStudio и вставить в модуль "Выполнение скрипта R" в Студии машинного обучения Microsoft Azure.  

Если на вашем компьютере еще не установлен язык R, рекомендую сделать это сейчас. Бесплатно загрузить R с открытым исходным кодом можно на ресурсе Comprehensive R Archive Network (CRAN) по адресу http://www.r-project.org/. Доступны загрузки для Windows, MacOS и Linux/UNIX. Выберите любое зеркало и следуйте инструкциям по загрузке.   CRAN также содержит множество полезных пакетов для аналитики и обработки данных.

Если вы еще не знакомы с RStudio, вам лучше загрузить и установить версию для настольного компьютера. Загрузить RStudio для Windows, MacOS и Linux/UNIX можно на по адресу http://www.rstudio.com/products/RStudio/. Следуйте инструкциям по установке RStudio на компьютер.  

Учебник по основам работы с RStudio доступен по адресу https://support.rstudio.com/hc/ru-ru/sections/200107586-Using-RStudio.

Дополнительную информацию по использованию RStudio можно найти в [приложении 1][appendixa].  

##<a id="scriptmodule"></a>Ввод и вывод данных модуля "Выполнение скрипта R"

В этом разделе мы рассмотрим ввод и вывод данных модуля "Выполнение скрипта R".  Мы познакомимся с обработкой различных типов данных, передаваемых в модуль "Выполнение скрипта R" и получаемых из него.

Полный код для этого раздела есть в ZIP-файле, который вы загрузили ранее.

###Загрузка данных в Студию машинного обучения Microsoft Azure и их проверка

####<a id="loading"></a>Загрузка набора данных

Для начала загрузим в Студию машинного обучения Microsoft Azure файл **csdairydata.csv**.

- Запустите Студию машинного обучения Microsoft Azure.

- Щелкните значок плюса (+) в нижнем левом углу экрана и выберите элемент **Набор данных**.

- Выберите файл, выбрав элемент **Обзор**.

- Убедитесь, что выбран **универсальный CSV-файл с заголовком**.

- Щелкните значок галочки.

- Вы увидите новые наборы данных, открыв вкладку **Наборы данных**.  

####Создание эксперимента

Теперь у нас есть определенные данные в Студии машинного обучения Microsoft Azure и можно создать эксперимент, чтобы выполнить анализ.  

- Щелкните значок плюса (+) в нижнем левом углу и выберите элемент **Эксперимент**.

- Дайте имя своему эксперименту.  Я назову свой **Анализ молочных продуктов**.

- Выполните поиск набора данных, который вы только что передали.

- Перетащите **набор данных csdairydata.csv** на рабочую область эксперимента.  

- В поле **Поиск элементов эксперимента** в верхней части левой панели введите текст **Выполнение скрипта R**.  Этот модуль появится в списке результатов поиска.

- Перетащите модуль "Выполнение скрипта R" на рабочую область.  

- Соедините порт вывода **набора данных csdairydata.csv** с крайним левым портом ввода (**Набор данных 1**) модуля **Выполнение скрипта R**.

- **Не забудьте нажать кнопку "Сохранить"!**  

На этом этапе ваш эксперимент должен выглядеть, как показано на рисунке 3.

![The CA Dairy Analysis Experiment with dataset and Execute R Script module][3]

*Рисунок 3.  Эксперимент "Анализ молочных продуктов": набор данных и модуль "Выполнение скрипта R"*

####Проверка данных

Рассмотрим данные, загруженные в наш эксперимент.  В эксперименте дважды щелкните порт вывода **набора данных cadairydata.csv** и выберите элемент **Визуализировать**.   Вы увидите нечто вроде этого (рис. 4):  

![The summary of the cadairydata.csv data set][4]

*Рисунок 4.  Сводка набора данных cadairydata.csv.*

Здесь представлено много полезной информации.  Строка **Тип компонента** показывает, какие типы данных присвоены столбцам нашего набора данных в Студии машинного обучения Microsoft Azure.  Также видны первые несколько строк этого набора данных.  Такой беглый просмотр данных - хорошая проверка перед началом серьезной работы.

###	Первый скрипт R

Создадим простой первый скрипт на R, с которым и будем работать в Студии машинного обучения Microsoft Azure.  Я создал и протестировал такой скрипт в RStudio:  

```r
## Only one of the following two lines should be used
## If running in ML Studio use the first line with maml.mapInputPort().
## If in RStudio used the second line with read.csv()
cadairydata <- maml.mapInputPort(1)
# cadairydata  <- read.csv("cadairydata.csv", header = TRUE, stringsAsFactors = FALSE)
str(cadairydata)
pairs(~ Cotagecheese.Prod + Icecream.Prod + Milk.Prod + N.CA.Fat.Price, data = cadairydata)
## The following line should be executed only when running in
## Azure ML Studio.
maml.mapOutputPort('cadairydata')
```

Теперь мне нужно перенести его в Студию машинного обучения Microsoft Azure.  Можно было бы его просто вырезать и вставить.  Но в данном случае я перенесу свой скрипт R при помощи ZIP-файла.

###	Ввод данных в модуль "Выполнение скрипта R"

Рассмотрим порты ввода данных модуля "Выполнение скрипта R".  В этом примере мы считаем данные по молочной продукции Калифорнии в модуль "Выполнение скрипта R".  

У модуля "Выполнение скрипта R" может быть три порта ввода данных.  В зависимости от приложения можно использовать любой из них или все.  Также бывает целесообразно использовать модуль вообще без портов ввода.  

Рассмотрим все порты ввода по порядку слева направо. Наведя курсор на порт, можно увидеть всплывающую подсказку с его именем.  

####	Пакет скриптов

Порт ввода "Пакет скриптов" позволяют передать содержимое ZIP-файла в модуль "Выполнение скрипта R".  Для считывания содержимого ZIP-файла в код R можно использовать одну из этих команд:

```r
source("src/yourfile.R") # Reads an zipped R script
load("src/yourData.rdata") # Reads a zipped R data file
```

> [WACOM.NOTE] Студия машинного обучения Microsoft Azure обрабатывает файлы ZIP-архива как если бы они находились в каталоге src/, поэтому необходимо добавлять имя этого каталога в начало имен файлов.  

Загрузка наборов данных уже рассматривалась в разделе [Загрузка набора данных](#loading).  После создания и тестирования скрипта R, описанных в предыдущем разделе, сделайте следующее:

1. Сохраните скрипт R в файл с расширением .R.  Я назвал свой файл скрипта "simpleplot.R".  

2.  Создайте ZIP-файл и скопируйте в него свой скрипт.

3.	Добавьте свой файл в раздел **наборы данных** в Студии машинного обучения, указав тип файла **zip**. Вы увидите ZIP-файл среди своих наборов данных.

4.	Перетащите свой ZIP-файл из раздела **наборы данных** на **канву Студии машинного обучения Microsoft Azure**.

5.	Соедините порт вывода значка **ZIP-данных** с портом ввода **Пакет скриптов** модуля **Выполнение скрипта R**.

6.	В окне кода модуля **Выполнение скрипта R** введите функцию source() с именем вашего ZIP-файла.  В данном случае введено `source("src/SimplePlot.R")`.  

7.	Обязательно нажмите **Сохранить**.

После выполнения этих шагов модуль "Выполнение скрипта R" выполнит скрипт R в ZIP-файле при запуске эксперимента. На этом этапе ваш эксперимент должен выглядеть, как изображено на рисунке 5.

![Experiment using zipped R script][6]

*Рисунок 5. Эксперимент с использованием скрипта R, сжатого в ZIP-файл.*

####Набор данных 1

С помощью порта ввода "Набор данных 1" можно передать прямоугольную таблицу данных в код на R.  В нашем простом скрипте функция maml.mapInputPort(1) считывает данные из порта 1.  Затем эти данные присваиваются имени переменной в вашем коде, тип которой - таблица данных.  В нашем примере скрипта присвоение выполняет первая строка кода.

```r
cadairydata <- maml.mapInputPort(1)
```

Выполните эксперимент, нажав кнопку **Запуск**.  По завершении выполнения щелкните модуль "Выполнение скрипта R", а затем - **Просмотр журнала выходных данных** на панели свойств.  В браузере откроется новая страница с содержимым файла Output.log.  Прокрутив ее вниз, вы увидите следующее:

	[ModuleOutput] [1] "Loading variable port1..."
	[ModuleOutput]
	[ModuleOutput] 'data.frame':	228 obs. of  9 variables:
	[ModuleOutput]
	[ModuleOutput]  $ Column 0         : int  1 2 3 4 5 6 7 8 9 10 ...
	[ModuleOutput]
	[ModuleOutput]  $ Year.Month       : num  1995 1995 1995 1995 1995 ...
	[ModuleOutput]
	[ModuleOutput]  $ Month.Number     : int  1 2 3 4 5 6 7 8 9 10 ...
	[ModuleOutput]
	[ModuleOutput]  $ Year             : int  1995 1995 1995 1995 1995 1995 1995 1995 1995 1995 ...
	[ModuleOutput]
	[ModuleOutput]  $ Month            : chr  "Jan" "Feb" "Mar" "Apr" ...
	[ModuleOutput]
	[ModuleOutput]  $ Cotagecheese.Prod: num  4.37 3.69 4.54 4.28 4.47 ...
	[ModuleOutput]
	[ModuleOutput]  $ Icecream.Prod    : num  51.6 56.1 68.5 65.7 73.7 ...
	[ModuleOutput]
	[ModuleOutput]  $ Milk.Prod        : num  2.11 1.93 2.16 2.13 2.23 ...
	[ModuleOutput]
	[ModuleOutput]  $ N.CA.Fat.Price   : num  0.98 0.892 0.892 0.897 0.897 ...

Результаты преимущественно ожидаемые. В таблице данных 228 наблюдений и 9 столбцов.  Отображаются имена столбцов, тип данных R и пример каждого столбца.

> [WACOM.NOTE] Эти же результаты можно получить с помощью порта вывода "Устройство R" модуля "Выполнение скрипта R".  Порты вывода этого модуля мы рассмотрим подробнее в следующем разделе.  

####Набор данных 2

Поведение портов ввода "Набор данных 2" такое же, как у портов "Набор данных 1".  С помощью этого порта можно передать еще одну прямоугольную таблицу данных в код на R.  Для передачи этих данных используется функция maml.mapInputPort(2) с аргументом 2.  

###Порты вывода модуля "Выполнение скрипта R"

####Вывод таблицы данных

Через порт "Итоговый набор данных 1" можно вывести содержимое таблицы данных на R в виде прямоугольной таблицы с помощью функции maml.mapOutputPort().  В нашем примере скрипта R это выполняется с помощью такой строки:

```r
maml.mapOutputPort('cadairydata')
```

Выполнив эксперимент, щелкните порт вывода "Итоговый набор данных 1" и выберите элемент **Визуализировать**.  Вы увидите нечто вроде этого (рис. 6):

![The visualization of the output of the California dairy data][7]

*Рисунок 6. Визуализация вывода данных по молочной продукции Калифорнии.*

Выходные данные выглядят в точности так, как и входные - как и предполагалось.  

###	Порт вывода "Устройство R"

Порт вывода "Устройство R" модуля "Выполнение скрипта R" предназначен для вывода сообщений и графики.  Как стандартный вывод данных, так и сообщения об ошибках на R направляются в порт вывода "Устройство R".  

Чтобы просмотреть выходные данные порта "Устройство R", щелкните этот порт и команду **Визуализировать**.  На рисунке 7 показаны стандартный вывод данных и стандартный вывод ошибок.

![Standard output and standard error from the R Device port][8]

*Рисунок 7. Стандартный вывод данных и стандартный вывод ошибок из порта "Устройство R".*

Прокрутив вниз, увидим графический вывод данных скрипта R (рис. 8).  

![Graphics output from the R Device port][9]

*Рисунок 8. Графический вывод данных из порта "Устройство R".*  

##<a id="filtering"></a>Фильтрация и преобразование данных

В этом разделе мы выполним простые операции фильтрации и преобразования данных по молочной продукции Калифорнии.  В конце мы получим данные в формате, удобном для построения аналитической модели.  

В частности, в этом разделе мы выполним несколько распространенных задач по очистке и преобразованию данных: преобразование типа данных, фильтрацию таблиц данных, добавление новых вычисляемых столбцов и преобразование значений. Эти базовые навыки помогут вам справиться с любыми видами задач при решении практических проблем.

Полный код на R для этого раздела доступен в ZIP-файле, который вы загрузили ранее.

###	Преобразование типов данных

Мы уже можем считать данные по молочной продукции Калифорнии в модуль "Выполнение скрипта R", но нужно убедиться, что данные в столбцах имеют нужный тип и формат.  

R - динамически типизированный язык. Другими словами, при необходимости типы данных преобразуются из одного в другой. Атомарные типы данных в языке R включают числовые, логические и символьные.  Факторы используются для компактного хранения категориальных данных.  Дополнительные сведения о типах данных можно найти в материалах [приложения 2](#appendixb).

При считывании в R табличных данных из внешних источников рекомендуется всегда проверять в столбцах результирующие типы.  Зачастую может оказаться, что данные в столбце не символьного типа, как предполагалось, а относятся к типу фактор (или наоборот).  В других случаях столбец, который должен содержать числовые данные, содержит символьные данные, например '1,23' вместо 1,23 - числа с плавающей запятой.  

К счастью, можно легко преобразовывать один тип данных в другой, при условии что их сопоставление возможно.  Например, нельзя преобразовать слово "Самара" в числовое значение, но его можно преобразовать в фактор (категориальную переменную).  Еще один пример. Числовое значение 1 можно преобразовать в символ '1' или в фактор.  

Синтаксис любого из этих преобразований прост: as.datatype().  Вот функции преобразования типов данных:

* `as.numeric()`

* `as.character()`

* `as.logical()`

* `as.factor()`

Рассмотрим типы данных столбцов, которые мы ввели в предыдущем разделе. Тип всех столбцов числовой, кроме столбца "Месяц", тип которого символьный.  Преобразуем его в фактор и проверим результат.  

Я удалил строку, создававшую матрицу точечной диаграммы, и добавил строку, преобразующую тип столбца "Месяц" в фактор.  В моем эксперименте я просто вырежу код на R и вставлю его в окно кода модуля "Выполнение скрипта R".  Также можно обновить ZIP-файл и передать его в Студию машинного обучения Microsoft Azure, но это будет дольше.  

```r
## Only one of the following two lines should be used
## If running in ML Studio use the first line with maml.mapInputPort().
## If in RStudio used the second line with read.csv()
cadairydata <- maml.mapInputPort(1)
# cadairydata  <- read.csv("cadairydata.csv", header = TRUE, stringsAsFactors = FALSE)
## Ensure the coding is consistent and convert column to a factor
cadairydata$Month <- as.factor(cadairydata$Month)
str(cadairydata) # Check the result
## The following line should be executed only when running in
## Azure ML Studio.
maml.mapOutputPort('cadairydata')
```

Выполним этот код и посмотрим на результат. Вывод данных, полученных после нажатия кнопки **Визуализировать** в меню порта "Устройство R", приведен на рисунке 9.

![Summary of the dataframe with a factor variable][10]

*Рисунок 9. Сводка таблицы данных с фактором в качестве переменной.*

Тип столбца "Месяц" изменился на **Factor w/ 14 levels**.  Такой вариант нас не устраивает, поскольку в году всего 12 месяцев. Также можно убедиться, выбрав пункт **Визуализировать** в меню порта "Итоговый набор данных", что у выходных данных **категориальный** тип.

Проблема в том, что кодирование столбца "Месяц" было бессистемным.  В некоторых случаях месяц назван April, а в других - сокращенно Apr. Эту проблему можно решить, сократив строку до трех символов.  Теперь строка кода выглядит так:

```r
## Ensure the coding is consistent and convert column to a factor
cadairydata$Month <- as.factor(substr(cadairydata$Month, 1, 3))
```

Выполним эксперимент повторно и **визуализируем** вывод данных порта "Устройство R". Результат представлен на рисунке 10.  

![Summary of the dataframe with correct number of factor levels][11]

*Рисунок 10. Сводка таблицы данных с правильным количеством уровней фактора.*

Теперь у нашей переменной - фактора - 12 уровней, как и положено.

###Базовая фильтрация таблицы данных

Таблицы данных R поддерживают массу возможностей фильтрации.  Наборы данных можно разбивать на подмножества, используя логическую фильтрацию по строкам или столбцам. Во многих случаях вам потребуются сложные критерии фильтрации. В материалах из [приложения 2](#appendixb) содержится множество примеров фильтрации таблиц данных.  

Выполним операцию фильтрации в нашем наборе данных. Если рассмотреть столбцы таблицы данных R cadariydata, можно заметить два ненужных столбца.  Первый содержит только номер строки - который не так уж и важен. Второй, "Год.Месяц"  (Year.Month), содержит избыточные сведения.  С помощью кода на R мы можем легко исключить эти столбцы.

> [WACOM.NOTE] С этого момента я буду показывать только дополнительный код, который добавляется в модуль "Выполнение скрипта R".  Я буду добавлять новые строки **перед** функцией str(). Эта функция нужна для проверки результатов в Студии машинного обучения Microsoft Azure.

Добавим следующую строку в код на R в модуле "Выполнение скрипта R".

```r
# Remove two columns we do not need
cadairydata <- cadairydata[, c(-1, -2)]
```

Выполните это код в своем эксперименте и проверьте результат с помощью команды **Визуализировать** в меню порта "Устройство R". Результат приведен на рисунке 11.

![The summary of the dataframe with two columns removed][12]

*Рисунок 11.  Сводка таблицы данных после удаления двух столбцов.*

Отличная новость! Результат оправдал ожидания.

###Добавление нового столбца

При создании модели временных рядов удобно иметь столбец, отсчитывающий месяцы с начала временного ряда. Мы создадим столбец Month.Count (Количество месяцев).

Для упрощения кодирования создадим первую простую функцию num.month().  Затем применим эту функцию для создания столбца в таблице данных. Вот новый код:

```r
## Create a new column with the month count
## Function to find the number of months from the first
## month of the time series.
num.month <- function(Year, Month) {
  ## Find the starting year.
  min.year  <- min(Year)

  ## Compute the number of months from the start of the time series.
  12 * (Year - min.year) + Month - 1
}

# Compute the new column for the dataframe.
cadairydata$Month.Count <- num.month(cadairydata$Year, cadairydata$Month.Number)
```

Теперь выполним обновленный эксперимент и просмотрим результат, нажав **Визуализировать** в меню порта "Устройство R". Этот результат приведен на рисунке 12.

![Summary of the dataframe with the additional column][13]

*Рисунок 12. Сводка таблицы данных с добавленным столбцом.*

Похоже, все работает.  У нас появился новый столбец с заданными значениями.

###Преобразование значений

В этом разделе мы выполним несколько простых преобразований значений в некоторых столбцах таблицы данных.  Язык R поддерживает практически любые преобразования значений.  В материалах [приложения 2](#appendixb) содержится масса примеров.

Изучив значения в сводках таблиц данных, можно заметить нечто странное. Неужели мороженого в Калифорнии производят больше, чем молока?  Разумеется, нет. Это просто не имеет смысла - как это ни печально для всех любителей мороженого. Просто использованы разные единицы измерения. Цена привязана к фунтам веса. Количество молока измеряется в миллионах фунтов, мороженого - в тысячах галлонов, а творога - в тысячах фунтов. Зная, что вес мороженого составляет около 6,5 фунтов на галлон, мы легко преобразуем все значения, чтобы привести их к одной единице измерения - 1 000 фунтов.

В нашей модели прогнозирования мы используем мультипликативную модель для корректировки этих данных. Логарифмическое преобразование позволяет использовать линейную модель, что упрощает этот процесс.  Логарифмическое преобразование можно применить в той же функции, в которой применяется множитель.

В следующем примере кода я определил новую функцию log.transform() и применил ее к строкам, содержащим числовые значения. Функция R Map() используется для того, чтобы применить функцию log.transform() к выбранным столбцам таблицы данных.  Функция Map() сходна с функцией apply(), но позволяет добавлять в функцию более одного списка аргументов. Обратите внимание: список множителей предоставляет второй аргумент функции log.transform(). Функция na.omit() используется для очистки, чтобы убедиться, что в таблице данных нет пропущенных или неопределенных значений.

```r
log.transform <- function(invec, multiplier = 1) {
  ## Function for the transformation which is the log
  ## of the input value times a multiplier

  warningmessages <- c("ERROR: Non-numeric argument encountered in function log.transform",
                       "ERROR: Arguments to function log.transform must be greate than zero",
                       "ERROR: Aggurment multiplier to funcition log.transform must be a scaler",
                       "ERROR: Invalid time seies value encountered in function log.transform"
                       )

  ## Check the input arguments.
  if(!is.numeric(invec) | !is.numeric(multiplier)) {warning(warningmessages[1]); return(NA)}  
  if(any(invec < 0.0) | any(multiplier < 0.0)) {warning(warningmessages[2]); return(NA)}
  if(length(multiplier) != 1) {{warning(warningmessages[3]); return(NA)}}

  ## Wrap the multiplication in tryCatch.
  ## If there is an exception, print the warningmessage to
  ## standard error and return NA.
  tryCatch(log(multiplier * invec),
           error = function(e){warning(warningmessages[4]); NA})
}


## Apply the transformation function to the 4 columns
## of the dataframe with production data.
multipliers  <- list(1.0, 6.5, 1000.0, 1000.0)
cadairydata[, 4:7] <- Map(log.transform, cadairydata[, 4:7], multipliers)

## Get rid of any rows with NA values
cadairydata <- na.omit(cadairydata)  
```

Функция log.transform() выполняет большую работу.  Большая часть кода выполняет поиск потенциальных проблем с аргументами или обрабатывает исключения, которые могут возникать во время вычислений. Фактически, только несколько строк кода выполняют вычисления.

Цель такого защищенного программирования - не допустить, чтобы сбой одной функции привел к нарушению всей работы.  Внезапный сбой продолжительного анализа - вещь довольно неприятная. Чтобы избежать этого, необходимо выбрать значения, возвращаемые по умолчанию, что уменьшит возможные негативные последствия.  Также выдается сообщение, предупреждающее пользователя о проблеме.

Если вы не знакомы с защищенным программированием на R, понять этот код может быть трудно. Поясню основные шаги:

1. Определяется вектор четырех сообщений, использующихся для передачи информации о некоторых потенциальных ошибках и исключениях, которые могут возникнуть при выполнении кода.

2.  Во всех этих случаях возвращается значение NA (нет данных).  Есть и другие возможности, у которых может быть меньше побочных эффектов.  Например, можно было бы возвращать вектор нулей или вектор исходного входного объекта.

3.  Выполняются проверки аргументов функций.  В каждом случае при обнаружении ошибки возвращается значение по умолчанию и создается сообщение с помощью функции warming(). Я использую warning(), а не stop(), поскольку последняя функция прерывает выполнение, а именно этого я и хочу избежать. Обратите внимание, что при написании этого кода я использовал процедуры, поскольку использование функций сделало бы его сложнее и непонятнее.

4.  Вычисления выполняются внутри вызова tryCatch(), чтобы исключения не привели к внезапному прерыванию обработки. Без функции tryCatch() большинство ошибок, вызванных функциями R, вызывает сигнал остановки, что приводит именно к прерыванию.

Выполните этот код на R в своем эксперименте и просмотрите вывод данных в файле output.log.  Воспользовавшись командой **Визуализировать** в меню порта "Устройство R", вы увидите преобразованные значения четырех столбцов (см. рис. 13).

![The summary of the transformed values in the dataframe][14]

*Рисунок 13. Сводка преобразованных значений в таблице данных.*

Как мы видим, значения изменились.  Теперь производство молока значительно превышает по объемам производство остальных молочных продуктов (не забывайте, что мы используем логарифмическую шкалу).

Теперь все наши данные в порядке и мы можем приступать к моделированию.  Просмотрев визуализацию вывода данных через порт "Итоговый набор данных" модуля "Выполнение скрипта R", вы увидите, что тип столбца "Месяц" теперь категориальный с 12 уникальными значениями, как мы и хотели.

##<a id="timeseries"></a>Объекты временного ряда и корреляционный анализ

В этом разделе мы исследуем несколько базовых объектов временных рядов R и проанализируем взаимосвязи некоторых переменных. Наша задача - вывод таблицы данных, содержащей сведения о попарной корреляции с несколькими задержками.

Полный код на R для этого раздела доступен в ZIP-файле, который вы загрузили ранее.

###Объекты временных рядов в языке R

Как уже упоминалось, временные ряды представляют собой ряды значений данных, индексированные по времени.  Объекты временных рядов на R используются для создания индексов времени и управления ними. Использование объектов временных рядов имеет несколько преимуществ. Оно избавляет от необходимости вникать в подробности управления значениями индексов временных рядов, которые уже включены в объект. Кроме того, использование объектов временных рядов позволяет применять многочисленные методы временных рядов для построения диаграмм, моделирования и много другого.

Класс временных рядов POSIXct довольно распространен и относительно прост. Этот класс временных рядов измеряет количество времени, прошедшее с начала эры UNIX - 1 января 1970 г.  В этом примере мы будем использовать объекты временных рядов POSIXct. Другие распространенные классы объектов временных рядов включают zoo и xts (расширяемые временные ряды).
<!-- Additional information on R time series objects is provided in the references in Section 5.7. [commenting because this section doesn't exist, even in the original] -->

###	Пример объекта временных рядов

Приступим к разбору примера. Перетащим **новый модуль "Выполнение скрипта R"** в свой эксперимент.  Соединим порт вывода "Итоговый набор данных 1" существующего модуля выполнения скрипта R с портом ввода "Набор данных 1" нового модуля.

Как и в предыдущих случаях, с определенного момента работы над примером я буду показывать только отдельные фрагменты кода, которые добавляются на каждом этапе.  

####	Чтение таблицы данных

Для начала давайте считаем таблицу данных и убедимся, что мы получили тот результат, на который рассчитывали. Эту работу может выполнить следующий код:

```r
# Comment the following if using RStudio
cadairydata <- maml.mapInputPort(1)
str(cadairydata) # Check the results
```

Теперь выполним эксперимент.  На рисунке 14 показано, какими будут данные, полученные с порта вывода "Устройство R".

![Summary of the dataframe in the Execute R Script module][15]

*Рисунок 14. Сводка таблицы данных в модуле "Выполнение скрипта R".*

У этих данных ожидаемый тип и формат.  Тип данных столбца "Месяц" - фактор с верным количеством уровней.

####Создание объекта временного ряда

В нашу таблицу данных нужно добавить объект временного ряда.  Замените текущий код следующим, добавляющим новый столбец класса POSIXct:

```r
# Comment the following if using RStudio
cadairydata <- maml.mapInputPort(1)

## Create a new column as a POSIXct object
Sys.setenv(TZ = "PST8PDT")
cadairydata$Time <- as.POSIXct(strptime(paste(as.character(cadairydata$Year), "-", as.character(cadairydata$Month.Number), "-01 00:00:00", sep = ""), "%Y-%m-%d %H:%M:%S"))

str(cadairydata) # Check the results
```

Теперь проверьте данные с порта вывода "Устройство R". Результат приведен на рисунке 15.

![Summary of the dataframe with a time series object][16]

*Рисунок 15. Сводка таблицы данных с объектом временного ряда.*

Как мы видим, действительно появился новый столбец класса POSIXct.

###Исследование и преобразование данных

Рассмотрим некоторые из переменных в этом наборе данных.  Для этого прекрасно подойдет точечная диаграмма. Заменим функцию str() в предыдущем фрагменте кода R следующей строкой:

```r
pairs(~ Cotagecheese.Prod + Icecream.Prod + Milk.Prod + N.CA.Fat.Price, data = cadairydata, main = "Pairwise Scatterplots of dairy time series")
```

Выполним этот код и посмотрим на результат.  Диаграмма, полученная через порт "Устройство R", приведена на рисунке 16.

![Scatterplot matrix of selected variables][17]

*Рисунок 16. Точечная диаграмма выбранных переменных.*

Во взаимосвязях этих переменных можно заметить необычную структуру.  Возможно, это результат наличия тренда в данных или вызвано тем, что переменные не стандартизованы.

###Корреляционный анализ

Для осуществления корреляционного анализа необходимо произвести как вычитание тренда, так и стандартизацию переменных. Можно просто использовать функцию scale(), которая масштабирует переменные и размещает их по центру. Возможно, это было бы быстрее.  Однако я хочу продемонстрировать защищенное программирование на R.

Функция ts.detrend(), показанная ниже, выполняет обе эти операции. Следующие две строки кода вычитают тренд из данных и приводят значения к одному стандарту.

```r
ts.detrend <- function(ts, Time, min.length = 3){
  ## Function to detrend and standardize a time series.

  ## Define some messages if they are NULL.  
  messages <- c('ERROR: ts.detrend requires arguments ts and Time to have the same length',
                'ERROR: ts.detrend requires argument ts to be of type numeric',
                paste('WARNING: ts.detrend has encountered a time series with length less than', as.character(min.length)),
                'ERROR: ts.detrend has encountered a Time argument not of class POSIXct',
                'ERROR: Detrend regression has failed in ts.detrend',
                'ERROR: Exception occurred in ts.detrend while standardizing time series in function ts.detrend'
  )
  # Create a vector of zeros to return as a default in some cases.
  zerovec  <- rep(length(ts), 0.0)

  # The input arguments are not of the same length, return ts and quit.
  if(length(Time) != length(ts)) {warning(messages[1]); return(ts)}

  # If the ts is not numeric, just return a zero vector and quit.
  if(!is.numeric(ts)) {warning(messages[2]); return(zerovec)}

  # If the ts is too short, just return it and quit.
  if((ts.length <- length(ts)) < min.length) {warning(messages[3]); return(ts)}

  ## Check that the Time variable is of class POSIXct.
  if(class(cadairydata$Time)[[1]] != "POSIXct") {warning(messages[4]); return(ts)}

  ## Detrent the time series using a linear model.
  ts.frame  <- data.frame(ts = ts, Time = Time)
  tryCatch({ts <- ts - fitted(lm(ts ~ Time, data = ts.frame))},
           error = function(e){warning(messages[5]); zerovec})

  tryCatch( {stdev <- sqrt(sum((ts - mean(ts))^2))/(ts.length - 1)
             ts <- ts/stdev},
            error = function(e){warning(messages[6]); zerovec})

  ts
}  
## Apply the detrend.ts function to the variables of interest.
df.detrend <- data.frame(lapply(cadairydata[, 4:7], ts.detrend, cadairydata$Time))

## Plot the results to look at the relationships.
pairs(~ Cotagecheese.Prod + Icecream.Prod + Milk.Prod + N.CA.Fat.Price, data = df.detrend, main = "Pairwise Scatterplots of detrended standardized time series")
```

Функция ts.detrend() выполняет большую работу.  Большая часть кода выполняет поиск потенциальных проблем с аргументами или обрабатывает исключения, которые могут возникать во время вычислений. Фактически, только несколько строк кода выполняют вычисления.

Мы уже обсуждали пример защищенного программирования в разделе [Преобразование значений](#valuetransformations). Оба блока вычислений выполняются внутри функции tryCatch().  Для некоторых ошибок имеет смысл возвращать вектор исходного входного объекта, а в других случаях я возвращаю вектор нулей.  

Обратите внимание, что линейная регрессия, использующаяся для вычитания тренда, является регрессией временного ряда. Прогнозирующая переменная - это объект временного ряда.  

Когда функция ts.detrend() определена, применим ее к интересующим нас переменным таблицы данных. Нужно привести список, созданный функцией lapply(), в соответствие с данными таблицы данных с помощью функции as.data.frame().  Благодаря защищенности ts.detrend(), сбой обработки одной переменной не помешает обработке остальных.  

Последняя строка кода создает попарную точечную диаграмму. Точечная диаграмма, полученная в результате выполнения этого кода на R, приведена на рисунке 17.

![Pairwise scatterplot of de-trended and standardized time series][18]

*Рисунок 17. Попарная точечная диаграмма после вычитания тренда и стандартизации временного ряда.*

Можно сравнить эти результаты с приведенными на рисунке 17. После удаления тренда и стандартизации переменных мы видим, что взаимосвязи переменных гораздо менее структурированы.

Код для вычисления корреляций как объектов взаимнокорреляционной функции (CCF-объектов) R следующий:

```r
## A function to compute pairwise correlations from a
## list of time series value vectors.
pair.cor <- function(pair.ind, ts.list, lag.max = 1, plot = FALSE){
  ccf(ts.list[[pair.ind[1]]], ts.list[[pair.ind[2]]], lag.max = lag.max, plot = plot)
}

## A list of the pairwaise indices.
corpairs <- list(c(1,2), c(1,3), c(1,4), c(2,3), c(2,4), c(3,4))

## Compute the list of ccf objects.
cadairycorrelations <- lapply(corpairs, pair.cor, df.detrend)  

cadairycorrelations
```

Пример вывода данных после выполнения этого кода приведен на рисунке 18.

![List of ccf objects from the pairwise correlation analysis][19]

*Рисунок 18. Список CCF-объектов после попарного корреляционного анализа.*

Каждой задержке соответствует значение корреляции.  Все эти значения корреляции слишком малы, чтобы быть значимыми. Таким образом, можно заключить, что каждую переменную можно моделировать независимо от других.

###Вывод таблицы данных

Мы рассчитали попарные корреляции в виде списка CCF-объектов. Это представляет определенные сложности, поскольку порту вывода "Итоговый набор данных" требуется таблица данных на R.  Более того, CCF-объект сам по себе является списком, а нас интересуют только значения первого элемента этого списка, корреляции с различными задержками.

Следующий код извлекает значения задержек из списка CCF-объектов, которые и сами являются списками:

```r
df.correlations <- data.frame(do.call(rbind, lapply(cadairycorrelations, '[[', 1)))

c.names <- c("-1 lag", "0 lag", "+1 lag")
r.names  <- c("Corr Cot Cheese - Ice Cream",
              "Corr Cot Cheese - Milk Prod",
              "Corr Cot Cheese - Fat Price",
              "Corr Ice Cream - Mik Prod",
              "Corr Ice Cream - Fat Price",
              "Corr Milk Prod - Fat Price")

## Build a dataframe with the row names column and the
## correlation data frame and assign the column names.
outframe <- cbind(r.names, df.correlations)
colnames(outframe) <- c.names
outframe


## WARNING!
## The following line only works in Azure ML.
## when running in RStudio, this code will result in an error.
#maml.mapOutputPort('outframe')
```

Первая строка кода сложновата. Возможно, объяснения помогут понять ее. Проанализируем по порядку, от вложенных операторов к внешним:

1.  Оператор **[[** с аргументом **1** выбирает вектор корреляций с задержками из первого элемента списка CCF-объектов.

2.  Функция do.call() применяет функцию rbind() к элементам списка возвращаемых значений с помощью lapply().

3.  Функция data.frame() относит результаты, полученные от do.call(), к таблице данных.

Обратите внимание, что имена строк находятся в столбце таблицы данных. Благодаря этому имена строк сохраняются при выводе из модуля "Выполнение скрипта R".

Результат выполнения кода после **визуализации** вывода из порта "Итоговый набор данных" приведен на рисунке 29. Имена строк находятся в первом столбце, как и предполагалось.

![Results output from the correlation analysis][20]

*Рисунок 29. Вывод результатов корреляционного анализа.*

##<a id="seasonalforecasting"></a>Пример временных рядов: Сезонное прогнозирование

Сейчас наши данные приведены к виду, удобному для анализа, и мы установили, что между переменными нет значимых корреляций.  Пойдем дальше и создадим прогностическую модель временных рядов.  С помощью этой модели мы спрогнозируем производство молока в Калифорнии на 12 месяцев 2013 г.

У нашей прогностической модели будет два компонента: тренд и сезонный компонент.  Окончательный прогноз будет произведением этих двух компонентов.  Модели такого типа называются мультипликативными. Альтернативой является аддитивная модель. Мы уже применили логарифмическое преобразование к интересующим нас переменным, благодаря чему будет легко обработать результаты анализа.

Полный код на R для этого раздела доступен в ZIP-файле, который вы загрузили ранее.

###	Создание таблицы данных для анализа

В первую очередь добавьте в эксперимент **новый модуль "Выполнение скрипта R"**.  Соедините порт вывода **Итоговый набор данных** существующего модуля выполнения скрипта R с портом ввода **Набор данных 1** нового модуля.  Результат изображен на рисунке 20.

![The experiment with the new Execute R Script module added][21]

*Рисунок 20. Эксперимент после добавления нового модуля "Выполнение скрипта R".*

Как и в случае недавно выполненного корреляционного анализа, нужно добавить столбец с объектом временных рядов POSIXct. Это может выполнить следующий код:

```r
# If running in ML Studio uncomment the first line with maml.mapInputPort().
cadairydata <- maml.mapInputPort(1)

## Create a new column as a POSIXct object
Sys.setenv(TZ = "PST8PDT")
cadairydata$Time <- as.POSIXct(strptime(paste(as.character(cadairydata$Year), "-", as.character(cadairydata$Month.Number), "-01 00:00:00", sep = ""), "%Y-%m-%d %H:%M:%S"))

str(cadairydata)
```

Выполните этот код и просмотрите вывод данных порта "Устройство R". Результат приведен на рисунке 21.

![A summary of the dataframe][22]

*Рисунок 21. Сводка таблицы данных.*

Получив такой результат, мы можем приступить к анализу.

###Создание учебного набора данных

Имея готовую таблицу данных, нужно создать учебный набор данных. Эти данные будут включать все наблюдения за исключением последних 12 (за 2013 год), которые станут тестовым набором данных. Приведенный ниже код разбивает таблицу данных на подмножества и создает диаграммы переменных: цены и производства молочных продуктов. Затем создаем диаграммы четырех переменных: цены и производства молочных продуктов. Анонимная функция используется для определения приращений диаграммы и последующей итерации для списка оставшихся двух аргументов с помощью Map(). Если вам кажется, что здесь пригодилась бы структура for ... loop, вы совершенно правы. Но поскольку язык R оперирует функциями, я продемонстрирую решение с использованием функций.

```r
cadairytrain <- cadairydata[1:216, ]

Ylabs  <- list("Log CA Cotage Cheese Production, 1000s lb",
               "Log CA Ice Cream Production, 1000s lb",
               "Log CA Milk Production 1000s lb",
               "Log North CA Milk Milk Fat Price per 1000 lb")

Map(function(y, Ylabs){plot(cadairytrain$Time, y, xlab = "Time", ylab = Ylabs, type = "l")}, cadairytrain[, 4:7], Ylabs)
```

После выполнения кода получаем серию диаграмм временных рядов через порт вывода "Устройство R" (см. рис. 22). Заметьте, что по оси времени расположены даты. Это приятный бонус при использовании метода построения диаграмм временных рядов.

![First of time series plots of California dairy production and price data](./media/machine-learning-r-quickstart/unnamed-chunk-161.png)

![Second of time series plots of California dairy production and price data](./media/machine-learning-r-quickstart/unnamed-chunk-162.png)

![Third of time series plots of California dairy production and price data](./media/machine-learning-r-quickstart/unnamed-chunk-163.png)

![Fourth of time series plots of California dairy production and price data](./media/machine-learning-r-quickstart/unnamed-chunk-164.png)

*Рисунок 22. Диаграммы временных рядов данных по ценам и производству молочных продуктов в Калифорнии.*

###	Модель тренда

Создав объект временных рядов и просмотрев данные, приступим к созданию модели тренда для данных по производству молочных продуктов в Калифорнии. Для этого можно использовать регрессию временного ряда.  Однако по диаграмме видно, что для точного моделирования наблюдаемого в учебных данных тренда недостаточно знать только наклон и смещение.

Учитывая небольшой объем данных, построим модель для тренда в RStudio, а затем вырежем результат и вставим его в Студию машинного обучения Microsoft Azure. RStudio предоставляет интерактивную среду для такого рода интерактивного анализа.

Для начала попробуем применить полиномиальную регрессию со степенями до 3.  При создании таких моделей существует высокая вероятность избыточной детализации. Поэтому лучше не использовать члены со степенями высокого порядка.  Функция I() запрещает интерпретацию содержимого (интерпретирует содержимое "как есть") и позволяет записать интерпретируемую буквально функцию в уравнение регрессии.

```r
milk.lm <- lm(Milk.Prod ~ Time + I(Month.Count^2) + I(Month.Count^3), data = cadairytrain)
summary(milk.lm)
```

Это дает следующий результат:

```
##
## Call:
## lm(formula = Milk.Prod ~ Time + I(Month.Count^2) + I(Month.Count^3),
##     data = cadairytrain)
##
## Residuals:
##      Min       1Q   Median       3Q      Max
## -0.12667 -0.02730  0.00236  0.02943  0.10586
##
## Coefficients:
##                   Estimate Std. Error t value Pr(>|t|)
## (Intercept)       6.33e+00   1.45e-01   43.60   <2e-16 ***
## Time              1.63e-09   1.72e-10    9.47   <2e-16 ***
## I(Month.Count^2) -1.71e-06   4.89e-06   -0.35    0.726
## I(Month.Count^3) -3.24e-08   1.49e-08   -2.17    0.031 *  
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
##
## Residual standard error: 0.0418 on 212 degrees of freedom
## Multiple R-squared:  0.941,	Adjusted R-squared:  0.94
## F-statistic: 1.12e+03 on 3 and 212 DF,  p-value: <2e-16
```	

По значениям P (Pr(>|t|)) можно видеть, что значением члена со степенью 2 можно пренебречь.  С помощью функции update() изменим эту модель, опустив член со степенью 2.

```r
milk.lm <- update(milk.lm, . ~ . - I(Month.Count^2))
summary(milk.lm)
```

Это дает следующий результат:

```
##
## Call:
## lm(formula = Milk.Prod ~ Time + I(Month.Count^3), data = cadairytrain)
##
## Residuals:
##      Min       1Q   Median       3Q      Max
## -0.12597 -0.02659  0.00185  0.02963  0.10696
##
## Coefficients:
##                   Estimate Std. Error t value Pr(>|t|)
## (Intercept)       6.38e+00   4.07e-02   156.6   <2e-16 ***
## Time              1.57e-09   4.32e-11    36.3   <2e-16 ***
## I(Month.Count^3) -3.76e-08   2.50e-09   -15.1   <2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
##
## Residual standard error: 0.0417 on 213 degrees of freedom
## Multiple R-squared:  0.941,  Adjusted R-squared:  0.94
## F-statistic: 1.69e+03 on 2 and 213 DF,  p-value: <2e-16
```

Теперь значительно лучше.  Остались только значимые члены.  Однако значение 2e-16 - значение по умолчанию, и ему не стоит придавать большого значения.  

Для проверки корректности создадим диаграмму временных рядов данных молочного производства Калифорнии с использованием полученной линии тренда.  Для создания модели и построения диаграммы я добавил приведенный ниже код в модуль "Выполнение скрипта R" в Студии машинного обучения (а не RStudio).

```r
milk.lm <- lm(Milk.Prod ~ Time + I(Month.Count^3), data = cadairytrain)

plot(cadairytrain$Time, cadairytrain$Milk.Prod, xlab = "Time", ylab = "Log CA Milk Production 1000s lb", type = "l")
lines(cadairytrain$Time, predict(milk.lm, cadairytrain), lty = 2, col = 2)
```

![CA milk production data with trend model shown](./media/machine-learning-r-quickstart/unnamed-chunk-18.png)

*Рисунок 23. Данные молочного производства Калифорнии с моделью тренда.* 

Как видим, модель тренда идеально соответствует данным. Более того, нет никаких признаков чрезмерной детализации вроде случайных колебаний линии модели.  

###Сезонная модель

Получив модель тренда, можно двигаться дальше и добавить сезонные составляющие. Мы используем месяц года в качестве фиктивной переменной линейной модели, чтобы отследить изменения по месяцам. Обратите внимание, что при внесении в модель переменных факторов расчет смещения не выполняют.  Если это сделать, формула будет слишком детализирована, и R проигнорирует один из требуемых факторов, но сохранит определяющий смещение член.

Поскольку у нас удовлетворительная модель тренда, можно добавить новые члены в существующую модель с помощью функции update(). -1 в формуле обновления удаляет определяющий смещение член.  Теперь продолжим в RStudio:

```r
milk.lm2 <- update(milk.lm, . ~ . + Month - 1)
summary(milk.lm2)
```

Это дает следующий результат:

```
##
## Call:
## lm(formula = Milk.Prod ~ Time + I(Month.Count^3) + Month - 1,
##     data = cadairytrain)
##
## Residuals:
##      Min       1Q   Median       3Q      Max
## -0.06879 -0.01693  0.00346  0.01543  0.08726
##
## Coefficients:
##                   Estimate Std. Error t value Pr(>|t|)
## Time              1.57e-09   2.72e-11    57.7   <2e-16 ***
## I(Month.Count^3) -3.74e-08   1.57e-09   -23.8   <2e-16 ***
## MonthApr          6.40e+00   2.63e-02   243.3   <2e-16 ***
## MonthAug          6.38e+00   2.63e-02   242.2   <2e-16 ***
## MonthDec          6.38e+00   2.64e-02   241.9   <2e-16 ***
## MonthFeb          6.31e+00   2.63e-02   240.1   <2e-16 ***
## MonthJan          6.39e+00   2.63e-02   243.1   <2e-16 ***
## MonthJul          6.39e+00   2.63e-02   242.6   <2e-16 ***
## MonthJun          6.38e+00   2.63e-02   242.4   <2e-16 ***
## MonthMar          6.42e+00   2.63e-02   244.2   <2e-16 ***
## MonthMay          6.43e+00   2.63e-02   244.3   <2e-16 ***
## MonthNov          6.34e+00   2.63e-02   240.6   <2e-16 ***
## MonthOct          6.37e+00   2.63e-02   241.8   <2e-16 ***
## MonthSep          6.34e+00   2.63e-02   240.6   <2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
##
## Residual standard error: 0.0263 on 202 degrees of freedom
## Multiple R-squared:     1,	Adjusted R-squared:     1
## F-statistic: 1.42e+06 on 14 and 202 DF,  p-value: <2e-16
```

Мы видим, что в модели отсутствует определяющий смещение член, но есть 12 значимых факторов месяца.  Именно к этому мы и стремились.

Построим еще одну диаграмму временного ряда данных по молочному производству Калифорнии, чтобы проверить работу модели.  Я добавил следующий код в модуль "Выполнение скрипта R" Студии машинного обучения Microsoft Azure, чтобы создать модель и построить диаграмму:

```r
milk.lm2 <- lm(Milk.Prod ~ Time + I(Month.Count^3) + Month - 1, data = cadairytrain)

plot(cadairytrain$Time, cadairytrain$Milk.Prod, xlab = "Time", ylab = "Log CA Milk Production 1000s lb", type = "l")
lines(cadairytrain$Time, predict(milk.lm2, cadairytrain), lty = 2, col = 2)
```

Диаграмма, полученная в результате выполнения этого кода в Студии машинного обучения, приведена на рисунке 24.

![CA milk production with model including seasonal effects](./media/machine-learning-r-quickstart/unnamed-chunk-20.png)

*Рисунок 24. Молочное производство Калифорнии с моделью, включающей сезонные составляющие.*

Соответствие данных на рисунке 24 довольно обнадеживающее.  И тренд, и сезонная составляющая (в помесячном варианте) выглядят вполне разумно.

В качестве еще одной проверки нашей модели рассмотрим остатки. Приведенный ниже код вычисляет прогнозируемые значения наших двух моделей, вычисляет остатки для сезонной модели и отображает эти остатки для учебных данных.

```r
## Compute predictions from our models.
predict1  <- predict(milk.lm, cadairydata)
predict2  <- predict(milk.lm2, cadairydata)

## Compute and plot the residuals
residuals <- cadairydata$Milk.Prod - predict2
plot(cadairytrain$Time, residuals[1:216], xlab = "Time", ylab ="Residuals of Seasonal Model")
```

Диаграмма остатков приведена на рисунке 25.

![Residuals of the seasonal model for the training data](./media/machine-learning-r-quickstart/unnamed-chunk-21.png)

*Рисунок 25. Остатки сезонной модели для учебных данных.*

Выглядит вполне логично.  Определенная структура отсутствует, за исключением влияния экономического спада 2008-2009 годов, который не слишком хорошо отражен в нашей модели.

Диаграмма на рисунке 25 помогает определить любые связанные со временем закономерности в остатках. Благодаря использованию эксплицитного подхода к вычислению и визуальному представлению остатков они располагаются на диаграмме во временной последовательности.  Если бы для построения диаграммы использовалось milk.lm$residuals, диаграмма не отражала бы зависимость от времени.

Для построения ряда диагностических диаграмм можно использовать функцию plot.lm():

```r
## Show the diagnostic plots for the model
plot(milk.lm2, ask = FALSE)
```

Пример ряда диагностических диаграмм, созданных с помощью этого кода, приведен на рисунке 26.

![First of Diagnostic plots for the seasonal model](./media/machine-learning-r-quickstart/unnamed-chunk-221.png)

![Second of Diagnostic plots for the seasonal model](./media/machine-learning-r-quickstart/unnamed-chunk-222.png)

![Third of Diagnostic plots for the seasonal model](./media/machine-learning-r-quickstart/unnamed-chunk-223.png)

![Fourth of Diagnostic plots for the seasonal model](./media/machine-learning-r-quickstart/unnamed-chunk-224.png)

*Рисунок 26. Диагностические диаграммы для сезонной модели.*

На этих диаграммах можно увидеть несколько точек влияния, но они не дают поводов для серьезного беспокойства. Более того, на графике Q-Q видно, что распределение остатков близко к нормальному, что важно для линейных моделей.

###Прогнозирование и оценка моделей

Остался последний шаг до завершения работы.  Необходимо рассчитать прогнозы и измерить их отклонения от фактических данных.  Составим прогноз на 12 месяцев 2013 года. Можно рассчитать величину отклонений для этого прогноза по отношению к фактическим данным, не входящим в наш учебный набор данных. Кроме того, можно сравнить эффективность, используя учебные данные за 18 лет и тестовые данные за 12 месяцев.  

Для измерения эффективности моделей временных рядов используется несколько показателей. В нашем случае мы используем среднеквадратическое отклонение. Следующая функция вычисляет среднеквадратическое отклонение между двумя рядами:  

```r
RMS.error <- function(series1, series2, is.log = TRUE, min.length = 2){
  ## Function to compute the RMS error or difference between two
  ## series or vectors.

  messages <- c("ERROR: Input arguments to function RMS.error of wrong type encountered",
                "ERROR: Input vector to function RMS.error is too short",
                "ERROR: Input vectors to function RMS.error must be of same length",
                "WARNING: Funtion rms.error has received invald input time series.")

  ## Check the arguments.
  if(!is.numeric(series1) | !is.numeric(series2) | !is.logical(is.log) | !is.numeric(min.length)) {
    warning(messages[1])
    return(NA)}

  if(length(series1) < min.length) {
    warning(messages[2])
    return(NA)}

  if((length(series1) != length(series2))) {
    warning(messages[3])
    return(NA)}

  ## If is.log is TRUE exponentiate the values, else just copy.
  if(is.log) {
    tryCatch( {
      temp1 <- exp(series1)
      temp2 <- exp(series2) },
      error = function(e){warning(messages[4]); NA}
    )
  } else {
    temp1 <- series1
    temp2 <- series2
  }

 ## Compute predictions from our models.
predict1  <- predict(milk.lm, cadairydata)
predict2  <- predict(milk.lm2, cadairydata)

## Compute the RMS error in a dataframe.
  tryCatch( {
    sqrt(sum((temp1 - temp2)^2) / length(temp1))},
    error = function(e){warning(messages[4]); NA})
}
```

Как и в случае с функцией log.transform(), которую мы рассматривали в разделе "Преобразование значений", значительная часть кода данной функции занимается проверкой и обработкой исключений.  Задействованы те же принципы. Работа выполняется двумя фрагментами кода внутри функций tryCatch().  В первом фрагменте временные ряды возводятся в степень, поскольку до этого мы работали с логарифмами значений. Во втором фрагменте вычисляется фактическое среднеквадратическое отклонение.  

Вооружившись функцией для измерения среднеквадратического отклонения, построим и выведем таблицу данных с отклонениями. Введем только члены для модели тренда и полную модель с сезонными факторами. Приведенный ниже код выполнит эту задачу с помощью двух линейных моделей, созданных ранее.

```r
## Compute the RMS error in a dataframe.
## Include the row names in the first column so they will
## appear in the output of the Execute R Script.
RMS.df  <-  data.frame(
rowNames = c("Trend Model", "Seasonal Model"),
  Traing = c(
  RMS.error(predict1[1:216], cadairydata$Milk.Prod[1:216]),
  RMS.error(predict2[1:216], cadairydata$Milk.Prod[1:216])),
  Forecast = c(
    RMS.error(predict1[217:228], cadairydata$Milk.Prod[217:228]),
    RMS.error(predict2[217:228], cadairydata$Milk.Prod[217:228]))
)
RMS.df

## The following line should be executed only when running in
## Azure ML Studio.
maml.mapOutputPort('RMS.df')
```

Результат выполнения этого кода, выведенный через порт "Итоговый набор данных", приведен на рисунке 27 

![Comparison of RMS error for the models][26]

*Рисунок 27. Сравнение среднеквадратического отклонения.*

Как видно по этим результатам, после добавления к модели сезонных факторов среднеквадратическое отклонение значительно уменьшилось.  Вполне ожидаемо, что отклонение для учебных данных чуть меньше, чем для прогноза.

##<a id="appendixa"></a>Приложение 1. Руководство по RStudio

Среда разработки RStudio хорошо описана, поэтому в данном приложении приведены некоторые ссылки на ключевые разделы документации по RStudio, которые помогут вам приступить к работе

1.	Создание проектов

	С помощью RStudio можно организовывать свой код на языке R в проекты и управлять ими.  Документацию по использованию проектов можно найти по адресу https://support.rstudio.com/hc/ru-ru/articles/200526207-Using-Projects.

	Рекомендую следовать этим инструкциям и создать проект для примеров кода на R, приведенных в данном документе.  

2.	Изменение и выполнение кода на R

	RStudio предоставляет интегрированную среду для изменения и выполнения кода на R.  Документацию можно найти по адресу https://support.rstudio.com/hc/ru-ru/articles/200484448-Editing-and-Executing-Code.

3.	Отладка

	RStudio располагает эффективными возможностями отладки.  Документацию по этим функциям можно найти по адресу https://support.rstudio.com/hc/ru-ru/articles/200713843-Debugging-with-RStudio.

	Функции устранения неполадок точек останова описаны в документе по адресу https://support.rstudio.com/hc/ru-ru/articles/200534337-Breakpoint-Troubleshooting.

##<a id="appendixb"></a>Приложение 2. Дополнительная литература

Если вы еще не знакомы с языком R, на ресурсе CRAN можно найти два вводных курса:

- "R для начинающих" Эммануэля Паради (Emmanuel Paradis) - замечательный учебник для начала работы, который доступен по адресу http://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf;  

- "Введение в язык R" В. Н. Венаблеса (W. N. Venables) - немного более углубленный курс, доступный по адресу http://cran.r-project.org/doc/manuals/R-intro.html.

По языку R написано много книг, которые могут помочь в его освоении.  Вот некоторые из них, которые показались мне наиболее полезными:

- Книги Нормана Мэтлофа (Norman Matloff) "Искусство программирования на R" и "Обзор статистического программного обеспечения" - хороший пример введения в программирование на R.  

- Книга Пола Титора (Paul Teetor) "Рецепты R" содержит проблемы и их решение на R.  

- Еще одна полезная книга для начинающих - 
- "R в действии" Роберта Кабакова (Robert Kabacoff)  Веб-сайт Quick R - полезный ресурс по адресу http://www.statmethods.net/.

- 'Инферно R' Патрика Бернса (Patrick Burns), написанная с большим юмором, рассматривает сложные проблемы, с которыми можно столкнуться при программировании на R. Книгу можно найти по адресу http://www.burns-stat.com/documents/books/the-r-inferno/.

- Если вы хотите углубиться в сложные темы языка R, почитайте новую книгу Хэдли Викхема (Hadley Wickham) "Продвинутый уровень R'.  Электронную версию этой книги можно найти по адресу http://adv-r.had.co.nz/.

В разделе Task View ресурса CRAN можно найти каталог пакетов временных рядов на R для анализа временных рядов.: http://cran.r-project.org/web/views/TimeSeries.html. For information on specific time series object packages, you should refer to the documentation for that package.

Книга "Простые временные ряды с R" Пола Каупервейта и Эндрю Меткалфа представляет собой введение в использование языка R для анализа временных рядов.  Множество других теоретических работ содержат примеры на языке R.

<!--Image references-->
[1]: ./media/machine-learning-r-quickstart/fig1.png
[2]: ./media/machine-learning-r-quickstart/fig2.png
[3]: ./media/machine-learning-r-quickstart/fig3.png
[4]: ./media/machine-learning-r-quickstart/fig4.png
[5]: ./media/machine-learning-r-quickstart/fig5.png
[6]: ./media/machine-learning-r-quickstart/fig6.png
[7]: ./media/machine-learning-r-quickstart/fig7.png
[8]: ./media/machine-learning-r-quickstart/fig8.png
[9]: ./media/machine-learning-r-quickstart/fig9.png
[10]: ./media/machine-learning-r-quickstart/fig10.png
[11]: ./media/machine-learning-r-quickstart/fig11.png
[12]: ./media/machine-learning-r-quickstart/fig12.png
[13]: ./media/machine-learning-r-quickstart/fig13.png
[14]: ./media/machine-learning-r-quickstart/fig14.png
[15]: ./media/machine-learning-r-quickstart/fig15.png
[16]: ./media/machine-learning-r-quickstart/fig16.png
[17]: ./media/machine-learning-r-quickstart/fig17.png
[18]: ./media/machine-learning-r-quickstart/fig18.png
[19]: ./media/machine-learning-r-quickstart/fig19.png
[20]: ./media/machine-learning-r-quickstart/fig20.png
[21]: ./media/machine-learning-r-quickstart/fig21.png
[22]: ./media/machine-learning-r-quickstart/fig22.png

[26]: ./media/machine-learning-r-quickstart/fig26.png

<!--links-->
[appendixa]: #appendixa
[download]: https://azurebigdatatutorials.blob.core.windows.net/rquickstart/RFiles.zip

<!--HONumber=35.2-->
