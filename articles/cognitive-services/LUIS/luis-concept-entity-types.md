---
title: Типы сущностей
titleSuffix: Language Understanding - Azure Cognitive Services
description: Добавляйте сущности (ключевые данные в предметной области приложения) в приложения Интеллектуальной службы распознавания речи (LUIS).
services: cognitive-services
author: diberry
manager: cgronlun
ms.custom: seodec18
ms.service: cognitive-services
ms.subservice: language-understanding
ms.topic: conceptual
ms.date: 01/02/2019
ms.author: diberry
ms.openlocfilehash: a6dba36eadde9bc9bb1e6ca778a3bce07b561e54
ms.sourcegitcommit: 95822822bfe8da01ffb061fe229fbcc3ef7c2c19
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/29/2019
ms.locfileid: "55207298"
---
# <a name="entity-types-and-their-purposes-in-luis"></a>Типы сущностей и их задачи в LUIS

Сущности — это слова или фразы в высказываниях, которые являются ключевыми данными в предметной области приложения.

## <a name="entity-compared-to-intent"></a>Сущность по сравнению с намерением

Сущность представляет подлежащее извлечению слово или фразу в высказывании. Фраза может содержать много сущностей или вообще ни одной. Сущность представляет класс, включающий коллекцию похожих объектов (мест, предметов, людей, событий или понятий). Сущности описывают информацию, относящуюся к намерению, и иногда они необходимы приложению для выполнения поставленной задачи. Например, в приложение для поиска новостей могут входить такие сущности, как "topic", "source", "keyword" и "publishing date", которые являются ключевыми данными для поиска новостей. В приложении для путешествий с функциями бронирования сущности location, date, airline, travel class и tickets представляют собой ключевые данные для бронирования авиабилетов (связанные с намерением Book flight).

Если сравнивать, намерение представляет предсказание всего высказывания. 

## <a name="entities-help-with-data-extraction-only"></a>Сущности полезны только при извлечении данных.

Сущности помечаются только для извлечения данных, они не используются для прогнозирования намерений.

## <a name="entities-represent-data"></a>Сущности представляют данные

Сущности — это данные, которые требуется извлечь из высказывания. Это может быть имя, дата, название продукта или любая группа слов. 

|Фраза|Сущность|Данные|
|--|--|--|
|Купить 3 билета в Нью-Йорк|Предварительно созданная сущность number<br>Location.Destination|3<br>Нью-Йорк|
|Купить билет из Нью-Йорка в Лондон на 5 марта|Location.Origin<br>Location.Destination<br>Предварительно созданная сущность datetimeV2|Нью-Йорк<br>Лондон<br>5 марта 2018 г.|

## <a name="entities-are-optional-but-highly-recommended"></a>Сущности являются необязательными, но настоятельно рекомендуемыми к использованию

Тогда как намерения являются обязательными, использовать сущности необязательно. Не нужно создавать сущности для каждого понятия в приложении — они требуются только для тех, которые требуются для работы клиентского приложения. 

Если высказывания не содержат сведения, необходимые боту для продолжения, добавлять их не нужно. Их можно добавить позднее по мере развития приложения. 

Если вы не знаете, как будете использовать данные, добавьте несколько общих предварительно созданных сущностей, таких как [datetimeV2](luis-reference-prebuilt-datetimev2.md), [порядковый номер](luis-reference-prebuilt-ordinal.md), [адрес электронной почты](luis-reference-prebuilt-email.md) и [номер телефона](luis-reference-prebuilt-phonenumber.md).

## <a name="label-for-word-meaning"></a>Пометка для значения слова

Если выбор или расположение слов одинаковы, но имеют разное значение, их не нужно помечать с помощью сущности. 

В следующих высказываниях слово `fair` является омографом. Оно пишется одинаково, но имеет другое значение:

|Фраза|
|--|
|Какие ярмарки проходят неподалеку от Сиэтла этим летом?|
|Справедлива ли эта оценка за обзор Сиэтла?|

Если требуется, чтобы сущность события находила все данные события, пометьте слово `fair` в первом высказывании, а не во втором.

## <a name="entities-are-shared-across-intents"></a>Сущности являются общими в намерениях

Сущности являются общими в намерениях. Они не принадлежат отдельному намерению. Намерения и сущности могут быть семантически связаны, но эта связь не является исключительной.

Во фразе Book me a ticket to Paris (Забронировать билет в Париж) Paris (Париж) — это сущность, связанная с расположением. Распознавая сущности, которые упоминаются во фразе пользователя, LUIS помогает клиентскому приложению выбирать конкретные действия, выполняемые для удовлетворения запроса пользователя.

## <a name="mark-entities-in-none-intent"></a>Пометка сущностей в намерении None

Все намерения, включая намерение **None**, должны при возможности иметь помеченные сущности. В этом случае LUIS хорошо известно о месте расположения сущностей в высказываниях и какие слова находятся вокруг сущностей. 

## <a name="entity-status-for-predictions"></a>Состояние сущности для прогнозирования

На портале LUIS вы всегда можете узнать, когда сущность в примере высказывания отличается от помеченной сущности или слишком близка к другой сущности (и поэтому является неясной). Такое различие визуально представлено с помощью красного подчеркивания в примере высказывания. 

Дополнительные сведения см. в разделе [Прогнозирование состояния сущности](luis-how-to-add-example-utterances.md#entity-status-predictions). 

## <a name="types-of-entities"></a>Типы сущностей

LUIS предлагает множество типов сущностей. Выберите сущность на основе способа извлечения данных и их представления после извлечения.

Сущности могут быть извлечены с помощью машинного обучения, что позволяет LUIS продолжать обучение отображению сущности в высказывании. Сущности могут быть извлечены без использования машинного обучения — за счет точного совпадения с текстом или регулярным выражением. Сущности в шаблонах можно извлекать с помощью смешанных реализации. 

После извлечения сущности ее данные можно представить в виде единицы информации либо в сочетании с другими сущностями для формирования единицы информации, используемой в клиентском приложении.

|Прошедшая машинное обучение|Можно пометить|Учебник|Пример<br>Ответ|Тип сущности|Назначение|
|--|--|--|--|--|--|
|✔|✔|[✔](luis-tutorial-composite-entity.md)|[✔](luis-concept-data-extraction.md#composite-entity-data)|[**Составная**](#composite-entity)|Группа сущностей независимо от типа сущности.|
|✔|✔|[✔](luis-quickstart-intent-and-hier-entity.md)|[✔](luis-concept-data-extraction.md#hierarchical-entity-data)|[**Иерархическая**](#hierarchical-entity)|Группа простых сущностей.|
|||[✔](luis-quickstart-intent-and-list-entity.md)|[✔](luis-concept-data-extraction.md#list-entity-data)|[**Список**](#list-entity)|Список элементов и их синонимов, извлеченных в результате поиска точных совпадений.|
|Смешанная||[✔](luis-tutorial-pattern.md)|[✔](luis-concept-data-extraction.md#patternany-entity-data)|[**Pattern.any**](#patternany-entity)|Сущность, конец которой определить довольно сложно.|
|||[✔](luis-tutorial-prebuilt-intents-entities.md)|[✔](luis-concept-data-extraction.md#prebuilt-entity-data)|[**Предварительно созданная**](#prebuilt-entity)|Уже обученная для извлечения различных видов данных.|
|||[✔](luis-quickstart-intents-regex-entity.md)|[✔](luis-concept-data-extraction.md#regular-expression-entity-data)|[**Регулярное выражение**](#regular-expression-entity)|Использует регулярное выражение для сравнения текста.|
|✔|✔|[✔](luis-quickstart-primary-and-secondary-data.md)|[✔](luis-concept-data-extraction.md#simple-entity-data)|[**Простая**](#simple-entity)|Содержит единое понятие в слове или фразе.|

В примерах высказываний для каждого намерения следует помечать только сущности, прошедшие машинное обучение. Прошедшие машинное обучение сущности лучше всего работают после тестирования с помощью [запросов конечной точки](luis-concept-test.md#endpoint-testing) и [проверки высказываний конечной точки](luis-how-to-review-endoint-utt.md). 

Сущности Pattern.Any необходимо помечать в примерах [шаблонов](luis-how-to-model-intent-pattern.md), а не в примерах намерений пользователя. 

Смешанные сущности используют сочетание методов обнаружения сущности.

## <a name="composite-entity"></a>Составная сущность

Составная сущность образована из других сущностей, таких как предварительно созданные, простые, регулярное выражение, список, иерархические. Эти отдельные сущности формируют единую сущность. 

Эта сущность оптимальна для данных в таких случаях.

* данные связаны между собой; 
* Связаны между собой в контексте фразы.
* для них используются различные типы сущностей;
* должны быть сгруппированы и обработаны клиентским приложением в качестве единицы информации;
* имеют различные высказывания пользователей, которые требуют машинного обучения.

![составная сущность](./media/luis-concept-entities/composite-entity.png)

[Руководство](luis-tutorial-composite-entity.md)<br>
[Пример ответа JSON для сущности](luis-concept-data-extraction.md#composite-entity-data)<br>

## <a name="hierarchical-entity"></a>Иерархическая сущность

Иерархическая сущность — это категория контекстно-зависимых обученных простых сущностей, называемых дочерними.

Эта сущность оптимальна для данных в таких случаях.

* Являются простыми сущностями.
* Связаны между собой в контексте фразы.
* В них использовано конкретное слово, обозначающее каждую дочернюю сущность. Примеры этих слов включают в себя: из/в, выход/переход, от/к.
* Дочерние сущности часто содержатся в одной фразе. 
* Должны быть сгруппированы и обработаны клиентским приложением в качестве единицы информации.

Эти сущности не используются в указанных ниже случаях.

* Вам нужна сущность, которая имеет точные текстовые совпадения для дочерних сущностей вне зависимости от контекста. Используйте [сущность списка](#list-entity). 
* Вам нужна сущность для установки родительско-дочерних отношений с другими типами сущностей. Используйте [составную сущность](#composite-entity).

![иерархическая сущность](./media/luis-concept-entities/hierarchical-entity.png)

[Руководство](luis-quickstart-intent-and-hier-entity.md)<br>
[Пример ответа JSON для сущности](luis-concept-data-extraction.md#hierarchical-entity-data)<br>

### <a name="roles-versus-hierarchical-entities"></a>Сравнение ролей и иерархических сущностей

[Роли](luis-concept-roles.md#roles-versus-hierarchical-entities) шаблона решают ту же проблему, что и иерархические сущности, но применяются ко всем типам сущностей. Сейчас роли доступны только в шаблонах. Роли недоступны в высказываниях в примере намерения.  

## <a name="list-entity"></a>Сущность списка

Сущности списка представляют фиксированный, закрытый набор связанных слов вместе с их синонимами. LUIS не обнаруживает дополнительные значения для сущностей списка. Посмотреть предложения для новых слов на основе текущего списка можно с помощью функции **Рекомендовать**. Если имеется несколько сущностей списка с одним и тем же значением, в запросе конечной точки возвращается каждая сущность. 

Сущность оптимальна для данных в таких случаях.

* Значения данных являются известным набором.
* Набор не превышает максимальные [ограничения](luis-boundaries.md) LUIS для этого типа сущности.
* Текст в высказывании в точности совпадает с синонимом или каноническим именем. LUIS не использует список вне точных текстовых совпадений. Сущность списка не используется для разрешения выделения корней, множественных форм и других вариантов. Для управления вариантами рекомендуется применять [шаблон](luis-concept-patterns.md#syntax-to-mark-optional-text-in-a-template-utterance) с синтаксисом, имеющим необязательный текст.

![сущность списка](./media/luis-concept-entities/list-entity.png)

[Руководство](luis-quickstart-intent-and-list-entity.md)<br>
[Пример ответа JSON для сущности](luis-concept-data-extraction.md#list-entity-data)

## <a name="patternany-entity"></a>Сущность Pattern.any

Patterns.any — это местозаполнитель переменной длины, используемый только в высказывании шаблона для пометки начала и окончания сущности.  

Сущность оптимальна для данных в таких случаях.

* Конечную часть сущности можно спутать с оставшимся текстом высказывания. 
[Руководство](luis-tutorial-pattern.md)<br>
[Пример ответа JSON для сущности](luis-concept-data-extraction.md#patternany-entity-data)

**Пример**  
В клиентском приложении для поиска книг по названию сущность pattern.any извлекает полное название. Высказывание шаблона, использующее сущность pattern.any для поиска книги, — `Was {BookTitle} written by an American this year[?]`. 

В следующей таблице каждая строка имеет две версии высказывания. Верхнее высказывание — то, каким образом LUIS сначала увидит высказывание, из которого непонятно, как начинается и заканчивается название книги. Нижнее высказывание — то, как LUIS определит название книги при наличии шаблона для извлечения. 

|Фраза|
|--|
|Книга The Man Who Mistook His Wife for a Hat and Other Clinical Tales (Человек, который принял жену за шляпу, и другие истории из врачебной практики) была написана американским автором в этом году?<br>Книга **The Man Who Mistook His Wife for a Hat and Other Clinical Tales (Человек, который принял жену за шляпу, и другие истории из врачебной практики)** была написана американским автором в этом году?|
|Книга Half Asleep in Frog Pajamas (Сонные глазки и пижама в лягушечку) была написана американским автором в этом году?<br>Книга **Half Asleep in Frog Pajamas (Сонные глазки и пижама в лягушечку)** была написана американским автором в этом году?|
|Роман The Particular Sadness of Lemon Cake (Особая печаль лимонного торта) был написан американским автором в этом году?<br>Роман **The Particular Sadness of Lemon Cake (Особая печаль лимонного торта)**  был написан американским автором в этом году?|
|Книга There's A Wocket In My Pocket! (Кто живет в моем кармане?) была написана американским автором этом году?<br>Книга **There's A Wocket In My Pocket! (Кто живет в моем кармане?)** была написана американским автором этом году?|

## <a name="prebuilt-entity"></a>Предварительно созданная сущность

Предварительно созданные сущности являются встроенными типами, которые представляют общие понятия, такие как адрес электронной почты, URL-адрес и номер телефона. Имена предварительно созданных сущностей являются зарезервированными. [Все предварительно созданные сущности](luis-prebuilt-entities.md), добавленные в приложение, возвращаются в запросе прогнозирования конечной точки, если они были найдены в высказывании. 

Сущность оптимальна для данных в таких случаях.

* Данные соответствуют распространенному варианту использования, поддерживаемому предварительно созданными сущностями для вашего языка и региональных параметров. 

Предварительно созданные сущности можно добавлять и удалять в любое время. Если в примере выказывания вы обнаружите предварительно созданную сущность, что препятствует пометке пользовательской сущности, удалите предварительно созданную сущность из приложения, пометьте сущность, а затем снова добавьте предварительно созданную сущность. 

![Предварительно созданная сущность Number](./media/luis-concept-entities/number-entity.png)

[Руководство](luis-tutorial-prebuilt-intents-entities.md)<br>
[Пример ответа JSON для сущности](luis-concept-data-extraction.md#prebuilt-entity-data)

Некоторые из этих предварительно созданных сущностей определены в проекте [Recognizers-Text](https://github.com/Microsoft/Recognizers-Text) с открытым исходным кодом. Если в настоящее время определенный язык и региональные параметры или сущность не поддерживается, примите участие в добавлении материалов в проект. 

## <a name="regular-expression-entity"></a>Сущность регулярного выражения 

Регулярное выражение является оптимальным вариантом при использовании необработанного текста высказывания. Оно не учитывает регистр и игнорирует региональный алфавит.  Сопоставление регулярных выражений применяется на уровне символов, а не на уровне маркеров, после внесения изменений при проверке орфографии. Если регулярное выражение слишком сложное, например в нем используется много квадратных скобок, вы не сможете добавить выражение в модель. Используется только часть библиотеки [.Net Regex](https://docs.microsoft.com/dotnet/standard/base-types/regular-expressions). 

Сущность оптимальна для данных в таких случаях.

* Данные согласованно отформатированы с любыми также согласованными вариантами.
* У регулярного выражения может быть не более двух уровней вложенности. 

![Сущность регулярного выражения](./media/luis-concept-entities/regex-entity.png)

[Руководство](luis-quickstart-intents-regex-entity.md)<br>
[Пример ответа JSON для сущности](luis-concept-data-extraction.md#regular-expression-entity-data)<br>

## <a name="simple-entity"></a>Простая сущность 

Простая сущность — это универсальная сущность, описывающая одно понятие и обучаемая на основе контекста машинного обучения. Так как простые сущности обычно являются именами, например названиями компаний, продуктов или другими категориями имен, добавьте [список фраз](luis-concept-feature.md) для выделения используемых имен. 

Сущность оптимальна для данных в таких случаях.

* У данных отсутствует согласованное форматирование, но они означают одно и то же. 

![простая сущность](./media/luis-concept-entities/simple-entity.png)

[Руководство](luis-quickstart-primary-and-secondary-data.md)<br/>
[Пример ответа для сущности](luis-concept-data-extraction.md#simple-entity-data)<br/>

## <a name="entity-limits"></a>Ограничения сущностей

Ознакомьтесь с [ограничениями](luis-boundaries.md#model-boundaries), чтобы понять, сколько сущностей каждого типа можно добавить в модель.

## <a name="composite-vs-hierarchical-entities"></a>Сравнение составных и иерархических сущностей

Составные и иерархические сущности имеют связь "родитель-потомок" и прошли машинное обучение. Благодаря машинному обучению LUIS может понимать сущности на основе различных контекстов (расположения слов). Составные сущности более гибкие, так как в качестве дочерних они поддерживают различные типы сущностей. Дочерними элементами иерархической сущности являются только простые сущности. 

|type|Назначение|Пример|
|--|--|--|
|Иерархическая сущность|Родительские и дочерние сущности простых сущностей|Location.Origin=New York<br>Location.Destination=London|
|Составная сущность|Родительские и дочерние сущности: предварительно созданные, списка, простые, иерархические| number=3<br>list=first class<br>prebuilt.datetimeV2=March 5|

## <a name="if-you-need-more-than-the-maximum-number-of-entities"></a>Если требуется количество сущностей, превышающее максимальное значение 

Может потребоваться использовать иерархические и составные сущности. Иерархические сущности отражают связь между сущностями, имеющими общие характеристики или являющимися членами категории. Все дочерние сущности входят в их родительскую категорию. Например, у иерархической сущности PlaneTicketClass могут быть дочерние сущности EconomyClass и FirstClass. Иерархия распространяется только на один уровень глубины.  

Составные сущности представляют части целого. Например, у составной сущности PlaneTicketOrder могут быть дочерние сущности Airline, Destination, DepartureCity, DepartureDate и PlaneTicketClass. Составная сущность создается на основе существующих простых сущностей, дочерних элементов иерархических сущностей или предварительно созданных сущностей.  

LUIS также предоставляет тип сущности списка, который не прошел машинное обучение, но позволяет приложению LUIS указывать фиксированный список значений. Ограничения для типа сущности списка см. в статье [Границы LUIS](luis-boundaries.md). 

Если вы рассматривали иерархические, составные сущности и сущности списка, но вам требуются значения, превышавшие ограничения, обратитесь в службу поддержки. Для этого соберите подробные сведения о системе, откройте веб-сайт [LUIS](luis-reference-regions.md#luis-website), а затем выберите элемент **Поддержка**. Если ваша подписка Azure включает службы поддержки, обратитесь в службу [технической поддержки Azure](https://azure.microsoft.com/support/options/). 

## <a name="next-steps"></a>Дополнительная информация

Ознакомьтесь с подходящими [высказываниями](luis-concept-utterance.md). 

Дополнительные сведения о добавлении сущностей в приложение LUIS см. в статье [Добавление сущностей](luis-how-to-add-entities.md).
