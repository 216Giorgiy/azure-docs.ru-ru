<properties 
	pageTitle="Использование эластичного масштабирования с помощью Dapper" 
	description="Использование эластичного масштабирования с помощью Dapper." 
	services="sql-database" 
	documentationCenter="" 
	manager="stuartozer" 
	authors="torsteng"/>

<tags 
	ms.service="sql-database" 
	ms.workload="sql-database" 
	ms.tgt_pltfrm="na" 
	ms.devlang="na" 
	ms.topic="article" 
	ms.date="02/01/2015" 
	ms.author="torsteng@microsoft.com"/>

# Использование эластичного масштабирования с помощью Dapper 

Этот документ предназначен для разработчиков, которые используют Dapper для создания приложений, но также хотят с его помощью использовать [эластичное масштабирование базы данных SQL Azure](http://azure.microsoft.com/documentation/articles/sql-database-elastic-scale-introduction/) для эластичного изменения емкости приложений путем сегментирования и масштабирования. В этом документе показаны изменения, которые следует внести в приложениях на базе Dapper для интеграции текущих возможностей эластичного масштабирования. Здесь внимание уделяется совмещению методов управления сегментами эластичного масштабирования и маршрутизации на основе данных с помощью Dapper. 

**Пример кода**: [Эластичное масштабирование базы данных SQL - интеграция с Dapper](https://code.msdn.microsoft.com/Elastic-Scale-with-Azure-e19fc77f).
 
Интегрировать **Dapper** и **DapperExtensions** с эластичным масштабированием базы данных SQL Azure очень просто. Чтобы приложения могли использовать маршрутизацию на основе данных с эластичным масштабированием, необходимо изменить создание и открыть новые объекты [SqlConnection](http://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.aspx) для использования вызова [OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn807226.aspx) из [библиотеки эластичного масштабирования](http://msdn.microsoft.com/library/azure/dn765902.aspx). Это ограничивает внесение изменений в приложении местами создания и открытия новых подключений. 

## Обзор Dapper
**Dapper** - это объектно-реляционное средство сопоставления. Оно сопоставляет объекты .NET в приложении с объектами в реляционной базе данных (и наоборот). В первой части примера кода показано, как можно интегрировать эластичное масштабирование базы данных SQL Azure с приложениями, созданными с помощью Dapper. Во второй части в примера кода показано, как можно интегрировать эластичное масштабирование при одновременном использовании Dapper и DapperExtensions. 

Средство сопоставления в Dapper предоставляет методы расширения для подключений к базе данных, упрощающие отправку операторов T-SQL для выполнения базы данных или создания адресуемых ей запросов. К примеру, Dapper упрощает сопоставление объектов .NET и параметров операторов SQL для вызовов **Execute** и использование результатов SQL-запросов объектов .NET с помощью вызовов **Query** из Dapper. 

При использовании DapperExtensions больше не требуется предоставлять операторы SQL. Методы расширения для подключений к базе данных, такие как **GetList** или **Insert**, создают операторы SQL в фоновом режиме.
 
Другое преимущество использования Dapper и DapperExtensions заключается в том, что приложение контролирует создание подключения к базе данных. Это позволяет взаимодействовать с эластичным масштабированием, действующим в качестве посредника при подключении к базе данных, на основе сопоставления шардлетов с базами данных.

Информацию о получении сборок Dapper см. в статье [Dapper .NET](http://www.nuget.org/packages/Dapper/). Информацию о расширениях Dapper см. в статье [DapperExtensions](http://www.nuget.org/packages/DapperExtensions).

## Знакомство с эластичным масштабированием

Эластичное масштабирование базы данных SQL Azure позволяет определять разделы данных приложения, которые называются *shardlets*, сопоставлять их с базами данных и определять их с помощью *sharding keys*. Вы можете использовать любое количество баз данных и распределять свои шардлеты между этими базами данных. Сопоставление значений ключей сегментирования к базам данных хранится в сопоставлении сегментов (shard map). Его предоставляют API-интерфейсы эластичного масштабирования. Мы называем эту возможность **управление сопоставлением сегментов**. Сопоставление сегментов также выступает в качестве посредника подключений к базе данных для запросов с ключом сегментирования. Мы называем эту функцию **маршрутизация на основе данных**.

![Shard maps and data dependent routing][1]

Диспетчер сопоставления сегментов эластичного масштабирования защищает пользователей от получения несогласованных представлений данных шардлета, которые могут иметь место при выполнении параллельных операций управления шардлетом в базе данных. Для предотвращения таких случаев подключения к базе данных для приложения Elastic Scale проводятся через сопоставления сегментов Elastic Scale. Так как операции управления сегментами могут повлиять на шардлет, функция сопоставления сегментов может завершать подключение к базе данных автоматически. 

Вместо стандартных способов создания подключений для Dapper необходимо использовать [метод OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn824099.aspx). Это гарантирует, что при перемещении данных между сегментами выполняется полная проверка и надлежащее управление сегментами.

### Требования к интеграции Dapper

При работе с API эластичного масштабирования и API Dapper мы хотим сохранить следующие свойства:

* **Масштабирование**. Необходимо добавлять и удалять базы данных из уровня данных сегментированного приложения согласно требованиям приложения к ресурсам. 
-    **Согласованность**: Так как наше приложение масштабируется путем сегментирования, необходимо выполнить маршрутизацию на основе данных. Для этого нам понадобится использовать возможности маршрутизации на основе данных эластичного масштабирования. В частности, нам необходимо сохранить гарантии проверки и согласованности, предоставляемые с помощью подключений, которые проходят через диспетчер сопоставления сегментов эластичного масштабирования, во избежание повреждения или неправильного запроса. Это гарантирует, что подключения к заданному шардлету отклоняются или останавливаются, если (например) в настоящее время шардлет перемещается в другой сегмент с помощью API для разделения и объединения.
-    **Сопоставление объектов**. Нам необходимо сохранить удобство сопоставлений, предоставляемое Dapper, для преобразования между классами в приложении и базовыми структурами базы данных. 

В следующем разделе приведены рекомендации по этим требованиям для приложений, созданных с помощью **Dapper** и **DapperExtensions**.

## Техническое руководство
### Маршрутизация на основе данных с помощью Dapper 

При использовании Dapper приложение, как правило, отвечает за создание и открытие подключений к базе данных. Если присвоить приложению тип T, Dapper возвращает результаты запроса в качестве коллекции .NET типа T. Dapper сопоставляет данные в строках результатов T-SQL с объектами типа T. Аналогичным образом Dapper сопоставляет объекты .NET в значениях или параметрах SQL для операторов языка обработки данных (DML). Dapper обеспечивает эти функциональные возможности с помощью методов расширения в регулярном объекте [SqlConnection](http://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.aspx) из библиотек ADO .NET для клиента SQL. Подключения SQL, возвращенные API эластичного масштабирования для DDR, также являются регулярными объектами [SqlConnection](http://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.aspx). Это позволяет использовать расширения Dapper непосредственно для типа объекта, возвращаемого API эластичного масштабирования для DDR, так как он также является простым подключением клиента SQL.

Эти наблюдения упрощают использование подключений, которые проходят через диспетчер сопоставления сегментов эластичного масштабирования. 

В этом примере кода (из соответствующего примера) показан подход, в котором приложение предоставляет ключ сегментирования библиотеке эластичного масштабирования, чтобы подключение прошло через посредника к правильному сегменту.  

    using (SqlConnection sqlconn = shardingLayer.ShardMap.OpenConnectionForKey(
                     key: tenantId1, 
                     connectionString: connStrBldr.ConnectionString, 
                     options: ConnectionOptions.Validate))
    {
        var blog = new Blog { Name = name };
        sqlconn.Execute(@"
                      INSERT INTO
                            Blog (Name)
                            VALUES (@name)", new { name = blog.Name }
                        );
    }

Чтобы вызвать [OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn807226.aspx), API заменяет создание и открытие подключения клиента SQL по умолчанию. Метод [OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn807226.aspx) при вызове принимает аргументы, которые требуются для маршрутизации на основе данных эластичного масштабирования: 

-    сопоставление сегментов для доступа к интерфейсам маршрутизации на основе данных;
-    ключ сегментирования для определения шардлета;
-    учетные данные (имя пользователя и пароль) для подключения к сегменту.

Объект сопоставления сегментов создает открытое подключение к сегменту, в котором содержится шардлет, соответствующий заданному ключу сегментирования. API эластичного масштабирования также помечают подключение тегом для реализации гарантий согласованности. Так как при вызове [OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn807226.aspx) возвращается регулярный объект подключения клиента SQL, последующий вызов метода расширения **Execute** из Dapper выполняется по стандартной схеме.

Запросы формируются одинаково: сначала открывается подключение с помощью [OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn807226.aspx) в API эластичного масштабирования, а затем используются регулярные методы расширения Dapper для сопоставления результатов SQL-запроса в объектах .NET:

    using (SqlConnection sqlconn = shardingLayer.ShardMap.OpenConnectionForKey(
                    key: tenantId1, 
                    connectionString: connStrBldr.ConnectionString, 
                    options: ConnectionOptions.Validate ))
    {    
           // Display all Blogs for tenant 1
           IEnumerable<Blog> result = sqlconn.Query<Blog>(@"
                                SELECT * 
                                FROM Blog
                                ORDER BY Name");

           Console.WriteLine("All blogs for tenant id {0}:", tenantId1);
           foreach (var item in result)
           {
                Console.WriteLine(item.Name);
            }
    }

Обратите внимание, что блок **using** с подключением DDR из эластичного масштабирования ограничивает все операции базы данных в пределах блока к одному сегменту, в котором хранится tenantId1. Запрос возвращает только блоги, хранящиеся в текущем сегменте, а не в любых других сегментах. 

## Маршрутизация на основе данных с помощью Dapper и DapperExtensions

В Dapper включена экосистема дополнительных расширений, которые могут обеспечивать дополнительное удобство и предоставлять абстракцию из базы данных при разработке приложений баз данных. И примером таких расширений является DapperExtensions. 

При использовании DapperExtensions в приложении способ создания подключений к базе данных и управления ими не меняется. Приложение все еще отвечает за открытие подключений, а методы расширения ожидают регулярные объекты подключений клиента SQL. Мы можем использовать [OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn807226.aspx), как описано выше. Единственное изменение заключается в том, что больше не нужно писать операторы T-SQL, как показано в следующих примерах кода:

    using (SqlConnection sqlconn = shardingLayer.ShardMap.OpenConnectionForKey(
                    key: tenantId2, 
                    connectionString: connStrBldr.ConnectionString, 
                    options: ConnectionOptions.Validate))
    {
           var blog = new Blog { Name = name2 };
           sqlconn.Insert(blog);
    }

А вот пример кода для запроса: 

    using (SqlConnection sqlconn = shardingLayer.ShardMap.OpenConnectionForKey(
                    key: tenantId2, 
                    connectionString: connStrBldr.ConnectionString, 
                    options: ConnectionOptions.Validate))
    {
           // Display all Blogs for tenant 2
           IEnumerable<Blog> result = sqlconn.GetList<Blog>();
           Console.WriteLine("All blogs for tenant id {0}:", tenantId2);
           foreach (var item in result)
           {
               Console.WriteLine(item.Name);
           }
    }

### Обработка временных сбоев

Команда Microsoft Patterns & Practices опубликовала [блок приложений обработки временных сбоев](http://msdn.microsoft.com/library/hh680934.aspx), чтобы позволить разработчикам приложений устранять распространенные временные сбои при выполнении в облаке. Дополнительную информацию см. в разделе [Упорство - секрет всех побед. Использование блока приложения для обработки временных сбоев](http://msdn.microsoft.com/library/dn440719.aspx).

В примере кода для защиты от временных сбоев используется библиотека временных сбоев. 

    SqlDatabaseUtils.SqlRetryPolicy.ExecuteAction(() =>
    {
       using (SqlConnection sqlconn = 
          shardingLayer.ShardMap.OpenConnectionForKey(tenantId2, connStrBldr.ConnectionString, ConnectionOptions.Validate))
          {
              var blog = new Blog { Name = name2 };
              sqlconn.Insert(blog);
          }
    });

Политика **SqlDatabaseUtils.SqlRetryPolicy** в приведенном выше коде определена как **SqlDatabaseTransientErrorDetectionStrategy** с числом попыток равным 10 и 5-секундным временем ожидания между повторами попытки. При использовании транзакций убедитесь, что при возникновении временного сбоя область повтора переходит к началу транзакции.

## Ограничения

Подходы, описанные в данном документе, имеют несколько ограничений:

* В примере кода для этого документа не показано, как управлять схемой для разных сегментов.
* Предполагается, что вся обработка в базе данных для выполнения запроса ведется в пределах одного сегмента, который идентифицируется ключом сегментирования, предоставленном в запросе. Тем не менее, это не всегда так, например, в случае, если невозможно сделать ключ сегментирования доступным. Для решения этой проблемы библиотеки эластичного масштабирования предоставляют [класс MultiShardQuery](http://msdn.microsoft.com/library/azure/microsoft.azure.sqldatabase.elasticscale.query.multishardexception.aspx). Этот класс реализует абстракцию подключения для выполнения запросов нескольких сегментов. Использование MultiShardQuery вместе с EF выходит за рамки данного документа

## Заключение

Приложения, использующие **Dapper** и **DapperExtensions**, могут легко использовать преимущества эластичного масштабирования базы данных SQL Azure. С помощью шагов, описанных в этом документе, для приложений можно настроить использование возможностей эластичного масштабирования для маршрутизации на основе данных. Для этого требуется изменить создание и открытие новых объектов [SqlConnection](http://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.aspx), чтобы использовать вызов [OpenConnectionForKey](http://msdn.microsoft.com/library/azure/dn807226.aspx) библиотеки эластичного масштабирования. Это ограничивает внесение требуемых изменений в приложении местами создания и открытия новых подключений. 

[AZURE.INCLUDE [elastic-scale-include](../includes/elastic-scale-include.md)]

<!--Image references-->
[1]: ./media/sql-database-elastic-scale-working-with-dapper/dapperimage1.png

<!--HONumber=47-->
