---
title: "Рекомендации по Функциям Azure | Документация Майкрософт"
description: "Ознакомьтесь с рекомендациями и шаблонами для Функций Azure."
services: functions
documentationcenter: na
author: wesmc7777
manager: erikre
editor: 
tags: 
keywords: "Функции Azure, шаблоны, рекомендация, функции, обработка событий, объекты webhook, динамические вычисления, бессерверная архитектура"
ms.assetid: 9058fb2f-8a93-4036-a921-97a0772f503c
ms.service: functions
ms.devlang: multiple
ms.topic: article
ms.tgt_pltfrm: multiple
ms.workload: na
ms.date: 11/09/2016
ms.author: wesmc
translationtype: Human Translation
ms.sourcegitcommit: 182e28e37eb56c547e28524f2a3e13f042238cb4
ms.openlocfilehash: c638bf42b9adf906f195d77268637d056f7b00a9

---

# <a name="best-practices-for-azure-functions"></a>Рекомендации по Функциям Azure

##<a name="overview"></a>Обзор

В этой статье представлен набор рекомендаций, которые необходимо учитывать при реализации приложений-функций. Имейте в виду, что вы используете такое приложения-функцию Azure, как служба приложений Azure. Поэтому в этом случае применяются эти рекомендации.


## <a name="avoid-large-long-running-functions"></a>Избегайте крупных длительных функций

Крупные длительные функции могут вызывать непредвиденные проблемы времени ожидания. Функция может быть крупной, если она содержит множество зависимостей Node.js. Импорт этих зависимостей может привести к замедлению загрузки, что, в свою очередь, приводит к непредвиденному времени ожидания. Зависимости Node.js можно явно загрузить в код в нескольких операторах `require()`. Они также могут быть неявными на основе одного модуля, загруженного в коде, с собственными внутренними зависимостями.  

По возможности выполняйте рефакторинг крупных функций и перерабатывайте их на более мелкие совместимые наборы функций, которые быстро возвращают ответ. Например, для функции webhook или триггера HTTP может потребоваться подтверждение в течение ограниченного промежутка времени. Полезные данные триггера HTTP можно передать в очередь для обработки с помощью функции триггера очереди. Такой подход позволяет отложить фактическую работу и сразу возвратить ответ. Чаще всего для объектов webhook требуется немедленный ответ.


## <a name="cross-function-communication"></a>Взаимодействие функций

При интеграции нескольких функций лучше всего для взаимодействия между ними использовать очереди хранилища,  так как они дешевле и их гораздо проще подготовить к работе. 

Размер отдельных сообщений в очереди хранилища ограничен до 64 КБ. Если между функциями нужно передать сообщения большего размера, можно использовать очередь служебной шины Azure, которая поддерживает сообщения размером до 256 КБ.

Если перед обработкой сообщений их нужно отфильтровать, ознакомьтесь со статьями о служебной шине.

Для поддержки обмена крупными сообщениями используются концентраторы событий.



## <a name="write-functions-to-be-stateless"></a>Создавайте функции без отслеживания состояния 

По возможности функции должны быть без отслеживания состояния и идемпотентными. Свяжите любые необходимые сведения о состоянии со своими данными. Например, с обрабатываемым заказом скорее всего будет связан элемент `state`. Функция может обработать заказ, основываясь на этом состоянии, но в ней самой при этом не отслеживается состояние. 

Идемпотентные функции рекомендуется использовать с триггерами таймера. Например, если какой-либо компонент нужно выполнять раз в день, пропишите его таким образом, чтобы он выполнялся в любое время в течение дня с тем же результатом. Функцию можно закрыть, если в определенный день ничего не нужно делать. Кроме того, если предыдущее выполнение завершилось ошибкой, следующее выполнение должно начаться с прерванного момента.


## <a name="write-defensive-functions"></a>Создавайте защищенные функции

Предположим, что в любое время в функции может возникнуть исключение. Реализуйте в функции возможность продолжения с предыдущей точки сбоя во время следующего выполнения. Давайте рассмотрим сценарий, в котором необходимо сделать следующее:

1. Запросить 10 000 строк в базе данных.
2. Создать сообщение очереди для каждой из этих строк для дальнейшей обработки.
 
В зависимости от сложности системы, подчиненные службы могут работать неправильно, могут происходить сбои в работе сети или нарушения лимитов квоты и т. д. Все это может в любое время повлиять на функцию. Функции необходимо подготавливать к таким проблемам.

Как отреагирует ваш код при сбое после вставки 5000 элементов в очередь для обработки? Отслеживайте элементы в наборе, работа с которым завершена. В противном случае их можно вставить позже. Это может серьезно повлиять на рабочий процесс. 

Если элемент очереди уже обработан, разрешите холостой цикл выполнения функции.

Воспользуйтесь предоставленными возможностями защиты для компонентов, используемых на платформе Функций Azure. Например, ознакомьтесь с разделом **Обработка подозрительных сообщений очереди** в документации по [триггерам очереди службы хранилища Azure](functions-bindings-storage-queue.md#trigger).
 



## <a name="dont-mix-test-and-production-code-in-the-same-function-app"></a>Не используйте тестовый и рабочий код в одном приложении-функции

Функции в приложении-функции совместно используют ресурсы. Например, память. Если приложение-функция используется в рабочей среде, не добавляйте в нее тестовые функции и ресурсы. Это может вызвать непредвиденные затраты во время выполнения кода в рабочей среде.

Следите за тем, что вы загружаете в рабочие приложения-функции. Память усредняется для каждой функции в приложении.

При наличии общей сборки, указанной в нескольких функциях .Net, поместите ее в общую папку. Создайте ссылку на сборку с помощью оператора, аналогичного следующему: 

    #r "..\Shared\MyAssembly.dll". 

В противном случае очень просто случайно развернуть несколько тестовых версий одного двоичного файла, которые действуют по-разному в разных функциях.

Не используйте подробное ведение журнала в рабочем коде. Это отрицательно сказывается на производительности.



## <a name="use-async-code-but-avoid-taskresult"></a>Используйте асинхронный код и не используйте Task.Result

Рекомендуется применять метод асинхронного программирования. Тем не менее, не создавайте ссылки на свойство `Task.Result`. Обычно при таком подходе выполняется холостой цикл с блокировкой другого потока. При блокировке может возникнуть взаимоблокировка.




## <a name="next-steps"></a>Дальнейшие действия
Для получения дополнительных сведений см. следующие ресурсы:

* [Справочник разработчика по функциям Azure](functions-reference.md)
* [Справочник разработчика C# по функциям Azure](functions-reference-csharp.md)
* [Справочник разработчика F# по функциям Azure](functions-reference-fsharp.md)
* [Справочник разработчика NodeJS по функциям Azure](functions-reference-node.md)




<!--HONumber=Feb17_HO2-->


