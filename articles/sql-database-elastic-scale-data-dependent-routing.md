<properties 
	pageTitle="Маршрутизация, управляемая данными" 
	description="Как использовать ShardMapManager для управляемой данными маршрутизации - функции эластичного масштабирования для БД SQL Azure" 
	services="sql-database" 
	documentationCenter="" 
	manager="stuartozer" 
	authors="stuartozer" 
	editor=""/>

<tags 
	ms.service="sql-database" 
	ms.workload="sql-database" 
	ms.tgt_pltfrm="na" 
	ms.devlang="na" 
	ms.topic="article" 
	ms.date="03/05/2015" 
	ms.author="stuarto"/>

#Маршрутизация, управляемая данными

Класс **ShardMapManager** предоставляет приложениям ADO.NET возможность легко направлять запросы и команды базы данных в соответствующую физическую базу данных в сегментированной среде. Это называется **маршрутизацией, управляемой данными**, и является основной моделью при работе с сегментированными базами данных. Каждый конкретный запрос или транзакция в приложении, которое использует зависящую от данных маршрутизацию, ограничены обращением только к одной базе данных за раз.  

При использовании маршрутизации, управляемой данными, приложению нет необходимости отслеживать различные строки подключения или расположения базы данных, связанные с различными срезами данных в сегментированной среде. Вместо нее [диспетчер сопоставления сегментов](./sql-database-elastic-scale-shard-map-management.md) по мере необходимости выдает открытые соединения соответствующей базе данных на основе данных в сопоставлении сегментов и значения ключа сегментирования, которое является целевым объектом запроса приложения. (Этим ключом обычно является *customer_id*, *tenant_id*, *date_key* или другой конкретный идентификатор, являющийся основным параметром запроса к базе данных). 

## Использование ShardMapManager при маршрутизации с зависимостью от данных 

Для приложений, использующих маршрутизацию, зависящую от данных, во время инициализации для каждого домена приложения должен быть создан экземпляр диспетчера **ShardMapManager** с помощью вызова, установленного производителем: **GetSQLShardMapManager**.

    ShardMapManager smm = ShardMapManagerFactory.GetSqlShardMapManager(smmConnnectionString, 
                      ShardMapManagerLoadPolicy.Lazy);
    RangeShardMap<int> customerShardMap = smm.GetRangeShardMap<int>("customerMap"); 

В данном примере инициализируются и диспетчер **ShardMapManager**, и конкретное сопоставление **ShardMap**, которое он содержит. 

Для приложений, не использующих сопоставление сегментов, учетные данные, применяемые в заводском методе, для получения диспетчера**ShardMapManager** (в примере выше, *smmConnectionString*) должны заменяться учетными данными, доступными только для чтения, в базе данных **глобального сопоставления сегментов**, ссылка на которую содержится в строке подключения. Обычно эти учетные данные отличаются от учетных данных, используемых в открытых подключениях к диспетчеру карты сегментов. См. также: [Управление учетными данными эластичного масштабирования](sql-database-elastic-scale-manage-credentials.md). 

## Вызов управляемой данными маршрутизацией 

Метод **ShardMap.OpenConnectionForKey (key, connectionString, connectionOptions) ** возвращает подключение к ADO.Net, готовое к выдаче команд к соответствующей базе данных на основе значения параметра **key**. Информация о сегментации кэшируется в приложении с помощью диспетчера **ShardMapManager**, поэтому такие запросы обычно не сопровождаются поиском в базе данных **глобального сопоставления сегментов**. 

* Параметр **key** используется как ключ поиска в сопоставлении сегментов для определения соответствующей базы данных для запроса. 

* Строка **connectionString** используется для передачи только учетных данных пользователя для необходимого подключения. Имя базы данных и имя сервера не включены в строку *connectionString*, так как метод определяет базу данных и сервер с помощью сопоставления **ShardMap**. 

* Enum для **connectionOptions** используется для указания, происходит ли проверка при осуществлении открытого подключения. **Рекомендуется использовать ConnectionOptions.Validate**. В среде, где карты сегментов могут меняться, а строки перемещаться в другие базы данных в результате операций разбиения или слияния, проверка гарантирует, что кэшированный поиск в базе данных на основе значения ключа по-прежнему дает правильный результат. При проверке выполняется краткий запрос для сопоставления локальной карты сегментов в целевой базе данных (не на глобальной карте сегментов), прежде чем подключение предоставляется приложению. 

При наличии сбоя в проверке локальной карты сегментов (что означает неправильный кэш) диспетчер карты сегментов запросит глобальную карту сегментирования для получения новых правильных значений для поиска, обновления кэша и возврата к подключению к соответствующей базе данных. 

Единственный случай, когда вариант **ConnectionOptions.None** (не проверять) является приемлемым, - если внесение изменений в сопоставление отдельных сегментов не предполагается, т. е. когда приложение работает в интерактивном режиме. В этом случае можно предположить, что кэшированные значения всегда являются правильными, и дополнительный проверочный вызов в два конца к целевой базе данных можно безопасно пропустить. Это может уменьшить задержки передачи и трафик базы данных. Также можно задать параметры **connectionOptions** через значение в файле конфигурации, указывающее, ожидаются ли изменения сегментов в течение определенного периода времени.  

Это пример кода, использующего диспетчер сопоставления сегментов для осуществления маршрутизации на основе данных на основе значения целочисленного ключа **CustomerID**, использующего объект **ShardMap** с именем **customerShardMap**.  

## Пример: управляемая данными маршрутизация 

    int customerId = 12345; 
    int newPersonId = 4321; 

    // Connection to the shard for that customer ID
    using (SqlConnection conn = customerShardMap.OpenConnectionForKey(customerId, 
        Configuration.GetCredentialsConnectionString(), ConnectionOptions.Validate)) 
    { 
        // Execute a simple command 
        SqlCommand cmd = conn.CreateCommand(); 
        cmd.CommandText = @"UPDATE Sales.Customer 
                            SET PersonID = @newPersonID 
                            WHERE CustomerID = @customerID"; 

        cmd.Parameters.AddWithValue("@customerID", customerId); 
        cmd.Parameters.AddWithValue("@newPersonID", newPersonId); 
        cmd.ExecuteNonQuery(); 
    }  

Обратите внимание, что вместо того, чтобы использовать конструктор для подключения **SqlConnection**, за которым следует вызов **Open()** к объекту подключения, в примере применяется метод **OpenConnectionForKey**, который предоставляет новое, уже открытое подключение к соответствующей базе данных. Подключения, используемые в этом случае, по-прежнему имеют все преимущества объединенных подключений ADO.Net. При условии, что запросы и транзакции, могут выполняться с одного сегмента одновременно, это должно быть единственным необходимым изменением в приложении, уже работающем с ADO.Net. 

Метод **OpenConnectionForKeyAsync** также доступен, если в приложении используется асинхронное программирование с помощью ADO.Net.  Его поведение представляет собой маршрутизацию, управляемую данными, эквивалентную методу ADO.NET **Connection.OpenAsync**.

## Интеграция с обработкой временных сбоев 

При разработке облачных приложений для доступа к данным рекомендуется убедиться, что временные сбои в подключении или отправке запроса к базе данных перехватываются приложением, и что попытка выполнения операции осуществляется несколько раз, прежде чем возникнет сообщение об ошибке. Обработка временных сбоев в облачных приложениях рассматривается в статье [Обработка временных сбоев](http://msdn.microsoft.com/library/dn440719\(v=pandp.60\).aspx). 
 
Обработка временных сбоев может естественным образом сосуществовать с шаблоном маршрутизации, управляемой данными. Основным требованием является повтор запроса доступа к данным целиком, включая блок **using**, с которым осуществляется подключение с маршрутизацией, управляемой данными. Приведенный выше пример можно переписать следующим образом (обратите внимание на выделенные изменения). 

### Пример: маршрутизация, управляемая данными, с обработкой временных сбоев 

<pre><code>int customerId = 12345; 
int newPersonId = 4321; 

<span style="background-color:  #FFFF00">Configuration.SqlRetryPolicy.ExecuteAction(() =&gt; </span> 
<span style="background-color:  #FFFF00">    { </span>
        // Connection to the shard for that customer ID 
        using (SqlConnection conn = customerShardMap.OpenConnectionForKey(customerId,  
        Configuration.GetCredentialsConnectionString(), ConnectionOptions.Validate)) 
        { 
            // Execute a simple command 
            SqlCommand cmd = conn.CreateCommand(); 

            cmd.CommandText = @&quot;UPDATE Sales.Customer 
                            SET PersonID = @newPersonID 
                            WHERE CustomerID = @customerID&quot;; 

            cmd.Parameters.AddWithValue(&quot;@customerID&quot;, customerId); 
            cmd.Parameters.AddWithValue(&quot;@newPersonID&quot;, newPersonId); 
            cmd.ExecuteNonQuery(); 

            Console.WriteLine(&quot;Update completed&quot;); 
        } 
<span style="background-color:  #FFFF00">    }); </span> 
</code></pre>


Пакеты, необходимые для реализации обработки временных сбоев, автоматически загружаются при построении приложения в начальном наборе для эластичного масштабирования. Также пакеты доступны отдельно в [Блоке приложений обработки временных сбоев в библиотеке предприятия](http://www.nuget.org/packages/EnterpriseLibrary.TransientFaultHandling/). Используйте версию 6.0 или более позднюю. 

## Согласованность транзакций 

Свойства транзакций сохраняются для всех операций, являющихся локальными для сегмента. Например, транзакции, осуществленные посредством маршрутизации, управляемой данными, выполняются в области целевого сегмента для подключения. В данный момент нет возможности связывания нескольких подключений с транзакцией, поэтому невозможно гарантировать осуществление транзакций для операций, выполняемых через сегменты.  

[AZURE.INCLUDE [elastic-scale-include](../includes/elastic-scale-include.md)]

<!--HONumber=47-->
