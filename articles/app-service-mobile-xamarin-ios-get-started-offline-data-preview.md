<properties
    pageTitle="Включение автономной синхронизации для мобильного приложения (Xamarin iOS)"
    description="Использование мобильного приложения службы приложений для кэширования и синхронизации автономных данных в приложении Xamarin iOS"
    documentationCenter="xamarin"
    authors="lindydonna"
    manager="dwrede"
    editor=""
    services="app-service\mobile"/>

<tags
    ms.service="app-service-mobile"
    ms.workload="mobile"
    ms.tgt_pltfrm="xamarin-ios"
    ms.devlang="dotnet"
    ms.topic="article"
    ms.date="03/26/2015"
    ms.author="donnam"/>

# Включение автономной синхронизации для мобильного приложения Xamarin iOS

<!-- [AZURE.INCLUDE [mobile-services-selector-offline](../includes/mobile-services-selector-offline.md)]
 -->

В этом учебнике рассматривается функция автономной синхронизации мобильных приложений для iOS. Автономная синхронизация позволяет конечным пользователям взаимодействовать с мобильным приложением - просматривать, добавлять или изменять данные - даже при отсутствии подключения к сети. Изменения сохраняются в локальной базе данных; как только устройство возвращается в режим подключения к сети, эти изменения синхронизируются с удаленной службой.

Автономная синхронизация может применяться в следующих случаях:

* Повышение скорости реагирования приложений путем локального кэширования данных сервера в устройстве
* Защита приложений от потери сетевой связности
* Предоставление конечным пользователям возможности создания и изменения данных даже в том случае, когда отсутствует сетевой доступ, поддерживая сценарии с минимальной связностью или при отсутствии связности
* Синхронизация данных между несколькими устройствами и обнаружение конфликтов, когда два устройства изменяют одну и ту же запись

Если вы впервые работаете с мобильными приложениями, сначала пройдите учебник [Создание приложения Xamarin iOS].

Для работы с данным учебником требуется следующее:

* Visual Studio 2013
* [Расширение Xamarin] Visual Studio **или** [Xamarin Studio] на OS X

## Обзор кода синхронизации мобильных приложений

Автономная синхронизация мобильных приложений позволяет конечным пользователям взаимодействовать с локальной базой данных, если сеть недоступна. Чтобы использовать эти функции в приложении, следует инициализировать `MobileServiceClient.SyncContext` в локальном хранилище. Затем укажите ссылку на таблицу с помощью интерфейса `IMobileServiceSyncTable`.
В этом разделе рассматривается связанный код автономной синхронизации в `QSTodoService.cs`.

1. В Visual Studio откройте проект, созданный в учебнике [Начало работы с мобильными приложениями]. Откройте файл `QSTodoService.cs`.

2. Обратите внимание, что элемент `todoTable` имеет тип `IMobileServiceSyncTable`. Автономная синхронизация использует этот интерфейс таблицы синхронизации вместо `IMobileServiceTable`. При использовании таблицы синхронизации все операции направляются в локальное хранилище и синхронизируются с удаленной службой только по явным операциям принудительной отправки и принудительного получения.

    Для получения ссылки на таблицу синхронизации используется метод `GetSyncTable()`. Вместо этого для удаления функции автономной синхронизации используется `GetTable()`.

3. Прежде чем можно будет выполнить операции с таблицами, необходимо инициализировать локальное хранилище. Это выполняется в методе `InitializeStoreAsync`:

        public async Task InitializeStoreAsync()
        {
            var store = new MobileServiceSQLiteStore(localDbPath);
            store.DefineTable<ToDoItem>();

            // Uses the default conflict handler, which fails on conflict
            await client.SyncContext.InitializeAsync(store);
        }

    При этом создается локальное хранилище, использующее класс `MobileServiceSQLiteStore`, который предоставляется в пакете SDK для мобильного приложения. Можно также предоставить другую реализацию локального хранилища, внедрив `IMobileServiceLocalStore`.

    Метод `DefineTable` создает в локальном хранилище таблицу, совпадающую с полями в указанном типе, в данном случае `ToDoItem`. Тип необязательно должен включать в себя все столбцы, которые находятся в удаленной базе данных, так как можно хранить и подмножество столбцов.

<!--     Эта перегрузка `InitializeAsync` использует обработчик конфликтов по умолчанию, который завершается сбоем всякий раз, когда возникает конфликт. Чтобы предоставить пользовательский обработчик конфликтов, см. учебник [Обработка конфликтов с автономной поддержкой мобильных служб].
 -->
4. Метод `SyncAsync` активирует операцию фактической синхронизации:

        public async Task SyncAsync()
        {
            try
            {
                await client.SyncContext.PushAsync();
                await todoTable.PullAsync("allTodoItems", todoTable.CreateQuery()); // query ID is used for incremental sync
            }

            catch (MobileServiceInvalidOperationException e)
            {
                Console.Error.WriteLine(@"Sync Failed: {0}", e.Message);
            }
        }

    Сначала выполняется вызов `IMobileServiceSyncContext.PushAsync()`. Этот метод является участником `IMobileServicesSyncContext`, а не таблицы синхронизации, так как изменения будут переданы во все таблицы. Только те записи, которые были каким-либо образом локально изменены (с помощью операций CUD), будут отправлены на сервер.

    Затем метод вызывает `IMobileServiceSyncTable.PullAsync()` для извлечения данных из таблицы на сервере в приложение. Обратите внимание, что если в контексте синхронизации имеются ожидающие изменения, то операция принудительного получения всегда предварительно выполняет операцию принудительной отправки. Это позволяет обеспечить согласованность всех таблиц в локальном хранилище, а также связей между ними. В этом случае мы вызвали операцию принудительной отправки явным образом.

    В этом примере мы вернем из удаленной таблицы `TodoItem` все записи, которые можно также отфильтровать путем передачи запроса. Первым параметром для `PullAsync()` является идентификатор запроса, используемый для добавочной синхронизации, в рамках которой используется метка времени `UpdatedAt`, чтобы получить только записи, измененные с момента последней синхронизации. Идентификатор запроса должен быть описательной строкой, уникальной для каждого логического запроса в приложении. Чтобы явно отказаться от добавочной синхронизации, передайте в качестве ИД запроса значение `null`. В этом случае команда получает все записи по каждой операции принудительного извлечения, которая потенциально неэффективна.

<!--     >[AZURE.NOTE] Для удаления записей из локального хранилища устройства, если они были удалены в базе данных мобильной службы, следует включить [обратимое удаление]. В противном случае приложение должно периодически вызывать `IMobileServiceSyncTable.PurgeAsync()` для очистки локального хранилища.

    Обратите внимание, что исключение `MobileServicePushFailedException` может возникать как при операциях отправки push-уведомлений, так и при операциях извлечения. В следующем учебнике [Обработка конфликтов с автономной поддержкой мобильных служб] показано, как обрабатывать такие исключения, связанные с синхронизацией.
-->

5. В классе `QSTodoService` метод `SyncAsync()` вызывается после операций, которые изменяют данные: `InsertTodoItemAsync()` и `CompleteItemAsync`. Он также вызывается из `RefreshDataAsync()`, поэтому пользователь получает последние данные при каждом выполнении жеста обновления. Приложение также выполняет синхронизацию при запуске, поскольку `QSTodoListViewController.ViewDidLoad()` вызывает `RefreshDataAsync()`.

    Поскольку `SyncAsync()` вызывается при каждом изменении данных, это приложение предполагает, что пользователь находится в сети каждый раз, когда вносит изменения в данные. В следующем разделе мы обновим приложение, чтобы пользователи могли изменять данные, даже работая в автономном режиме.

## Обновление режима синхронизации приложения

В этом разделе вы измените приложение, чтобы оно не синхронизировалось при запуске или операциях вставки и изменения и синхронизировалось только при выполнении жеста обновления. Затем вы разорвете связь приложения с мобильным внутренним сервером для имитации автономного сценария. При добавлении элементов данных они будут храниться в локальном хранилище, но не будут синхронизированы с хранилищем данных мобильного внутреннего сервера немедленно.

1. Откройте `QSTodoService.cs`. Закомментируйте вызовы `SyncAsync()` в следующих методах:

    - `InsertTodoItemAsync`
    - `CompleteItemAsync`
    - `RefreshAsync`

    Теперь `RefreshAsync()` будет загружать только данные из локального хранилища, но не будет подключаться к внутреннему серверу приложений.

2. В `QSTodoService.cs` измените определение `applicationURL`, чтобы оно указывало на недопустимый URI мобильного приложения:

        const string applicationURL = @"https://your-service.azurewebsites.xxx/"; // invalid URI

3. Чтобы обеспечить синхронизацию данных при выполнении обновления, измените метод `QSTodoListViewController.RefreshAsync()`. Добавьте вызов `SyncAsync()` перед вызовом `RefreshDataAsync()`:

        private async Task RefreshAsync ()
        {
            RefreshControl.BeginRefreshing ();

            await todoService.SyncAsync();
            await todoService.RefreshDataAsync (); // add this line

            RefreshControl.EndRefreshing ();

            TableView.ReloadData ();
        }

4. Выполните сборку и запустите приложение. Добавьте несколько новых элементов списка дел. Эти новые элементы существуют только в локальном хранилище, пока не будут принудительно переданы на мобильный внутренний сервер. Клиентское приложение ведет себя так, как если бы оно было подключено к внутреннему серверу, поддерживающему все операции создания, чтения, обновления и удаления (CRUD).

5. Закройте приложение и перезапустите его, чтобы убедиться, что новые элементы сохранены в локальном хранилище.

## Обновление приложения для повторного подключения мобильного внутреннего сервера

В этом разделе вы повторно подключите приложение к мобильному внутреннему серверу, имитирующему приложение, подключающееся к сети. При выполнении жеста обновления данные будут синхронизированы с мобильным внутренним сервером.

1. Откройте `QSTodoService.cs`. Удалите недопустимый URL-адрес мобильного приложения и верните правильный URL-адрес и ключ приложения.

2. Повторно выполните сборку и запустите приложение. Обратите внимание, что данные не изменились несмотря на то, что приложение теперь подключено к мобильному внутреннему серверу. Это вызвано тем, что данное приложение всегда использует объект `IMobileServiceSyncTable`, который указывает на локальное хранилище.

3. Подключитесь к базе данных SQL внутреннего сервера, чтобы просмотреть сохраненные данные. В Visual Studio последовательно щелкните пункты **Обозреватель серверов** -> **Azure** -> **Базы данных SQL**. Щелкните правой кнопкой мыши базу данных и выберите **Открыть в обозревателе объектов SQL Server**.

    Обратите внимание, что данные не синхронизированы между базой данных и локальным хранилищем.

4. Находясь в приложении, сделайте жест обновления, потянув список элементов вниз. После этого приложение вызывает `RefreshDataAsync()`, который в свою очередь вызывает `SyncAsync()`. Это приведет к отправке push-уведомлений и выполнению операций получения: сначала элементы локального хранилища отправляются на мобильный внутренний сервер, а затем из мобильного внутреннего сервера извлекаются новые данные.

5. Обновите представление базы данных и подтвердите, что изменения были синхронизированы.

<!-- ##Сводка

[AZURE.INCLUDE [mobile-services-offline-summary-csharp](../includes/mobile-services-offline-summary-csharp.md)]

## Дальнейшие действия

* [Обработка конфликтов с поддержкой автономного режима для мобильных служб]

* [Использование клиентского компонента Xamarin для мобильных служб Azure]
 -->

<!-- Images -->

<!-- URLs. -->
[Создание приложения Xamarin iOS]: app-service-mobile-dotnet-backend-xamarin-ios-get-started.md

[Использование клиентского компонента Xamarin для мобильных служб Azure]: partner-xamarin-mobile-services-how-to-use-client-library.md

[Xamarin Studio]: http://xamarin.com/download
[Расширение Xamarin]: http://xamarin.com/visual-studio

<!--HONumber=49-->