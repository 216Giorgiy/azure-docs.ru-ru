<properties urlDisplayName="Service Bus Queues" pageTitle="Как использовать очереди служебной шины (Node.js) - Azure" metaKeywords="очереди служебной шины Azure, очереди Azure, обмен сообщениями Azure, очереди Azure Node.js" description="Узнайте, как использовать очереди Service Bus в Azure. Примеры кода написаны на Node.js." metaCanonical="" services="service-bus" documentationCenter="nodejs" title="How to Use Service Bus Queues" authors="larryfr" solutions="" manager="wpickett" editor="" />

<tags ms.service="service-bus" ms.workload="tbd" ms.tgt_pltfrm="na" ms.devlang="nodejs" ms.topic="article" ms.date="09/17/2014" ms.author="larryfr" />






# Использование очередей Service Bus

В этом руководстве показано, как использовать очереди Service Bus. Примеры
подготовлены на языке JavaScript и используют модуль Node.js Azure. Здесь описаны такие сценарии,
как **создание очередей, отправка и получение сообщений**, а также
**удаление очередей**. Дополнительные сведения об очередях см. в разделе [Дальнейшие
действия].

## Оглавление

-   [Что такое очереди Service Bus?][]
-   [Создание пространства имен службы][]
-   [Получение учетных данных управления по умолчанию для пространства имен][]
-   [Создание приложения Node.js](#create-app)
-   [Настройка приложения для использования шины обслуживания](#configure-app)
-   [Практическое руководство. Создать очередь](#create-queue)
-   [Практическое руководство. Отправка сообщений в очередь](#send-messages)
-   [Практическое руководство. Получение сообщений из очереди](#receive-messages)
-   [Практическое руководство. Обработка сбоев приложения и нечитаемых сообщений](#handle-crashes)
-   [Дальнейшие действия](#next-steps)

[WACOM.INCLUDE [howto-service-bus-queues](../includes/howto-service-bus-queues.md)]

## <a name="create-app"> </a>Создание приложения Node.js

Создание пустого приложения Node.js. Инструкции по созданию приложения Node.js см. в статьях [Создание и развертывание приложения Node.js на веб-сайте Azure], [Облачная служба Node.js][Облачная служба Node.js] (с использованием Windows PowerShell) или [Веб-сайт с WebMatrix].

## <a name="configure-app"> </a>Настройка приложения для использования шины обслуживания

Чтобы использовать служебную шину Azure, необходимо загрузить и применить
Пакет Azure Node.js. Содержит набор удобных библиотек, которые
взаимодействуют с REST-службами служебной шины.

### Использование диспетчера пакета Node (NPM) для получения пакета

1.  Используйте окно командой строки **Windows PowerShell для Node.js** для
    для перехода к папке **c:\\node\\sbqueues\\WebRole1** где был
    создан ваш пример приложения.

2.  В командном окне введите **npm install azure** в результате чего
    будет получен результат, аналогичный приведенному ниже:

        azure@0.7.5 node_modules\azure
		├── dateformat@1.0.2-1.2.3
		├── xmlbuilder@0.4.2
		├── node-uuid@1.2.0
		├── mime@1.2.9
		├── underscore@1.4.4
		├── validator@1.1.1
		├── tunnel@0.0.2
		├── wns@0.5.3
		├── xml2js@0.2.7 (sax@0.5.2)
		└── request@2.21.0 (json-stringify-safe@4.0.0, forever-agent@0.5.0, aws-sign@0.3.0, tunnel-agent@0.3.0, oauth-sign@0.3.0, qs@0.6.5, cookie-jar@0.3.0, node-uuid@1.4.0, http-signature@0.9.11, form-data@0.0.8, hawk@0.13.1)

3.  Можно вручную запустить команду **ls**, чтобы проверить
    **Создана папка node\_modules**. В этой папке найдите
    **пакет Azure**, содержащий библиотеки, необходимые для доступа к
    Очереди служебной шины.

### Импорт модуля

С помощью программы Блокнот или другого текстового редактора добавьте следующее в начало
файлу **server.js** приложения:

    var azure = require('azure');

### Настройка подключения к Service Bus Azure

Модуль Azure будет считывать переменные среды AZURE_SERVICEBUS_NAMESPACE и AZURE_SERVICEBUS_ACCESS_KEY для получения сведений, необходимых для подключения к служебной шине в Azure. Если эти переменные среды не заданы, при вызове **createServiceBusService** необходимо указать сведения об учетной записи.

Пример настройки переменных среды в файле конфигурации для облачной службы Azure см. в статье [Облачная служба Node.js с хранилищем].

Пример настройки переменных среды на портале управления для веб-сайта Azure см. в статье [Веб-приложение Node.js с хранилищем]

## <a name="create-queue"> </a>Создание очереди

Объект **ServiceBusService** позволяет работать с очередями. Пример:
Следующий код создает объект **ServiceBusService**. Добавьте его к
в начале файла**server.js** после оператора импорта Azure
модуль:

    var serviceBusService = azure.createServiceBusService();

Путем вызова **createQueueIfNotExists** в объекте **ServiceBusService**
, можно получить указанную очередь (если она существует,) или новую
созданную очередь с таким именем. Следующий код использует
метод **createTopicIfNotExists**, чтобы создать или подключиться к очереди с именем
myqueue:

    serviceBusService.createQueueIfNotExists('myqueue', function(error){
        if(!error){
            // Queue exists
        }
    });

**createServiceBusService** также поддерживает дополнительные параметры, которые
позволяют переопределить параметры очереди по умолчанию, например срок жизни сообщения
или максимальный размер очереди. В следующем примере показано, как задать
максимальный размер очереди 5 ГБ и срок жизни 1 минута:

    var queueOptions = {
          MaxSizeInMegabytes: '5120',
          DefaultMessageTimeToLive: 'PT1M'
        };

    serviceBusService.createQueueIfNotExists('myqueue', queueOptions, function(error){
        if(!error){
            // Queue exists
        }
    });

###Фильтры

Дополнительные операции фильтрации можно применить к выполняемым операциям, используя **ServiceBusService**. К операциям фильтрации могут относиться ведение журнала, автоматически повтор и т. д. Фильтры являются объектами, реализующими метод со следующей сигнатурой:

		function handle (requestOptions, next)

Выполнив предварительную обработку параметров запроса, метод должен вызвать "next", передавая обратный вызов со следующей сигнатурой:

		function (returnObject, finalCallback, next)

В этой функции обратного вызова и после обработки returnObject (ответ на запрос к серверу) функция обратного вызова должна либо вызвать "next", если он существует, чтобы продолжить обработку других фильтров, либо в противном случае просто вызвать "finalCallback" для завершения обращения к службе.

В Azure SDK для Node.js включены два фильтра, реализующие логику повторных попыток: **ExponentialRetryPolicyFilter** и **LinearRetryPolicyFilter**. Следующий код создает объект **ServiceBusService**, использующий **ExponentialRetryPolicyFilter**:

	var retryOperations = new azure.ExponentialRetryPolicyFilter();
	var serviceBusService = azure.createServiceBusService().withFilter(retryOperations);

## <a name="send-messages"> </a>Отправка сообщений в очередь

Чтобы отправить сообщение в очередь Service Bus, приложение вызывает
метод **sendQueueMessage** объекта **ServiceBusService**.
Сообщения, отправляемые в очереди Service Bus и получаемые из них, - это
объекты **BrokeredMessage** объекты, которые имеют набор стандартных свойств (например,
**Label** и **TimeToLive**), словарь, содержащий 
настраиваемые свойства приложения и набор произвольных
данных приложения. Приложение может задать текст сообщения
,передав строковое значение как сообщение и все необходимые стандартные
свойства будут заполнены значениями по умолчанию.

В следующем примере показано, как отправить тестовое сообщение в
очередь с именем myqueue с помощью **sendQueueMessage**:

    var message = {
        body: 'Test message',
        customProperties: {
            testproperty: 'TestValue'
        }};
    serviceBusService.sendQueueMessage('myqueue', message, function(error){
        if(!error){
            // message sent
        }
    });

Очереди служебной шины поддерживают максимальный размер сообщения 256 КБ (заголовок,
, которая содержит стандартные и настраиваемые свойства приложения и размер которой
максимум 64 КБ). Ограничения на количество сообщений нет
содержится в очереди, но существует ограничение на общий размер сообщений
в очереди. Этот размер очереди определен во время создания,
верхнее ограничение - 5 ГБ.

## <a name="receive-messages"> </a>Получение сообщений из очереди

Сообщения извлекаются из очереди с помощью метода **receiveQueueMessage**
объекта **ServiceBusService**. По умолчанию сообщения
удаляются из очереди по мере считывания. Тем не менее можно прочитать (просмотреть)
и заблокировать сообщение без его удаления из очереди, установив
необязательному параметру **isPeekLock** значение **true**.

Стандартная логика операции - считывание и удаление сообщения;
при этом операция получения является простейшей моделью, оптимальной для сценариев,
в которых приложение может не обрабатывать сообщение в случае
сбоя. Чтобы разобраться, рассмотрим сценарий, в котором
получатель выдает запрос на получение, и у него возникает сбой до его
обработки. Так как служебная шина отметила сообщение, как используемое,
после перезапуска приложения и возобновления обработки сообщений
оно пропустит сообщение, отправленное до сбоя.

Если параметр **isPeekLock** имеет значение **true**, 
получение становится операцией из двух этапов, что позволяет поддерживать приложения,
неустойчивые к пропуску сообщений. Получив запрос, служебная шина
находит следующее сообщение, блокирует его, чтобы предотвратить
его получение другими получателями, и возвращает его приложению.
Закончив обработку сообщения (или надежно сохранив его
 для будущей обработки), приложение выполняет второй этап
процесс получения, вызывая метод **deleteMessage**, и предоставляя
сообщение для удаления в качестве параметра. Метод **deleteMessage**
помечает сообщение как использованное и удаляет его из очереди.

В примере ниже показано, как можно получать сообщения, и
обрабатывать их с помощью метода **receiveQueueMessage**. В примере сначала принимается и
и удаляется сообщение, а затем сообщение принимается с параметром **isPeekLock**
,заданным как true, затем сообщение удаляется с помощью метода **deleteMessage**:

    serviceBusService.receiveQueueMessage('taskqueue', function(error, receivedMessage){
        if(!error){
            // Message received and deleted
        }
    });
    serviceBusService.receiveQueueMessage(queueName, { isPeekLock: true }, function(error, lockedMessage){
        if(!error){
            // Message received and locked
            serviceBusService.deleteMessage(lockedMessage, function (deleteError){
                if(!deleteError){
                    // Message deleted
                }
            }
        }
    });

## <a name="handle-crashes"> </a>Обработка сбоев приложения и нечитаемых сообщений

служебная шина предоставляет функции, помогающие надлежащим образом исправить ошибки
в приложении или восстановиться после трудностей, возникших при обработке сообщения. Если
приложение-получатель не может обработать сообщение по какой-то причине,
оно может вызвать метод **unlockMessage** 
объекта **ServiceBusService**. После этого служебная шина разблокирует
сообщение в очереди и сделает его доступным для приема
тем же приложением или другим приложением.
приложения.

Существует также время ожидания, связанное с сообщением, заблокированным в
и если приложение не сможет обработать сообщение в течение времени ожидания
время ожидания блокировки истекает (например, при сбое приложения), то служебная шина
разблокирует сообщение автоматически и сделает его доступным для
повторного получения.

Если сбой приложения происходит после обработки сообщения
, но перед вызовом метода **deleteMessage**, то сообщение будет
будет повторно доставлено в приложение после его перезапуска. Часто этот подход называют
**обработать хотя бы один раз**, т. е. каждое сообщение будет обрабатываться
по крайней мере один раз, но в некоторых случаях это же сообщение может быть
доставлено повторно. Если повторная обработка недопустима,
рекомендуется добавить в приложение дополнительную логику
для обработки повторной доставки сообщений. Часто это достигается с помощью
свойства **MessageId** сообщения, которое остается постоянным для
различных попыток доставки.

## <a name="next-steps"> </a>Дальнейшие действия

Вы ознакомились с основами использования очередей служебной шины. Теперь вы можете
по ссылкам на дополнительные сведения.

-   Справочник MSDN: [Очереди, разделы и подписки.][]
-   Посетите репозиторий [Azure SDK for Node] на веб-сайте GitHub.

  [Azure SDK для Node]: https://github.com/WindowsAzure/azure-sdk-for-node
  [Дальнейшие действия]: #next-steps
  [Что такое очереди Service Bus?]: #what-are-service-bus-queues
  [Создание пространства имен службы]: #create-a-service-namespace
  [Получение учетных данных управления по умолчанию для пространства имен]: #obtain-default-credentials
  [Создание приложения Node.js]: #create-app
  [Настройка приложения для использования шины обслуживания]: #configure-app
  [Практическое руководство. Создать очередь]: #create-queue
  [Практическое руководство. Отправка сообщений в очередь]: #send-messages
  [Практическое руководство. Получение сообщений из очереди]: #receive-messages
  [Практическое руководство. Обработка сбоев приложения и нечитаемых сообщений]: #handle-crashes
  [Основные понятия очередей]: ../../dotNet/Media/sb-queues-08.png
  [Портал управления Azure]: http://manage.windowsazure.com
  
  
  
  
  
  [Облачная служба Node.js]: /ru-ru/documentation/articles/cloud-services-nodejs-develop-deploy-app/
  [Очереди, разделы и подписки.]: http://msdn.microsoft.com/ru-ru/library/windowsazure/hh367516.aspx
  [Веб-сайт с WebMatrix]: /ru-ru/develop/nodejs/tutorials/web-site-with-webmatrix/
[Предыдущая версия портала управления]: ../../Shared/Media/previous-portal.png
  [Создание и развертывание приложения Node.js на веб-сайте Azure]: /ru-ru/develop/nodejs/tutorials/create-a-website-(mac)/
  [Облачная служба Node.js с хранилищем]: /ru-ru/develop/nodejs/tutorials/web-app-with-storage/
  [Веб-приложение Node.js с хранилищем]: /ru-ru/develop/nodejs/tutorials/web-site-with-storage/
