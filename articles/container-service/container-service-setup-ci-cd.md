---
title: "Непрерывные интеграция и доставка с использованием Службы контейнеров Azure и DC/OS | Документация Майкрософт"
description: "Полная автоматизация создания и развертывания многоконтейнерного приложения с помощью Docker в кластере службы контейнеров Azure под управлением DC/OS."
services: container-service
documentationcenter: 
author: spboyer
manager: wpickett
editor: 
tags: acs, azure-container-service
keywords: "Docker, контейнеры, микрослужбы, Mesos, Azure"
ms.assetid: b16b767a-2eaa-418a-becc-8c032713a1f2
ms.service: container-service
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 11/14/2016
ms.author: johnsta
translationtype: Human Translation
ms.sourcegitcommit: eeb56316b337c90cc83455be11917674eba898a3
ms.openlocfilehash: acfba48585b960a1ce39b77e35d292189aa9732b
ms.lasthandoff: 04/03/2017


---

# <a name="continuous-integration-and-deployment-of-multi-container-docker-applications-to-azure-container-service"></a>Непрерывная интеграция и развертывание многоконтейнерных приложений с помощью Docker в службе контейнеров Azure 
Из этого руководства вы узнаете, как полностью автоматизировать создание и развертывание многоконтейнерного приложения с помощью Docker в кластере службы контейнеров Azure под управлением DC/OS. Преимущества непрерывной интеграции и развертывания очевидны. Интеграция контейнеров в рабочий процесс открывает дополнительные возможности, на которых мы остановимся подробнее. С помощью реестра контейнеров Azure и команд интерфейса командной строки мы настроим полнофункциональную последовательность, к которой можно применять пользовательские настройки.

## <a name="get-started"></a>Приступая к работе
Инструкции из приведенного ниже пошагового руководства можно выполнить в операционной системе OS X, Windows или Linux.
- Вам понадобится подписка Azure. Если у вас ее нет, [зарегистрируйте учетную запись](https://azure.microsoft.com/).
- Установите [Azure CLI 2.0](/cli/azure/install-az-cli2).

## <a name="what-well-create"></a>Что мы будем создавать
Рассмотрим некоторые ключевые аспекты приложения и последовательности его развертывания, которую мы собираемся настроить.
* **Приложение состоит из нескольких служб**. Такие средства Docker, как Dockerfile и docker-compose.yml, предназначены для определения служб в приложении. Каждая из них выполняется в отдельном контейнере. Благодаря этому части приложения доступны для масштабирования независимо друг от друга, а службы приложения могут быть созданы на разных платформах с использованием разных языков программирования. Код приложения может быть размещен в одном или нескольких репозиториях Git (в настоящее время средства поддерживают GitHub или Visual Studio Team Services).

* Приложение запускается в **кластере ACS, настроенном с помощью DC/OS**. Оркестратор контейнера позволяет управлять работоспособностью кластера и обеспечивает выполнение необходимого количества экземпляров контейнера. 

* Процесс **создания и развертывания образов контейнера полностью автоматизирован, за счет чего время простоя приложения равно нулю**. Мы хотим, чтобы разработчики просто помещали приложение в ветвь репозитория, которая автоматически активирует процесс интеграции. Этот процесс включает построение образов контейнеров и присвоение им тегов, выполнение тестирования в каждом контейнере и передачу образов в частный реестр Docker. Из реестра новые образы автоматически развертываются в общую подготовительную среду в кластере ACS для дальнейшего тестирования.

* **Перемещение выпуска из одной среды в следующую**. Например, среда разработки -> среда тестирования -> промежуточная среда -> рабочая среда. Во время перемещения в следующую среду нам не нужно повторно собирать образы контейнеров, чтобы развернуть образы, которые уже протестированы в предыдущей среде. Этот процесс представляет собой концепцию *неизменяемых служб*, которая снижает вероятность незаметного проникновения ошибок в рабочую среду.

* Чтобы максимально эффективно использовать вычислительные ресурсы в кластере ACS, мы используем один кластер для выполнения задач, которые включают в себя действия по построению и развертыванию. Кроме того, в кластере находятся несколько сред разработки, тестирования и производства.


## <a name="create-an-azure-container-service-cluster-configured-with-dcos"></a>Создание кластера DC/OS, настроенного в службе контейнеров Azure

>[!IMPORTANT]
> Чтобы создать защищенный кластер, передайте файл с открытым ключом SSH для передачи при вызове `az acs create`. Вы также можете создать ключи с помощью интерфейса командной строки Azure 2.0 и передать их, используя параметр `--generate-ssh-keys`. Или вы можете указать путь к ключам с помощью параметра `--ssh-key-value` (расположение по умолчанию в Linux `~/.ssh/id_rsa.pub` и Windows `%HOMEPATH%\.ssh\id_rsa.pub`, которое можно изменить).
<!---Loc Comment: What do you mean by "you pass your SSH public key file to pass"? Thank you.--->
> Чтобы создать открытый и закрытый ключ SSH в Linux, см. инструкции в статье [Создание ключей SSH для виртуальных машин Linux в ОС Linux и Mac в Azure](../virtual-machines/linux/mac-create-ssh-keys.md?toc=%2fazure%2fcontainer-services%2ftoc.json). 
> Чтобы создать открытый и закрытый ключ SSH в Windows, см. инструкции в статье [Использование SSH с Windows в Azure](../virtual-machines/linux/ssh-from-windows.md?toc=%2fazure%2fcontainer-services%2ftoc.json). 

1. Сначала введите команду [az login](/cli/azure/#login) в окно терминала, чтобы войти в подписку Azure с помощью интерфейса командной строки Azure: 

    `az login`

1. Выполнив команду [az group create](/cli/azure/group#create), создайте группу ресурсов, в которой будет расположен кластер.
    
    `az group create --name myacs-rg --location westus`

    Может потребоваться указать ближайший к вам [регион центра обработки данных Azure](https://azure.microsoft.com/regions). 

1. Создайте кластер ACS с параметрами по умолчанию с помощью команды [az acs create](/cli/azure/acs#create) и передайте путь к файлу с открытым ключом SSH: 

    ```azurecli
    az acs create \
    --resource-group myacs-rg 
    --name myacs \
    --dns-prefix myacs \
    --ssh-key-value ~/.ssh/id_rsa.pub
    ```
    
Этот шаг занимает несколько минут, поэтому можете читать дальше.  Команда `acs create` возвращает сведения о созданном кластере. Или можно просмотреть список кластеров ACS в подписке с помощью команды `az acs list`. Дополнительные параметры конфигурации ACS см. в статье [Развертывание кластера службы контейнеров Azure](container-service-deployment.md).

## <a name="set-up-sample-code"></a>Настройка примера кода
Во время создания кластера можно настроить пример кода, который будет развернут в ACS.

1. [Создайте разветвление](https://help.github.com/articles/fork-a-repo/) примера репозитория GitHub, чтобы иметь собственную копию: [https://github.com/azure-samples/container-service-dotnet-continuous-integration-multi-container.git](https://github.com/azure-samples/container-service-dotnet-continuous-integration-multi-container.git). По сути это приложение является многоконтейнерной версией hello world.
1. После создания разветвления в собственной учетной записи GitHub локально клонируйте репозиторий на компьютер:

    ```bash
    git clone  https://github.com/your-github-account/container-service-dotnet-continuous-integration-multi-container.git
    cd container-service-dotnet-continuous-integration-multi-container
    ```
    
Рассмотрим элементы кода подробнее.
* `/service-a` — это веб-приложение Angular.js с серверной частью Node.js.
* `/service-b` — это служба .NET Core, которая вызывается с помощью приложения `service-a` через интерфейс REST.
* Приложения `service-a` и `service-b` содержат `Dockerfile` во всех своих каталогах, которые описывают соответственно образы контейнеров Node.js и .NET Core. 
* `docker-compose.yml` объявляет набор служб, которые собираются и развертываются.
* В дополнение к `service-a` и `service-b` третья служба с именем `cache` выполняет кэш Redis, который может использовать приложение `service-a`. `cache` отличается от первых двух служб тем, что в исходном репозитории нет ее кода. Мы получили готовый образ `redis:alpine` из концентратора Docker и развернули его в ACS.
* `/service-a/server.js` содержит код, где `service-a` вызывает и `service-b`, и `cache`. Обратите внимание, что код `service-a` ссылается на `service-b` и `cache`, используя их имена в `docker-compose.yml`. Если мы выполним эти службы на локальном компьютере с помощью `docker-compose`, благодаря Docker все службы будут правильно объединены в сеть, чтобы они могли находить друг друга по имени. Если выполнять службы в среде кластера с сетью с балансировкой нагрузки, им будет сложнее найти друг друга, чем при локальном выполнении. Хорошие новости заключаются в том, что команды интерфейса командной строки Azure настраивают последовательность CI/CD, благодаря которой код непосредственного обнаружения службы продолжает выполняться как есть в ACS. 

    ![Обзор примера многоконтейнерного приложения](media/container-service-setup-ci-cd/multi-container-sample-app-overview.PNG)

## <a name="set-up-continuous-integration-and-deployment"></a>Настройка непрерывной интеграции и развертывания
1. Проверьте готовность кластера ACS: запустите команду [az acs list](/cli/azure/acs#list) и убедитесь, что он есть в списке. (Примечание. В кластере ACS должна работать ОС DC/OS 1.8 или более поздней версии).

1. [Создайте личный маркер доступа к GitHub](https://help.github.com/articles/creating-an-access-token-for-command-line-use/), передав его как минимум области `repo`.  Не забудьте скопировать маркер в буфер обмена, так как он будет использоваться в следующей команде (которая настроит [webhook](https://help.github.com/articles/about-webhooks/) в нашем репозитории GitHub). 

1. Установите текущий каталог в корневом каталоге клонированного исходного репозитория. Затем создайте конвейер сборки и выпуска с помощью маркера _&lt;GitHubPersonalAccessToken&gt;, который вы только что создали:
    
    `cd container-service-dotnet-continuous-integration-multi-container`

    ```azurecli
    az container release create \
    --target-name myacs \
    --target-resource-group myacs-rg \
    --remote-access-token <GitHubPersonalAccessToken>
    ```

    Где `--target-name` — имя кластера ACS, а `--target-resource-group` — имя группы ресурсов кластера ACS.

При первом запуске для выполнения этой команды может потребоваться около минуты. После ее выполнения возвращаются важные сведения о конвейере сборки и выпуска, который она создала:
* `sourceRepo`: [webhook](https://help.github.com/articles/about-webhooks/) настроен для исходного репозитория. Каждый раз, когда исходный код помещается в него, автоматически активируется конвейер сборки и выпуска.  
* `vstsProject`: [Visual Studio Team Services](https://www.visualstudio.com/team-services/) (VSTS) настроены на *ведение* рабочего процесса (фактические задачи построения и развертывания выполняются внутри контейнеров в ACS). Если вы хотите использовать конкретную учетную запись VSTS и проект, вы можете определить их с помощью параметров `--vsts-account-name` и `--vsts-project-name`.
* `buildDefinition`: определяет задачи, которые выполняются для каждой сборки. Образы контейнеров создаются для каждой службы, определенной в docker-compose.yml, а затем помещаются в реестр контейнеров Docker. 
* `containerRegistry`: реестр контейнеров Azure является управляемой службой, которая запускает контейнер реестра Docker. Новый реестр контейнеров Azure создается с именем по умолчанию. Или вы можете указать его имя с помощью параметра `--registry-name`.
* `releaseDefinition`: определяет задачи, которые выполняются для каждого развертывания. Образы контейнеров для службы, определенной в docker-compose.yml, извлекаются из реестра контейнера и развертываются в кластере ACS. По умолчанию создаются три среды: *разработки*, *тестирования* и *рабочая среда*. Определение выпуска настроено по умолчанию на автоматическое развертывание в среду *разработки* после каждой успешной сборки. Выпуск можно вручную перенести в среду *тестирования* или *рабочую* среду без повторной сборки. Последовательность по умолчанию можно настроить в VSTS. 
* `containerService`: целевой кластер ACS кластера (в нм должна работать ОС DC/OS 1.8).


Следующий фрагмент кода является примером команды, которую следует ввести, если у вас уже есть реестра контейнеров Azure с именем `myregistry`. Создайте и соберите определения версии с помощью учетной записи VSTS в `myvstsaccount.visualstudio.com` и существующего проекта VSTS `myvstsproject`:
        
```azurecli
az container release create \
--target-name myacs \
--target-resource-group myacs-rg \
--registry-name myregistry \
--vsts-account-name myvstsaccount \
--vsts-project-name myvstsproject \
--remote-access-token <GitHubPersonalAccessToken>
```

## <a name="view-deployment-pipeline-progress"></a>Просмотр хода выполнения конвейера развертывания
После создания конвейера первая сборка и развертывание будут запущены автоматически. Последующие сборки активируются каждый раз, когда код отправляется в исходный репозиторий. Вы может проверить ход выполнения сборки или выпуска, открыв в обозревателе URL-адреса определения сборки или определения выпуска.

Чтобы найти URL-адрес определения выпуска, связанного с кластером ACS, выполните следующую команду:

```azurecli
az container release list \
--target-name myacs \
--target-resource-group myacs-rg
``` 

![Сборка VSTS](media/container-service-setup-ci-cd/vsts-build.PNG)

*Снимок экрана VSTS с результатами непрерывной интеграции многоконтейнерного приложения*

![Выпуск VSTS](media/container-service-setup-ci-cd/vsts-release.PNG)

*Выпуск docker-compose VSTS с несколькими средами*

## <a name="view-the-application"></a>Просмотр приложения
На этом этапе приложение развертывается в общей среде разработки и не является общедоступным. Пока что используйте панель мониторинга DC/OS для просмотра служб и управления ими и [создайте туннель SSH к конечным точкам, связанным с DC/OS](https://azure.microsoft.com/documentation/articles/container-service-connect/) или выполните команду, доступную в интерфейсе командной строки Azure.

> [!IMPORTANT]
> Во время первого развертывания убедитесь, что выпуск VSTS успешно развернут, прежде чем продолжить.

> [!NOTE]
> Примечание только для пользователей Windows: чтобы выполнить инструкции этого раздела, необходимо настроить [Pageant](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html).
> 
>* Запустите *PuttyGen* и загрузите закрытый ключ SSH, который использовался для создания кластера ACS (% homepath%\id_rsa).
>* Сохранить закрытый ключ SSH как `id_rsa.ppk` в той же папке.
>* Запустите агент *Pageant*. После его запуска в правому нижнем углу области уведомлений вы увидите его значок.
>* Щелкните правой кнопкой мыши значок на панели задач и выберите *Добавить ключ*.
>* Добавьте файл `id_rsa.ppk`.
> 
> 

1. Откройте панель мониторинга кластера ACS в интерфейсе DC/OS. Для удобства воспользуйтесь командой интерфейса командной строки Azure:
    
    `az acs dcos browse -g myacs-rg -n myacs`

    * `-g` — это имя группы ресурсов целевого кластера ACS.
    * `-n` — это имя целевого кластера ACS.
    * Может появиться запрос на ввод пароля локальной учетной записи, так как для выполнения этой команды требуются права администратора. Команда создает туннель SSH к конечной точке DC/OS, открывает браузер по умолчанию для этой конечной точки и временно настраивает прокси-сервер браузера. 

    > [!TIP]
    > Если необходимо найти имя кластера ACS, список всех кластеров ACS можно отобразить в подписке, выполнив команду `az acs list`. 

1. На панели мониторинга DC/OS в меню навигации слева щелкните **Службы**: ([http://localhost/#/services](http://localhost/#/services)). Службы, развернутые с помощью конвейера, группируются в корневой папке с именем *dev* (папка названа так и-за среды разработки в определении выпуска VSTS). 

![Пользовательский интерфейс Marathon](media/container-service-setup-ci-cd/marathon-ui.png)

На панели мониторинга DC/OS можно выполнять различные задачи:

* отслеживать состояние развертывания каждой службы;
* просматривать требования к ЦП и памяти;
* просматривать журналы;
* масштабировать количество экземпляров для каждой службы.

**Чтобы просмотреть веб-приложение service-a**, откройте корневую папку *dev*, а затем перейдите вниз по иерархии папок, пока не дойдете до `service-a`. В этом представлении перечислены выполняемые задачи (или экземпляры контейнера) для `service-a`.

![service a](media/container-service-setup-ci-cd/service-a.png)

Щелкните задачу, чтобы открыть ее представление, затем выберите одну из доступных конечных точек.

![задача service a](media/container-service-setup-ci-cd/service-a-task.PNG)

Простое веб-приложение вызывает службу `service-a`, которая вызывает службу `service-b` и возвращает сообщение hello world. Значение счетчика увеличивается на Redis при каждом запросе.

![веб-приложение service a](media/container-service-setup-ci-cd/service-a-web-app.PNG)

### <a name="optional-reaching-a-service-from-the-command-line"></a>(Необязательно) Доступ к службе из командной строки
Если вы хотите связаться со службой с помощью cURL из командной строки, выполните следующие действия.

1. Выполните команду `az acs dcos browse --verbose -g myacs-rg -n myacs` и запишите строку "Proxy running on <IP-адрес>:<port>" после ввода пароля.
1. В новом окне терминала введите следующее:

    `export http_proxy=http://<web-proxy-service-ip>:<portnumber>`

    Например: `export http_proxy=http://127.0.0.1:55405`

1. Теперь можно связаться с конечной точкой службы (`curl http://service-url`) с помощью cURL, где `service-url` — это адрес, который вы видите при переходе к конечной точке службы из пользовательского интерфейса Marathon. Чтобы удалить из командной строки переменную http_proxy, введите `unset http_proxy`.
 

## <a name="scale-services"></a>Масштабирование служб
Пока открыта панель мониторинга DC/OS, масштабируем наши службы.
1. Перейдите к приложению во вложенной папке *dev*.
1. Наведите указатель мыши на `service-b`, щелкните значок шестеренки и выберите **Scale** (Масштабирование).

    ![Меню "Действие"](media/container-service-setup-ci-cd/marathon-ui-action-menu.PNG)

1. Увеличьте количество до 3 и нажмите кнопку **Scale Service** (Масштабировать службу).

    ![Масштабирование служб](media/container-service-setup-ci-cd/marathon-ui-scale-service.png)

1. Вернитесь к работающему веб-приложению и несколько раз нажмите кнопку *Say It Again* (Повторить это). Обратите внимание, что вызовы `service-b` начинают циклический перебор по набору узлов, а единственный экземпляр `service-a` продолжает уведомлять один и тот же узел.   

## <a name="promote-a-release-to-downstream-environments-without-rebuilding-container-images"></a>Перемещение выпуска в следующую среду без повторной сборки образов контейнеров
В конвейере выпуска VSTS настроены три среды по умолчанию: *разработки*, *тестирования*, и *рабочая*. Итак, мы развернули выпуск в среду *разработки*. Посмотрим, как можно перенести выпуск в следующую среду, то есть среду *тестирования*, без повторной сборки образов контейнеров. Этот рабочий процесс гарантирует, что мы развертываем те же образы, протестированные в предыдущей среде, а концепция *неизменяемых служб* снижает вероятность незаметного проникновения ошибок в рабочую среду.

1. В пользовательском веб-интерфейсе VSTS перейдите в каталог **Выпуски**

    ![Меню "Выпуски VSTS"](media/container-service-setup-ci-cd/vsts-releases-menu.PNG)

1. Откройте последний выпуск.

1. В строке меню определения выпуска нажмите кнопку **Развернуть**, а затем выберите **Тестирование**. Начнется развертывание в эту среду тех же образов, которые ранее были развернуты в среду *разработки*. Щелкните **Журналы**, если вы хотите подробно отслеживать развертывание.

    ![VSTS переносит выпуск](media/container-service-setup-ci-cd/vsts-promote-release.PNG)

После успешного развертывания в среду *тестирования* для этой среды будет создана новая корневая папка с именем *test* в пользовательском интерфейсе Marathon. Эта папка содержит выполняющиеся службы. 

![Вложенные папки для каждой среды в DC/OS](media/container-service-setup-ci-cd/marathon-ui-dev-test-environments.png)

## <a name="trigger-a-new-build-and-deployment"></a>Запуск новой сборки и развертывания
Посмотрим, что произойдет, если разработчик из нашей команды передаст изменение кода в исходный репозиторий.

1. Вернитесь в редактор кода и откройте `service-a/public/index.html`. 
1. Замените следующую строку кода:

    `<h2>Server Says</h2>`

    строкой примерно такого содержания:

    `<h2>Server Says Hello</h2>`

1. Сохраните файл, зафиксируйте его и отправьте изменение кода в исходный репозиторий.

    ```bash
    git commit -am 'updated title'
    git push
    ```

Фиксация автоматически запустит новую сборку, и новый выпуск будет развернут в среду *разработки*. Службы в следующих в потоке средах (*тестирования* или *рабочей*) останутся неизменными, пока мы не решим перенести конкретный выпуск в соответствующую среду.

Если открыть определение сборки в VSTS, вы увидите похожие сведения: 

![Новая сборка, активированная перемещением в репозиторий git](media/container-service-setup-ci-cd/new-build.png)



## <a name="expose-public-endpoint-for-production"></a>Предоставление открытой конечной точки для рабочей среды

1. Добавьте следующий код yaml в новый файл с именем `docker-compose.env.production.yml` в корневую папку исходного репозитория. Этот код добавит метку, которая предоставит открытую конечную точку для `service-a`. 
    
    ```yaml
    version: "2"
    services:
      service-a:
        labels:
          com.microsoft.acs.dcos.marathon.vhost: "<FQDN, or custom domain>"
    ```

    * В качестве значения метки можно указать URL-адрес полного доменного имени агента ACS или пользовательского домена (например, app.contoso.com). Чтобы найти полное доменное имя агента ACS, выполните команду `az acs list` и проверьте свойство на наличие `agentPoolProfiles.fqdn`. Например, `myacsagents.westus.cloudapp.azure.com`.
    * Пример приложения по умолчанию ожидает передачи данных через порт 80. Если приложения Docker пользователей ожидают передачи данных из других портов, например `port 8080` или `443`, добавьте номер порта к полному доменному имени. Например, `myacsagents.westus.cloudapp.azure.com:8080`. Однако при попытке получить доступ к приложению извне необходимо будет запрашивать его через порт 80.
    * Согласно соглашению об именовании файла docker-compose.env.*environment-name*.yml эти параметры влияют только на именованные среды (в данном случае на среду с именем *Production*). Проверьте определение выпуска в VSTS: каждая задача развертывания в среде должна быть настроена на чтение файла docker-compose, названного в соответствии с этим соглашением об именовании.

1. Зафиксируйте и отправьте файл в репозиторий основного источника, чтобы запустить другую сборку.

    ```bash
    git add .
    git commit -am "expose public port for service-a"
    git push
    ```

1. Подождите, пока обновление будет собрано и развернуто в среду *разработки*, затем перенесите его в *тестовую* среду, а затем — в *рабочую*. (Для выполнения инструкций этого руководства можно развернуть обновление сразу в *рабочую* среду, но желательно попрактиковаться в развертывании в следующую в потоке среду).

1. (Необязательно) **Если указан пользовательский домен** для vhost (например, app.contoso.com), добавьте запись DNS в параметры поставщика доменов. Войдите в пользовательский интерфейс администрирования поставщика доменов и добавьте запись DNS, как показано ниже:

    * Тип: CNAME
    * Узел: ваш домен, например app.contoso.com
    * Ответ: полное имя агента ACS, например myacsagents.westus.cloudapp.azure.com
    * Срок жизни (необязательно): в некоторых случаях поставщик домена позволяет изменить срок жизни. Если указать низкое значение, обновление DNS-записи будет распространяться быстрее.   

1. После развертывания выпуска в *рабочую* среду эта версия будет доступна всем. Откройте в браузере URL-адрес, указанный для метки `com.microsoft.acs.dcos.marathon.vhost`. (Примечание. Выпуски в подготовительных средах по-прежнему будут закрытыми).

## <a name="summary"></a>Сводка
Поздравляем! Вы научились создавать DC/OS кластер ACS и настраивать полностью автоматизированный контейнерный конвейер для сборки и развертывания многоконтейнерных приложений.

Дальнейшие действия
* **Масштабируйте агенты VSTS.** Чтобы обеспечить дополнительную пропускную способность для выполнения задач сборки и выпуска, можно увеличить количество экземпляров агентов VSTS. Перейдите в меню **Services** (Службы) на панели мониторинга DC/OS, откройте папку vsts-agents и попробуйте поэкспериментировать с масштабированием количества экземпляров агентов VSTS.
* **Интегрируйте модульное тестирование.** На сайте репозитория GitHub показано, как добавить в контейнеры функции модульного тестирования и тестов интеграции и включить их в задачи сборки: [https://github.com/mindaro/sample-app](https://github.com/mindaro/sample-app). 
    * Совет: просмотрите следующие файлы в репозитории: `service-a/unit-tests.js`, `service-a/service-tests.js`, `docker-compose.ci.unit-tests.yml` и `docker-compose.ci.service-tests.yml`.

## <a name="clean-up"></a>Очистка
Чтобы ограничить расходы на вычислительные операции, связанные с выполнением примеров этого руководства, выполните следующую команду и запишите ресурсы конвейера развертывания, связанные с кластером ACS.

```azurecli    
az container release list --resource-name myacs --resource-group myacs-rg
```

Удаление кластера ACS
1. Войдите на [портал Azure](https://portal.azure.com).
1. Найдите группу ресурсов, которая содержит ваш кластер ACS.
1. Откройте колонку группы ресурсов и выберите **Удалить** на панели команд колонки.

Удалите реестр контейнеров Azure: на портале Azure найдите реестр контейнеров Azure и удалите его. 

[Учетная запись Visual Studio Team Services предоставляет базовый уровень доступа бесплатно для первых пяти пользователей](https://azure.microsoft.com/en-us/pricing/details/visual-studio-team-services/), но вы можете удалить определения сборки и выпуска.

Удаление определения сборки VSTS
        
1. Откройте в браузере URL-адрес определения сборки, затем выберите ссылку **Определения сборок** (рядом с именем определения сборки, которая открыта в данный момент).
2. Щелкните меню действий рядом с определением сборки, которое необходимо удалить, и выберите **Удалить определение**

`![Удаление определения сборки VSTS](media/container-service-setup-ci-cd/vsts-delete-build-def.png) 

Удаление определения выпуска VSTS

1. Откройте в браузере URL-адрес определения выпуска.
2. В списке определений выпуска в на панели слева щелкните раскрывающийся список рядом с определением выпуска, которое требуется удалить, и выберите **Удалить**.

`![Удаление определения выпуска VSTS](media/container-service-setup-ci-cd/vsts-delete-release-def.png)

