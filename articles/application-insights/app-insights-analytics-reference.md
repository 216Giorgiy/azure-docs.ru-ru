<properties 
	pageTitle="Справочные материалы по аналитике в Application Insights" 
	description="Справочные материалы по регулярным выражениям в аналитике — мощном инструменте поиска Application Insights." 
	services="application-insights" 
    documentationCenter=""
	authors="alancameronwills" 
	manager="douge"/>

<tags 
	ms.service="application-insights" 
	ms.workload="tbd" 
	ms.tgt_pltfrm="ibiza" 
	ms.devlang="na" 
	ms.topic="article" 
	ms.date="03/30/2016" 
	ms.author="awills"/>

# Справочные материалы по аналитике

[Аналитика](app-insights-analytics.md) — это мощный инструмент поиска [Application Insights](app-insights-overview.md). На этих страницах описан язык запросов аналитики приложений.

*Воспользуйтесь поиском в обозревателе, чтобы найти элементы языка на этой странице, где объединено содержимое страниц о запросах, агрегатах и скалярах.*

[AZURE.INCLUDE [app-insights-analytics-top-index](../../includes/app-insights-analytics-top-index.md)]



## Запросы и операторы

Запрос на данные телеметрии выполняется с помощью ссылки на исходный поток, за которой следует конвейер фильтров. Например:


```AIQL
requests
| where client_City == "London" and timestamp > ago(3d)
| count
```
    
Каждый фильтр, перед которым используется вертикальная черта `|`, — это экземпляр класса *operator* с определенными параметрами. Входные данные для оператора представлены таблицей, которая является результатом предыдущего конвейера. В большинстве случаев все параметры — это [скалярные выражения](##scalars) для столбцов входных данных. В некоторых случаях параметры являются именами входных столбцов, но иногда параметр может быть второй таблицей. Результат запроса всегда является таблицей — даже если она включает только один столбец и одну строку.

Перед запросом может быть указано одно или несколько [предложений let](#let-clause). Эти предложения определяют скалярные значения, таблицы или функции, которые могут использоваться в запросе.

```AIQL

    let interval = 3d ;
    let city = "London" ;
    let req = (city:string) {
      requests
      | where client_City == city and timestamp > ago(interval) };
    req(city) | count
```

> `T` используется в приведенных ниже примерах запросов для обозначения предыдущей вертикальной черты или исходной таблицы.
> 

### Оператор count

Оператор `count` возвращает количество записей (строк) в наборе входных записей.

**Синтаксис**

    T | count

**Аргументы**

* *T* — табличные данные, записи которых будут посчитаны.

**Результаты**

Эта функция возвращает таблицу с одной записью и столбцом типа `long`. Значение единственной ячейки — количество записей в *T*.

**Пример**

```AIQL
requests | count
```



### Оператор extend

     T | extend duration = stopTime - startTime

Добавляет в таблицу один или несколько вычисляемых столбцов.


**Синтаксис**

    T | extend ColumnName = Expression [, ...]

**Аргументы**

* *T* — входная таблица.
* *ColumnName* — имена столбцов, которые будут добавлены. 
* *Expression* — вычисления для существующих столбцов.

**Результаты**

Копия входной таблицы с указанными дополнительными столбцами.

**Советы**

* Используйте [`project`](#project-operator) вместо этого оператора, если вам также нужно удалить или переименовать некоторые столбцы.
* Не используйте оператор `extend`, только чтобы получить более короткое имя, которое будет использоваться в длинном выражении. `...| extend x = anonymous_user_id_from_client | ... func(x) ...` 

    Собственные столбцы таблицы уже проиндексированы. Так как новое имя определяет дополнительный столбец, который не проиндексирован, скорее всего, запрос будет выполняться медленнее.

**Пример**

```AIQL
traces
| extend
    Age = now() - timestamp
```


### Оператор join

    Table1 | join (Table2) on CommonColumn

Объединяет строки в двух таблицах, сопоставляя значения из указанного столбца.


**Синтаксис**

    Table1 | join [kind=Kind] (Table2) on CommonColumn [, ...]

**Аргументы**

* *Table1* — левая часть объединенных данных.
* *Table2* — правая часть объединенных данных. Может быть выражением в виде вложенного запроса для вывода таблицы.
* *CommonColumn* — столбец с одинаковым именем в двух таблицах.
* *Kind* — определяет способ сопоставления строк в двух таблицах.

**Результаты**

Таблица со следующими элементами.

* Столбец для каждого столбца в каждой из двух таблиц, в том числе соответствующие ключи. В случае конфликта имен столбцы в правой части будут автоматически переименованы.
* Строка для каждого соответствия во входных таблицах. Соответствие — это выбранная в одной таблице строка, для которой во второй таблице есть соответствие (строка с одинаковым значением для всех полей `on`). 

* `Kind` (без определения)

    Каждому значению ключа `on` соответствует только одна строка из левой части. Выходные данные содержат по одной строке для каждого соответствия этой строки со строками из правой части.

* `Kind=inner`
 
     Строка в выходных данных для каждой комбинации соответствующих строк из левой и правой частей.

* `kind=leftouter` (или `kind=rightouter`, или `kind=fullouter`)

     Кроме внутренних соответствий есть также строка для каждой строки в левой и (или) правой части, даже при отсутствии соответствия. В этом случае ячейки выходных данных без соответствий содержат значения NULL.

* `kind=leftanti`

     Возвращает все записи из левой части, для которых нет соответствий в правой. Итоговая таблица содержит только столбцы из левой части.
 
Если есть несколько строк с одинаковыми значениями для этих полей, вы получите строки для всех комбинаций.

**Советы**

Обеспечить наилучшую производительность можно так.

* Используйте `where` и `project`, чтобы сократить количество строк и столбцов во входных таблицах (перед оператором `join`). 
* Если одна таблица меньше другой, используйте ее в качестве левой (перенаправленной) части объединенных данных.
* У объединяемых по соответствию столбцов должно быть одно имя. При необходимости переименуйте столбец в одной из таблиц с помощью оператора project.

**Пример**

Получите расширенные сведения о действиях из журнала, в котором некоторые записи указывают на время начала и конца действия.

```AIQL
    let Events = MyLogTable | where type=="Event" ;
    Events
    | where Name == "Start"
    | project Name, City, ActivityId, StartTime=timestamp
    | join (Events
           | where Name == "Stop"
           | project StopTime=timestamp, ActivityId)
        on ActivityId
    | project City, ActivityId, StartTime, StopTime, Duration, StopTime, StartTime

```

### Предложение let

**Табличное предложение let — присвоение имени таблице**

    let recentReqs = requests | where timestamp > ago(3d); 
    recentReqs | count

**Скалярное предложение let — присвоение имени значению**

    let interval = 3d; 
    requests | where timestamp > ago(interval)

**Лямбда-предложение let — присвоение имени функции**

    let Recent = 
       (interval:timespan) { requests | where timestamp > ago(interval) };
    Recent(3h) | count

Предложение let связывает имя с табличным результатом, скалярным значением или функцией. Предложение представлено префиксом для запроса, а сам запрос — это область привязки. (Let нельзя использовать для присвоения имен элементам, которые будут использоваться позже в ходе сеанса).

**Синтаксис**

    let name = scalar_constant_expression ; query

    let name = query ; query

    let name = (parameterName : type [, ...]) { plain_query }; query

* *type:* `bool`, `int`, `long`, `double`, `string`, `timespan`, `datetime`, `guid`, [`dynamic`](#dynamic-type)
* *plain\_query* — запрос без префикса в виде предложения let.

**Примеры**




    let rows(n:long) = range steps from 1 to n step 1;
    rows(10) | ...


Самосоединение:

    let Recent = events | where timestamp > ago(7d);
    Recent | where name contains "session_started" 
    | project start = timestamp, session_id
    | join (Recent 
        | where name contains "session_ended" 
        | project stop = timestamp, session_id)
      on session_id
    | extend duration = stop - start 

### Оператор limit

     T | limit 5

Возвращает заданное количество строк из входной таблицы. Указать, какие записи будут возвращены, нельзя. (Чтобы вернуть определенные записи, используйте оператор [`top`](#top-operator)).

**Псевдоним** `take`

**Синтаксис**

    T | limit NumberOfRows


**Советы**

`Take` — простой и эффективный способ просмотреть пример результатов при работе в интерактивном режиме. Учтите, что этот оператор не используется для создания конкретных строк либо их создания в указанном порядке.

Есть неявное ограничение на количество строк, возвращаемых клиенту, даже если вы не используете оператор `take`. Чтобы снять это ограничение, используйте параметр `notruncation` клиентского запроса.



### Оператор mvexpand

    T | mvexpand listColumn 

Разворачивает список из ячейки с динамической типизацией (JSON) так, чтобы у каждой записи была отдельная строка. Все остальные ячейки в развернутой строке дублируются.

(См. также оператор [`summarize makelist`](#summarize-operator), который выполняет противоположную функцию).

**Пример**

Предположим, что у вас такая входная таблица:

|A:int|B:string|D:dynamic|
|---|---|---|
|1|"hello"|{"key":"value"}|
|2|"world"|[0,1,"k","v"]|

    mvexpand D

Результат будет таким:

|A:int|B:string|D:dynamic|
|---|---|---|
|1|"hello"|{"key":"value"}|
|2|"world"|0|
|2|"world"|1|
|2|"world"|"k"|
|2|"world"|"v"|


**Синтаксис**

    T | mvexpand  [bagexpansion=(bag | array)] ColumnName [limit Rowlimit]

    T | mvexpand  [bagexpansion=(bag | array)] [Name =] ArrayExpression [to typeof(Typename)] [limit Rowlimit]

**Аргументы**

* *ColumnName* — массивы именованного столбца в результате будут развернуты в несколько строк. 
* *ArrayExpression* — выражение, которое возвращает массив. Если используется этот аргумент, добавляется новый столбец, а существующий сохраняется.
* *Name* — имя нового столбца.
* *Typename* — приводит развернутое выражение к определенному типу.
* *RowLimit* — максимальное количество строк, созданных из каждой исходной строки. Значение по умолчанию — 128.

**Результаты**

Несколько строк для каждого значения в массиве в именованном столбце или выражении массива.

Тип развернутого столбца всегда динамический. Используйте такое приведение, как `todatetime()` или `toint()`, чтобы выполнить обычное или статическое вычисление значений.

Поддерживаются два режима развертывания контейнера свойств.

* `bagexpansion=bag` — контейнеры свойств развертываются в контейнеры свойств с одной записью. Это значение по умолчанию.
* `bagexpansion=array` — контейнеры свойств развертываются в структуры массива с двумя элементами (`[`*key*`,`*value*`]`), предоставляя универсальный доступ к ключам и значениям (а также, например, выполняя статистический подсчет числа различных объектов для имен свойств). 

**Примеры**


    exceptions | take 1 
    | mvexpand details[0]

Разбивает запись исключения на строки для каждого элемента в поле подробных сведений.



### Оператор parse

    T | parse "I am 63 next birthday" with "I am" Year:int "next birthday"

    T | parse kind=regex "My 62nd birthday" 
        with "My" Year:regex("[0..9]+") regex("..") "birthday"

Извлекает значения из строки. Можно использовать сопоставление простых или регулярных выражений.

Элементы в предложении `with`, в свою очередь, сопоставляются с исходной строкой. Каждый элемент обрабатывает часть исходного текста. Если это простая строка, курсор перемещается в рамках соответствия. Если это столбец с именем типа, курсор перемещается, пока есть возможность выполнять синтаксический анализ указанного типа. (Соответствия строк обрабатываются до тех пор, пока не будет найден следующий элемент). Если это регулярное выражение, ищется соответствие регулярному выражению (тип итогового столбца всегда будет строковым).

**Синтаксис**

    T | parse StringExpression with [SimpleMatch | Column:Type] ...

    T | parse kind=regex StringExpression 
        with [SimpleMatch | Column : regex("Regex")] ...

**Аргументы**

* *T* — входная таблица.
* *kind* — простое или регулярное выражение. По умолчанию используется простое выражение.
* *StringExpression* — выражение, результатом вычисления или преобразования которого является строка.
* *SimpleMatch* — строка, которая совпадает со следующей частью текста.
* *Column* — указывает новый столбец, которому будет назначено соответствие.
* *Type* — указывает, как анализировать следующую часть исходной строки.
* *Regex* — регулярное выражение для сопоставления следующей части строки. 

**Результаты**

Входную таблицу, развернутую в соответствии со списком столбцов.


**Примеры**

Оператор `parse` — это упрощенный способ развернуть (`extend`) таблицу с помощью нескольких приложений `extract` в одном выражении `string`. Это эффективно, если в таблице есть столбец `string` с несколькими значениями, которые нужно разбить на отдельные столбцы (например, столбец, который создан с помощью инструкции трассировки — `printf` или `Console.WriteLine`).

В примере ниже предполагается, что столбец `EventNarrative` таблицы `StormEvents` содержит строки в формате `{0} at {1} crested at {2} feet around {3} on {4} {5}`. В ходе операции ниже будет развернута таблица с двумя столбцами: `SwathSize` и `FellLocation`.


|Описание события (EventNarrative)|
|---|
|12 декабря в 09:30 по восточному поясному времени уровень воды в реке Грин-Ривер в городе Браунсвилл поднялся до отметки 5,7 м. Паводковый уровень в городе Браунсвилл составляет 5,5 м, соответственно, произошло небольшое затопление. Вода преодолела заграждения и вышла из берегов, затопив часть сельскохозяйственных угодий, расположенных в низинах.|
|12 декабря в 17:00 по восточному поясному времени уровень воды в реке Роллинг-Форк-Ривер в городе Бостон поднялся до отметки 12 м. Паводковый уровень в городе Бостон составляет 10,7 м, соответственно, произошло небольшое затопление, покрывшее часть сельскохозяйственных угодий, расположенных в низинах.|
|16 декабря в 06:00 по восточному поясному времени уровень воды в реке Грин-Ривер в городе Вудбери поднялся до отметки 11,2 м. Паводковый уровень в городе Вудбери составляет 10,1 м, соответственно, на этом уровне произошло небольшое затопление, покрывшее часть пригородных территорий расположенных в низинах.|
|18 декабря в 07:00 по восточному поясному времени уровень воды в реке Огайо-Ривер в городе Телл-Сити поднялся до отметки 11,9 м. Паводковый уровень в городе Телл-Сити составляет 10,6 м, соответственно, на этом уровне река вышла из берегов. Трассу 66 в штате Индиана затопило между городами Рим и Дерби.|

```AIQL

StormEvents 
|  parse EventNarrative 
   with RiverName:string 
        "at" 
        Location:string 
        "crested at" 
        Height:double  
        "feet around" 
        Time:string 
        "on" 
        Month:string 
        " " 
        Day:long 
        "." 
        notImportant:string
| project RiverName , Location , Height , Time , Month , Day

```

|Название реки (RiverName)|Расположение|Высота|Время|Месяц|День|
|---|---|---|---|---|---|
|Грин-Ривер | Вудбери |11,2| 06:00 | Декабрь|16|
|Роллинг-Форк-Ривер | Бостон |12| 17:00 | Декабрь|12|
|Грин-Ривер | Браунсвилл |5,7| 09:30 | Декабрь|12|
|Огайо-Ривер | Телл-Сити |11,9| 07:00 | Декабрь|18|

Сопоставление также можно выполнять с использованием регулярных выражений. Результат будет тот же, но тип всех итоговых столбцов будет строковым.

```AIQL

StormEvents
| parse kind=regex EventNarrative 
  with RiverName:regex("(\\s?[a-zA-Z]+\\s?)+") 
  "at" Location:regex(".*") 
  "crested at " Height:regex("\\d+\\.\\d+") 
  " feet around" Time:regex(".*") 
  "on " Month:regex("(December|November|October)") 
   " " Day:regex("\\d+") 
   "." notImportant:regex(".*")
| project RiverName , Location , Height , Time , Month , Day
```


### Оператор project

    T | project cost=price*quantity, price

Выберите столбцы для включения, переименования или удаления, а затем вставьте новые вычисляемые столбцы. Порядок столбцов в результате определяется порядком аргументов. В результат будут включены только указанные в аргументах столбцы. Другие входные данные удаляются. (См. также `extend`.)


**Синтаксис**

    T | project ColumnName [= Expression] [, ...]

**Аргументы**

* *T* — входная таблица.
* *ColumnName* — имя столбца, которое будет отображено в выходных данных. Если аргумент *Expression* отсутствует, столбец с таким именем должен указываться во входных данных. 
* *Expression* — необязательное скалярное выражение, указывающее на входные столбцы. 

    Можно получить новый вычисляемый столбец с именем существующего столбца во входных данных.

**Результаты**

Таблица со столбцами, именованными как аргументы, а также количеством строк, соответствующим входной таблице.

**Пример**

В следующем примере показано несколько типов операций, которые можно выполнить с помощью оператора `project`. Входная таблица `T` содержит три столбца типа `int`: `A`, `B` и `C`.

```AIQL
T
| project
    X=C,                       // Rename column C to X
    A=2*B,                     // Calculate a new column A from the old B
    C=strcat("-",tostring(C)), // Calculate a new column C from the old C
    B=2*B                      // Calculate a new column B from the old B
```



### Оператор range

    range LastWeek from ago(7d) to now() step 1d

Создает таблицу значений с одним столбцом. Обратите внимание: входные данные конвейера отсутствуют.

|LastWeek|
|---|
|2015-12-05 09:10:04.627|
|2015-12-06 09:10:04.627|
|...|
|2015-12-12 09:10:04.627|



**Синтаксис**

    range ColumnName from Start to Stop step Step

**Аргументы**

* *ColumnName* — имя одного столбца в выходной таблице.
* *Start* — наименьшее значение в выходных данных.
* *Stop* — наибольшее значение, созданное в выходных данных (или ограничение на максимальное значение, если аргумент *step* пропускает это значение).
* *Step* — разница между двумя последовательными значениями. 

Аргументы должны иметь числовые значения, значения даты или временного диапазона. Они не могут ссылаться на столбцы таблицы. (Если вы хотите вычислить диапазон на основе входной таблицы, используйте [*функцию* range](#range), возможно, с [оператором mvexpand](#mvexpand-operator).)

**Результаты**

Таблица с одним столбцом с именем *ColumnName* и следующими значениями: *Start*, *Start* + *Step*, … и *Stop*.

**Пример**

```AIQL
range Steps from 1 to 8 step 3
```

Таблица с одним столбцом с именем `Steps`, типом `long` и значениями `1`, `4` и `7`.

**Пример**

    range LastWeek from bin(ago(7d),1d) to now() step 1d

Таблица со значениями в полночь за последние семь дней. Функция bin (floor) позволяет сократить время до начала каждого дня.

**Пример**

```AIQL
range timestamp from ago(4h) to now() step 1m
| join kind=fullouter
  (traces
      | where timestamp > ago(4h)
      | summarize Count=count() by bin(timestamp, 1m)
  ) on timestamp
| project Count=iff(isnull(Count), 0, Count), timestamp
| render timechart  
```

Пример того, как оператор `range` можно использовать для создания небольшой ad-hoc-таблицы измерений, с помощью которой затем заменяют отсутствующие в исходных данных значения на нули.

### Оператор reduce

    exceptions | reduce by outerMessage

Пытается сгруппировать похожие записи. Для каждой группы оператор выводит модель (`Pattern`) наилучшего ее описания, а также количество (`Count`) записей в этой группе.


![](./media/app-insights-analytics-queries/reduce.png)

**Синтаксис**

    T | reduce by  ColumnName [ with threshold=Threshold ]

**Аргументы**

* *ColumnName* — анализируемый столбец. Он должен быть строкового типа.
* *Threshold* — пороговое значение в диапазоне {0..1}. Значение по умолчанию — 0,001. Для объемных входных данных пороговое значение должно быть небольшим. 

**Результаты**

Два столбца: `Pattern` и `Count`. Во многих случаях модель будет представлена полным значением из столбца. В некоторых случаях оператор может определить общие термины, заменив части переменных символом *.

Например, результат `reduce by city` может быть таким:

|Модель | Count |
|---|---|
| Сан * | 5182 |
| Сант * | 2846 |
| Москва | 3726 |
| * -на- * | 2730 |
| Париж | 27 163 |


### Директива render

    T | render [ table | timechart  | barchart | piechart ]

Render указывает уровню представления данных способ отображения таблицы. Этот элемент должен быть последним в канале. Он является удобной альтернативой использованию элементов управления, позволяя сохранять запрос с помощью конкретного метода представления.


### Оператор sort 

    T | sort by country asc, price desc

Сортирует по порядку строки входной таблицы (по одному или нескольким столбцам).

**Псевдоним** `order`

**Синтаксис**

    T  | sort by Column [ asc | desc ] [ `,` ... ]

**Аргументы**

* *T* — входные данные таблицы для сортировки.
* *Column* — столбец значений аргумента *T*, по которому выполняется сортировка. Значения должны быть представлены числовыми или строковыми значениями, значениями времени или даты.
* `asc` — сортировка по возрастанию. `desc` — сортировка по убыванию. Используется по умолчанию.

**Пример**

```AIQL
Traces
| where ActivityId == "479671d99b7b"
| sort by Timestamp asc
```
Все строки в таблице Traces с определенным значением `ActivityId`, отсортированные по меткам времени.

### Оператор summarize

Создает таблицу, которая объединяет содержимое входной таблицы.
 
    requests
	| summarize count(), avg(duration), makeset(client_City) 
      by client_CountryOrRegion

В таблице отображено количество, средняя продолжительность запроса и группа городов каждой страны. Для каждой страны в выходных данных есть своя строка. В выходных столбцах отображено количество, средняя продолжительность, города и страна. Все остальные входные столбцы игнорируются.


    T | summarize count() by price_range=bin(price, 10.0)

В таблице отображено количество элементов с ценами в каждом интервале [0,10.0], [10.0,20.0] и т. д. Пример включает один столбец для подсчета и один столбец для диапазон цен. Все остальные входные столбцы игнорируются.


**Синтаксис**

    T | summarize
         [  [ Column = ] Aggregation [ `,` ... ] ]
         [ by
            [ Column = ] GroupExpression [ `,` ... ] ]

**Аргументы**

* *Column* — необязательное имя итогового столбца. По умолчанию это имя, получаемое из выражения. 
* *Aggregation* — вызов статистической функции, например `count()` или `avg()`, с именами столбцов в качестве аргументов. См. раздел об [агрегатах](#aggregations).
* *GroupExpression* — выражение для столбцов, предоставляющее набор уникальных значений. Обычно это имя столбца, которое уже предоставляет ограниченный набор значений, или функция `bin()` с числовым или временным столбцом в качестве аргумента. 

Если указать числовое или временное выражение без `bin()`, аналитика автоматически применит его с интервалом `1h` для временных значений и интервалом `1.0` для числовых.

Если выражение *GroupExpression* не указано, вся таблица будет суммирована в одну итоговую строку.



**Результаты**

Входные строки объединяются в группы с одинаковыми значениями выражений `by`. Затем указанные агрегатные функции выполняют вычисления и создают строку для каждой группы. Результат содержит столбцы `by`, а также хотя бы один столбец для каждого вычисленного статистического выражения. (Некоторые агрегатные функции возвращают несколько столбцов).

Результат включает количество строк, соответствующее разным комбинациям значений `by`. Чтобы суммировать диапазоны числовых значений, используйте `bin()`. Так вы ограничите диапазоны дискретными значениями.

**Примечание.**

Хотя произвольные выражения можно предоставить как для статистических выражений, так и для выражений группирования, эффективнее использовать простые имена столбцов или применить `bin()` к числовому столбцу.



### Оператор take

Псевдоним оператора [limit](#limit-operator)


### Оператор top

    T | top 5 by Name desc

Возвращает первые *N* записей, отсортированных по указанным столбцам.


**Синтаксис**

    T | top NumberOfRows by Sort_expression [ `asc` | `desc` ] [, ... ]

**Аргументы**

* *NumberOfRows* — количество строк *T*, которое будет возвращено.
* *Sort\_expression* — выражение, по которому выполняется сортировка строк. Обычно это просто имя столбца. Можно указать несколько аргументов sort\_expression.
* `asc` или `desc` (по умолчанию) может использоваться как указатель направления выделения элементов в диапазоне: снизу вверх или сверху вниз.


**Советы**

Выражения `top 5 by name` внешне эквивалентны `sort by name | take 5`. Тем не менее, первое работает быстрее и в отличие от `take` всегда возвращает отсортированные результаты.


### Оператор union

     Table1 | union Table2, Table3

Принимает несколько таблиц и возвращает строки из них.

**Синтаксис**

    T | union [ kind= inner | outer ] [ withsource = ColumnName ] Table2 [ , ...]  

    union [ kind= inner | outer ] [ withsource = ColumnName ] Table1, Table2 [ , ...]  

**Аргументы**

* *Table1*, *Table2*…
 *  Имя таблицы, например `events`.
 *  Выражение запроса, например `(events | where id==42)`.
 *  Набор таблиц, указанных с помощью подстановочного знака. Например, `E*` объединит в базе данных все таблицы, имена которых начинаются с `E`.
* `kind`: 
 * `inner` — результат содержит подмножество столбцов, которые являются общими для всех входных таблиц.
 * `outer` — результат содержит все столбцы, которые присутствуют в любых входных данных. Для ячеек, которые не были определены входной строкой, задается значение `null`.
* `withsource=`*ColumnName:* если аргумент указан, выходные данные будут содержать столбец с именем *ColumnName*, значение которого определяет для каждой строки передающую ее исходную таблицу.

**Результаты**

Таблица с количеством строк, соответствующим количеству строк во всех входных таблицах.

**Пример**

```AIQL

let ttrr = requests | where timestamp > ago(1h);
let ttee = exceptions | where timestamp > ago(1h);
union tt* | count
```
Объединение всех таблиц, имена которых начинаются с tt.


**Пример**

```AIQL

union withsource=SourceTable kind=outer Query, Command
| where Timestamp > ago(1d)
| summarize dcount(UserId)
```
Количество отдельных пользователей, которые за последний день создали событие `exceptions` или `traces`. В результате в столбце SourceTable будет указано одно из значений: Query или Command.

```AIQL
exceptions
| where Timestamp > ago(1d)
| union withsource=SourceTable kind=outer 
   (Command | where Timestamp > ago(1d))
| summarize dcount(UserId)
```

Это более эффективный способ получить тот же результат, так как перед объединением каждая таблица отфильтровывается.

### Оператор where

     T | where fruit=="apple"

Отфильтровывает таблицу для подмножества строк, которые удовлетворяют предикату.

**Псевдоним** `filter`

**Синтаксис**

    T | where Predicate

**Аргументы**

* *T* — табличные входные данные, записи которых будут отфильтрованы.
* *Predicate* — [выражение](#boolean) `boolean` для столбцов *T*. Вычисляется для каждой строки в *T*.

**Результаты**

Строки в *T*, для которых *Predicate* — это `true`.

**Советы**

Обеспечить максимальную производительность можно так.

* **Используйте простые сравнения** между именами столбцов и константами. (Так как речь идет о константах, содержащихся в таблице, можно использовать функции `now()` и `ago()`, а также скалярные значения, назначенные с помощью [предложения `let`](#let-clause).)

    Например, лучше использовать `where Timestamp >= ago(1d)`, чем `where floor(Timestamp, 1d) == ago(1d)`.

* **Вводите сначала более простые элементы**. Если у вас есть несколько предложений, объединенных с помощью `and`, сначала вводите предложения, которые включают только один столбец. Это значит, что порядок `Timestamp > ago(1d) and OpId == EventId` является предпочтительным.


**Пример**

```AIQL
Traces
| where Timestamp > ago(1h)
    and Source == "Kuskus"
    and ActivityId == SubActivityIt 
```

Записи не старше 1 часа из источника Kuskus, у которых есть по два столбца с одним значением.

Обратите внимание: сравнение двух столбцов вводится в последнюю очередь, так как эта операция не предполагает использование индекса и запуска проверки.



## Агрегаты и суммирующие операторы

### любой 

    any(Expression)

Случайным образом выбирает одну строку группы и возвращает значение указанного выражения.

Это полезно, например, когда в каком-то столбце есть большое количество подобных значений (например, в столбце "текст ошибки") и вы хотите сделать выборку из этого столбца по уникальному значению составного ключа группы.

**Пример**

```

traces 
| where timestamp > now(-15min)  
| summarize count(), any(message) by operation_Name 
| top 10 by count_level desc 
```

<a name="argmin"></a> <a name="argmax"></a>
### argmin, argmax

    argmin(ExprToMinimize, * | ExprToReturn  [ , ... ] )
    argmax(ExprToMaximize, * | ExprToReturn  [ , ... ] ) 

Находит строку в группе, которая уменьшает до минимума или увеличивает до максимума значение *ExprToMaximize* и возвращает значение *ExprToReturn* (или `*` для возврата всей строки).

**Примечание**. Переданные столбцы переименовываются автоматически. Чтобы убедиться, что вы используете правильные имена, проверьте результаты с помощью `take 5`, прежде чем передавать их другому оператору.

**Примеры**

Показать время возникновения самого продолжительного запроса для каждого имени запроса:

    requests | summarize argmax(duration, timestamp) by name

Показать все подробности выполнения самого длинного запроса, а не только метку времени:

    requests | summarize argmax(duration, *) by name


Найти наименьшее значение каждой метрики с ее меткой времени и другими данными:

    metrics 
    | summarize minValue=argmin(value, *) 
      by name


![](./media/app-insights-analytics-aggregations/argmin.png)
 


### avg

    avg(Expression)

Вычисляет среднее выражение *Expression* в группе.

### buildschema

    buildschema(DynamicExpression)

Возвращает минимальную схему, которая допускает все значения *DynamicExpression*.

В качестве параметра типа столбца нужно указать `dynamic` — массив или контейнер свойств.

**Пример**

    exceptions | summarize buildschema(details)

Результат:

    { "`indexer`":
     {"id":"string",
       "parsedStack":
       { "`indexer`": 
         {  "level":"int",
            "assembly":"string",
            "fileName":"string",
            "method":"string",
            "line":"int"
         }},
      "outerId":"string",
      "message":"string",
      "type":"string",
      "rawStack":"string"
    }}

Обратите внимание, что `indexer` используется для обозначения тех случаев, в которых необходимо применять числовой индекс. Некоторые допустимые пути для этой схемы будут следующими (предполагается, что эти индексы в этом примере находятся в диапазоне):

    details[0].parsedStack[2].level
    details[0].message
    arraylength(details)
    arraylength(details[0].parsedStack)

**Пример**

Предположим, что входной столбец имеет три динамических значения:

| |
|---|
|`{"x":1, "y":3.5}`
|`{"x":"somevalue", "z":[1, 2, 3]}`
|`{"y":{"w":"zzz"}, "t":["aa", "bb"], "z":["foo"]}`


Итоговая схема будет следующей:

    { 
      "x":["int", "string"], 
      "y":["double", {"w": "string"}], 
      "z":{"`indexer`": ["int", "string"]}, 
      "t":{"`indexer`": "string"} 
    }

Схема указывает следующее:

* Корневой объект представляет собой контейнер с четырьмя свойствами x, y, z и t.
* Свойство x, которое может быть типа int или string.
* Свойство y, которое может либо типа double, либо другой контейнер со свойством w типа string.
* Ключевое слово ``indexer`` указывает, что z и t являются массивами.
* Каждый элемент в массиве z имеет тип int или string.
* t представляет собой массив строк.
* Каждое свойство является необязательным, и любой массив может быть пустым.

##### Модель схемы

Синтаксис возвращаемой схемы следующий:

    Container ::= '{' Named-type* '}';
    Named-type ::= (name | '"`indexer`"') ':' Type;
	Type ::= Primitive-type | Union-type | Container;
    Union-type ::= '[' Type* ']';
    Primitive-type ::= "int" | "string" | ...;

Они эквивалентны подмножеству аннотаций типов TypeScript, закодированному как динамическое значение. В Typescript пример схемы будет следующим:

    var someobject: 
    { 
      x?: (number | string), 
      y?: (number | { w?: string}), 
      z?: { [n:number] : (int | string)},
      t?: { [n:number]: string } 
    }


### count

    count([ Predicate ])

Возвращает число строк, для которых предикат *Predicate* равен `true`. Если предикат *Predicate* не указан, возвращается общее число записей в группе.

**Совет по улучшению производительности**. Используйте `summarize count(filter)` вместо `where filter | summarize count()`.

> [AZURE.NOTE] Не используйте count() для поиска числа запросов, исключений или других произошедших событий. При обработке [выборки](app-insights-sampling.md) число точек данных будет меньше, чем количество фактических событий. Вместо этого используйте `summarize sum(itemCount)...`. Свойство itemCount отражает число исходных событий, представленных каждой сохраненной точкой данных.
   

### dcount

    dcount( Expression [ ,  Accuracy ])

Возвращает приблизительное количество различных значений выражений *Expr* в группе. (Чтобы получить список уникальных значений, используйте [`makeset`](#makeset).)

*Accuracy* (если указан) уравновешивает скорость и точность.

 * `0` — наименее точное и самое быстрое вычисление.
 * `1` — вычисление по умолчанию, при котором точность и время расчета уравновешены. Вероятность ошибки составляет около 0,8 %.
 * `2` — наиболее точное и самое медленное вычисление. Вероятность ошибки составляет около 0,4 %.

**Пример**

    pageViews 
    | summarize countries=dcount(client_City) 
      by client_CountryOrRegion

![](./media/app-insights-analytics-aggregations/dcount.png)

### makelist

    makelist(Expr [ ,  MaxListSize ] )

Возвращает массив `dynamic` (JSON) всех значений выражений *Expr* в группе.

* *MaxListSize* — необязательное целочисленное ограничение для максимального количества возвращаемых элементов (по умолчанию — *128*).

### makeset

    makeset(Expression [ , MaxSetSize ] )

Возвращает массив `dynamic` (JSON) набора различных значений, которые выражение *Expr* принимает в группе. (Совет. Для подсчета только уникальных значений используйте [`dcount`](#dcount).)
  
*  *MaxSetSize* — необязательное целочисленное ограничение для максимального количества возвращаемых элементов (по умолчанию — *128*).

**Пример**

    pageViews 
    | summarize countries=makeset(client_City) 
      by client_CountryOrRegion

![](./media/app-insights-analytics-aggregations/makeset.png)

Противоположную функцию см. в разделе об [операторе `mvexpand`](#mvexpand-operator).


### max, min

    max(Expr)

Вычисляет максимальное значение выражения *Expr*.
    
    min(Expr)

Вычисляет минимальное значение выражения *Expr*.

**Совет**. Эта функция выдает минимальный или максимальный результат — например, наибольшую или наименьшую цену. Но если нужно получить в строке и другие столбцы, например имя поставщика с наименьшей ценой, используйте [argmin или argmax](#argmin-argmax).


<a name="percentile"></a> <a name="percentiles"></a>
### percentile, percentiles

    percentile(Expression, Percentile)

Возвращает оценку выражения *Expression* из указанного процентиля в группе. Точность зависит от плотности заполнения области процентиля.
    
    percentiles(Expression, Percentile1 [ , Percentile2 ] )

Похожа на `percentile()`, но вычисляет количество значений процентилей (это быстрее, чем вычислять каждый процентиль по отдельности).

**Примеры**


Значение `duration`, которое превышает 95 % значений выборки и меньше 5 % значений выборки, вычисляется для каждого запроса имени.

    request 
    | summarize percentile(duration, 95)
      by name

Чтобы выполнить вычисления для всей таблицы, пропустите "by...".

Одновременно вычислите несколько процентилей для других имен запросов:

    
    requests 
    | summarize 
        percentiles(duration, 5, 20, 50, 80, 95) 
      by name

![](./media/app-insights-analytics-aggregations/percentiles.png)

Результаты показывают, что для запроса /Events/Index 5 % запросов были выполнены за 2,44 с, половина запросов — за 3,52 с, а 5 % — более чем за 6,85 с.


Вычисление множественной статистики:

    requests 
    | summarize 
        count(), 
        avg(Duration),
        percentiles(Duration, 5, 50, 95)
      by name

##### Ошибка оценки в процентилях

Статистическая оценка процентилей предоставляет приблизительное значение с помощью [T-Digest](https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf).

Некоторые важные моменты:

* Границы ошибки оценки изменяются со значением запрошенного процентиля. Наивысшая точность наблюдается на концах шкалы [0..100], процентили 0 и 100 — это точное минимальное и максимальное значения распределения. Точность постепенно снижается к середине шкалы. Она худшая на медиане и ограничена сверху 1 %. 
* Границы ошибки наблюдаются на диапазоне, а не на значении. Предположим, что функция percentile(X, 50) вернула значение Xm. Оценка гарантирует, что не менее 49 % и не более 51 % значений X меньше, чем Xm. Теоретического ограничения на разницу между Xm и X нет.

### stdev

     stdev(Expr)

Возвращает стандартное отклонение выражения *Expr* для группы.

### variance

    variance(Expr)

Возвращает вариацию выражения *Expr* для группы.

### sum

    sum(Expr)

Возвращает сумму выражения *Expr* для группы.


## Скалярные значения

[приведение типов](#casts) | [сравнения](#scalar-comparisons) <br/> [gettype](#gettype) | [hash](#hash) | [iff](#iff)| [isnull](#isnull) | [isnotnull](#isnotnull) | [notnull](#notnull)

Ниже приведены поддерживаемые типы.

| Тип | Дополнительные имена | Эквивалентный тип .NET |
| --------- | -------------------- | -------------------- |
| `bool` | `boolean` | `System.Boolean` |
| `datetime`| `date` | `System.DateTime` |
| `dynamic` | | `System.Object` |
| `guid` | `uuid`, `uniqueid` | `System.Guid` |
| `int` | | `System.Int32` |
| `long` | | `System.Int64` |
| `double` | `real` | `System.Double` |
| `string` | | `System.String` |
| `timespan`| `time` | `System.TimeSpan` |

### Приведение типов

Типы можно приводить друг к другу. Как правило, если преобразование имеет смысл, оно будет работать:

    todouble(10), todouble("10.6")
    toint(10.6) == 11
    floor(10.6) == 10
	toint("200")
    todatetime("2016-04-28 13:02")
    totimespan("1.5d"), totimespan("1.12:00:00")
    toguid("00000000-0000-0000-0000-000000000000")
    tostring(42.5)
    todynamic("{a:10, b:20}")

### Скалярные сравнения

||
---|---
`<` |Меньше
`<=`|Меньше или равно
`>` |Больше
`>=`|Больше или равно
`<>`|Не равно
`!=`|Не равно 
`in`| Правый операнд является массивом (динамическим), а левый операнд равен одному из его элементов.
`!in`| Правый операнд является массивом (динамическим), а левый операнд не равен ни одному из его элементов.




### gettype

**Возвращает**

Строка, представляющая базовый тип хранилища для единственного аргумента. Это особенно удобно для значений типа `dynamic`: в таком случае `gettype()` покажет, как закодировано значение.

**Примеры**

|||
---|---
`gettype("a")` |`"string" `
`gettype(111)` |`"long" `
`gettype(1==1)` |`"int8" (*) `
`gettype(now())` |`"datetime" `
`gettype(1s)` |`"timespan" `
`gettype(parsejson('1'))` |`"int" `
`gettype(parsejson(' "abc" '))` |`"string" `
`gettype(parsejson(' {"abc":1} '))` |`"dictionary"` 
`gettype(parsejson(' [1, 2, 3] '))` |`"array"` 
`gettype(123.45)` |`"real" `
`gettype(guid(12e8b78d-55b4-46ae-b068-26d7a0080254))` |`"guid"` 
`gettype(parsejson(''))` |`"null"`



### hash

**Синтаксис**

    hash(source [, mod])

**Аргументы**

* *source* — исходный скаляр, для которого вычисляется хэш.
* *mod* — значение модуля (остатка от деления), которое будет применено к итоговому хэшу.

**Возвращает**

Значение xxhash (тип long) для заданного скаляра, указанное значение модуля (если указано).

**Примеры**

```
hash("World")                   // 1846988464401551951
hash("World", 100)              // 51 (1846988464401551951 % 100)
hash(datetime("2015-01-01"))    // 1380966698541616202
```
### iff

Функция `iff()` вычисляет первый аргумент (предикат) и возвращает значение второго или третьего аргументов, в зависимости от того, является ли предикат `true` или `false`. Второй и третий аргументы должны быть одного типа.

**Синтаксис**

    iff(predicate, ifTrue, ifFalse)


**Аргументы**

* *predicate* — выражение, результатом которого является значение `boolean`.
* *ifTrue* — выражение, которое вычисляется и значение которого возвращается из функции, если *predicate* равен `true`.
* *ifFalse* — выражение, которое вычисляется и значение которого возвращается из функции, если *predicate* равен `false`.

**Возвращает**

Эта функция возвращает значение *ifTrue*, если *predicate* равен `true`. В противном случае возвращается значение *ifFalse*.

**Пример**

```
iff(floor(timestamp, 1d)==floor(now(), 1d), "today", "anotherday")
```

<a name="isnull"/></a> <a name="isnotnull"/></a> <a name="notnull"/></a>
### isnull, isnotnull, notnull

    isnull(parsejson("")) == true

Принимает один аргумент и сообщает, равен ли он null.

**Синтаксис**


    isnull([value])


    isnotnull([value])


    notnull([value])  // alias for isnotnull

**Возвращает**

Значение true или false в зависимости от того, равен ли аргумент null.


|x|isnull(x)
|---|---
| "" | нет
|"x" | нет
|parsejson("")|Да
|parsejson("")|нет
|parsejson("{}")|нет

**Пример**

    T | where isnotnull(PossiblyNull) | count

Обратите внимание, что того же эффекта можно добиться другими способами:

    T | summarize count(PossiblyNull)




## Логический 

### Логические литералы

	true == 1
    false == 0
    gettype(true) == "int8"
    typeof(bool) == typeof(int8)

### Логические операторы

	and 
    or 

    

## Числа

[bin](#bin) | [floor](#floor) | [rand](#rand) | [range](#range) | [sqrt](#sqrt) | [todouble](#todouble) | [toint](#toint) | [tolong](#tolong)

### Числовые литералы

|||
|---|---
|`42`|`long`
|`42.0`|`real`

### Арифметические операторы

|| |
|---|-------------|
| + | Добавить |
| – | Вычитание || * | Умножение | | / | Деление | | % | Остаток от деления | || |`<` | Меньше |`<=`|Меньше или равно |`>` |Больше |`>=`|Больше или равно |`<>`|Не равно |`!=`|Не равно




### bin

Округляет значения до целого, кратного указанному размеру группы. Часто используется в запросе [`summarize by`](#summarize-operator). При наличии разрозненного набора значений они будут сгруппированы в меньший набор определенных значений.

Псевдоним `floor`.

**Синтаксис**

     bin(value, roundTo)

**Аргументы**

* *value* — число, дата или интервал времени. 
* *roundTo* — "размер группы". Число, дата или интервал времени, на который делится *value*. 

**Возвращает**

Ближайшее число, кратное *roundTo* и меньшее *value*.
 
    (toint((value/roundTo)-0.5)) * roundTo

**Примеры**

Выражение | Результат
---|---
`bin(4.5, 1)` | `4.0`
`bin(time(16d), 7d)` | `14d`
`bin(datetime(1953-04-15 22:25:07), 1d)`| `datetime(1953-04-15)`


Следующее выражение вычисляет гистограмму длительности с размером сегмента в 1 секунду:

```AIQL

    T | summarize Hits=count() by bin(Duration, 1s)
```

### floor

Псевдоним для [`bin()`](#bin).


### rand

Генератор случайных чисел.

* `rand()` — вещественное число от 0,0 до 1,0.
* `rand(n)` — целое число от 0 до n-1.




### sqrt

Функция квадратного корня.

**Синтаксис**

    sqrt(x)

**Аргументы**

* *x* — вещественное число >= 0.

**Возвращает**

* Положительное число, например `sqrt(x) * sqrt(x) == x`
* `null`, если аргумент является отрицательным числом или не может быть преобразован в значение `real`. 




### toint

    toint(100)        // cast from long
    toint(20.7) == 21 // nearest int from double
    toint(20.4) == 20 // nearest int from double
    toint("  123  ")  // parse string
    toint(a[0])       // cast from dynamic
    toint(b.c)        // cast from dynamic

### tolong

    tolong(20.7) == 21 // conversion from double
    tolong(20.4) == 20 // conversion from double
    tolong("  123  ")  // parse string
    tolong(a[0])       // cast from dynamic
    tolong(b.c)        // cast from dynamic


### todouble

    todouble(20) == 20.0 // conversion from long or int
    todouble(" 12.34 ")  // parse string
    todouble(a[0])       // cast from dynamic
    todouble(b.c)        // cast from dynamic



## Дата и время


[ago](#ago) | [dayofweek](#dayofweek) | [getmonth](#getmonth)| [getyear](#getyear) | [now](#now) | [startofmonth](#startofmonth) | [startofyear](#startofyear) | [todatetime](#todatetime) | [totimespan](#totimespan)

### Литералы даты и времени

|||
---|---
**datetime**|
`datetime("2015-12-31 23:59:59.9")`<br/>`datetime("2015-12-31")`|Время всегда выражается в формате UTC. Если дата не указана, то имеется в виду время для сегодняшнего дня.
`now()`|Текущее время.
`now(`-*timespan*`)`|`now()-`*timespan*
`ago(`*timespan*`)`|`now()-`*timespan*
**интервал времени**|
`2d`|2 дня
`1.5h`|1,5 часа 
`30m`|30 минут
`10s`|10 с
`0.1s`|0,1 с
`100ms`| 100 мс
`10microsecond`|
`1tick`|100 нс
`time("15 seconds")`|
`time("2")`| 2 дня
`time("0.12:34:56.7")`|`0d+12h+34m+56.7s`

### Выражения для даты и времени

Выражение |Результат
---|---
`datetime("2015-01-02") - datetime("2015-01-01")`| `1d`
`datetime("2015-01-01") + 1d`| `datetime("2015-01-02")`
`datetime("2015-01-01") - 1d`| `datetime("2014-12-31")`
`2h * 24` | `2d`
`2d` / `2h` | `24`
`datetime("2015-04-15T22:33") % 1d` | `timespan("22:33")`
`bin(datetime("2015-04-15T22:33"), 1d)` | `datetime("2015-04-15T00:00")`
||
`<` |Меньше
`<=`|Меньше или равно
`>` |Больше
`>=`|Больше или равно
`<>`|Не равно
`!=`|Не равно 




### ago

Вычитает заданный интервал времени из текущего времени UTC. Как и `now()`, эту функцию можно использовать в выражении несколько раз, и значение времени UTC будет одинаковым для всех случаев.

**Синтаксис**

    ago(a_timespan)

**Аргументы**

* *a\_timespan* — интервал для вычитания из текущего времени UTC (`now()`).

**Возвращает**

    now() - a_timespan

**Пример**

Все строки за последний час:

```AIQL

    T | where timestamp > ago(1h)
```



### dayofweek

    dayofweek(datetime("2015-12-14")) == 1d  // Monday

Целое число дней с предыдущего воскресенья, представленное в формате `timespan`.

**Синтаксис**

    dayofweek(a_date)

**Аргументы**

* `a_date` — `datetime`.

**Возвращает**

Значение `timespan` с полуночи в начале предыдущего воскресенья, округленное до целого числа дней.

**Примеры**

```AIQL
dayofweek(1947-11-29 10:00:05)  // time(6.00:00:00), indicating Saturday
dayofweek(1970-05-11)           // time(1.00:00:00), indicating Monday
```

### getmonth

Возвращает номер месяца (1-12) для аргумента типа datetime.

**Пример**

    ... | extend month = getmonth(datetime(2015-10-12))

    --> month == 10

### getyear

Возвращает год для аргумента типа datetime.

**Пример**

    ... | extend year = getyear(datetime(2015-10-12))

    --> year == 2015

### now

    now()
    now(-2d)

Текущее время UTC, при необходимости с учетом указанного смещения. Эта функция может использоваться в выражении несколько раз, и значение времени будет одинаковым для всех случаев.

**Синтаксис**

    now([offset])

**Аргументы**

* *offset* — смещение `timespan`, добавляемое к текущему времени UTC. По умолчанию: 0.

**Возвращает**

Текущее время UTC в формате `datetime`.

    now() + offset

**Пример**

Определяет интервал с момента события, определенного предикатом.

```AIQL
T | where ... | extend Elapsed=now() - timestamp
```

### startofmonth

    startofmonth(date)

Начало месяца, содержащего дату.

### startofyear

    startofyear(date)

Начало года, содержащего дату.


### todatetime

Псевдоним `datetime()`.

     todatetime("2016-03-28")
     todatetime("03/28/2016")
     todatetime("2016-03-28 14:34")
     todatetime("03/28/2016 2:34pm")
     todatetime("2016-03-28T14:34.5Z")
     todatetime(a[0])  // cast a dynamic type
     todatetime(b.c)   // cast a dynamic type

### totimespan

Псевдоним `timespan()`.

    totimespan("21d")
    totimespan("21h")
    totimespan(request.duration)


## Строка

[countof](#countof) | [extract](#extract) | [extractjson](#extractjson) | [isempty](#isempty) | [isnotempty](#isnotempty) | [notempty](#notempty) | [replace](#replace) | [split](#split) | [strcat](#strcat) | [strlen](#strlen) | [substring](#substring) | [tolower](#tolower) | [tostring](#tostring) | [toupper](#toupper)


### Строковые литералы

Используются такие же правила, как в JavaScript.

Строки могут быть заключены в одинарные или двойные кавычки.

Обратная косая черта (``) используется для экранирования символов, таких как `\t` (табуляция), `\n` (новая строка) и кавычек.

* `'this is a "string" literal in single \' quotes'`
* `"this is a 'string' literal in double " quotes"`
* `@"C:\backslash\not\escaped\with @ prefix"`

### Скрываемые строковые литералы

Скрываемые строковые литералы — это строки, которые аналитика скрывает при выводе строки (например, при трассировке). Для этого все скрываемые символы заменяются начальным символом (`*`).

Для образования скрываемого строкового литерала укажите символ `h` или "H". Например:

```
h'hello'
h@'world' 
h"hello"
```

### Сравнение строк

Оператор|Описание|С учетом регистра|Пример
---|---|---|---
`==`|Равно |Да| `"aBc" == "aBc"`
`<>`|Не равно|Да| `"abc" <> "ABC"`
`=~`|Равно |Нет| `"abc" =~ "ABC"`
`!~`|Не равно |Нет| `"aBc" !~ "xyz"`
`has`|Правая часть представляет собой все слово в левой части|Нет| `"North America" has "america"`
`!has`|Правая часть не является всем словом в левой части|Нет|`"North America" !has "amer"` 
`contains` | Правая часть является вхождением в левую часть|Нет| `"FabriKam" contains "BRik"`
`!contains`| Правая часть не входит в левую часть|Нет| `"Fabrikam" !contains "xyz"`
`containscs` | Правая часть является вхождением в левую часть|Да| `"FabriKam" contains "Kam"`
`!containscs`| Правая часть не входит в левую часть|Да| `"Fabrikam" !contains "Kam"`
`startswith`|Правая часть является начальным вхождением в левую часть|Нет|`"Fabrikam" startswith "fab"`
`matches regex`|Левая часть содержит соответствие для правой части|Да| `"Fabrikam" matches regex "b.*k"`


При проверке на наличие полного лексического слова (т. е. символа или буквенно-цифрового слова, окруженного не буквенно-цифровыми символами, не началом и не концом поля) используйте `has` или `in`. `has` выполняется быстрее, чем `contains` или `startswith`. Первый из этих запросов выполняется быстрее:

    EventLog | where continent has "North" | count;
	EventLog | where continent contains "nor" | count





### countof

    countof("The cat sat on the mat", "at") == 3
    countof("The cat sat on the mat", @"\b.at\b", "regex") == 3

Подсчитывает вхождения подстроки в строку. Совпадения для обычных строк могут перекрывать друг друга, для регулярных выражений — не могут.

**Синтаксис**

    countof(text, search [, kind])

**Аргументы**

* *text* — строка.
* *search* — строка обычного текста или [регулярное выражение](app-analytics-reference.md#regular-expressions), которое проверяется на вхождение в *text*.
* *kind* — `"normal"|"regex"` по умолчанию `normal`. 

**Возвращает**

Количество совпадений для строки поиска в контейнере. Совпадения для обычных строк могут перекрывать друг друга, для регулярных выражений — не могут.

**Примеры**

|||
|---|---
|`countof("aaa", "a")`| 3 
|`countof("aaaa", "aa")`| 3 (не 2!)
|`countof("ababa", "ab", "normal")`| 2
|`countof("ababa", "aba")`| 2
|`countof("ababa", "aba", "regex")`| 1
|`countof("abcabc", "a.c", "regex")`| 2
    



### extract

    extract("x=([0-9.]+)", 1, "hello x=45.6|wo") == "45.6"

Определяет совпадение для [регулярного выражения](#regular-expressions) из текстовой строки. При необходимости извлеченная подстрока преобразуется к указанному типу.

**Синтаксис**

    extract(regex, captureGroup, text [, typeLiteral])

**Аргументы**

* *regex* — [регулярное выражение](#regular-expressions).
* *captureGroup* — положительная константа `int`, указывающая группу захвата для извлечения. 0 означает полное совпадение, 1 — значение, соответствующее первой '('круглой скобке')' в регулярном выражении, 2 или более — последующим круглым скобкам.
* *text* — `string` для поиска.
* *typeLiteral* — необязательный литерал типа (например, `typeof(long)`). Если указан, то извлеченная подстрока преобразуется в этот тип. 

**Возвращает**

Если *regex* находит совпадение в *text*, то возвращается подстрока, которая сравнивалась с указанной группой захвата *captureGroup*, при необходимости преобразованная в тип *typeLiteral*.

Если совпадения нет или не удается выполнить преобразование типа, возвращается `null`.

**Примеры**

В примере строки `Trace` производится поиск определения `Duration`. Совпадение преобразуется в `real`, а затем умножается на константу времени (`1s`), так чтобы `Duration` получил тип `timespan`. В этом примере он равен 123,45 секунды:

```AIQL
...
| extend Trace="A=1, B=2, Duration=123.45, ..."
| extend Duration = extract("Duration=([0-9.]+)", 1, Trace, typeof(real)) * time(1s) 
```

Этот пример аналогичен `substring(Text, 2, 4)`:

```AIQL
extract("^.{2,2}(.{4,4})", 1, Text)
```

<a name="notempty"></a> <a name="isnotempty"></a> <a name="isempty"></a>
### isempty, isnotempty, notempty

    isempty("") == true

True, если аргумент является пустой строкой или имеет значение null. См. также [isnull](#isnull).


**Синтаксис**

    isempty([value])


    isnotempty([value])


    notempty([value]) // alias of isnotempty

**Возвращает**

Указывает, является ли аргумент пустой строкой или имеет значение null.

|x|isempty(x)
|---|---
| "" | Да
|"x" | нет
|parsejson("")|Да
|parsejson("")|нет
|parsejson("{}")|нет


**Пример**


    T | where isempty(fieldName) | count




### replace

Заменяет все найденные совпадения регулярного выражения другой строкой.

**Синтаксис**

    replace(regex, rewrite, text)

**Аргументы**

* *regex* — [регулярное выражение](https://github.com/google/re2/wiki/Syntax) для поиска в *text*. Оно может содержать группы захвата в '('круглых скобках')'. 
* *rewrite* — замена регулярного выражения для любого сравнения, производимого с *matchingRegex*. Используйте `\0` для указания полного совпадения, `\1` для первой группы захвата, `\2` и более — для следующих групп захвата.
* *text* — строка.

**Возвращает**

*text* после замены всех вхождений *regex* с вычислениями *rewrite*. Совпадения не перекрываются.

**Пример**

Выражение:

```AIQL
range x from 1 to 5 step 1
| extend str=strcat('Number is ', tostring(x))
| extend replaced=replace(@'is (\d+)', @'was: \1', str)
```

Получены следующие результаты:

| x | str | заменена|
|---|---|---|
| 1 | Число равно: 1,000000 | Число было равно: 1,000000|
| 2 | Число равно: 2,000000 | Число было равно: 2,000000|
| 3 | Число равно: 3,000000 | Число было равно: 3,000000|
| 4\. | Число равно: 4,000000 | Число было равно: 4,000000|
| 5 | Число равно: 5,000000 | Число было равно: 5,000000|
 



### split

    split("aaa_bbb_ccc", "_") == ["aaa","bbb","ccc"]

Разбивает указанную строку в соответствии с заданным разделителем и возвращает массив строк, содержащий подстроки. При необходимости может быть возвращена конкретная подстрока, если она существует.

**Синтаксис**

    split(source, delimiter [, requestedIndex])

**Аргументы**

* *source* — исходная строка, которая будет разделена в соответствии с указанным разделителем.
* *delimiter* — разделитель, который будет использоваться для разделения исходной строки.
* *requestedIndex* — необязательный отсчитываемый от нуля индекс `int`. Если указан, возвращаемый массив строк будет содержать запрошенную подстроку, если она существует. 

**Возвращает**

Массив строк, содержащий подстроки заданной исходной строки, разделенные указанным разделителем.

**Примеры**

```
split("aa_bb", "_")           // ["aa","bb"]
split("aaa_bbb_ccc", "_", 1)  // ["bbb"]
split("", "_")                // [""]
split("a__b")                 // ["a","","b"]
split("aabbcc", "bb")         // ["aa","cc"]
```




### strcat

    strcat("hello", " ", "world")

Объединяет от 1 до 16 строк, переданных в качестве аргументов.

### strlen

    strlen("hello") == 5

Длина строки.

### substring

    substring("abcdefg", 1, 2) == "bc"

Извлекает подстроку из заданной исходной строки, начиная с указанного индекса. При необходимости можно указать длину запрашиваемой подстроки.

**Синтаксис**

    substring(source, startingIndex [, length])

**Аргументы**

* *source* — исходная строка, из которой будет извлечена подстрока.
* *startingIndex* — отсчитываемая от нуля позиция первого символа запрашиваемой подстроки.
* *length* — необязательный параметр, который может использоваться для указания требуемого количества символов в подстроке. 

**Возвращает**

Подстрока для указанной строки. Подстрока начинается с позиции startingIndex (отсчитывается начиная с нуля) и продолжается до конца строки или до требуемого количества символов, если оно указано.

**Примеры**

```
substring("123456", 1)        // 23456
substring("123456", 2, 2)     // 34
substring("ABCD", 0, 2)       // AB
```

### tolower

    tolower("HELLO") == "hello"

Преобразует строку в нижний регистр.

### toupper

    toupper("hello") == "HELLO"

Преобразует строку в верхний регистр.



## Идентификаторы GUID

    guid(00000000-1111-2222-3333-055567f333de)


## Массивы, объекты и динамические типы

[литералы](#dynamic-literals) | [приведение типов](#casting-dynamic-objects) | [операторы](#operators) | [предложения let](#dynamic-objects-in-let-clauses) <br/> [arraylength](#arraylength) | [extractjson](#extractjson) | [parsejson](#parsejson) | [range](#range) | [treepath](#treepath) | [todynamic](#todynamic)


Ниже приведен результат запроса на исключение Application Insights. Значение `details` является массивом.

![](./media/app-analytics-scalars/310.png)

**Индексирование**. Индексируйте массивы и объекты, так же как JavaScript:

    exceptions | take 1
    | extend 
        line = details[0].parsedStack[0].line,
        stackdepth = arraylength(details[0].parsedStack)

* Но используйте `arraylength` и другие функции аналитики (не ".length"!).

**Приведение типов**. Иногда необходимо привести тип элемента, который можно извлечь из объекта, так как его тип может варьироваться. Например, `summarize...to` необходим конкретный тип:

    exceptions 
    | summarize count() 
      by toint(details[0].parsedStack[0].line)

    exceptions 
    | summarize count() 
      by tostring(details[0].parsedStack[0].assembly)

**Литералы** используются для создания явного массива или объекта контейнера свойств, его записи в виде строки JSON и приведения типов:

    todynamic('[{"x":"1", "y":"32"}, {"x":"6", "y":"44"}]')


**mvexpand**. Чтобы извлечь свойства объекта в отдельные строки, воспользуйтесь mvexpand:

    exceptions | take 1 
    | mvexpand details[0].parsedStack[0]


![](./media/app-analytics-scalars/410.png)


**treepath** используется для поиска всех путей в сложном объекте:

    exceptions | take 1 | project timestamp, details 
    | extend path = treepath(details) 
    | mvexpand path


![](./media/app-analytics-scalars/420.png)

**buildschema** используется для поиска минимальной схемы, которая учитывает все значения выражения в таблице:

    exceptions | summarize buildschema(details)

Результат:

    { "`indexer`":
     {"id":"string",
       "parsedStack":
       { "`indexer`": 
         {  "level":"int",
            "assembly":"string",
            "fileName":"string",
            "method":"string",
            "line":"int"
         }},
      "outerId":"string",
      "message":"string",
      "type":"string",
      "rawStack":"string"
    }}

Обратите внимание, что `indexer` используется для обозначения тех случаев, в которых необходимо применять числовой индекс. Некоторые допустимые пути для этой схемы будут следующими (предполагается, что эти индексы в этом примере находятся в диапазоне):

    details[0].parsedStack[2].level
    details[0].message
    arraylength(details)
    arraylength(details[0].parsedStack)



### Литералы массива и объекта

Чтобы создать динамический литерал, используйте `parsejson` (псевдоним `todynamic`) со строкой JSON в качестве аргумента:

* `parsejson('[43, 21, 65]')` — массив чисел.
* `parsejson('{"name":"Alan", "age":21, "address":{"street":432,"postcode":"JLK32P"}}')` 
* `parsejson('21')` — одно значение динамического типа, содержащее число.
* `parsejson('"21"')` — одно значение динамического типа, содержащее строку.

Обратите внимание, что в отличие от JavaScript, в JSON необходимо заключать строки в двойные кавычки (`"`). Поэтому обычно проще заключать закодированные JSON литералы в одинарные кавычки (`'`).

В этом примере создается динамическое значение, а затем используются его поля:

```

T
| extend person = parsejson('{"name":"Alan", "age":21, "address":{"street":432,"postcode":"JLK32P"}}')
| extend n = person.name, add = person.address.street
```


### Операторы и функции для динамических типов

|||
|---|---|
| *value* `in` *array*| Возвращает значение true, если в массиве *array* есть элемент, который равен значению *value*<br/>`where City in ('London', 'Paris', 'Rome')`
| *value* `!in` *array*| Возвращает значение true, если в массиве *array* нет ни одного элемента, который равен значению *value*
|[`arraylength(`array`)`](#arraylength)| Возвращает NULL, если это не массив
|[`extractjson(`path,object`)`](#extractjson)|Использует путь path для перехода к объекту object.
|[`parsejson(`source`)`](#parsejson)| Преобразует строку формата JSON в динамический объект.
|[`range(`from,to,step`)`](#range)| Массив значений
|[`mvexpand` listColumn](app-analytics-queries.md#mvexpand-operator) | Реплицирует строку для каждого значения в списке в указанной ячейке.
|[`summarize buildschema(`column`)`](app-analytics-queries.md#summarize-operator) |Определяет схему типа по содержимому столбца.
|[`summarize makelist(`column`)` ](app-analytics-queries.md#summarize-operator)| Выполняет сведение групп строк и помещает значения столбца в массив.
|[`summarize makeset(`column`)`](app-analytics-queries.md#summarize-operator) | Выполняет сведение групп строк и помещает значения столбца в массив без дублирования значений.

### Динамические объекты в предложениях let


В [предложениях let](app-analytics-queries.md#let-clause) динамические значения хранятся в виде строк, поэтому оба предложения эквивалентны и требуют `parsejson` (или `todynamic`) перед использованием:

    let list1 = '{"a" : "somevalue"}';
    let list2 = parsejson('{"a" : "somevalue"}');

    T | project parsejson(list1).a, parsejson(list2).a




### arraylength

Количество элементов в динамическом массиве.

**Синтаксис**

    arraylength(array)

**Аргументы**

* *array* — значение `dynamic`.

**Возвращает**

Число элементов в *array* или `null`, если *array* не является массивом.

**Примеры**

```
arraylength(parsejson('[1, 2, 3, "four"]')) == 4
arraylength(parsejson('[8]')) == 1
arraylength(parsejson('[{}]')) == 1
arraylength(parsejson('[]')) == 0
arraylength(parsejson('{}')) == null
arraylength(parsejson('21')) == null
```



### extractjson

    extractjson("$.hosts[1].AvailableMB", EventText, typeof(int))

Возвращает указанный элемент текста JSON с помощью выражения пути. При необходимости преобразует извлеченную строку к указанному типу.


**Синтаксис**

```

    string extractjson(jsonPath, dataSource)​​ 
    resulttype extractjson(jsonPath, dataSource, typeof(resulttype))​​
```


**Возвращает**

Эта функция выполняет запрос JsonPath к источнику данных dataSource, который содержит допустимую строку JSON. При необходимости это значение преобразуется в другой тип, в зависимости от третьего аргумента.



**Пример**

Обозначения с [квадратными скобками] и точками эквивалентны:

    ... | extend AvailableMB = extractjson("$.hosts[1].AvailableMB", EventText, typeof(int)) | ...

    ... | extend AvailableMD = extractjson("$['hosts'][1]['AvailableMB']", EventText, typeof(int)) | ...



**Советы по улучшению производительности**

* Применяйте предложение where перед использованием `extractjson()`.
* По возможности заменяйте его на сопоставление с регулярным выражением с [extract](#extract). Он выполняется гораздо быстрее и эффективнее, если JSON создается из шаблона.
* Используйте `parsejson()`, если необходимо извлечь из JSON несколько значений.
* При возможности проведите анализ JSON при обработке, объявив динамический тип столбца.

### Выражения пути JSON

|||
|---|---|
|`$`|Корневой объект|
|`@`|Текущий объект|
|`[0]`|Индекс массива|
|`.` или `[0]` | Дочерний|

*(В настоящее время подстановочные знаки, рекурсии, объединения и срезы не реализованы.)*




### parsejson

Интерпретирует `string` как [значение JSON](http://json.org/) и возвращает значение как `dynamic`. Этот метод предпочтительнее, чем `extractjson()`, если необходимо извлечь более одного элемента из составного объекта JSON.

**Синтаксис**

    parsejson(json)

**Аргументы**

* *json* — документ JSON.

**Возвращает**

Объект типа `dynamic`, определенный *json*.

**Пример**

В следующем примере, когда `context_custom_metrics` представляет собой `string`, который выглядит таким образом:

```
{"duration":{"value":118.0,"count":5.0,"min":100.0,"max":150.0,"stdDev":0.0,"sampledValue":118.0,"sum":118.0}}
```

Затем следующий фрагмент получает значение слота `duration` в объекте и из него получает два слота `duration.value` и `duration.min` (`118.0` и `110.0` соответственно).

```AIQL
T
| ...
| extend d=parsejson(context_custom_metrics) 
| extend duration_value=d.duration.value, duration_min=d["duration"]["min"]
```



#### range

Функция `range()` (не следует путать с оператором `range`) создает динамический массив, содержащий последовательность равномерно распределенных значений.

**Синтаксис**

    range(start, stop, step)

**Аргументы**

* *start* — значение первого элемента итогового массива. 
* *stop* — значение последнего элемента итогового массива или наименьшее значение, которое больше, чем последний элемент итогового массива, и находится в целом количестве шагов *step* от первого элемента *start*.
* *step* — различие между двумя последовательными элементами массива.

**Примеры**

В следующем примере возвращается `[1, 4, 7]`:

```AIQL
range(1, 8, 3)
```

Следующий пример возвращает массив, содержащий все дни 2015 года:

```AIQL

    range(datetime(2015-01-01), datetime(2015-12-31), 1d)
```

### todynamic

    todynamic('{"a":"a1", "b":["b1", "b2"]}')

Преобразует строку в динамическое значение.

### treepath

    treepath(dynamic_object)

Перечисляет все выражения пути, которые определяют листья в динамическом объекте.

**Возвращает**

Массив выражений пути.

**Примеры**

    treepath(parsejson('{"a":"b", "c":123}')) 
    =>       ["['a']","['c']"]
    treepath(parsejson('{"prop1":[1,2,3,4], "prop2":"value2"}'))
    =>       ["['prop1']","['prop1'][0]","['prop2']"]
    treepath(parsejson('{"listProperty":[100,200,300,"abcde",{"x":"y"}]}'))
    =>       ["['listProperty']","['listProperty'][0]","['listProperty'][0]['x']"]

Обратите внимание, что "[0]" определяет наличие массива, но не обозначает индекс, используемый указанным расположением.



[AZURE.INCLUDE [app-insights-analytics-footer](../../includes/app-insights-analytics-footer.md)]

<!---HONumber=AcomDC_0330_2016-->