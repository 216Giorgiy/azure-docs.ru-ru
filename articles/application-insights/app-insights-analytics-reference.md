<properties 
	pageTitle="Справочные материалы по аналитике в Application Insights" 
	description="Справочные материалы по регулярным выражениям в аналитике — мощном инструменте поиска Application Insights." 
	services="application-insights" 
    documentationCenter=""
	authors="alancameronwills" 
	manager="douge"/>

<tags 
	ms.service="application-insights" 
	ms.workload="tbd" 
	ms.tgt_pltfrm="ibiza" 
	ms.devlang="na" 
	ms.topic="article" 
	ms.date="04/18/2016" 
	ms.author="awills"/>

# Справочные материалы по аналитике

[Аналитика](app-insights-analytics.md) — это мощный инструмент поиска [Application Insights](app-insights-overview.md). На этих страницах описан язык запросов аналитики приложений.


[AZURE.INCLUDE [app-insights-analytics-top-index](../../includes/app-insights-analytics-top-index.md)]


| | | | | 
|---|---|---|---|---
|[ago](#ago)|[dayofweek](#dayofweek)|[Предложение let](#let-clause)|[rand](#rand)|[sum](#sum)
|[любой](#any)|[dcount](#dcount)|[Оператор limit](#limit-operator)|[range](#range)|[Оператор summarize](#summarize-operator)
|[argmax](#argmax)|[Динамические объекты в предложениях let](#dynamic-objects-in-let-clauses)|[log](#log)|[Оператор range](#range-operator)|[Оператор take](#take-operator)
|[argmin](#argmin)|[exp](#exp)|[makelist](#makelist)|[Оператор reduce](#reduce-operator)|[todatetime](#todatetime)
|[Арифметические операторы](#arithmetic-operators)|[Оператор extend](#extend-operator)|[makeset](#makeset)|[Директива render](#render-directive)|[todouble](#todouble)
|[Литералы массива и объекта](#array-and-object-literals)|[extract](#extract)|[max](#max)|[replace](#replace)|[todynamic](#todynamic)
|[arraylength](#arraylength)|[extractjson](#extractjson)|[min](#min)|[Предложение restrict](#restrict-clause)|[toint](#toint)
|[avg](#avg)|[floor](#floor)|[Оператор mvexpand](#mvexpand-operator)|[Скалярные сравнения](#scalar-comparisons)|[tolong](#tolong)
|[bin](#bin)|[getmonth](#getmonth)|[notempty](#notempty)|[Оператор sort](#sort-operator)|[tolower](#tolower)
|[Логические литералы](#boolean-literals)|[gettype](#gettype)|[notnull](#notnull)|[split](#split)|[Оператор top](#top-operator)
|[Логические операторы](#boolean-operators)|[getyear](#getyear)|[now](#now)|[sqrt](#sqrt)|[totimespan](#totimespan)
|[buildschema](#buildschema)|[hash](#hash)|[Числовые литералы](#numeric-literals)|[startofmonth](#startofmonth)|[toupper](#toupper)
|[Приведение типов](#casts)|[iff](#iff)|[Скрываемые строковые литералы](#obfuscated-string-literals)|[startofyear](#startofyear)|[treepath](#treepath)
|[count](#count)|[isempty](#isempty)|[Оператор parse](#parse-operator)|[stdev](#stdev)|[Оператор union](#union-operator)
|[Оператор count](#count-operator)|[isnotempty](#isnotempty)|[parsejson](#parsejson)|[strcat](#strcat)|[variance](#variance)
|[countif](#countif)|[isnotnull](#isnotnull)|[percentile](#percentile)|[Сравнение строк](#string-comparisons)|[Оператор where](#where-operator)
|[countof](#countof)|[isnull](#isnull)|[percentiles](#percentiles)|[Строковые литералы](#string-literals)
|[Выражения для даты и времени](#date-and-time-expressions)|[Оператор join](#join-operator)|[Оператор project](#project-operator)|[strlen](#strlen)
|[Литералы даты и времени](#date-and-time-literals)|[Выражения пути JSON](#json-path-expressions)|[Оператор project-away](#project-away-operator)|[substring](#substring)


## Запросы и операторы

Запрос на данные телеметрии выполняется с помощью ссылки на исходный поток, за которой следует конвейер фильтров. Например:


```AIQL
requests // The request table starts this pipeline.
| where client_City == "London" // filter the records
   and timestamp > ago(3d)
| count 
```
    
Каждый фильтр, перед которым стоит символ конвейера `|`, — это экземпляр класса *operator* с определенными параметрами. Входные данные для оператора представлены таблицей, которая является результатом предыдущего конвейера. В большинстве случаев все параметры — это [скалярные выражения](##scalars) для столбцов входных данных. В некоторых случаях параметры являются именами входных столбцов, но иногда параметр может быть второй таблицей. Результат запроса всегда является таблицей — даже если она включает только один столбец и одну строку.

Запросы могут содержать одиночные разрывы строк, но завершаются пустой строкой. Они могут содержать комментарии между `//` и окончанием строки.

Перед запросом можно указать одно или несколько [предложений let](#let-clause), чтобы определить скалярные значения, таблицы или функции, которые могут использоваться в запросе.

```AIQL

    let interval = 3d ;
    let city = "London" ;
    let req = (city:string) {
      requests
      | where client_City == city and timestamp > ago(interval) };
    req(city) | count
```

> В приведенных ниже примерах запросов символ `T` обозначает предыдущий конвейер или исходную таблицу.
> 

### Оператор count

Оператор `count` возвращает количество записей (строк) во входном наборе записей.

**Синтаксис**

    T | count

**Аргументы**

* *T* — табличные данные, записи которых будут посчитаны.

**Результаты**

Эта функция возвращает таблицу с одной записью и столбцом типа `long`. Значение единственной ячейки — количество записей в *T*.

**Пример**

```AIQL
requests | count
```



### Оператор extend

     T | extend duration = stopTime - startTime

Добавляет в таблицу один или несколько вычисляемых столбцов.


**Синтаксис**

    T | extend ColumnName = Expression [, ...]

**Аргументы**

* *T* — входная таблица.
* *ColumnName* — имена столбцов, которые будут добавлены. [Имена](#names) зависят от регистра и могут содержать буквы и цифры, а также символы нижнего подчеркивания (\_). Используйте `['...']` или `["..."]`, чтобы заключать в кавычки ключевые слова или имена с другими символами.
* *Expression* — операции над значениями существующих столбцов.

**Результаты**

Копия входной таблицы с указанными дополнительными столбцами.

**Советы**

* Используйте [`project`](#project-operator) вместо этого оператора, если вам также нужно удалить или переименовать некоторые столбцы.
* Не используйте оператор `extend`, если вы просто хотите использовать в длинном выражении более короткое имя. `...| extend x = anonymous_user_id_from_client | ... func(x) ...` 

    Собственные столбцы таблицы уже проиндексированы. Так как новое имя определяет дополнительный столбец, который не проиндексирован, скорее всего, запрос будет выполняться медленнее.

**Пример**

```AIQL
traces
| extend
    Age = now() - timestamp
```


### Оператор join

    Table1 | join (Table2) on CommonColumn

Объединяет строки в двух таблицах, сопоставляя значения из указанного столбца.


**Синтаксис**

    Table1 | join [kind=Kind] (Table2) on CommonColumn [, ...]

**Аргументы**

* *Table1* — левая часть объединенных данных.
* *Table2* — правая часть объединенных данных. Может быть выражением в виде вложенного запроса для вывода таблицы.
* *CommonColumn* — столбец с одинаковым именем в двух таблицах.
* *Kind* — определяет способ сопоставления строк в двух таблицах.

**Результаты**

Таблица со следующими элементами.

* Столбец для каждого столбца в каждой из двух таблиц, в том числе соответствующие ключи. В случае конфликта имен столбцы в правой части будут автоматически переименованы.
* Строка для каждого соответствия во входных таблицах. Соответствие — это строки из обеих таблиц, у которых совпадают значения всех полей, перечисленных в условии `on`. 

* `Kind` не используется

    Для каждого значения ключа `on` из левой части отбирается только одна строка. Выходные данные содержат по одной строке для каждого соответствия этой строки со строками из правой части.

* `Kind=inner`
 
     Строка в выходных данных для каждой комбинации соответствующих строк из левой и правой частей.

* `kind=leftouter` (или `kind=rightouter`, или `kind=fullouter`)

     Кроме внутренних соответствий есть также строка для каждой строки в левой и (или) правой части, даже при отсутствии соответствия. В этом случае ячейки выходных данных без соответствий содержат значения NULL.

* `kind=leftanti`

     Возвращает все записи из левой части, для которых нет соответствий в правой. Итоговая таблица содержит только столбцы из левой части.
 
Если есть несколько строк с одинаковыми значениями для этих полей, вы получите строки для всех комбинаций.

**Советы**

Обеспечить наилучшую производительность можно так.

* Перед оператором `join` используйте `where` и `project`, чтобы сократить количество строк и столбцов во входных таблицах. 
* Если одна таблица меньше другой, используйте ее в качестве левой (перенаправленной) части объединенных данных.
* У объединяемых по соответствию столбцов должно быть одно имя. При необходимости переименуйте столбец в одной из таблиц с помощью оператора project.

**Пример**

Получите расширенные сведения о действиях из журнала, в котором некоторые записи указывают на время начала и конца действия.

```AIQL
    let Events = MyLogTable | where type=="Event" ;
    Events
    | where Name == "Start"
    | project Name, City, ActivityId, StartTime=timestamp
    | join (Events
           | where Name == "Stop"
           | project StopTime=timestamp, ActivityId)
        on ActivityId
    | project City, ActivityId, StartTime, StopTime, Duration, StopTime, StartTime

```

### Предложение let

**Табличное предложение let — присвоение имени таблице**

    let recentReqs = requests | where timestamp > ago(3d); 
    recentReqs | count

**Скалярное предложение let — присвоение имени значению**

    let interval = 3d; 
    requests | where timestamp > ago(interval)

**Лямбда-предложение let — присвоение имени функции**

    let Recent = 
       (interval:timespan) { requests | where timestamp > ago(interval) };
    Recent(3h) | count

Предложение let связывает [имя](#names) с табличным результатом, скалярным значением или функцией. Предложение представлено префиксом для запроса, а сам запрос — это область привязки. (Let нельзя использовать для присвоения имен элементам, которые будут использоваться позже в ходе сеанса).

**Синтаксис**

    let name = scalar_constant_expression ; query

    let name = query ; query

    let name = (parameterName : type [, ...]) { plain_query }; query

* *type* — `bool`, `int`, `long`, `double`, `string`, `timespan`, `datetime`, `guid`, [`dynamic`](#dynamic-type)
* *plain\_query* — запрос без предложения let в начале.

**Примеры**

    let rows(n:long) = range steps from 1 to n step 1;
    rows(10) | ...


Самосоединение:

    let Recent = events | where timestamp > ago(7d);
    Recent | where name contains "session_started" 
    | project start = timestamp, session_id
    | join (Recent 
        | where name contains "session_ended" 
        | project stop = timestamp, session_id)
      on session_id
    | extend duration = stop - start 

### Оператор limit

     T | limit 5

Возвращает заданное количество строк из входной таблицы. Указать, какие записи будут возвращены, нельзя. (Чтобы вернуть определенные записи, используйте оператор [`top`](#top-operator).)

**Псевдоним** `take`

**Синтаксис**

    T | limit NumberOfRows


**Советы**

`Take` — простой и эффективный способ просмотреть пример результатов во время работы в интерактивном режиме. Учтите, что этот оператор не используется для создания конкретных строк либо их создания в указанном порядке.

Есть неявное ограничение на количество строк, возвращаемых клиенту, даже если вы не используете оператор `take`. Чтобы снять это ограничение, используйте параметр `notruncation` клиентского запроса.



### Оператор mvexpand

    T | mvexpand listColumn 

Разворачивает список из ячейки с динамической типизацией (JSON) так, чтобы у каждой записи была отдельная строка. Все остальные ячейки в развернутой строке дублируются.

(См. также оператор [`summarize makelist`](#summarize-operator), который выполняет противоположную функцию.)

**Пример**

Предположим, что у вас такая входная таблица:

|A:int|B:string|D:dynamic|
|---|---|---|
|1|"hello"|{"key":"value"}|
|2|"world"|[0,1,"k","v"]|

    mvexpand D

Результат будет таким:

|A:int|B:string|D:dynamic|
|---|---|---|
|1|"hello"|{"key":"value"}|
|2|"world"|0|
|2|"world"|1|
|2|"world"|"k"|
|2|"world"|"v"|


**Синтаксис**

    T | mvexpand  [bagexpansion=(bag | array)] ColumnName [limit Rowlimit]

    T | mvexpand  [bagexpansion=(bag | array)] [Name =] ArrayExpression [to typeof(Typename)] [limit Rowlimit]

**Аргументы**

* *ColumnName* — в выходных данных массивы из этого столбца будут развернуты в несколько строк. 
* *ArrayExpression* — выражение, которое возвращает массив. Если используется этот аргумент, добавляется новый столбец, а существующий сохраняется.
* *Name* — имя нового столбца.
* *Typename* — приводит развернутое выражение к определенному типу.
* *RowLimit* — максимальное количество строк, созданных из каждой исходной строки. Значение по умолчанию — 128.

**Результаты**

Несколько строк для каждого значения в массиве в именованном столбце или выражении массива.

Тип развернутого столбца всегда динамический. Чтобы использовать это значение в обычных или статистических вычислениях, используйте приведение типов, например `todatetime()` или `toint()`.

Поддерживаются два режима развертывания контейнера свойств.

* `bagexpansion=bag` — контейнеры свойств развертываются в контейнеры свойств с одной записью. Это значение по умолчанию.
* `bagexpansion=array` — контейнеры свойств развертываются в структуры массива с двумя элементами `[`*key*`,`*value*`]`. Это позволяет единообразно обращаться к ключам и значениям (а также выполнять, например, подсчет различных значений в именах свойств). 

**Примеры**


    exceptions | take 1 
    | mvexpand details[0]

Разбивает запись исключения на строки для каждого элемента в поле подробных сведений.



### Оператор parse

    T | parse "I am 63 next birthday" with "I am" Year:int "next birthday"

    T | parse kind=regex "My 62nd birthday" 
        with "My" Year:regex("[0..9]+") regex("..") "birthday"

Извлекает значения из строки. Можно использовать сопоставление простых или регулярных выражений.

Элементы в предложении `with`, в свою очередь, сопоставляются с исходной строкой. Каждый элемент обрабатывает часть исходного текста. Если это простая строка, курсор перемещается в рамках соответствия. Если это столбец с именем типа, курсор перемещается, пока есть возможность выполнять синтаксический анализ указанного типа. (Соответствия строк обрабатываются до тех пор, пока не будет найден следующий элемент). Если это регулярное выражение, ищется соответствие регулярному выражению (тип итогового столбца всегда будет строковым).

**Синтаксис**

    T | parse StringExpression with [SimpleMatch | Column:Type] ...

    T | parse kind=regex StringExpression 
        with [SimpleMatch | Column : regex("Regex")] ...

**Аргументы**

* *T* — входная таблица.
* *kind* — простое или регулярное выражение. По умолчанию используется простое выражение.
* *StringExpression* — выражение, результат вычисления которого является строкой или может быть преобразован в строку.
* *SimpleMatch* — строка, которая совпадает со следующей частью текста.
* *Column* — указывает новый столбец, которому будет назначено соответствие.
* *Type* — указывает, как анализировать следующую часть исходной строки.
* *Regex* — регулярное выражение для сопоставления со следующей частью строки. 

**Результаты**

Входную таблицу, развернутую в соответствии со списком столбцов.


**Примеры**

Оператор `parse` — это удобный способ дополнить (`extend`) таблицу, несколько раз применив `extract` к одному выражению `string`. Это полезно, если в таблице есть столбец `string` с несколькими значениями, которые нужно разбить на отдельные столбцы (например, созданный с помощью инструкции трассировки — `printf` или `Console.WriteLine`).

В примере ниже предполагается, что столбец `EventNarrative` таблицы `StormEvents` содержит строки вида `{0} at {1} crested at {2} feet around {3} on {4} {5}`. Предложенная операция дополнит таблицу двумя новыми столбцами: `SwathSize` и `FellLocation`.


|Описание события (EventNarrative)|
|---|
|12 декабря в 09:30 по восточному поясному времени уровень воды в реке Грин-Ривер в городе Браунсвилл поднялся до отметки 5,7 м (The Green River at Brownsville crested at 18.8 feet around 0930EST on December 12). Паводковый уровень в городе Браунсвилл составляет 5,5 м (Flood stage at Brownsville is 18 feet), соответственно, произошло небольшое затопление (Minor flooding occurs at this level). Вода преодолела заграждения и вышла из берегов, затопив часть сельскохозяйственных угодий, расположенных в низинах (The river overflows lock walls and some of the lower banks, along with some agricultural bottom land).|
|12 декабря в 17:00 по восточному поясному времени уровень воды в реке Роллинг-Форк-Ривер в городе Бостон поднялся до отметки 12 м (The Rolling Fork River at Boston crested at 39.3 feet around 1700EST on December 12). Паводковый уровень в городе Бостон составляет 10,7 м (Flood stage at Boston is 35 feet), соответственно, произошло небольшое затопление, покрывшее часть сельскохозяйственных угодий, расположенных в низинах (Minor flooding occurs at this level, with some agricultural bottom land covered).|
|16 декабря в 06:00 по восточному поясному времени уровень воды в реке Грин-Ривер в городе Вудбери поднялся до отметки 11,2 м (The Green River at Woodbury crested at 36.7 feet around 0600EST on December 16). Паводковый уровень в городе Вудбери составляет 10,1 м (Flood stage at Woodbury is 33 feet), соответственно, на этом уровне произошло небольшое затопление, покрывшее часть пригородных территорий расположенных в низинах (Minor flooding occurs at this level, with some lowlands around the town of Woodbury covered with water).|
|18 декабря в 07:00 по восточному поясному времени уровень воды в реке Огайо-Ривер в городе Телл-Сити поднялся до отметки 11,9 м (The Ohio River at Tell City crested at 39.0 feet around 7 AM EST on December 18). Паводковый уровень в городе Телл-Сити составляет 10,6 м (Flood stage at Tell City is 38 feet), соответственно, на этом уровне река вышла из берегов (At this level, the river begins to overflow its banks above the gage). Трассу 66 в штате Индиана затопило между городами Рим и Дерби (Indiana Highway 66 floods between Rome and Derby).|

```AIQL

StormEvents 
|  parse EventNarrative 
   with RiverName:string 
        "at" 
        Location:string 
        "crested at" 
        Height:double  
        "feet around" 
        Time:string 
        "on" 
        Month:string 
        " " 
        Day:long 
        "." 
        notImportant:string
| project RiverName , Location , Height , Time , Month , Day

```

|Название реки (RiverName)|Расположение|Высота|Время|Месяц|День|
|---|---|---|---|---|---|
|Грин-Ривер | Вудбери |11,2| 06:00 | Декабрь|16|
|Роллинг-Форк-Ривер | Бостон |12| 17:00 | Декабрь|12|
|Грин-Ривер | Браунсвилл |5,7| 09:30 | Декабрь|12|
|Огайо-Ривер | Телл-Сити |11,9| 07:00 | Декабрь|18|

Сопоставление также можно выполнять с использованием регулярных выражений. Результат будет тот же, но тип всех итоговых столбцов будет строковым.

```AIQL

StormEvents
| parse kind=regex EventNarrative 
  with RiverName:regex("(\\s?[a-zA-Z]+\\s?)+") 
  "at" Location:regex(".*") 
  "crested at " Height:regex("\\d+\\.\\d+") 
  " feet around" Time:regex(".*") 
  "on " Month:regex("(December|November|October)") 
   " " Day:regex("\\d+") 
   "." notImportant:regex(".*")
| project RiverName , Location , Height , Time , Month , Day
```


### Оператор project

    T | project cost=price*quantity, price

Выберите столбцы для включения, переименования или удаления, а затем вставьте новые вычисляемые столбцы. Порядок столбцов в результате определяется порядком аргументов. В результат будут включены только указанные в аргументах столбцы. Другие входные данные удаляются. (См. также `extend`.)


**Синтаксис**

    T | project ColumnName [= Expression] [, ...]

**Аргументы**

* *T* — входная таблица.
* *ColumnName* — имя столбца, которое будет отображено в выходных данных. Если аргумент *Expression* отсутствует, столбец с таким именем должен присутствовать во входных данных. [Имена](#names) зависят от регистра и могут содержать буквы и цифры, а также символы нижнего подчеркивания (\_). Используйте `['...']` или `["..."]`, чтобы заключать в кавычки ключевые слова или имена с другими символами.
* *Expression* — необязательное скалярное выражение над значениями входных столбцов. 

    Можно получить новый вычисляемый столбец с именем существующего столбца во входных данных.

**Результаты**

Таблица со столбцами, именованными как аргументы, а также количеством строк, соответствующим входной таблице.

**Пример**

В следующем примере показано несколько типов операций, которые можно выполнить с помощью оператора `project`. Входная таблица `T` содержит три столбца типа `int`: `A`, `B` и `C`.

```AIQL
T
| project
    X=C,               // Rename column C to X
    A=2*B,             // Calculate a new column A from the old B
    C=strcat("-",tostring(C)), // Calculate a new column C from the old C
    B=2*B,              // Calculate a new column B from the old B
    ['where'] = client_City // rename, using a keyword as a column name
```

### Оператор project-away

    T | project-away column1, column2, ...

Исключение указанных столбцов. Результат содержит все входные столбцы, кроме указанных.

### Оператор range

    range LastWeek from ago(7d) to now() step 1d

Создает таблицу значений с одним столбцом. Обратите внимание: входные данные конвейера отсутствуют.

|LastWeek|
|---|
|2015-12-05 09:10:04.627|
|2015-12-06 09:10:04.627|
|...|
|2015-12-12 09:10:04.627|



**Синтаксис**

    range ColumnName from Start to Stop step Step

**Аргументы**

* *ColumnName* — имя одного столбца в выходной таблице.
* *Start* — наименьшее значение в выходных данных.
* *Stop* — наибольшее значение, созданное в выходных данных (или ограничение на максимальное значение, если применение *step* приводит к пропуску этого значения).
* *Step* — разница между двумя последовательными значениями. 

Аргументы должны иметь числовые значения, значения даты или временного диапазона. Они не могут ссылаться на столбцы таблицы. (Если вы хотите вычислить диапазон на основе входной таблицы, используйте [*функцию* range](#range), например, с [оператором mvexpand](#mvexpand-operator).)

**Результаты**

Таблица с одним столбцом с именем *ColumnName* и следующими значениями: *Start*, *Start* + *Step*, … до *Stop* включительно.

**Пример**

```AIQL
range Steps from 1 to 8 step 3
```

Таблица с одним столбцом с именем `Steps`, типом `long` и значениями `1`, `4` и `7`.

**Пример**

    range LastWeek from bin(ago(7d),1d) to now() step 1d

Таблица со значениями в полночь за последние семь дней. Функция bin (floor) позволяет сократить время до начала каждого дня.

**Пример**

```AIQL
range timestamp from ago(4h) to now() step 1m
| join kind=fullouter
  (traces
      | where timestamp > ago(4h)
      | summarize Count=count() by bin(timestamp, 1m)
  ) on timestamp
| project Count=iff(isnull(Count), 0, Count), timestamp
| render timechart  
```

В этом примере оператор `range` создает небольшую временную таблицу измерения, на основе которой заполняет нулями все поля, для которых нет значений в исходных данных.

### Оператор reduce

    exceptions | reduce by outerMessage

Пытается сгруппировать похожие записи. Для каждой группы оператор выводит шаблон (`Pattern`), который считает наилучшим описанием этой группы, а также количество записей (`Count`).


![](./media/app-insights-analytics-queries/reduce.png)

**Синтаксис**

    T | reduce by  ColumnName [ with threshold=Threshold ]

**Аргументы**

* *ColumnName* — анализируемый столбец. Он должен быть строкового типа.
* *Threshold* — пороговое значение в диапазоне {0..1}. Значение по умолчанию — 0,001. Для объемных входных данных пороговое значение должно быть небольшим. 

**Результаты**

Два столбца: `Pattern` и `Count`. Во многих случаях модель будет представлена полным значением из столбца. В некоторых случаях оператор может определить общие термины, заменив части переменных символом *.

Например, результат выполнения `reduce by city` может быть таким.

|Модель | Count |
|---|---|
| Сан * | 5182 |
| Сант * | 2846 |
| Москва | 3726 |
| * -на- * | 2730 |
| Париж | 27 163 |


### Директива render

    T | render [ table | timechart  | barchart | piechart ]

Render указывает уровню представления данных способ отображения таблицы. Этот элемент должен быть последним в канале. Он является удобной альтернативой использованию элементов управления, позволяя сохранять запрос с помощью конкретного метода представления.

### Предложение restrict 

Задает набор имен таблиц, доступных для операторов, которые следуют. Например:

    let e1 = requests | project name, client_City;
    let e2 =  requests | project name, success;
    // Exclude predefined tables from the union:
    restrict access to (e1, e2);
    union * |  take 10 

### Оператор sort 

    T | sort by country asc, price desc

Сортирует по порядку строки входной таблицы (по одному или нескольким столбцам).

**Псевдоним** `order`

**Синтаксис**

    T  | sort by Column [ asc | desc ] [ `,` ... ]

**Аргументы**

* *T* — входная таблица для сортировки.
* *Column* — столбец из таблицы *T*, по которому выполняется сортировка. Значения должны быть представлены числовыми или строковыми значениями, значениями времени или даты.
* `asc` — сортировка по возрастанию. `desc` — сортировка по убыванию. Используется по умолчанию.

**Пример**

```AIQL
Traces
| where ActivityId == "479671d99b7b"
| sort by Timestamp asc
```
Все строки из таблицы Traces с определенным значением `ActivityId`, отсортированные по меткам времени.

### Оператор summarize

Создает таблицу, которая объединяет содержимое входной таблицы.
 
    requests
	| summarize count(), avg(duration), makeset(client_City) 
      by client_CountryOrRegion

В таблице отображено количество, средняя продолжительность запроса и группа городов каждой страны. Для каждой страны в выходных данных есть своя строка. В выходных столбцах отображено количество, средняя продолжительность, города и страна. Все остальные входные столбцы игнорируются.


    T | summarize count() by price_range=bin(price, 10.0)

В таблице отображено количество элементов с ценами в каждом интервале [0,10.0], [10.0,20.0] и т. д. Пример включает один столбец для подсчета и один столбец для диапазон цен. Все остальные входные столбцы игнорируются.


**Синтаксис**

    T | summarize
         [  [ Column = ] Aggregation [ `,` ... ] ]
         [ by
            [ Column = ] GroupExpression [ `,` ... ] ]

**Аргументы**

* *Column* — необязательное имя результирующего столбца. По умолчанию это имя, получаемое из выражения. [Имена](#names) зависят от регистра и могут содержать буквы и цифры, а также символы нижнего подчеркивания (\_). Используйте `['...']` или `["..."]`, чтобы заключать в кавычки ключевые слова или имена с другими символами.
* *Aggregation* — вызов статистической функции, например `count()` или `avg()`, с именами столбцов в качестве аргументов. См. подробнее о [статистических функциях](#aggregations).
* *GroupExpression* — операция со значениями столбцов, которая возвращает набор уникальных значений. Обычно это имя столбца, который уже содержит ограниченный набор значений, либо функция `bin()` с числовым или временным столбцом в качестве аргумента. 

Если указать числовое или временное выражение без `bin()`, аналитика автоматически применит его с группировкой по интервалам `1h` для временных значений или `1.0` для числовых.

Если выражение *GroupExpression* не указано, вся таблица будет суммирована в одну выходную строку.



**Результаты**

Входные строки объединяются в группы с одинаковыми значениями выражений `by`. Затем указанные агрегатные функции выполняют вычисления и создают строку для каждой группы. Результат содержит все столбцы из списка `by` и хотя бы один столбец для каждого вычисленного статистического выражения. (Некоторые агрегатные функции возвращают несколько столбцов).

Результат содержит столько строк, сколько существует уникальных комбинаций значений в столбцах `by`. Чтобы суммировать диапазоны числовых значений, ограничьте диапазоны дискретными значениями с помощью `bin()`.

**Примечание.**

Для статистических выражений и для выражений группирования допускаются произвольные выражения, но более эффективно использовать простые имена столбцов или функцию `bin()` для числовых столбцов.



### Оператор take

Псевдоним оператора [limit](#limit-operator)


### Оператор top

    T | top 5 by Name desc

Возвращает первые *N* записей, отсортированных по указанным столбцам.


**Синтаксис**

    T | top NumberOfRows by Sort_expression [ `asc` | `desc` ] [, ... ]

**Аргументы**

* *NumberOfRows* — возвращаемое количество строк из *T*.
* *Sort\_expression* — выражение, по которому сортируются строки. Обычно это просто имя столбца. Можно указать несколько аргументов sort\_expression.
* `asc` или `desc` (по умолчанию) указывает направление выбора элементов в диапазоне: снизу вверх или сверху вниз.


**Советы**

Выражение `top 5 by name` на первый взгляд эквивалентно `sort by name | take 5`. Но первое работает быстрее и в отличие от `take` всегда возвращает отсортированные результаты.


### Оператор union

     Table1 | union Table2, Table3

Принимает несколько таблиц и возвращает строки из них.

**Синтаксис**

    T | union [ kind= inner | outer ] [ withsource = ColumnName ] Table2 [ , ...]  

    union [ kind= inner | outer ] [ withsource = ColumnName ] Table1, Table2 [ , ...]  

**Аргументы**

* *Table1*, *Table2*…
 *  Имя таблицы, например `requests`, или таблицы, определенной в [предложении let](#let-clause).
 *  Или выражение запроса, например `(requests | where success=="True")`.
 *  Набор таблиц, указанных с помощью подстановочного знака. Например, `e*` сформирует объединение всех таблиц, определенных в предыдущих предложениях let, имена которых начинаются на e, вместе с таблицей exceptions.
* `kind`: 
 * `inner` — результат содержит подмножество столбцов, которые являются общими для всех входных таблиц.
 * `outer` — результат содержит все столбцы, которые присутствуют хотя бы в одной из входных таблиц. Для ячеек, которые не определены во входной таблице, будет установлено значение `null`.
* `withsource=`*ColumnName:* если аргумент указан, выходные данные будут содержать столбец с именем *ColumnName*. В нем для каждой строки будет указано, из какой исходной таблицы она взята.

**Возвращает**

Таблица с таким количеством строк, как во всех входных таблицах, и таким количеством столбцов, сколько уникальных имен столбцов во входных данных.

**Пример**

```AIQL

let ttrr = requests | where timestamp > ago(1h);
let ttee = exceptions | where timestamp > ago(1h);
union tt* | count
```
Объединение всех таблиц, имена которых начинаются с tt.


**Пример**

```AIQL

union withsource=SourceTable kind=outer Query, Command
| where Timestamp > ago(1d)
| summarize dcount(UserId)
```
Количество различных пользователей, которые за последний день создали событие `exceptions` или `traces`. В результате в столбце SourceTable будет указано одно из значений: Query или Command.

```AIQL
exceptions
| where Timestamp > ago(1d)
| union withsource=SourceTable kind=outer 
   (Command | where Timestamp > ago(1d))
| summarize dcount(UserId)
```

Это более эффективный способ получить тот же результат, так как перед объединением каждая таблица отфильтровывается.

### Оператор where

     T | where fruit=="apple"

Отфильтровывает таблицу для подмножества строк, которые удовлетворяют предикату.

**Псевдоним** `filter`

**Синтаксис**

    T | where Predicate

**Аргументы**

* *T* — табличные входные данные, записи которых будут отфильтрованы.
* *Predicate* — [выражение](#boolean) `boolean` для столбцов таблицы *T*. Вычисляется отдельно для каждой строки в *T*.

**Результаты**

Строки из таблицы *T*, для которых *Predicate* имеет значение `true`.

**Советы**

Обеспечить максимальную производительность можно так.

* **Используйте простые сравнения** между именами столбцов и константами. (Под константой здесь понимается значение, постоянное для всех строк таблицы. Соответственно, допустимо использовать функции `now()` и `ago()`, а также скалярные значения, назначенные с помощью [предложения `let`](#let-clause).)

    Например, лучше использовать `where Timestamp >= ago(1d)`, чем `where floor(Timestamp, 1d) == ago(1d)`.

* **Вводите сначала более простые элементы**. Если у вас есть несколько предложений, объединенных с помощью `and`, сначала вводите предложения, которые включают только один столбец. Пример правильного порядка предложений: `Timestamp > ago(1d) and OpId == EventId`.


**Пример**

```AIQL
Traces
| where Timestamp > ago(1h)
    and Source == "Kuskus"
    and ActivityId == SubActivityIt 
```

Записи не старше 1 часа из источника Kuskus, у которых есть по два столбца с одним значением.

Обратите внимание: сравнение двух столбцов вводится в последнюю очередь, так как эта операция не предполагает использование индекса и запуска проверки.



## Агрегаты

Агрегаты — это функции, которые используются для объединения значений в группы, созданные в [операции суммирования](#summarize-operator). Например, в этом запросе dcount() является агрегатной функцией:

    requests | summarize dcount(name) by success

### любой 

    any(Expression)

Случайным образом выбирает одну строку группы и возвращает значение указанного выражения.

Это полезно, например, когда в каком-то столбце есть большое количество подобных значений (например, в столбце "текст ошибки") и вы хотите сделать выборку из этого столбца по уникальному значению составного ключа группы.

**Пример**

```

traces 
| where timestamp > now(-15min)  
| summarize count(), any(message) by operation_Name 
| top 10 by count_level desc 
```

<a name="argmin"></a> <a name="argmax"></a>
### argmin, argmax

    argmin(ExprToMinimize, * | ExprToReturn  [ , ... ] )
    argmax(ExprToMaximize, * | ExprToReturn  [ , ... ] ) 

Находит в группе строку, для которой выражение *ExprToMaximize* будет минимальным (или максимальным) и возвращает значение *ExprToReturn* (можно указать `*`, чтобы вернуть всю строку).

**Совет**. Переданные столбцы переименовываются автоматически. Чтобы убедиться, что вы используете правильные имена, проверьте результаты с помощью `take 5`, прежде чем передавать их другому оператору.

**Примеры**

Показать время возникновения самого продолжительного запроса для каждого имени запроса:

    requests | summarize argmax(duration, timestamp) by name

Показать все подробности выполнения самого длинного запроса, а не только метку времени:

    requests | summarize argmax(duration, *) by name


Найти наименьшее значение каждой метрики с ее меткой времени и другими данными:

    metrics 
    | summarize minValue=argmin(value, *) 
      by name


![](./media/app-insights-analytics-aggregations/argmin.png)
 


### avg

    avg(Expression)

Вычисляет среднее значение выражения *Expression* для группы.

### buildschema

    buildschema(DynamicExpression)

Возвращает минимальную схему, которая допускает все значения *DynamicExpression*.

Указанный в параметре столбец должен иметь тип `dynamic` — массив или контейнер свойств.

**Пример**

    exceptions | summarize buildschema(details)

Результат:

    { "`indexer`":
     {"id":"string",
       "parsedStack":
       { "`indexer`": 
         {  "level":"int",
            "assembly":"string",
            "fileName":"string",
            "method":"string",
            "line":"int"
         }},
      "outerId":"string",
      "message":"string",
      "type":"string",
      "rawStack":"string"
    }}

Обратите внимание, что `indexer` обозначает позицию, в которой нужно указать числовой индекс. Некоторые допустимые пути для этой схемы будут следующими (предполагается, что эти индексы в этом примере находятся в диапазоне):

    details[0].parsedStack[2].level
    details[0].message
    arraylength(details)
    arraylength(details[0].parsedStack)

**Пример**

Предположим, что входной столбец имеет три динамических значения:

| |
|---|
|`{"x":1, "y":3.5}`
|`{"x":"somevalue", "z":[1, 2, 3]}`
|`{"y":{"w":"zzz"}, "t":["aa", "bb"], "z":["foo"]}`


Итоговая схема будет следующей:

    { 
      "x":["int", "string"], 
      "y":["double", {"w": "string"}], 
      "z":{"`indexer`": ["int", "string"]}, 
      "t":{"`indexer`": "string"} 
    }

Схема указывает следующее:

* Корневой объект представляет собой контейнер с четырьмя свойствами x, y, z и t.
* Свойство x, которое может быть типа int или string.
* Свойство y, которое может либо типа double, либо другой контейнер со свойством w типа string.
* Ключевое слово ``indexer`` указывает, что z и t являются массивами.
* Каждый элемент в массиве z имеет тип int или string.
* t представляет собой массив строк.
* Каждое свойство является необязательным, и любой массив может быть пустым.

##### Модель схемы

Синтаксис возвращаемой схемы следующий:

    Container ::= '{' Named-type* '}';
    Named-type ::= (name | '"`indexer`"') ':' Type;
	Type ::= Primitive-type | Union-type | Container;
    Union-type ::= '[' Type* ']';
    Primitive-type ::= "int" | "string" | ...;

Они эквивалентны подмножеству аннотаций типов TypeScript, закодированному как динамическое значение. В Typescript пример схемы будет следующим:

    var someobject: 
    { 
      x?: (number | string), 
      y?: (number | { w?: string}), 
      z?: { [n:number] : (int | string)},
      t?: { [n:number]: string } 
    }


### count

    count([ Predicate ])

Возвращает число строк, для которых предикат *Predicate* принимает значение `true`. Если предикат *Predicate* не указан, возвращается общее число записей в группе.

**Совет для повышения производительности**: используйте `summarize count(filter)` вместо `where filter | summarize count()`.

> [AZURE.NOTE] Не используйте count() для поиска числа запросов, исключений или других произошедших событий. При обработке [выборки](app-insights-sampling.md) количество точек данных окажется меньше, чем количество фактических событий. Вместо этого используйте `summarize sum(itemCount)...`. Свойство itemCount отражает число исходных событий, представленных каждой сохраненной точкой данных.

### countif

    countif(Predicate)

Возвращает число строк, для которых предикат *Predicate* принимает значение `true`.

**Совет для повышения производительности**: используйте `summarize countif(filter)` вместо `where filter | summarize count()`.

> [AZURE.NOTE] Не используйте countif() для поиска количества запросов, исключений или других произошедших событий. При обработке [выборки](app-insights-sampling.md) количество точек данных окажется меньше, чем количество фактических событий. Вместо этого используйте `summarize sum(itemCount)...`. Свойство itemCount отражает число исходных событий, представленных каждой сохраненной точкой данных.

### dcount

    dcount( Expression [ ,  Accuracy ])

Возвращает приблизительное количество различных значений выражения *Expr* для группы. (Чтобы получить список уникальных значений, используйте [`makeset`](#makeset).)

Приоритет между скоростью и точностью контролирует необязательный параметр *Accuracy*.

 * `0` — наименее точное и самое быстрое вычисление.
 * `1` — значение по умолчанию, при котором точность и время расчета сбалансированы; допускается ошибка около 0,8 %.
 * `2` — наиболее точное и самое медленное вычисление; допускается ошибка около 0,4 %.

**Пример**

    pageViews 
    | summarize cities=dcount(client_City) 
      by client_CountryOrRegion

![](./media/app-insights-analytics-aggregations/dcount.png)

### makelist

    makelist(Expr [ ,  MaxListSize ] )

Возвращает массив типа `dynamic` (JSON) со всеми значениями выражения *Expr* для группы.

* *MaxListSize* — необязательное целочисленное ограничение для количества возвращаемых элементов (по умолчанию — *128*).

### makeset

    makeset(Expression [ , MaxSetSize ] )

Возвращает массив типа `dynamic` (JSON) с набором различных значений, которые выражение *Expr* принимает для группы. (Совет: для простого подсчета уникальных значений используйте [`dcount`](#dcount).)
  
*  *MaxSetSize* — необязательное целочисленное ограничение для количества возвращаемых элементов (по умолчанию — *128*).

**Пример**

    pageViews 
    | summarize cities=makeset(client_City) 
      by client_CountryOrRegion

![](./media/app-insights-analytics-aggregations/makeset.png)

Противоположную функцию выполняет [оператор `mvexpand`](#mvexpand-operator).


### max, min

    max(Expr)

Вычисляет максимальное значение выражения *Expr*.
    
    min(Expr)

Вычисляет минимальное значение выражения *Expr*.

**Совет**: эта функция выдает только минимальный или максимальный результат — например, наибольшую или наименьшую цену. Если вам нужны и другие столбцы этой строки, например имя поставщика с наименьшей ценой, используйте [argmin или argmax](#argmin-argmax).


<a name="percentile"></a> <a name="percentiles"></a>
### percentile, percentiles

    percentile(Expression, Percentile)

Возвращает оценку выражения *Expression* для группы по указанному процентилю. Точность зависит от плотности заполнения области процентиля.
    
    percentiles(Expression, Percentile1 [ , Percentile2 ] )

То же, что и `percentile()`, но вычисляет несколько значений (это быстрее, чем отдельно вычислять каждый процентиль).

**Примеры**


Значение `duration`, ниже которого находится 95 % значений, а выше — 5 % значений выборки, вычисленное для каждого имени запроса:

    request 
    | summarize percentile(duration, 95)
      by name

Чтобы выполнить вычисления для всей таблицы, пропустите "by...".

Одновременно вычислите несколько процентилей для других имен запросов:

    
    requests 
    | summarize 
        percentiles(duration, 5, 20, 50, 80, 95) 
      by name

![](./media/app-insights-analytics-aggregations/percentiles.png)

Результаты показывают, что для запроса /Events/Index 5 % запросов были выполнены за 2,44 с, половина запросов — за 3,52 с, а 5 % — более чем за 6,85 с.


Вычисление множественной статистики:

    requests 
    | summarize 
        count(), 
        avg(Duration),
        percentiles(Duration, 5, 50, 95)
      by name

##### Ошибка оценки в процентилях

Статистическая оценка процентилей предоставляет приблизительное значение с помощью [T-Digest](https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf).

Некоторые важные моменты:

* Границы ошибки оценки изменяются со значением запрошенного процентиля. Наивысшая точность наблюдается на концах шкалы [0..100], процентили 0 и 100 — это точное минимальное и максимальное значения распределения. Точность постепенно снижается к середине шкалы. Она худшая на медиане и ограничена сверху 1 %. 
* Границы ошибки наблюдаются на диапазоне, а не на значении. Предположим, что функция percentile(X, 50) вернула значение Xm. Оценка гарантирует, что не менее 49 % и не более 51 % значений X меньше, чем Xm. Теоретического ограничения на разницу между Xm и X нет.

### stdev

     stdev(Expr)

Возвращает стандартное отклонение выражения *Expr* для группы.

### variance

    variance(Expr)

Возвращает дисперсию выражения *Expr* для группы.

### sum

    sum(Expr)

Возвращает сумму выражения *Expr* для группы.


## Скалярные значения

[casts](#casts) | [comparisons](#scalar-comparisons) <br/> [gettype](#gettype) | [hash](#hash) | [iff](#iff)| [isnull](#isnull) | [isnotnull](#isnotnull) | [notnull](#notnull)

Ниже приведены поддерживаемые типы.

| Тип | Дополнительные имена | Эквивалентный тип .NET |
| --------- | -------------------- | -------------------- |
| `bool` | `boolean` | `System.Boolean` |
| `datetime`| `date` | `System.DateTime` |
| `dynamic` | | `System.Object` |
| `guid` | `uuid`, `uniqueid` | `System.Guid` |
| `int` | | `System.Int32` |
| `long` | | `System.Int64` |
| `double` | `real` | `System.Double` |
| `string` | | `System.String` |
| `timespan`| `time` | `System.TimeSpan` |

### Приведение типов

Типы можно приводить друг к другу. Как правило, если преобразование имеет смысл, оно будет работать:

    todouble(10), todouble("10.6")
    toint(10.6) == 11
    floor(10.6) == 10
	toint("200")
    todatetime("2016-04-28 13:02")
    totimespan("1.5d"), totimespan("1.12:00:00")
    toguid("00000000-0000-0000-0000-000000000000")
    tostring(42.5)
    todynamic("{a:10, b:20}")

### Скалярные сравнения

||
---|---
`<` |Меньше
`<=`|Меньше или равно
`>` |Больше
`>=`|Больше или равно
`<>`|Не равно
`!=`|Не равно 
`in`| Правый операнд является массивом (динамическим), а левый операнд равен одному из его элементов.
`!in`| Правый операнд является массивом (динамическим), а левый операнд не равен ни одному из его элементов.




### gettype

**Возвращает**

Строка, представляющая базовый тип хранилища для единственного аргумента. Это особенно удобно для значений типа `dynamic`: для них `gettype()` покажет, как закодировано значение.

**Примеры**

|||
---|---
`gettype("a")` |`"string" `
`gettype(111)` |`"long" `
`gettype(1==1)` |`"int8" (*) `
`gettype(now())` |`"datetime" `
`gettype(1s)` |`"timespan" `
`gettype(parsejson('1'))` |`"int" `
`gettype(parsejson(' "abc" '))` |`"string" `
`gettype(parsejson(' {"abc":1} '))` |`"dictionary"` 
`gettype(parsejson(' [1, 2, 3] '))` |`"array"` 
`gettype(123.45)` |`"real" `
`gettype(guid(12e8b78d-55b4-46ae-b068-26d7a0080254))` |`"guid"` 
`gettype(parsejson(''))` |`"null"`



### hash

**Синтаксис**

    hash(source [, mod])

**Аргументы**

* *source*: исходный скаляр, для которого вычисляется хэш.
* *mod*: значение модуля (остатка от деления), которое будет применено к полученному в результате хэшу.

**Возвращает**

Значение xxhash (тип long) для заданного скаляра, указанное значение модуля (если указано).

**Примеры**

```
hash("World")                   // 1846988464401551951
hash("World", 100)              // 51 (1846988464401551951 % 100)
hash(datetime("2015-01-01"))    // 1380966698541616202
```
### iff

Функция `iff()` вычисляет первый аргумент (предикат) и возвращает значение второго или третьего аргументов в зависимости от значения предиката (`true` или `false`). Второй и третий аргументы должны быть одного типа.

**Синтаксис**

    iff(predicate, ifTrue, ifFalse)


**Аргументы**

* *predicate:* выражение, которое возвращает значение типа `boolean`.
* *ifTrue* — функция вычислит это выражение и возвратит его результат, если *predicate* имеет значение `true`.
* *ifFalse* — функция вычислит это выражение и возвратит его результат, если *predicate* имеет значение `false`.

**Возвращает**

Эта функция возвращает значение *ifTrue*, если *predicate* равен `true`. В противном случае она возвращает значение *ifFalse*.

**Пример**

```
iff(floor(timestamp, 1d)==floor(now(), 1d), "today", "anotherday")
```

<a name="isnull"/></a> <a name="isnotnull"/></a> <a name="notnull"/></a>
### isnull, isnotnull, notnull

    isnull(parsejson("")) == true

Принимает один аргумент и сообщает, равен ли он null.

**Синтаксис**


    isnull([value])


    isnotnull([value])


    notnull([value])  // alias for isnotnull

**Возвращает**

Значение true или false в зависимости от того, равен ли аргумент null.


|x|isnull(x)
|---|---
| "" | нет
|"x" | нет
|parsejson("")|Да
|parsejson("")|нет
|parsejson("{}")|нет

**Пример**

    T | where isnotnull(PossiblyNull) | count

Обратите внимание, что того же эффекта можно добиться другими способами:

    T | summarize count(PossiblyNull)




## Логический 

### Логические литералы

	true == 1
    false == 0
    gettype(true) == "int8"
    typeof(bool) == typeof(int8)

### Логические операторы

	and 
    or 

    

## Числа

[bin](#bin) | [floor](#floor) | [rand](#rand) | [range](#range) | [sqrt](#sqrt) | [todouble](#todouble) | [toint](#toint) | [tolong](#tolong)

### Числовые литералы

|||
|---|---
|`42`|`long`
|`42.0`|`real`

### Арифметические операторы

|| |
|---|-------------|
| + | Добавить |
| – | Вычитание || * | Умножение | | / | Деление | | % | Остаток от деления | || |`<` | Меньше |`<=`|Меньше или равно |`>` |Больше |`>=`|Больше или равно |`<>`|Не равно |`!=`|Не равно




### bin

Округляет значения до целого, кратного указанному размеру группы. Часто используется в запросе [`summarize by`](#summarize-operator). При наличии разрозненного набора значений они будут сгруппированы в меньший набор определенных значений.

Псевдоним `floor`.

**Синтаксис**

     bin(value, roundTo)

**Аргументы**

* *value:* число, дата или интервал времени. 
* *roundTo:* размер группы. Число, дата или интервал времени, разбивающий *value* на сегменты. 

**Возвращает**

Ближайшее число, кратное *roundTo* и меньшее *value*.
 
    (toint((value/roundTo)-0.5)) * roundTo

**Примеры**

Выражение | Результат
---|---
`bin(4.5, 1)` | `4.0`
`bin(time(16d), 7d)` | `14d`
`bin(datetime(1953-04-15 22:25:07), 1d)`| `datetime(1953-04-15)`


Следующее выражение вычисляет гистограмму длительности с размером сегмента в 1 секунду:

```AIQL

    T | summarize Hits=count() by bin(Duration, 1s)
```
### exp

    exp(v)   // e raised to the power v
    exp2(v)  // 2 raised to the power v
    exp10(v) // 10 raised to the power v



### floor

Псевдоним для [`bin()`](#bin).


### log

    log(v)    // Natural logarithm of v
    log2(v)   // Logarithm base 2 of v
    log10(v)  // Logarithm base 10 of v


`v` должно быть вещественным числом > 0. В противном случае возвращается значение null.

### rand

Генератор случайных чисел.

* `rand()` — вещественное число от 0,0 до 1,0.
* `rand(n)` — целое число от 0 до n-1.




### sqrt

Функция квадратного корня.

**Синтаксис**

    sqrt(x)

**Аргументы**

* *x:* вещественное число >= 0.

**Возвращает**

* Положительное число, такое как `sqrt(x) * sqrt(x) == x`
* `null`, если аргумент является отрицательным числом или не может быть преобразован в значение `real`. 




### toint

    toint(100)        // cast from long
    toint(20.7) == 21 // nearest int from double
    toint(20.4) == 20 // nearest int from double
    toint("  123  ")  // parse string
    toint(a[0])       // cast from dynamic
    toint(b.c)        // cast from dynamic

### tolong

    tolong(20.7) == 21 // conversion from double
    tolong(20.4) == 20 // conversion from double
    tolong("  123  ")  // parse string
    tolong(a[0])       // cast from dynamic
    tolong(b.c)        // cast from dynamic


### todouble

    todouble(20) == 20.0 // conversion from long or int
    todouble(" 12.34 ")  // parse string
    todouble(a[0])       // cast from dynamic
    todouble(b.c)        // cast from dynamic



## Дата и время


[ago](#ago) | [dayofweek](#dayofweek) | [getmonth](#getmonth)| [getyear](#getyear) | [now](#now) | [startofmonth](#startofmonth) | [startofyear](#startofyear) | [todatetime](#todatetime) | [totimespan](#totimespan)

### Литералы даты и времени

|||
---|---
**datetime**|
`datetime("2015-12-31 23:59:59.9")`<br/>`datetime("2015-12-31")`|Время всегда выражается в формате UTC. Если дата не указана, то имеется в виду время для сегодняшнего дня.
`now()`|Текущее время.
`now(`-*timespan*`)`|`now()-`*timespan*
`ago(`*timespan*`)`|`now()-`*timespan*
**интервал времени**|
`2d`|2 дня
`1.5h`|1,5 часа 
`30m`|30 минут
`10s`|10 с
`0.1s`|0,1 с
`100ms`| 100 мс
`10microsecond`|
`1tick`|100 нс
`time("15 seconds")`|
`time("2")`| 2 дня
`time("0.12:34:56.7")`|`0d+12h+34m+56.7s`

### Выражения для даты и времени

Выражение |Результат
---|---
`datetime("2015-01-02") - datetime("2015-01-01")`| `1d`
`datetime("2015-01-01") + 1d`| `datetime("2015-01-02")`
`datetime("2015-01-01") - 1d`| `datetime("2014-12-31")`
`2h * 24` | `2d`
`2d` / `2h` | `24`
`datetime("2015-04-15T22:33") % 1d` | `timespan("22:33")`
`bin(datetime("2015-04-15T22:33"), 1d)` | `datetime("2015-04-15T00:00")`
||
`<` |Меньше
`<=`|Меньше или равно
`>` |Больше
`>=`|Больше или равно
`<>`|Не равно
`!=`|Не равно 




### ago

Вычитает заданный интервал времени из текущего времени UTC. Как и `now()`, эту функцию можно использовать в выражении несколько раз, и значение времени UTC будет каждый раз одинаковым.

**Синтаксис**

    ago(a_timespan)

**Аргументы**

* *a\_timespan*: интервал для вычитания из текущего времени UTC (`now()`).

**Возвращает**

    now() - a_timespan

**Пример**

Все строки за последний час:

```AIQL

    T | where timestamp > ago(1h)
```



### dayofweek

    dayofweek(datetime("2015-12-14")) == 1d  // Monday

Целое число дней с предыдущего воскресенья в виде `timespan`.

**Синтаксис**

    dayofweek(a_date)

**Аргументы**

* `a_date`: значение в формате `datetime`.

**Возвращает**

Интервал `timespan` с момента полуночи предыдущего воскресенья с округлением до целого числа (количества дней).

**Примеры**

```AIQL
dayofweek(1947-11-29 10:00:05)  // time(6.00:00:00), indicating Saturday
dayofweek(1970-05-11)           // time(1.00:00:00), indicating Monday
```

### getmonth

Возвращает номер месяца (1-12) для аргумента типа datetime.

**Пример**

    ... | extend month = getmonth(datetime(2015-10-12))

    --> month == 10

### getyear

Возвращает год для аргумента типа datetime.

**Пример**

    ... | extend year = getyear(datetime(2015-10-12))

    --> year == 2015

### now

    now()
    now(-2d)

Текущее время UTC, при необходимости с учетом указанного смещения. Эта функция может использоваться в выражении несколько раз, и значение времени будет одинаковым для всех случаев.

**Синтаксис**

    now([offset])

**Аргументы**

* *offset:* смещение `timespan`, добавляемое к текущему времени UTC. По умолчанию: 0.

**Возвращает**

Текущее время UTC в виде `datetime`.

    now() + offset

**Пример**

Определяет интервал с момента события, определенного предикатом.

```AIQL
T | where ... | extend Elapsed=now() - timestamp
```

### startofmonth

    startofmonth(date)

Начало месяца, содержащего дату.

### startofyear

    startofyear(date)

Начало года, содержащего дату.


### todatetime

Псевдоним `datetime()`.

     todatetime("2016-03-28")
     todatetime("03/28/2016")
     todatetime("2016-03-28 14:34")
     todatetime("03/28/2016 2:34pm")
     todatetime("2016-03-28T14:34.5Z")
     todatetime(a[0])  // cast a dynamic type
     todatetime(b.c)   // cast a dynamic type

### totimespan

Псевдоним `timespan()`.

    totimespan("21d")
    totimespan("21h")
    totimespan(request.duration)


## Строка

[countof](#countof) | [extract](#extract) | [extractjson](#extractjson) | [isempty](#isempty) | [isnotempty](#isnotempty) | [notempty](#notempty) | [replace](#replace) | [split](#split) | [strcat](#strcat) | [strlen](#strlen) | [substring](#substring) | [tolower](#tolower) | [tostring](#tostring) | [toupper](#toupper)


### Строковые литералы

Используются такие же правила, как в JavaScript.

Строки могут быть заключены в одинарные или двойные кавычки.

Обратная косая черта (``) используется для экранирования символов, таких как `\t` (табуляция), `\n` (новая строка) и кавычки.

* `'this is a "string" literal in single \' quotes'`
* `"this is a 'string' literal in double " quotes"`
* `@"C:\backslash\not\escaped\with @ prefix"`

### Скрываемые строковые литералы

Скрываемые строковые литералы — это строки, которые аналитика скрывает при выводе строки (например, при трассировке). Для этого все скрываемые символы заменяются символом звездочки (`*`).

Для образования скрываемого строкового литерала укажите перед строкой символ `h` или H. Например:

```
h'hello'
h@'world' 
h"hello"
```

### Сравнение строк

Оператор|Описание|С учетом регистра|Пример
---|---|---|---
`==`|Равно |Да| `"aBc" == "aBc"`
`<>`|Не равно|Да| `"abc" <> "ABC"`
`=~`|Равно |Нет| `"abc" =~ "ABC"`
`!~`|Не равно |Нет| `"aBc" !~ "xyz"`
`has`|Правая часть представляет собой все слово в левой части|Нет| `"North America" has "america"`
`!has`|Правая часть не является всем словом в левой части|Нет|`"North America" !has "amer"` 
`contains` | Правая часть является вхождением в левую часть|Нет| `"FabriKam" contains "BRik"`
`!contains`| Правая часть не входит в левую часть|Нет| `"Fabrikam" !contains "xyz"`
`containscs` | Правая часть является вхождением в левую часть|Да| `"FabriKam" contains "Kam"`
`!containscs`| Правая часть не входит в левую часть|Да| `"Fabrikam" !contains "Kam"`
`startswith`|Правая часть является начальным вхождением в левую часть|Нет|`"Fabrikam" startswith "fab"`
`matches regex`|Левая часть содержит соответствие для правой части|Да| `"Fabrikam" matches regex "b.*k"`


При проверке на наличие полного лексического слова (т. е. символа или буквенно-цифрового слова, окруженного не буквенно-цифровыми символами, не началом и не концом поля) используйте `has` или `in`. `has` выполняется быстрее, чем `contains` или `startswith`. Первый из этих запросов выполняется быстрее:

    EventLog | where continent has "North" | count;
	EventLog | where continent contains "nor" | count





### countof

    countof("The cat sat on the mat", "at") == 3
    countof("The cat sat on the mat", @"\b.at\b", "regex") == 3

Подсчитывает вхождения подстроки в строку. Совпадения для обычных строк могут перекрывать друг друга, для регулярных выражений — не могут.

**Синтаксис**

    countof(text, search [, kind])

**Аргументы**

* *text:* строка.
* *search:* текстовая строка или регулярное выражение, которое проверяется на вхождение в *text*.
* *kind:* `"normal"|"regex"`, по умолчанию `normal`. 

**Возвращает**

Количество совпадений для строки поиска в контейнере. Совпадения для обычных строк могут перекрывать друг друга, для регулярных выражений — не могут.

**Примеры**

|||
|---|---
|`countof("aaa", "a")`| 3 
|`countof("aaaa", "aa")`| 3 (не 2!)
|`countof("ababa", "ab", "normal")`| 2
|`countof("ababa", "aba")`| 2
|`countof("ababa", "aba", "regex")`| 1
|`countof("abcabc", "a.c", "regex")`| 2
    



### extract

    extract("x=([0-9.]+)", 1, "hello x=45.6|wo") == "45.6"

Определяет совпадение [регулярного выражения](#regular-expressions) из текстовой строки. При необходимости извлеченная подстрока преобразуется к указанному типу.

**Синтаксис**

    extract(regex, captureGroup, text [, typeLiteral])

**Аргументы**

* *regex:* [регулярное выражение](#regular-expressions).
* *captureGroup:* положительная константа `int`, указывающая группу для извлечения из совпадения. 0 означает полное совпадение, 1 — значение, соответствующее первой '('круглой скобке')' в регулярном выражении, 2 или более — последующим круглым скобкам.
* *text:* значение в формате `string` для поиска.
* *typeLiteral* — необязательный литерал типа (например, `typeof(long)`). Если указан, то извлеченная подстрока преобразуется в этот тип. 

**Возвращает**

Если *regex* находит совпадение в *text*, возвращается подстрока, которая сравнивалась с указанной в *captureGroup* группой захвата, при необходимости преобразованная в тип *typeLiteral*.

Если совпадения нет или не удается выполнить преобразование типа, возвращается `null`.

**Примеры**

В примере строки `Trace` производится поиск определения `Duration`. Совпадение преобразуется в `real`, а затем умножается на константу времени (`1s`), так чтобы `Duration` получил тип `timespan`. В этом примере он равен 123,45 секунды:

```AIQL
...
| extend Trace="A=1, B=2, Duration=123.45, ..."
| extend Duration = extract("Duration=([0-9.]+)", 1, Trace, typeof(real)) * time(1s) 
```

Этот пример аналогичен функции `substring(Text, 2, 4)`:

```AIQL
extract("^.{2,2}(.{4,4})", 1, Text)
```

<a name="notempty"></a> <a name="isnotempty"></a> <a name="isempty"></a>
### isempty, isnotempty, notempty

    isempty("") == true

True, если аргумент является пустой строкой или имеет значение null. См. также [isnull](#isnull).


**Синтаксис**

    isempty([value])


    isnotempty([value])


    notempty([value]) // alias of isnotempty

**Возвращает**

Указывает, является ли аргумент пустой строкой или имеет значение null.

|x|isempty(x)
|---|---
| "" | Да
|"x" | нет
|parsejson("")|Да
|parsejson("")|нет
|parsejson("{}")|нет


**Пример**


    T | where isempty(fieldName) | count




### replace

Заменяет все найденные совпадения регулярного выражения другой строкой.

**Синтаксис**

    replace(regex, rewrite, text)

**Аргументы**

* *regex:* [регулярное выражение](https://github.com/google/re2/wiki/Syntax) для поиска в *text*. Оно может содержать группы захвата в '('круглых скобках')'. 
* *rewrite:* регулярное выражение, результат которого заменит все найденные совпадения с *matchingRegex*. Используйте `\0` для указания полного совпадения, `\1` для первой группы захвата, `\2` и более — для следующих групп захвата.
* *text:* строка.

**Возвращает**

*text*, в котором все совпадения с *regex* заменены на *rewrite*. Совпадения не перекрываются.

**Пример**

Выражение:

```AIQL
range x from 1 to 5 step 1
| extend str=strcat('Number is ', tostring(x))
| extend replaced=replace(@'is (\d+)', @'was: \1', str)
```

Получены следующие результаты:

| x | str | заменена|
|---|---|---|
| 1 | Число равно: 1,000000 | Число было равно: 1,000000|
| 2 | Число равно: 2,000000 | Число было равно: 2,000000|
| 3 | Число равно: 3,000000 | Число было равно: 3,000000|
| 4\. | Число равно: 4,000000 | Число было равно: 4,000000|
| 5 | Число равно: 5,000000 | Число было равно: 5,000000|
 



### split

    split("aaa_bbb_ccc", "_") == ["aaa","bbb","ccc"]

Разбивает указанную строку в соответствии с заданным разделителем и возвращает массив строк, содержащий подстроки. При необходимости может быть возвращена конкретная подстрока, если она существует.

**Синтаксис**

    split(source, delimiter [, requestedIndex])

**Аргументы**

* *source*: исходная строка, которая будет разделена в соответствии с указанным разделителем.
* *delimiter*: разделитель, который будет использоваться для разделения исходной строки.
* *requestedIndex*: необязательный индекс типа `int`, стартовое значение — 0. Если указан, возвращаемый массив строк будет содержать запрошенную подстроку, если она существует. 

**Возвращает**

Массив строк, содержащий подстроки заданной исходной строки, разделенные указанным разделителем.

**Примеры**

```
split("aa_bb", "_")           // ["aa","bb"]
split("aaa_bbb_ccc", "_", 1)  // ["bbb"]
split("", "_")                // [""]
split("a__b")                 // ["a","","b"]
split("aabbcc", "bb")         // ["aa","cc"]
```




### strcat

    strcat("hello", " ", "world")

Объединяет от 1 до 16 строк, переданных в качестве аргументов.

### strlen

    strlen("hello") == 5

Длина строки.

### substring

    substring("abcdefg", 1, 2) == "bc"

Извлекает подстроку из заданной исходной строки, начиная с указанного индекса. При необходимости можно указать длину запрашиваемой подстроки.

**Синтаксис**

    substring(source, startingIndex [, length])

**Аргументы**

* *source:* исходная строка, из которой будет извлечена подстрока.
* *startingIndex:* отсчитываемая от нуля позиция первого символа запрашиваемой подстроки.
* *length:* необязательный параметр, который указывает требуемое количество символов в подстроке. 

**Возвращает**

Подстрока для указанной строки. Подстрока начинается с позиции startingIndex (отсчитывается начиная с нуля) и продолжается до конца строки или до требуемого количества символов, если оно указано.

**Примеры**

```
substring("123456", 1)        // 23456
substring("123456", 2, 2)     // 34
substring("ABCD", 0, 2)       // AB
```

### tolower

    tolower("HELLO") == "hello"

Преобразует строку в нижний регистр.

### toupper

    toupper("hello") == "HELLO"

Преобразует строку в верхний регистр.



## Идентификаторы GUID

    guid(00000000-1111-2222-3333-055567f333de)


## Массивы, объекты и динамические типы

[literals](#dynamic-literals) | [casting](#casting-dynamic-objects) | [operators](#operators) | [let clauses](#dynamic-objects-in-let-clauses) <br/> [arraylength](#arraylength) | [extractjson](#extractjson) | [parsejson](#parsejson) | [range](#range) | [treepath](#treepath) | [todynamic](#todynamic)


Ниже приведен результат запроса на исключение Application Insights. Значение `details` является массивом.

![](./media/app-insights-analytics-scalars/310.png)

**Индексирование:** массивы и объекты можно индексировать так же, как в JavaScript.

    exceptions | take 1
    | extend 
        line = details[0].parsedStack[0].line,
        stackdepth = arraylength(details[0].parsedStack)

* Используйте `arraylength` и другие функции аналитики (но не .length!).

**Приведение типов**. Иногда необходимо привести тип элемента, который можно извлечь из объекта, так как его тип может варьироваться. Например, для `summarize...to` необходим конкретный тип:

    exceptions 
    | summarize count() 
      by toint(details[0].parsedStack[0].line)

    exceptions 
    | summarize count() 
      by tostring(details[0].parsedStack[0].assembly)

**Литералы**. Чтобы создать явный массив или объект контейнера свойств, запишите его в виде строки JSON и выполните приведение типа:

    todynamic('[{"x":"1", "y":"32"}, {"x":"6", "y":"44"}]')


**mvexpand**. Чтобы извлечь свойства объекта в отдельные строки, воспользуйтесь mvexpand:

    exceptions | take 1 
    | mvexpand details[0].parsedStack[0]


![](./media/app-insights-analytics-scalars/410.png)


**treepath:** используется для поиска всех путей в сложном объекте:

    exceptions | take 1 | project timestamp, details 
    | extend path = treepath(details) 
    | mvexpand path


![](./media/app-insights-analytics-scalars/420.png)

**buildschema** применяется для поиска минимальной схемы, которая допускает все значения выражения в таблице:

    exceptions | summarize buildschema(details)

Результат:

    { "`indexer`":
     {"id":"string",
       "parsedStack":
       { "`indexer`": 
         {  "level":"int",
            "assembly":"string",
            "fileName":"string",
            "method":"string",
            "line":"int"
         }},
      "outerId":"string",
      "message":"string",
      "type":"string",
      "rawStack":"string"
    }}

Обратите внимание, что `indexer` обозначает позицию, в которой нужно указать числовой индекс. Некоторые допустимые пути для этой схемы будут следующими (предполагается, что эти индексы в этом примере находятся в диапазоне):

    details[0].parsedStack[2].level
    details[0].message
    arraylength(details)
    arraylength(details[0].parsedStack)



### Литералы массива и объекта

Чтобы создать динамический литерал, используйте `parsejson` (псевдоним `todynamic`) со строкой JSON в качестве аргумента:

* `parsejson('[43, 21, 65]')` — массив чисел.
* `parsejson('{"name":"Alan", "age":21, "address":{"street":432,"postcode":"JLK32P"}}')` 
* `parsejson('21')` — одно значение динамического типа, содержащее число.
* `parsejson('"21"')` — одно значение динамического типа, содержащее строку.

Обратите внимание, что в отличие от JavaScript в JSON необходимо заключать строки в двойные кавычки (`"`). Поэтому обычно проще заключать закодированные JSON литералы в одинарные кавычки (`'`).

В этом примере создается динамическое значение, а затем используются его поля:

```

T
| extend person = parsejson('{"name":"Alan", "age":21, "address":{"street":432,"postcode":"JLK32P"}}')
| extend n = person.name, add = person.address.street
```


## Функции динамического объекта

|||
|---|---|
| *value* `in` *array*| Возвращает true, если в массиве *array* есть элемент, который равен значению *value*<br/>`where City in ('London', 'Paris', 'Rome')`
| *value* `!in` *array*| Возвращает true, если в массиве *array* нет ни одного элемента, который равен значению *value*
|[`arraylength(`array`)`](#arraylength)| Возвращает NULL, если это не массив
|[`extractjson(`path,object`)`](#extractjson)|Использует путь path для перехода к объекту object.
|[`parsejson(`source`)`](#parsejson)| Преобразует строку формата JSON в динамический объект.
|[`range(`from,to,step`)`](#range)| Массив значений
|[`mvexpand`listColumn](#mvexpand-operator) | Реплицирует строку для каждого значения в списке в указанной ячейке.
|[`summarize buildschema(`column`)`](#buildschema) |Определяет схему типа по содержимому столбца.
|[`summarize makelist(`column`)` ](#makelist)| Выполняет сведение групп строк и помещает значения столбца в массив.
|[`summarize makeset(`column`)`](#makeset) | Выполняет сведение групп строк и помещает значения столбца в массив без дублирования значений.

### Динамические объекты в предложениях let


В [предложениях let](#let-clause) динамические значения хранятся в виде строк, поэтому оба предложения эквивалентны и должны использоваться с функцией `parsejson` (или `todynamic`).

    let list1 = '{"a" : "somevalue"}';
    let list2 = parsejson('{"a" : "somevalue"}');

    T | project parsejson(list1).a, parsejson(list2).a




### arraylength

Количество элементов в динамическом массиве.

**Синтаксис**

    arraylength(array)

**Аргументы**

* *array:* значение типа `dynamic`.

**Возвращает**

Количество элементов в массиве *array* или `null`, если *array* не является массивом.

**Примеры**

```
arraylength(parsejson('[1, 2, 3, "four"]')) == 4
arraylength(parsejson('[8]')) == 1
arraylength(parsejson('[{}]')) == 1
arraylength(parsejson('[]')) == 0
arraylength(parsejson('{}')) == null
arraylength(parsejson('21')) == null
```



### extractjson

    extractjson("$.hosts[1].AvailableMB", EventText, typeof(int))

Возвращает указанный элемент текста JSON с помощью выражения пути. При необходимости преобразует извлеченную строку к указанному типу.


**Синтаксис**

```

    string extractjson(jsonPath, dataSource)​​ 
    resulttype extractjson(jsonPath, dataSource, typeof(resulttype))​​
```


**Возвращает**

Эта функция выполняет запрос JsonPath к источнику данных dataSource, который содержит допустимую строку JSON. При необходимости это значение преобразуется в другой тип, в зависимости от третьего аргумента.



**Пример**

Обозначения с [квадратными скобками] и точками эквивалентны:

    ... | extend AvailableMB = extractjson("$.hosts[1].AvailableMB", EventText, typeof(int)) | ...

    ... | extend AvailableMD = extractjson("$['hosts'][1]['AvailableMB']", EventText, typeof(int)) | ...



**Советы по улучшению производительности**

* Применяйте предложения where перед использованием `extractjson()`.
* По возможности заменяйте его на сопоставление с регулярным выражением и [extract](#extract). Он выполняется гораздо быстрее и эффективнее, если JSON создается из шаблона.
* Используйте `parsejson()`, если требуется извлечь из JSON несколько значений.
* При возможности проведите анализ JSON при обработке, объявив динамический тип столбца.

### Выражения пути JSON

|||
|---|---|
|`$`|Корневой объект|
|`@`|Текущий объект|
|`[0]`|Индекс массива|
|`.` или `[0]` | Дочерний|

*(В настоящее время подстановочные знаки, рекурсии, объединения и срезы не реализованы.)*




### parsejson

Интерпретирует `string` как [значение JSON](http://json.org/) и возвращает значение типа `dynamic`. Этот метод предпочтительнее, чем `extractjson()`, если необходимо извлечь более одного элемента из составного объекта JSON.

**Синтаксис**

    parsejson(json)

**Аргументы**

* *json:* документ JSON.

**Возвращает**

Объект типа `dynamic`, определенный в *json*.

**Пример**

Допустим, что в следующем примере `context_custom_metrics` есть тип `string` и следующее значение:

```
{"duration":{"value":118.0,"count":5.0,"min":100.0,"max":150.0,"stdDev":0.0,"sampledValue":118.0,"sum":118.0}}
```

Тогда следующий фрагмент извлечет значение слота `duration` из объекта, а затем из него извлечет два слота `duration.value` и `duration.min` (`118.0` и `110.0` соответственно).

```AIQL
T
| ...
| extend d=parsejson(context_custom_metrics) 
| extend duration_value=d.duration.value, duration_min=d["duration"]["min"]
```



### range

Функция `range()` (не следует путать с оператором `range`) создает динамический массив, содержащий последовательность равномерно распределенных значений.

**Синтаксис**

    range(start, stop, step)

**Аргументы**

* *start:* значение первого элемента результирующего массива. 
* *stop:* значение последнего элемента результирующего массива или наименьшее значение, которое больше последнего элемента результирующего массива и находится в определенном количестве (целое число) шагов *step* от первого элемента *start*.
* *step:* разница между двумя последовательными элементами массива.

**Примеры**

В следующем примере возвращается `[1, 4, 7]`:

```AIQL
range(1, 8, 3)
```

Следующий пример возвращает массив, содержащий все дни 2015 года:

```AIQL

    range(datetime(2015-01-01), datetime(2015-12-31), 1d)
```

### todynamic

    todynamic('{"a":"a1", "b":["b1", "b2"]}')

Преобразует строку в динамическое значение.

### treepath

    treepath(dynamic_object)

Перечисляет все выражения пути, которые определяют листья в динамическом объекте.

**Возвращает**

Массив выражений пути.

**Примеры**

    treepath(parsejson('{"a":"b", "c":123}')) 
    =>       ["['a']","['c']"]
    treepath(parsejson('{"prop1":[1,2,3,4], "prop2":"value2"}'))
    =>       ["['prop1']","['prop1'][0]","['prop2']"]
    treepath(parsejson('{"listProperty":[100,200,300,"abcde",{"x":"y"}]}'))
    =>       ["['listProperty']","['listProperty'][0]","['listProperty'][0]['x']"]

Обратите внимание, что "[0]" определяет наличие массива, но не обозначает индекс, используемый указанным расположением.

## Имена

Имя может содержать до 1024 знаков. Оно зависит от регистра и может содержать буквы, цифры и символы подчеркивания (`_`).

Чтобы включить в имя другие символы или использовать в нем ключевое слово, заключите имя в кавычки ['...'] или ["..."]. Например:

```AIQL

    requests | 
    summarize  ["distinct urls"] = dcount(name) // non-alphanumerics
    by  ['where'] = client_City, // using a keyword as a name
        ['outcome!'] = success // non-alphanumerics
```


|||
|---|---|
|['path\\file\\n'x''] | Используйте \\ для экранирования символов|
|["d-e.=/f#\\n"] | |
|[@'path\\file'] | Экранирования нет: \\ является литералом.|
|[@"\\now & then"] | |
|[where] | Использование ключевого слова языка в качестве имени.|

[AZURE.INCLUDE [app-insights-analytics-footer](../../includes/app-insights-analytics-footer.md)]

<!---HONumber=AcomDC_0427_2016-->