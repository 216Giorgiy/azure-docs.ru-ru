<properties 
	pageTitle="Суммирование и агрегирование в аналитике Application Insights" 
	description="Справочник по статистическим функциям и инструкции суммирования в аналитике, мощном инструменте поиска Application Insights." 
	services="application-insights" 
    documentationCenter=""
	authors="alancameronwills" 
	manager="douge"/>

<tags 
	ms.service="application-insights" 
	ms.workload="tbd" 
	ms.tgt_pltfrm="ibiza" 
	ms.devlang="na" 
	ms.topic="article" 
	ms.date="03/21/2016" 
	ms.author="awills"/>

# Агрегирование в аналитике

[Аналитика](app-analytics.md) позволяет выполнять расширенные запросы к данным телеметрии приложения, собранным службой [Application Insights](app-insights-overview.md). На этих страницах описан язык запросов аналитики.

[AZURE.INCLUDE [app-analytics-top-index](../../includes/app-analytics-top-index.md)]


## Оператор summarize

Создает таблицу, которая объединяет содержимое входной таблицы.

    purchases
    | summarize avg(Price) 
      by Fruit, Supplier

![](./media/app-analytics-aggregations/01.png)

* Входные записи объединяются в группы, так чтобы у каждой группы было заданное сочетание значений в полях `by`.
* После этого для членов каждой группы вычисляются статистические выражения.
* Для каждого различного сочетания значений для выражений "by" формируется выходная строка. 
* Для каждого статистического выражения и каждого выражения "by" формируется выходной столбец. Все остальные входные столбцы удаляются.

### Синтаксис

    T | summarize
         [  [ Column = ] Aggregation [ , ... ]]
         [ by
            [ Column = ] GroupExpression [ , ... ]]

**Аргументы**

* *Column* — необязательное имя итогового столбца. По умолчанию это имя, получаемое из выражения.
* *Aggregation* — вызов агрегатной функции, например `count()` или `avg()`, с именами столбцов в качестве аргументов. Список статистических функций см. ниже.
* *GroupExpression* — выражение для столбцов, предоставляющее набор уникальных значений. Обычно это либо имя столбца, которое уже предоставляет ограниченный набор значений, или функция `bin()` с числовым столбцом или столбцом времени в качестве аргумента. 

Если указать числовое или временное выражение без `bin()`, аналитика автоматически применит его с интервалом `1h` для временных значений и интервалом `1.0` для числовых.

Если выражение *GroupExpression* не указано, вся таблица будет суммирована в одну итоговую строку.

В предложении `by` необходимо использовать простой, а не динамический тип. Например, приведение типов `tostring` здесь обязательно.

    exceptions
	| summarize count()
      by tostring(customDimensions.ClientRequestId)

### Суммирование по столбцам с дискретными значениями

Запрос для показа среднего времени ответа на различные HTTP-запросы с разделением любых запросов, имеющих различные коды ответа:

    requests 
    | summarize count(), avg(duration) 
      by operation_Name, resultCode

![result](./media/app-analytics-aggregations/03.png)


* Статистические выражения (например count и avg) должны состоять из статистических функций, описанных в этой статье. Их аргументами могут быть любые скалярные функции.
* Выражения группирования (после "by") могут быть любыми скалярными выражениями, но они обладают более высокой производительностью, если содержат только имена полей.

### Суммирование по числовым столбцам

Если требуется выполнить группирование по непрерывному скаляру, такому как число или время, нужно использовать функцию `bin` (также известную как `floor`) для разделения непрерывного диапазона на группы.

    requests
    | summarize count() 
      by bin(duration, 1000)/1000

![result](./media/app-analytics-aggregations/04.png)

(Поле длительности запроса содержит числовое значение в миллисекундах.)
 
## Советы

* Перед `summarize` используйте `where` для удаления всех нежелательных строк.
 * Удалите значения null. Одно значение null в группе сделает результат статистической обработки нулевым. 

```

        requests 
        | where isnotnull(duration) 
        | summarize count(), avg(duration)
          by operation_Name
```

* Хотя можно предоставить произвольные выражения как для статистической обработки, так и группирования, более эффективным будет использовать простые имена полей или применить `bin()` к числовому полю.





## Примеры

Найти минимальную и максимальную временные отметки времени для всех записей в таблице "Действия". Предложение group by отсутствует, поэтому в выходных данных всего одна строка:

```

requests | summarize Min = min(timestamp), Max = max(timestamp)
```

|`Min`|`Max`
|---|---
|`1975-06-09 09:21:45` | `2015-12-24 23:45:00`



#### Длительность сеанса

Сеансы в журнале событий содержат несколько событий. Поиск начала и конца каждого сеанса путем определения самого раннего и самого позднего события в каждом сеансе:

```

    requests 
    | where isnotempty(session_Id)
    | summarize start=min(timestamp), stop=max(timestamp) by session_Id 
    | extend duration = bin(stop - start, 1s)
```

Операция `extend` добавляет столбец "Продолжительность" с помощью функции `bin` (также называемой `floor`) для округления продолжительности до ближайшей секунды.

![](./media/app-analytics-aggregations/minmax.png)

#### Пример: средняя продолжительность

Теперь найдем среднюю продолжительность сеанса для клиентов в разных городах:

```

    requests
    | where isnotempty(session_Id)
    | summarize start=min(timestamp), stop=max(timestamp) 
      by session_Id, client_City 
    | extend duration = stop - start
    | summarize duration_by_city=bin(avg(duration),1s) by client_City
    | top 50 by duration_by_city
```

Мы добавили столбец `client_City` в `by`, чтобы он прошел первую операцию статистической обработки. Если все события из одного клиентского сеанса произошли в одном и том же городе, то количество выходных строк в результате статистической обработки не увеличится.


![](./media/app-analytics-aggregations/durationcity.png)


#### Пример: 

Найдите самое занятое время дня в каждом городе. "Самое занятое время дня" — это время дня, в которое в среднем начинается максимальное количество сеансов.

```
requests  
| summarize start=min(timestamp) by session_Id, city=client_City 
| extend timeofday=start % 1d 
| summarize popularity=dcount(session_Id) by bin(timeofday, 1h), city 
| summarize argmax(popularity, *) by city  
| sort by max_pop_tod asc
```

## АГРЕГАТЫ

## любой 

    any(Expression)

Случайным образом выбирает одну строку группы и возвращает значение указанного выражения.

Это полезно, например, когда в каком-то столбце есть большое количество подобных значений (например, в столбце "текст ошибки") и вы хотите сделать выборку из этого столбца по уникальному значению составного ключа группы.

**Пример**

```

traces 
| where timestamp > now(-15min)  
| summarize count(), any(message) by operation_Name 
| top 10 by count_level desc 
```

<a name="argmin"></a> <a name="argmax"></a>
## argmin, argmax

    argmin(ExprToMinimize, * | ExprToReturn  [ , ... ] )
    argmax(ExprToMaximize, * | ExprToReturn  [ , ... ] ) 

Находит строку в группе, которая минимизирует (максимизирует) *ExprToMaximize* и возвращает значение *ExprToReturn* (или `*` для возврата всей строки).

**Совет**. Переданные столбцы переименовываются автоматически. Чтобы убедиться, что вы используете правильные имена, проверьте результаты с помощью `take 5`, прежде чем передавать результаты другому оператору.

**Примеры**

Показать время возникновения самого продолжительного запроса для каждого имени запроса:

    requests | summarize argmax(duration, timestamp) by name

Показать все подробности выполнения самого длинного запроса, а не только метку времени:

    requests | summarize argmax(duration, *) by name


Найти наименьшее значение каждой метрики с ее меткой времени и другими данными:

    metrics 
    | summarize minValue=argmin(value, *) 
      by name


![](./media/app-analytics-aggregations/argmin.png)
 


## avg

    avg(Expression)

Вычисляет среднее выражение *Expression* в группе.

## buildschema

    buildschema(DynamicExpression)

Возвращает минимальную схему, которая допускает все значения *DynamicExpression*.

В качестве параметра типа столбца нужно указать `dynamic` — массив или контейнер свойств.

**Пример**

    exceptions | summarize buildschema(details)

Результат:

    { "`indexer`":
     {"id":"string",
       "parsedStack":
       { "`indexer`": 
         {  "level":"int",
            "assembly":"string",
            "fileName":"string",
            "method":"string",
            "line":"int"
         }},
      "outerId":"string",
      "message":"string",
      "type":"string",
      "rawStack":"string"
    }}

Обратите внимание, что `indexer` используется для обозначения тех случаев, в которых необходимо использовать числовой индекс. Некоторые допустимые пути для этой схемы будут следующими (предполагается, что эти индексы в этом примере находятся в диапазоне):

    details[0].parsedStack[2].level
    details[0].message
    arraylength(details)
    arraylength(details[0].parsedStack)

**Пример**

Предположим, что входной столбец имеет три динамических значения:

| |
|---|
|`{"x":1, "y":3.5}`
|`{"x":"somevalue", "z":[1, 2, 3]}`
|`{"y":{"w":"zzz"}, "t":["aa", "bb"], "z":["foo"]}`


Итоговая схема будет следующей:

    { 
      "x":["int", "string"], 
      "y":["double", {"w": "string"}], 
      "z":{"`indexer`": ["int", "string"]}, 
      "t":{"`indexer`": "string"} 
    }

Схема указывает следующее:

* Корневой объект представляет собой контейнер с четырьмя свойствами x, y, z и t.
* Свойство x, которое может быть типа int или string.
* Свойство y, которое может либо типа double, либо другой контейнер со свойством w типа string.
* Ключевое слово ``indexer`` указывает, что z и t являются массивами.
* Каждый элемент в массиве z имеет тип int или string.
* t представляет собой массив строк.
* Каждое свойство является необязательным, и любой массив может быть пустым.

#### Модель схемы

Синтаксис возвращаемой схемы следующий:

    Container ::= '{' Named-type* '}';
    Named-type ::= (name | '"`indexer`"') ':' Type;
	Type ::= Primitive-type | Union-type | Container;
    Union-type ::= '[' Type* ']';
    Primitive-type ::= "int" | "string" | ...;

Они эквивалентны подмножеству аннотаций типов TypeScript, закодированному как динамическое значение. В Typescript пример схемы будет следующим:

    var someobject: 
    { 
      x?: (number | string), 
      y?: (number | { w?: string}), 
      z?: { [n:number] : (int | string)},
      t?: { [n:number]: string } 
    }


## count

    count([ Predicate ])

Возвращает число строк, для которых предикат *Predicate* равен `true`. Если предикат *Predicate* указан, возвращается общее число записей в группе.

**Совет по улучшению производительности**. Используйте `summarize count(filter)` вместо `where filter | summarize count()`.
   

## dcount

    dcount( Expression [ ,  Accuracy ])

Возвращает приблизительное количество различных значений выражений *Expr* в группе. (Чтобы получить список уникальных значений, используйте [`makeset`](#makeset).)

*Accuracy* (если указан) управляет балансом между скоростью и точностью.

 * `0` — наименее точное и самое быстрое вычисление.
 * `1` — вычисление по умолчанию, при котором точность и время расчета сбалансированы; вероятность ошибки составляет около 0,8 %.
 * `2` — наиболее точное и самое медленное вычисление; вероятность ошибки составляет около 0,4 %.

**Пример**

    pageViews 
    | summarize countries=dcount(client_City) 
      by client_CountryOrRegion

![](./media/app-analytics-aggregations/dcount.png)

## makelist

    makelist(Expr [ ,  MaxListSize ] )

Возвращает массив `dynamic` (JSON) всех значений выражений *Expr* в группе.

* *MaxListSize* — необязательное целочисленное ограничение для максимального количества возвращаемых элементов (по умолчанию — *128*).

## makeset

    makeset(Expression [ , MaxSetSize ] )

Возвращает массив `dynamic` (JSON) набора различных значений, которые выражение *Expr* принимает в группе. (Совет. Для подсчета только уникальных значений используйте [`dcount`](#dcount).)
  
*  *MaxSetSize* — необязательное целочисленное ограничение для максимального количества возвращаемых элементов (по умолчанию — *128*).

**Пример**

    pageViews 
    | summarize countries=makeset(client_City) 
      by client_CountryOrRegion

![](./media/app-analytics-aggregations/makeset.png)

Противоположную функцию см. в разделе об [операторе `mvexpand`](app-analytics-queries.md#mvexpand-operator).


## max, min

    max(Expr)

Вычисляет максимальное значение выражения *Expr*.
    
    min(Expr)

Вычисляет минимальное значение выражения *Expr*.

**Совет**. Эта функция дает сам минимальный или максимальный результат — например, наибольшую или наименьшую цену. Но если вы хотите получить в строке и другие столбцы, например имя поставщика с наименьшей ценой, используйте [argmin или argmax](#argmin-argmax).


<a name="percentile"></a> <a name="percentiles"></a>
## percentile, percentiles

    percentile(Expression, Percentile)

Возвращает оценку выражения *Expression* из указанного процентиля в группе. Точность зависит от плотности заполнения области процентиля.
    
    percentiles(Expression, Percentile1 [ , Percentile2 ] )

Похожа на `percentile()`, но вычисляет количество значений процентилей (это быстрее, чем вычислять каждый процентиль по отдельности).

**Примеры**


Значение `duration`, которое превышает 95 % значений выборки и меньше 5 % значений выборки, вычисляется для каждого запроса имени.

    request 
    | summarize percentile(duration, 95)
      by name

Чтобы выполнить вычисления для всей таблицы, пропустите "by...".

Одновременно вычислите несколько процентилей для других имен запросов:

    
    requests 
    | summarize 
        percentiles(duration, 5, 20, 50, 80, 95) 
      by name

![](./media/app-analytics-aggregations/percentiles.png)

Результаты показывают, что для запроса /Events/Index 5 % запросов были выполнены за 2,44 с, половина запросов — за 3,52 с, а 5 % — более чем за 6,85 с.


Вычисление множественной статистики:

    requests 
    | summarize 
        count(), 
        avg(Duration),
        percentiles(Duration, 5, 50, 95)
      by name

#### Ошибка оценки в процентилях

Статистическая оценка процентилей предоставляет приблизительное значение с помощью [T-Digest](https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf).

Некоторые важные моменты:

* Границы ошибки оценки изменяются со значением запрошенного процентиля. Наивысшая точность наблюдается на концах шкалы [0..100], процентили 0 и 100 — это точное минимальное и максимальное значения распределения. Точность постепенно снижается к середине шкалы. Она худшая на медиане и ограничена сверху 1 %. 
* Границы ошибки наблюдаются на диапазоне, а не на значении. Предположим, что функция percentile(X, 50) вернула значение Xm. Оценка гарантирует, что не менее 49 % и не более 51 % значений X меньше, чем Xm. Теоретического ограничения на разницу между Xm и X нет.

## stdev

     stdev(Expr)

Возвращает стандартное отклонение выражения *Expr* для группы.

## variance

    variance(Expr)

Возвращает вариацию выражения *Expr* для группы.

## sum

    sum(Expr)

Возвращает сумму выражения *Expr* для группы.




[AZURE.INCLUDE [app-analytics-footer](../../includes/app-analytics-footer.md)]

<!---HONumber=AcomDC_0330_2016-->