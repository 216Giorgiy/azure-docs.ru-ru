<properties 
	pageTitle="Операторы и выражения в аналитике Application Insights" 
	description="Короткий справочник операторов, используемых при создании запросов в аналитике Application Insights, мощном средстве поиска для Application Insights." 
	services="application-insights" 
    documentationCenter=""
	authors="alancameronwills" 
	manager="douge"/>

<tags 
	ms.service="application-insights" 
	ms.workload="tbd" 
	ms.tgt_pltfrm="ibiza" 
	ms.devlang="na" 
	ms.topic="article" 
	ms.date="03/07/2016" 
	ms.author="awills"/>



# Синтаксис запросов в аналитике Application Insights


[Аналитика Application Insights](app-analytics.md) — это мощная поисковая система для работы с данными телеметрии [Application Insights](app-insights-overview.md). На этих страницах описывается язык запросов аналитики Application Insights (AIQL).


[AZURE.INCLUDE [app-analytics-top-index](../../includes/app-analytics-top-index.md)]

Запрос на данные телеметрии выполняется с помощью ссылки на исходный поток, за которой следует конвейер фильтров. Например:


```AIQL
requests
| where client_City == "London" and timestamp > ago(3d)
| count
```
    
Каждый фильтр, для которого в качестве префикса используется символ конвейера `|`, — это экземпляр класса *operator* с определенными параметрами. Входные данные для оператора представлены таблицей, которая является результатом предыдущего конвейера. В большинстве случаев все параметры — это [скалярные выражения](app-analytics-scalars.md) для столбцов входных данных. В некоторых случаях параметры являются именами входных столбцов, но иногда параметр может быть второй таблицей. Результат запроса всегда является таблицей — даже если она включает только один столбец и одну строку.

В качестве префикса запроса может использоваться одно или несколько [предложений let](#let-clause). Эти предложения определяют скалярные значения, таблицы или функции, которые могут использоваться в запросе.

```AIQL

    let interval = 3d ;
    let city = "London" ;
    let req = (city:string) {
      requests
      | where client_City == city and timestamp > ago(interval) };
    req(city) | count
```

> `T` используется в приведенных ниже примерах запросов для обозначения предыдущего конвейера или исходной таблицы.

## Оператор count

Оператор `count` возвращает количество записей (строк) в наборе входных записей.

**Синтаксис**

    T | count

**Аргументы**

* *T* — табличные данные, записи которых будут посчитаны.

**Результаты**

Эта функция возвращает таблицу с одной записью и столбцом типа `long`. Значение единственной ячейки — количество записей в *T*.

**Пример**

```AIQL
requests | count
```



## Оператор extend

     T | extend duration = stopTime - startTime

Добавляет в таблицу один или несколько вычисляемых столбцов.


**Синтаксис**

    T | extend ColumnName = Expression [, ...]

**Аргументы**

* *T* — входная таблица.
* *ColumnName* — имена столбцов, которые будут добавлены. 
* *Expression* — вычисления для существующих столбцов.

**Результаты**

Копия входной таблицы с указанными дополнительными столбцами.

**Советы**

* Используйте [`project`](#project-operator) вместо этого оператора, если вам также нужно удалить или переименовать некоторые столбцы.
* Не используйте оператор `extend`, только чтобы получить более короткое имя, которое будет использоваться в длинном выражении. `...| extend x = anonymous_user_id_from_client | ... func(x) ...` 

    Собственные столбцы таблицы уже проиндексированы. Так как новое имя определяет дополнительный столбец, который не проиндексирован, скорее всего, запрос будет выполняться медленнее.

**Пример**

```AIQL
traces
| extend
    Age = now() - timestamp
```


## Оператор join

    Table1 | join (Table2) on CommonColumn

Объединяет строки в двух таблицах, сопоставляя значения из указанного столбца.


**Синтаксис**

    Table1 | join [kind=Kind] (Table2) on CommonColumn [, ...]

**Аргументы**

* *Table1* — левая часть объединенных данных.
* *Table2* — правая часть объединенных данных. Может быть выражением в виде вложенного запроса для вывода таблицы.
* *CommonColumn* — столбец с одинаковым именем в двух таблицах.
* *Kind* — определяет способ сопоставления строк в двух таблицах.

**Результаты**

Таблица со следующими элементами.

* Столбец для каждого столбца в каждой из двух таблиц, в том числе соответствующие ключи. В случае конфликта имен столбцы в правой части будут автоматически переименованы.
* Строка для каждого соответствия во входных таблицах. Соответствие — это выбранная в одной таблице строка, для которой во второй таблице есть соответствие (строка с одинаковым значением для всех полей `on`). 

* `Kind` (без определения)

    Каждому значению ключа `on` соответствует только одна строка из левой части. Выходные данные содержат по одной строке для каждого соответствия этой строки со строками из правой части.

* `Kind=inner`
 
     Строка в выходных данных для каждой комбинации соответствующих строк из левой и правой частей.

* `kind=leftouter` (или `kind=rightouter`, или `kind=fullouter`)

     Кроме внутренних соответствий есть также строка для каждой строки в левой и (или) правой части, даже при отсутствии соответствия. В этом случае ячейки выходных данных без соответствий содержат значения NULL.

* `kind=leftanti`

     Возвращает все записи из левой части, для которых нет соответствий в правой. Итоговая таблица содержит только столбцы из левой части.
 
Если есть несколько строк с одинаковыми значениями для этих полей, вы получите строки для всех комбинаций.

**Советы**

Обеспечить наилучшую производительность можно так.

* Используйте `where` и `project`, чтобы сократить количество строк и столбцов во входных таблицах (перед оператором `join`). 
* Если одна таблица меньше другой, используйте ее в качестве левой (перенаправленной) части объединенных данных.
* У объединяемых по соответствию столбцов должно быть одно имя. При необходимости переименуйте столбец в одной из таблиц с помощью оператора project.

**Пример**

Получите расширенные сведения о действиях из журнала, в котором некоторые записи указывают на время начала и конца действия.

```AIQL
    let Events = MyLogTable | where type=="Event" ;
    Events
    | where Name == "Start"
    | project Name, City, ActivityId, StartTime=timestamp
    | join (Events
           | where Name == "Stop"
           | project StopTime=timestamp, ActivityId)
        on ActivityId
    | project City, ActivityId, StartTime, StopTime, Duration, StopTime, StartTime

```

[О разновидностях оператора join](app-analytics-samples.md#join-flavors).

## Предложение let

**Табличное предложение let — присвоение имени таблице**

    let recentReqs = requests | where timestamp > ago(3d); 
    recentReqs | count

**Скалярное предложение let — присвоение имени значению**

    let interval = 3d; 
    requests | where timestamp > ago(interval)

**Лямбда-предложение let — присвоение имени функции**

    let Recent = 
       (interval:timespan) { requests | where timestamp > ago(interval) };
    Recent(3h) | count

Предложение let связывает имя с табличным результатом, скалярным значением или функцией. Предложение представлено префиксом для запроса, а сам запрос — это область привязки. (Let нельзя использовать для присвоения имен элементам, которые будут использоваться позже в ходе сеанса).

**Синтаксис**

    let name = scalar_constant_expression ; query

    let name = query ; query

    let name = (parameterName : type [, ...]) { plain_query }; query

* *type:* `bool`, `int`, `long`, `double`, `string`, `timespan`, `datetime`, `guid`, [`dynamic`](app-analytics-scalars.md#dynamic-type)
* *plain\_query* — запрос без префикса в виде предложения let.

**Примеры**




    let rows(n:long) = range steps from 1 to n step 1;
    rows(10) | ...


Самосоединение:

    let Recent = events | where timestamp > ago(7d);
    Recent | where name contains "session_started" 
    | project start = timestamp, session_id
    | join (Recent 
        | where name contains "session_ended" 
        | project stop = timestamp, session_id)
      on session_id
    | extend duration = stop - start 

## Оператор limit

     T | limit 5

Возвращает заданное количество строк из входной таблицы. Указать, какие записи будут возвращены, нельзя. (Чтобы вернуть определенные записи, используйте оператор [`top`](#top-operator)).

**Псевдоним** `take`

**Синтаксис**

    T | limit NumberOfRows


**Советы**

`Take` — простой и эффективный способ просмотреть пример результатов при работе в интерактивном режиме. Учтите, что этот оператор не используется для создания конкретных строк либо их создания в указанном порядке.

Есть неявное ограничение на количество строк, возвращаемых клиенту, даже если вы не используете оператор `take`. Чтобы снять это ограничение, используйте параметр `notruncation` клиентского запроса.



## Оператор mvexpand

    T | mvexpand listColumn 

Разворачивает список из ячейки с динамической типизацией (JSON) так, чтобы у каждой записи была отдельная строка. Все остальные ячейки в развернутой строке дублируются.

(См. также оператор [`summarize makelist`](#summarize-operator), который выполняет противоположную функцию).

**Пример**

Предположим, что у вас такая входная таблица:

|A:int|B:string|D:dynamic|
|---|---|---|
|1|"hello"|{"key":"value"}|
|2|"world"|[0,1,"k","v"]|

    mvexpand D

Результат будет таким:

|A:int|B:string|D:dynamic|
|---|---|---|
|1|"hello"|{"key":"value"}|
|2|"world"|0|
|2|"world"|1|
|2|"world"|"k"|
|2|"world"|"v"|


**Синтаксис**

    T | mvexpand  [bagexpansion=(bag | array)] ColumnName [limit Rowlimit]

    T | mvexpand  [bagexpansion=(bag | array)] [Name =] ArrayExpression [to typeof(Typename)] [limit Rowlimit]

**Аргументы**

* *ColumnName* — массивы именованного столбца в результате будут развернуты в несколько строк. 
* *ArrayExpression* — выражение, которое возвращает массив. Если используется этот аргумент, добавляется новый столбец, а существующий сохраняется.
* *Name* — имя нового столбца.
* *Typename* — приводит развернутое выражение к определенному типу.
* *RowLimit* — максимальное количество строк, созданных из каждой исходной строки. Значение по умолчанию — 128.

**Результаты**

Несколько строк для каждого значения в массиве в именованном столбце или выражении массива.

Тип развернутого столбца всегда динамический. Используйте такое приведение, как `todatetime()` или `toint()`, чтобы выполнить обычное или статическое вычисление значений.

Поддерживаются два режима развертывания контейнера свойств.

* `bagexpansion=bag` — контейнеры свойств развертываются в контейнеры свойств с одной записью. Это значение по умолчанию.
* `bagexpansion=array` — контейнеры свойств развертываются в структуры массива с двумя элементами (`[`*key*`,`*value*`]`), предоставляя универсальный доступ к ключам и значениям (а также, например, выполняя статистический подсчет числа различных объектов для имен свойств). 

**Примеры**


    exceptions | take 1 
    | mvexpand details[0]

Разбивает запись исключения на строки для каждого элемента в поле подробных сведений.

См. [диаграмму с количеством выполняющихся во времени действий](app-analytics-samples.md#concurrent-activities).


## Оператор parse

    T | parse "I am 63 next birthday" with "I am" Year:int "next birthday"

    T | parse kind=regex "My 62nd birthday" 
        with "My" Year:regex("[0..9]+") regex("..") "birthday"

Извлекает значения из строки. Можно использовать сопоставление простых или регулярных выражений.

Элементы в предложении `with`, в свою очередь, сопоставляются с исходной строкой. Каждый элемент обрабатывает часть исходного текста. Если это простая строка, курсор перемещается в рамках соответствия. Если это столбец с именем типа, курсор перемещается, пока есть возможность выполнять синтаксический анализ указанного типа. (Соответствия строк обрабатываются до тех пор, пока не будет найден следующий элемент). Если это регулярное выражение, ищется соответствие регулярному выражению (тип итогового столбца всегда будет строковым).

**Синтаксис**

    T | parse StringExpression with [SimpleMatch | Column:Type] ...

    T | parse kind=regex StringExpression 
        with [SimpleMatch | Column : regex("Regex")] ...

**Аргументы**

* *T* — входная таблица.
* *kind* — простое или регулярное выражение. По умолчанию используется простое выражение.
* *StringExpression* — выражение, результатом вычисления или преобразования которого является строка.
* *SimpleMatch* — строка, которая совпадает со следующей частью текста.
* *Column* — указывает новый столбец, которому будет назначено соответствие.
* *Type* — указывает, как анализировать следующую часть исходной строки.
* *Regex* — регулярное выражение для сопоставления следующей части строки. 

**Результаты**

Входную таблицу, развернутую в соответствии со списком столбцов.


**Примеры**

Оператор `parse` — это упрощенный способ развернуть (`extend`) таблицу с помощью нескольких приложений `extract` в одном выражении `string`. Это полезно, если в таблице есть столбец `string` с несколькими значениями, которые нужно разбить на отдельные столбцы (например, столбец, который создан с помощью инструкции трассировки — `printf` или `Console.WriteLine`).

В примере ниже предполагается, что столбец `EventNarrative` таблицы `StormEvents` содержит строки в виде `{0} at {1} crested at {2} feet around {3} on {4} {5}`. В ходе операции ниже будет развернута таблица с двумя столбцами: `SwathSize` и `FellLocation`.


|Описание события (EventNarrative)|
|---|
|12 декабря в 09:30 по восточному поясному времени уровень воды в реке Грин-Ривер в городе Браунсвилл поднялся до отметки 5,7 м. Паводковый уровень в городе Браунсвилл составляет 5,5 м, соответственно, произошло небольшое затопление. Вода преодолела заграждения и вышла из берегов, затопив часть сельскохозяйственных угодий, расположенных в низинах.|
|12 декабря в 17:00 по восточному поясному времени уровень воды в реке Роллинг-Форк-Ривер в городе Бостон поднялся до отметки 12 м. Паводковый уровень в городе Бостон составляет 10,7 м, соответственно, произошло небольшое затопление, покрывшее часть сельскохозяйственных угодий, расположенных в низинах.|
|16 декабря в 06:00 по восточному поясному времени уровень воды в реке Грин-Ривер в городе Вудбери поднялся до отметки 11,2 м. Паводковый уровень в городе Вудбери составляет 10,1 м, соответственно, на этом уровне произошло небольшое затопление, покрывшее часть пригородных территорий расположенных в низинах.|
|18 декабря в 07:00 по восточному поясному времени уровень воды в реке Огайо-Ривер в городе Телл-Сити поднялся до отметки 11,9 м. Паводковый уровень в городе Телл-Сити составляет 10,6 м, соответственно, на этом уровне река вышла из берегов. Трассу 66 в штате Индиана затопило между городами Рим и Дерби.|

```AIQL

StormEvents 
|  parse EventNarrative 
   with RiverName:string 
        "at" 
        Location:string 
        "crested at" 
        Height:double  
        "feet around" 
        Time:string 
        "on" 
        Month:string 
        " " 
        Day:long 
        "." 
        notImportant:string
| project RiverName , Location , Height , Time , Month , Day

```

|Название реки (RiverName)|Расположение|Высота|Время|Месяц|День|
|---|---|---|---|---|---|
|Грин-Ривер | Вудбери |11,2| 06:00 | Декабрь|16|
|Роллинг-Форк-Ривер | Бостон |12| 17:00 | Декабрь|12|
|Грин-Ривер | Браунсвилл |5,7| 09:30 | Декабрь|12|
|Огайо-Ривер | Телл-Сити |11,9| 07:00 | Декабрь|18|

Сопоставление также можно выполнять с использованием регулярных выражений. Результат будет тот же, но тип всех итоговых столбцов будет строковым.

```AIQL

StormEvents
| parse kind=regex EventNarrative 
  with RiverName:regex("(\\s?[a-zA-Z]+\\s?)+") 
  "at" Location:regex(".*") 
  "crested at " Height:regex("\\d+\\.\\d+") 
  " feet around" Time:regex(".*") 
  "on " Month:regex("(December|November|October)") 
   " " Day:regex("\\d+") 
   "." notImportant:regex(".*")
| project RiverName , Location , Height , Time , Month , Day
```


## Оператор project

    T | project cost=price*quantity, price

Выберите столбцы для включения, переименования или удаления, а затем вставьте новые вычисляемые столбцы. Порядок столбцов в результате определяется порядком аргументов. В результат будут включены только указанные в аргументах столбцы. Другие входные данные удаляются. (См. также `extend`.)


**Синтаксис**

    T | project ColumnName [= Expression] [, ...]

**Аргументы**

* *T* — входная таблица.
* *ColumnName* — имя столбца, которое будет отображено в выходных данных. Если аргумент *Expression* отсутствует, столбец с таким именем должен указываться во входных данных. 
* *Expression* — необязательное скалярное выражение, указывающее на входные столбцы. 

    Можно получить новый вычисляемый столбец с именем существующего столбца во входных данных.

**Результаты**

Таблица со столбцами, именованными как аргументы, а также количеством строк, соответствующим входной таблице.

**Пример**

В следующем примере показано несколько типов операций, которые можно выполнить с помощью оператора `project`. Входная таблица `T` содержит три столбца типа `int`: `A`, `B` и `C`.

```AIQL
T
| project
    X=C,                       // Rename column C to X
    A=2*B,                     // Calculate a new column A from the old B
    C=strcat("-",tostring(C)), // Calculate a new column C from the old C
    B=2*B                      // Calculate a new column B from the old B
```


[Другие примеры](app-analytics-samples.md#activities).


## Оператор range

    range LastWeek from ago(7d) to now() step 1d

Создает таблицу значений с одним столбцом. Обратите внимание: входные данные конвейера отсутствуют.

|LastWeek|
|---|
|2015-12-05 09:10:04.627|
|2015-12-06 09:10:04.627|
|...|
|2015-12-12 09:10:04.627|



**Синтаксис**

    range ColumnName from Start to Stop step Step

**Аргументы**

* *ColumnName* — имя одного столбца в выходной таблице.
* *Start* — наименьшее значение в выходных данных.
* *Stop* — наибольшее значение, созданное в выходных данных (или ограничение на максимальное значение, если аргумент *step* пропускает это значение).
* *Step* — разница между двумя последовательными значениями. 

Аргументы должны иметь числовые значения, значения даты или временного диапазона. Они не могут ссылаться на столбцы таблицы. (Если вы хотите вычислить диапазон на основе входной таблицы, используйте [*функцию* range](app-analytics-scalars.md#range), возможно, с [оператором mvexpand](#mvexpand-operator)).

**Результаты**

Таблица с одним столбцом с именем *ColumnName* и следующими значениями: *Start*, *Start* + *Step*, … и *Stop*.

**Пример**

```AIQL
range Steps from 1 to 8 step 3
```

Таблица с одним столбцом с именем `Steps`, типом `long` и значениями `1`, `4` и `7`.

**Пример**

    range LastWeek from bin(ago(7d),1d) to now() step 1d

Таблица со значениями в полночь за последние семь дней. Функция bin (floor) позволяет сократить время до начала каждого дня.

**Пример**

```AIQL
range timestamp from ago(4h) to now() step 1m
| join kind=fullouter
  (traces
      | where timestamp > ago(4h)
      | summarize Count=count() by bin(timestamp, 1m)
  ) on timestamp
| project Count=iff(isnull(Count), 0, Count), timestamp
| render timechart  
```

Пример того, как оператор `range` может использоваться для создания небольшой ad-hoc-таблицы измерений, которая затем используется для замены нулями значений, отсутствующих в исходных данных.

## Оператор reduce

    exceptions | reduce by outerMessage

Пытается сгруппировать похожие записи. Для каждой группы оператор выводит модель (`Pattern`) наилучшего описания этой группы, а также количество (`Count`) записей в этой группе.


![](./media/app-analytics-queries/reduce.png)

**Синтаксис**

    T | reduce by  ColumnName [ with threshold=Threshold ]

**Аргументы**

* *ColumnName* — анализируемый столбец. Он должен быть строкового типа.
* *Threshold* — пороговое значение в диапазоне {0..1}. Значение по умолчанию — 0,001. Для объемных входных данных пороговое значение должно быть небольшим. 

**Результаты**

Два столбца: `Pattern` и `Count`. Во многих случаях модель будет представлена полным значением из столбца. В некоторых случаях оператор может определить общие термины, заменив части переменных символом *.

Например, результат `reduce by city` может быть таким.

|Модель | Count |
|---|---|
| Сан * | 5182 |
| Сант * | 2846 |
| Москва | 3726 |
| * -на- * | 2730 |
| Париж | 27 163 |




## Оператор sort 

    T | sort by country asc, price desc

Сортирует по порядку строки входной таблицы (по одному или нескольким столбцам).

**Псевдоним** `order`

**Синтаксис**

    T  | sort by Column [ asc | desc ] [ `,` ... ]

**Аргументы**

* *T* — входные данные таблицы для сортировки.
* *Column* — столбец значений аргумента *T*, по которому выполняется сортировка. Значения должны быть представлены числовыми или строковыми значениями, значениями времени или даты.
* `asc` — сортировка по возрастанию. `desc` — сортировка по убыванию. Используется по умолчанию.

**Пример**

```AIQL
Traces
| where ActivityId == "479671d99b7b"
| sort by Timestamp asc
```
Все строки в таблице трассировки с определенным значением `ActivityId`, отсортированные по меткам времени.

## Оператор summarize

Создает таблицу, которая объединяет содержимое входной таблицы.
 
    requests
	| summarize count(), avg(duration), makeset(client_City) 
      by client_CountryOrRegion

В таблице отображено количество, средняя продолжительность запроса и группа городов каждой страны. Для каждой страны в выходных данных есть своя строка. В выходных столбцах отображено количество, средняя продолжительность, города и страна. Все остальные входные столбцы игнорируются.


    T | summarize count() by price_range=bin(price, 10.0)

В таблице отображено количество элементов с ценами в каждом интервале [0,10.0], [10.0,20.0] и т. д. Пример включает один столбец для подсчета и один столбец для диапазон цен. Все остальные входные столбцы игнорируются.

[Другие примеры](app-analytics-aggregations.md).



**Синтаксис**

    T | summarize
         [  [ Column = ] Aggregation [ `,` ... ] ]
         [ by
            [ Column = ] GroupExpression [ `,` ... ] ]

**Аргументы**

* *Column* — необязательное имя итогового столбца. По умолчанию это имя, получаемое из выражения.
* *Aggregation* — вызов [агрегатной функции](app-analytics-aggregations.md), например `count()` или `avg()`, с именами столбцов в качестве аргументов. См. [список агрегатных функций](app-analytics-aggregations.md).
* *GroupExpression* — выражение для столбцов, предоставляющее набор уникальных значений. Обычно это либо имя столбца, которое уже предоставляет ограниченный набор значений, или функция `bin()` с числовым или временным столбцом в качестве аргумента. 

Если указать числовое или временное выражение, не используя функцию `bin()`, аналитика AI автоматически применит его с интервалом 1 час (`1h`) для временных значений и интервалом `1.0` для числовых.

Если выражение *GroupExpression* не указано, вся таблица будет суммирована в одну итоговую строку.



**Результаты**

Входные строки объединяются в группы с одинаковыми значениями выражений `by`. Затем указанные агрегатные функции выполняют вычисления и создают строку для каждой группы. Результат содержит столбцы `by`, а также хотя бы один столбец для каждого вычисленного статистического выражения. (Некоторые агрегатные функции возвращают несколько столбцов).

Результат включает количество строк, соответствующее разным комбинациям значений `by`. Чтобы суммировать диапазоны числовых значений, используйте `bin()`. Так вы ограничите диапазоны дискретными значениями.

**Примечание.**

Хотя произвольные выражения можно предоставить как для статистических выражений, так и для выражений группирования, эффективнее использовать простые имена столбцов или применить `bin()` к числовому столбцу.



## Оператор take

Псевдоним оператора [limit](#limit-operator)


## Оператор top

    T | top 5 by Name desc

Возвращает первые *N* записей, отсортированных по указанным столбцам.


**Синтаксис**

    T | top NumberOfRows by Sort_expression [ `asc` | `desc` ] [, ... ]

**Аргументы**

* *NumberOfRows* — количество строк *T*, которое будет возвращено.
* *Sort\_expression* — выражение, по которому выполняется сортировка строк. Обычно это просто имя столбца. Можно указать несколько аргументов sort\_expression.
* `asc` или `desc` (по умолчанию) может использоваться как указатель направления выделения элементов в диапазоне: снизу вверх или сверху вниз.


**Советы**

Выражения `top 5 by name` внешне эквивалентны `sort by name | take 5`. Тем не менее, первое работает быстрее и в отличие от `take` всегда возвращает отсортированные результаты.


## Оператор union

     Table1 | union Table2, Table3

Принимает несколько таблиц и возвращает строки из них.

**Синтаксис**

    T | union [ kind= inner | outer ] [ withsource = ColumnName ] Table2 [ , ...]  

    union [ kind= inner | outer ] [ withsource = ColumnName ] Table1, Table2 [ , ...]  

**Аргументы**

* *Table1*, *Table2*…
 *  Имя таблицы, например `events`.
 *  Или выражение запроса, например `(events | where id==42)`.
 *  Набор таблиц, указанных с помощью подстановочного знака. Например, `E*` объединит в базе данных все таблицы, имена которых начинаются с `E`.
* `kind`: 
 * `inner` — результат содержит подмножество столбцов, которые являются общими для всех входных таблиц.
 * `outer` — результат содержит все столбцы, которые присутствуют в любых входных данных. Для ячеек, которые не были определены входной строкой, задается значение `null`.
* `withsource=`* ColumnName: * если аргумент указан, выходные данные будут содержать столбец с именем *ColumnName*, значение которого определяет для каждой строки передающую ее исходную таблицу.

**Результаты**

Таблица с количеством строк, соответствующим количеству строк во всех входных таблицах.

**Пример**

```AIQL

let ttrr = requests | where timestamp > ago(1h);
let ttee = exceptions | where timestamp > ago(1h);
union tt* | count
```
Объединение всех таблиц, имена которых начинаются с tt.


**Пример**

```AIQL

union withsource=SourceTable kind=outer Query, Command
| where Timestamp > ago(1d)
| summarize dcount(UserId)
```
Количество отдельных пользователей, которые за последний день создали событие `exceptions` или `traces`. В результате в столбце SourceTable будет указано одно из значений: Query или Command.

```AIQL
exceptions
| where Timestamp > ago(1d)
| union withsource=SourceTable kind=outer 
   (Command | where Timestamp > ago(1d))
| summarize dcount(UserId)
```

Это более эффективный способ получить тот же результат, так как перед объединением каждая таблица отфильтровывается.

## Оператор where

     T | where fruit=="apple"

Отфильтровывает таблицу для подмножества строк, которые удовлетворяют предикату.

**Псевдоним** `filter`

**Синтаксис**

    T | where Predicate

**Аргументы**

* *T* — табличные входные данные, записи которых будут отфильтрованы.
* *Predicate* — [выражение](app-analytics-scalars.md#boolean) `boolean` для столбцов *T*. Вычисляется для каждой строки в *T*.

**Результаты**

Строки в *T*, для которых *Predicate* — это `true`.

**Советы**

Обеспечить максимальную производительность можно так.

* **Используйте простые сравнения** между именами столбцов и константами. (Так как речь о константах, содержащихся в таблице, можно использовать функции `now()` и `ago()`, а также скалярные значения, назначенные с помощью [инструкции `let`](app-analytics-syntax.md#let-statements)).

    Например, лучше использовать `where Timestamp >= ago(1d)`, чем `where floor(Timestamp, 1d) == ago(1d)`.

* **Вводите сначала более простые элементы**. Если у вас есть несколько предложений, объединенных с помощью `and`, сначала вводите предложения, которые включают только один столбец. Это значит, что порядок `Timestamp > ago(1d) and OpId == EventId` является предпочтительным.


**Пример**

```AIQL
Traces
| where Timestamp > ago(1h)
    and Source == "Kuskus"
    and ActivityId == SubActivityIt 
```

Записи не старше 1 часа из источника Kuskus, у которых есть по два столбца с одним значением.

Обратите внимание: сравнение двух столбцов вводится в последнюю очередь, так как эта операция не предполагает использование индекса и запуска проверки.





[AZURE.INCLUDE [app-analytics-footer](../../includes/app-analytics-footer.md)]

<!---HONumber=AcomDC_0309_2016-->