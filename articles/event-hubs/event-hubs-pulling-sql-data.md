<properties
   pageTitle="Извлечение данных SQL в концентраторы событий Azure | Microsoft Azure"
   description="Общие сведения о примере импорта данных в концентраторы событий из SQL"
   services="event-hubs"
   documentationCenter="na"
   authors="spyrossak"
   manager="timlt"
   editor=""/>

<tags 
   ms.service="event-hubs"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="02/26/2016"
   ms.author="spyros;spyrossak" />

# Извлечение данных из SQL в концентратор событий Azure

Типичная архитектура приложения для обработки данных в реальном времени включает их первоначальное перемещение в концентратор событий Azure. Это может быть сценарий IoT, такой как контроль автомобильного трафика на различных участках шоссе, игровой сценарий, такой как мониторинг действий возбужденных участников соревнования, или промышленный сценарий, такой как мониторинг занятости здания. В этих случаях поставщики данных обычно представляют собой внешние объекты, формирующие временные ряды данных, которые необходимо собрать, проанализировать, хранить и обрабатывать, и на построение инфраструктуры для этих процессов может быть затрачено много усилий. Что делать, если вы хотите получить данные не от источника потоковой передачи данных, а, например, из базы данных и использовать эти данные совместно с другими потоками данных? Рассмотрим случай, в котором вы хотите использовать Azure Stream Analytics, обозреватель удаленных данных (RDX) или другое средство для анализа и выполнения действий над медленно изменяющимися данными из Microsoft Dynamics AX или пользовательской системы управления оборудованием. Чтобы решить эту проблему, мы написали небольшой облачный пример с открытым исходным кодом, который можно изменить и развернуть. Этот пример извлекает данные из таблицы SQL и передает их в концентратор событий Azure для использования в качестве входных данных для нижестоящих аналитических приложений. Учтите, что это редкий сценарий и он подразумевает действия, противоположные тем, которые обычно выполняются с концентраторами событий. Тем не менее, если вы находитесь в ситуации, когда это необходимо сделать, можете воспользоваться кодом в коллекции примеров Azure [здесь](https://azure.microsoft.com/documentation/samples/event-hubs-dotnet-import-from-sql/).

Обратите внимание, что код в данном случае представляет собой не более чем пример. Он **не** является рабочим приложением, не разрабатывался для применения в подобных средах и предназначен только для использования в качестве основы для собственного кода. Прежде чем настраивать конечную архитектуру, изучите все факторы, связанные с безопасностью, эффективностью, функциональностью и стоимостью такого решения.

## Структура приложений

Приложение создается на языке C#, а файл readme.md в образце содержит все сведения, необходимые для его изменения, создания и публикации. Общие сведения о том, как работает приложение, см. в следующих разделах.

Начнем с предположения, что у вас есть доступ к таблице SQL Azure. Кроме того, вам нужно настроить концентратор событий Azure и знать соответствующую строку подключения.

При запуске решения SqlToEventHub оно считывает из файла конфигурации (App.config) следующие данные, как описано в файле readme.md. Эти данные не требуют пояснений, например имя таблицы данных и т. д.

После того как приложение считывает конфигурационный файл, оно переходит в цикл, считывая содержимое таблицы SQL и помещая записи в концентратор событий, затем ожидает в течение заданного пользователем интервала ожидания и повторяет все это снова. Несколько моментов заслуживают отдельного упоминания:

1. В этом приложении предполагается, что таблица SQL обновляется каким-либо внешним процессом, а вы хотите отправлять все обновления в концентратор событий.
2. В таблице SQL должно быть поле, содержащее уникальный и возрастающий номер, например номер записи. Это может быть поле с именем "Id" или любое другое поле, которое увеличивается при любом добавлении записей в эту базу данных, например "Creation\_time" или "Sequence\_number". Приложение отмечает и сохраняет значение этого поля в каждой итерации. В каждом последующем проходе цикла приложение по существу запрашивает у таблицы все записи, в которых значение этого поля превышает значение, обнаруженное при последнем проходе цикла. Мы называем это последнее значение "смещением".
3. Для хранения смещений приложение при запуске создает таблицу "TableOffsets". Эта таблица создается с помощью запроса "CreateOffsetTableQuery", определенного в файле конфигурации. 
4. Существует несколько запросов, используемых для работы с таблицей смещений. Они определены как "OffsetQuery", "UpdateOffsetQuery" и "InsertOffsetQuery" в файле конфигурации. Изменять их не следует.
5. Наконец, запрос "DataQuery", определенный в файле конфигурации, предназначен для извлечения записей из таблицы SQL. В настоящее время в целях оптимизации количество записей в каждом проходе цикла ограничено 1000 верхних записей. Например, если с момента последнего запроса в базу данных было добавлено 25 000 записей, то выполнение запроса может занять некоторое время. Путем ограничения запроса в 1000 записей для каждого прохода цикла выполнение запросов значительно ускоряется. При выборе 1000 верхних записей в концентратор событий помещаются успешно полученные пакеты для 1000 записей.    

## Дальнейшие действия

Чтобы развернуть решение, клонируйте или скачайте приложение SqlToEventHub, измените файл App.config, выполните сборку и опубликуйте приложение. После публикации приложения вы сможете посмотреть, как оно работает, в классическом портале Azure в разделе "Облачные службы" и отслеживать события, поступающие в концентратор событий. Обратите внимание, что частота обновления будет определяться двумя параметрами: частотой обновления таблицы SQL и интервалом ожидания, который указан в файле конфигурации приложения.

<!---HONumber=AcomDC_0302_2016-->