<properties
	pageTitle="Оценка уровня совместимости | Microsoft Azure"
	description="Этапы и средства, позволяющие определить самый оптимальный уровень совместимости для вашей базы данных в Базе данных SQL Azure или на сервере Microsoft SQL Server"
	services="sql-database"
	documentationCenter=""
	authors="alainlissoir"
	manager="jhubbard"
	editor=""/>

<tags
	ms.service="sql-database"
	ms.workload="data-management"
	ms.devlang="NA"
	ms.tgt_pltfrm="NA"
	ms.topic="article"
	ms.date="05/20/2016"
	ms.author="alainl"/>


# Повышение производительности запросов с использованием уровня совместимости 130 в базе данных SQL Azure


В базе данных SQL Azure прозрачно работают множество баз данных на многих уровнях совместимости. При этом сохраняется и гарантируется обратная совместимость с соответствующей версией Microsoft SQL Server для всех клиентов.

Поэтому ничто не мешает пользователям, обновляющим любую существующую базу данных до новейшего уровня совместимости, воспользоваться преимуществами нового оптимизатора и обработчика запросов. Напоминаем, что версии SQL согласованы с уровнями совместимости по умолчанию следующим образом:

- 100 — в SQL Server 2008 и Базе данных SQL Azure версии 11;
- 110 — в SQL Server 2012 и Базе данных SQL Azure версии 11;
- 120 — в SQL Server 2014 и Базе данных SQL Azure версии 12;
- 130 — в SQL Server 2016 и <азе данных SQL Azure версии 12.


> [AZURE.IMPORTANT] Начиная с **середины июня 2016 года** в Базе данных SQL Azure у **создаваемых** баз данных будет уровень совместимости по умолчанию 130, а не 120.
> 
> Это *не* касается баз данных, созданных до середины июня 2016 года. Они сохранят текущий уровень совместимости (100, 110 и 120). Уровень совместимости баз данных, перенесенных из Базы данных SQL Azure версии 11 в версию 12, также не изменится.


В этой статье рассматриваются преимущества уровня совместимости 130 и то, как использовать эти преимущества. Здесь также рассматриваются возможные негативные последствия для производительности запросов существующих приложений SQL.


## Об уровне совместимости 130


Если вам нужно узнать текущий уровень совместимости базы данных, выполните следующую инструкцию Transact-SQL:


```
SELECT compatibility_level
	FROM sys.databases
	WHERE name = '<YOUR DATABASE_NAME>’;
```


Прежде чем обновить **созданные** базы данных до уровня совместимости 130, давайте рассмотрим это изменение на простых примерах запросов и узнаем возможные преимущества.

Обработка запросов в реляционных базах данных может быть очень сложной задачей. Чтобы понять специфические методы и поведение, понадобится привлечь сведения из таких областей, как информатика и вычислительная техника, а также математика. В этом документе содержимое намеренно упрощено, чтобы любой пользователь с минимальными техническими знаниями смог понять, на что влияет изменение уровня совместимости, и определить преимущества его изменения для приложений.

Давайте кратко рассмотрим основные возможности, доступные на уровне совместимости 130. Дополнительные сведения см. в разделе [Уровень совместимости инструкции ALTER DATABASE (Transact-SQL)](https://msdn.microsoft.com/library/bb510680.aspx). Ниже представлены краткие сведения:

- У операции INSERT в инструкции INSERT SELECT может быть несколько потоков или параллельный план. Раньше у нее был один поток.
- У запроса оптимизированной для памяти таблицы и табличных переменных теперь могут быть параллельные планы. Раньше у этой операции также был один поток.
- Теперь можно выполнять выборку статистики для оптимизированных для памяти таблиц, а также автоматически обновлять ее. Дополнительные сведения см. в подразделе о [In-Memory OLTP раздела "Новые возможности (компонент Database Engine)"](https://msdn.microsoft.com/library/bb510411.aspx#InMemory).
- Изменения в пакетном режиме и в режиме строки, связанные с индексами хранилища столбцов
  - Сортировка в таблице с индексом хранилища столбцов теперь выполняется в пакетном режиме.
  - Оконные статистические выражения, например инструкции TSQL LAG или LEAD, теперь работают в пакетном режиме.
  - Запросы к таблицам хранилища столбцов с несколькими отдельными предложениями работают в пакетном режиме.
  - Запросы со степенью параллелизма DOP=1 или с последовательным планом также выполняются в пакетном режиме.
- И, наконец, на уровне совместимости 120 улучшена оценка количества элементов. При переходе от более низкого уровня совместимости (т. е. 100 или 110) к уровню совместимости 130 также будут внедрены эти улучшения. Кроме того, они могут повысить производительность запросов для приложений.


## Использование уровня совместимости 130


Давайте создадим таблицы, индексы и случайные данные, чтобы испытать новые возможности. Примеры сценариев TSQL можно выполнять в SQL Server 2016 или в Базе данных SQL Azure. Тем не менее при создании базы данных Azure SQL выберите базу данных P2, так как требуется по крайней мере пара ядер, чтобы можно было выполнять несколько потоков и таким образом использовать преимущества этих возможностей.


```
-- Create a Premium P2 Database in Azure SQL Database

CREATE DATABASE MyTestDB
	(EDITION=’Premium’, SERVICE_OBJECTIVE=’P2′);
GO

-- Create 2 tables with a column store index on
-- the second one (only available on Premium databases)

CREATE TABLE T_source
	(Color varchar(10), c1 bigint, c2 bigint);

CREATE TABLE T_target
	(c1 bigint, c2 bigint);

CREATE CLUSTERED COLUMNSTORE INDEX CCI ON T_target;
GO

-- Insert few rows.

INSERT T_source VALUES
	(‘Blue’, RAND() * 100000, RAND() * 100000),
	(‘Yellow’, RAND() * 100000, RAND() * 100000),
	(‘Red’, RAND() * 100000, RAND() * 100000),
	(‘Green’, RAND() * 100000, RAND() * 100000),
	(‘Black’, RAND() * 100000, RAND() * 100000);

GO 200

INSERT T_source SELECT * FROM T_source;

GO 10
```


Теперь рассмотрим некоторые функции обработки запросов уровня совместимости 130.


## Параллельное выполнение операции INSERT


Ниже выполняется инструкция TSQL с операцией INSERT при уровне совместимости 120 и 130, то есть операция выполняется в однопоточной модели (120) и в многопоточной модели (130) соответственно.


```
-- Parallel INSERT … SELECT … in heap or CCI
-- is available under 130 only

SET STATISTICS XML ON;

ALTER DATABASE MyTestDB
	SET COMPATIBILITY_LEVEL = 120;
GO 

-- The INSERT part is in serial

INSERT t_target WITH (tablock)
	SELECT C1, COUNT(C2) * 10 * RAND()
		FROM T_source
		GROUP BY C1
	OPTION (RECOMPILE);

ALTER DATABASE MyTestDB
	SET COMPATIBILITY_LEVEL = 130
GO

-- The INSERT part is in parallel

INSERT t_target WITH (tablock)
	SELECT C1, COUNT(C2) * 10 * RAND()
		FROM T_source
		GROUP BY C1
	OPTION (RECOMPILE);

SET STATISTICS XML OFF;
```


Запросив фактический план запроса, а также просмотрев его графическое представление или содержимое в формате XML, можно определить выполняемую функцию оценки количества элементов. Сравнив планы на рис. 1, четко видно, что на уровне 120 операция INSERT выполняется в хранилище столбцов последовательно, а на уровне 130 — параллельно. Кроме того, обратите внимание, что в плане 130 изменился значок итератора и теперь на нем отображаются две параллельные стрелки. Это значит, что теперь итератор действительно выполняется в параллельном режиме. При необходимости выполнять операции INSERT большого объема производительность параллельного выполнения можно повысить, связав ее количеством ядер, доступных для базы данных. В зависимости от ситуации операция может выполняться в 100 раз быстрее.


*Рис. 1. Изменение режима выполнения операции INSERT с последовательного на параллельный на уровне совместимости 130*


![На рисунке 1](./media/sql-database-compatibility-level-query-performance-130/figure-1.jpg)


## Последовательный пакетный режим


Аналогичным образом при переходе на уровень совместимости 130 появляется возможность обработки строк данных в пакетном режиме. Во-первых, выполнение операций в пакетном режиме доступно только при наличии индекса хранилища столбцов. Во-вторых, в пакете обычно содержится около 900 строк. Он использует логику кода, оптимизированную для многоядерных ЦП и повышения пропускной способности памяти, а также по возможности напрямую использует сжатые данные хранилища столбцов. В этих условиях SQL Server 2016 может обработать около 900 строк одновременно, вместо 1 строки за раз. В результате общие накладные расходы на операции распределяются по всему пакету, за счет чего снижаются общие затраты на строку. Благодаря общему объему операций, а также сжатию хранилища столбцов снижается задержка при выполнении операции SELECT в пакетном режиме. Дополнительные сведения о хранилище столбцов и пакетном режиме см. в разделе [Описание индексов columnstore](https://msdn.microsoft.com/library/gg492088.aspx).


```
-- Serial batch mode execution

SET STATISTICS XML ON;

ALTER DATABASE MyTestDB
	SET COMPATIBILITY_LEVEL = 120;
GO

-- The scan and aggregate are in row mode

SELECT C1, COUNT (C2)
	FROM T_target
	GROUP BY C1
	OPTION (MAXDOP 1, RECOMPILE);
GO

ALTER DATABASE MyTestDB
	SET COMPATIBILITY_LEVEL = 130;
GO 

– The scan and aggregate are in batch mode,
-- and force MAXDOP to 1 to show that batch mode
-- also now works in serial mode.

SELECT C1, COUNT(C2)
	FROM T_target
	GROUP BY C1
	OPTION (MAXDOP 1, RECOMPILE);
GO

SET STATISTICS XML OFF;
```


Сравнив планы запроса на рис. 2 ниже, становится видно, что с уровнем совместимости изменился режим обработки. В результате при выполнении запросов на обоих уровнях совместимости большую часть времени обработки занимает обработка в режиме строк (86 %) в сравнении с пакетным режимом (14 %) (обработано 2 пакета). Увеличьте набор данных и преимущество станет еще больше.


*Рис. 2. Изменение режима выполнения операции SELECT с последовательного на пакетный на уровне совместимости 130*


![На рис. 2](./media/sql-database-compatibility-level-query-performance-130/figure-2.jpg)


## Пакетный режим при выполнении сортировки


Если применить аналогичный подход к операции сортировки, с переходом из режима строки (уровень совместимости 120) в пакетный режим (уровень совместимости 130) производительность операции SORT повышается по тем же причинам.


```
-- Batch mode on sort execution

SET STATISTICS XML ON;

ALTER DATABASE MyTestDB
	SET COMPATIBILITY_LEVEL = 120;
GO

-- The scan and aggregate are in row mode

SELECT C1, COUNT(C2)
	FROM T_target
	GROUP BY C1
	ORDER BY C1
	OPTION (MAXDOP 1, RECOMPILE);
GO

ALTER DATABASE MyTestDB
	SET COMPATIBILITY_LEVEL = 130;
GO

-- The scan and aggregate are in batch mode,
-- and force MAXDOP to 1 to show that batch mode
-- also now works in serial mode.

SELECT C1, COUNT(C2)
	FROM T_target
	GROUP BY C1
	ORDER BY C1
	OPTION (MAXDOP 1, RECOMPILE);
GO

SET STATISTICS XML OFF;
```


Сравнение на рис. 3 показывает, что на операцию сортировки в режиме строки приходится 81 % расходов, а в пакетном режиме — всего 19 % (соответственно 81 % и 56 % на саму сортировку).


*Рис. 3. Изменение режима выполнения операции SORT с режима строки на пакетный режим на уровне совместимости 130*


![Рис. 3](./media/sql-database-compatibility-level-query-performance-130/figure-3.png)


Очевидно, что эти примеры содержат только десятки тысяч строк. Это количество ничтожно мало по сравнению с объемом данных, доступных на большинстве серверов SQL Server сегодня. Просто попробуйте перенести полученные результаты на несколько миллионов строк. Так вы можете сэкономить несколько минут выполнения каждый день, что обуславливается характером рабочей нагрузки.


## Улучшение оценки количества элементов


Все базы данных SQL Server 2014, работающие на уровне совместимости 120 или выше, будут использовать новую функцию оценки количества элементов. Фактически оценка количества элементов — это логика, используемая для определения того, как сервер SQL Server выполнит запрос, исходя из оценочной стоимости этого запроса. Оценка вычисляется на основе входных данных статистики, связанных с объектами, которые содержатся в этом запросе. Фактически функции оценки количества элементов — это преимущественно средства оценки количества строк со сведениями о распределении значений, уникальных и повторяющихся значениях, содержащихся в таблицах и объектах, на которые ссылается запрос. Неправильная оценка может привести к избыточному выполнению дисковых операций ввода-вывода из-за нехватки емкости временно предоставляемого буфера памяти (т. е. к перебросу в TempDB) или к выбору последовательного плана выполнения вместо параллельного плана. И это лишь некоторые из последствий. Можно сделать вывод, что неправильная оценка может привести к общему снижению производительности выполнения запросов. С другой стороны точная оценка повышает производительность выполнения запросов.

Как уже сказано ранее, оптимизация и оценка запросов — сложные задачи. Дополнительные сведения о планах запросов и механизме оценки кратности см. в документе [Optimizing Your Query Plans with the SQL Server 2014 Cardinality Estimator](https://msdn.microsoft.com/library/dn673537.aspx) (Оптимизация планов запросов с помощью механизма оценки количества элементов SQL Server 2014).


## Определение используемой оценки количества элементов


Чтобы определить оценку количества элементов для запросов, давайте просто используем приведенные ниже примеры. Обратите внимание, что первый пример выполняется на уровне совместимости 110. При этом подразумевается использование старых функций оценки количества элементов.


```
-- Old CE

ALTER DATABASE MyTestDB
	SET COMPATIBILITY_LEVEL = 110;
GO

SET STATISTICS XML ON;

SELECT [c1]
	FROM [dbo].[T_target]
	WHERE [c1] > 20000;
GO

SET STATISTICS XML OFF;
```


По завершении выполнения выберите ссылку XML и просмотрите свойства первого итератора, как показано ниже. Обратите внимание, что для свойства CardinalityEstimationModelVersion задано значение 70. Это не означает, что установлен уровень совместимости базы данных SQL Server 7.0 (установлен уровень 110, как видно в инструкциях TSQL выше). Значение 70 просто представляет собой устаревшую функцию оценки количества элементов, доступную в SQL Server 7.0, которая не обновлялась до выпуска SQL Server 2014 (предоставляемого с уровнем совместимости 120).


*Рис. 4. Для свойства CardinalityEstimationModelVersion задано значение 70 при использовании уровня совместимости 110 и ниже*


![Рис. 4](./media/sql-database-compatibility-level-query-performance-130/figure-4.png)


Кроме того, можно изменить уровень совместимости на 130 и отключить использование новой функции оценки количества элементов, задав для LEGACY\_CARDINALITY\_ESTIMATION значение ON с помощью [ALTER DATABASE SCOPED CONFIGURATION](https://msdn.microsoft.com/library/mt629158.aspx). С точки зрения функции оценки количества элементов результат будет точно таким же, как и при использовании уровня 110. Но при этом используется самый новый уровень совместимости обработки запросов. Таким образом можно использовать преимущества новых возможностей обработки запросов, которые предоставляет самый новый уровень совместимости (т. е. пакетный режим) и по-прежнему при необходимости использовать старую функцию оценки количества элементов.


```
-- Old CE

ALTER DATABASE MyTestDB
	SET COMPATIBILITY_LEVEL = 130;
GO

ALTER DATABASE
	SCOPED CONFIGURATION
	SET LEGACY_CARDINALITY_ESTIMATION = ON;
GO

SET STATISTICS XML ON;

SELECT [c1]
	FROM [dbo].[T_target]
	WHERE [c1] > 20000;
GO

SET STATISTICS XML OFF;
```


При переходе на уровень совместимости 120 или 130 становится доступной новая функция оценки количества элементов. В этом случае для CardinalityEstimationModelVersion по умолчанию будет установлено значение в соответствии с уровнем 120 или 130, как видно ниже.


```
-- New CE

ALTER DATABASE MyTestDB
	SET COMPATIBILITY_LEVEL = 130;
GO

ALTER DATABASE
	SCOPED CONFIGURATION
	SET LEGACY_CARDINALITY_ESTIMATION = OFF;
GO

SET STATISTICS XML ON;

SELECT [c1]
	FROM [dbo].[T_target]
	WHERE [c1] > 20000;
GO

SET STATISTICS XML OFF;
```


*Рис. 5. Для свойства CardinalityEstimationModelVersion задано значение 130 при использовании уровня совместимости 130*


![Рис. 5](./media/sql-database-compatibility-level-query-performance-130/figure-5.jpg)


## Отличия старой и новой функции оценки количества элементов


Теперь давайте выполним более сложный запрос с INNER JOIN, предложением WHERE и несколькими предикатами. Сначала давайте взглянем на оценку числа строк, полученную с использованием старой функции оценки количества элементов.


```
-- Old CE row estimate with INNER JOIN and WHERE clause

ALTER DATABASE MyTestDB
	SET COMPATIBILITY_LEVEL = 130;
GO

ALTER DATABASE
	SCOPED CONFIGURATION
	SET LEGACY_CARDINALITY_ESTIMATION = ON;
GO

SET STATISTICS XML ON;

SELECT T.[c2]
	FROM
		           [dbo].[T_source] S
		INNER JOIN [dbo].[T_target] T  ON T.c1=S.c1
	WHERE
		S.[Color] = ‘Red’  AND
		S.[c2] > 2000  AND
		T.[c2] > 2000
	OPTION (RECOMPILE);
GO

SET STATISTICS XML OFF;
```


При эффективном выполнении этого запроса возвращается 200 704 строки. Для старой функции оценки количества элементов это значение составляет 194 284 строки. Как упоминалось ранее, очевидно, что результаты расчета количества строк также зависят от того, сколько раз выполнялись предыдущие примеры, так как с каждым разом таблицы примеров заполняются все больше и больше. Ясно, что кроме формы таблицы, данных и их корреляции предикаты в запросе также будут влиять на фактическую оценку.


*Рис. 6. Предполагаемое число строк — 194 284 (на 6 000 строк меньше требуемого количества — 200 704 строки)*


![Рис. 6](./media/sql-database-compatibility-level-query-performance-130/figure-6.jpg)


Теперь давайте аналогичным образом выполним тот же запрос с новой функцией оценки кратности.


```
-- New CE row estimate with INNER JOIN and WHERE clause

ALTER DATABASE MyTestDB
	SET COMPATIBILITY_LEVEL = 130;
GO

ALTER DATABASE
	SCOPED CONFIGURATION
	SET LEGACY_CARDINALITY_ESTIMATION = OFF;
GO

SET STATISTICS XML ON;

SELECT T.[c2]
	FROM
		           [dbo].[T_source] S
		INNER JOIN [dbo].[T_target] T  ON T.c1=S.c1
	WHERE
		S.[Color] = ‘Red’  AND
		S.[c2] > 2000  AND
		T.[c2] > 2000
	OPTION (RECOMPILE);
GO

SET STATISTICS XML OFF;
```


В таблице ниже видно, что расчетное количество строк составляет 202 877. Это значение намного ближе и больше, чем в случае старой функции оценки количества элементов.

*Рис. 7. Расчетное число строк — 202 877, а не 194 284*


![Рис. 7](./media/sql-database-compatibility-level-query-performance-130/figure-7.jpg)


На самом деле в результирующем наборе содержится 200 704 строки. (Все зависит от частоты выполнения запросов в предыдущих примерах. Важнее всего другое: так как TSQL использует инструкцию RAND(), фактические возвращаемые значения могут быть разными при каждом новом выполнении.) Таким образом в этом конкретном примере новая функция оценки количества элементов лучше справляется с оценкой количества строк, так как 202 877 гораздо ближе к 200 704, чем 194 284. Наконец, если изменить предикаты предложения WHERE на знаки равенства (а не на ">", например), результаты старой и новой функции оценки количества элементов могут отличаться еще сильнее в зависимости от возможного количества совпадений.

Очевидно, что в этом случае погрешность в 6000 строк от действительного количества — сравнительно небольшой объем данных в некоторых ситуациях. Теперь перенесите это на миллионы строк в нескольких таблицах и более сложные запросы. В некоторых случаях погрешность оценки может составлять миллионы строк. Поэтому риск выбора неподходящего плана или запроса недостаточного объема временно предоставляемого буфера, который влечет переброс в TempDB и дополнительные операции ввода-вывода, гораздо выше.

По возможности проводите такое сравнение на самых типичных запросах и наборах данных и убедитесь сами, насколько сильно изменяются старые и новые оценки. Некоторые оценки могут отдалиться от реальных показателей, а другие могут наоборот приблизиться к фактическому количеству строк, возвращенных в результирующих наборах. Все показатели зависят от формы запросов, характеристик базы данных Azure SQL, характера и размера наборов данных и соответствующих статистических данных. Если вы только создали экземпляр Базы данных SQL Azure, оптимизатору запросов понадобится сформировать сведения с нуля, а не повторно использовать статистику на основе предыдущих выполнений запроса. Таким образом оценки в большой степени зависят от контекста и выполняются для конкретного сервера и приложения. Стоит помнить об этом.


## Рекомендации


Несмотря на то, что для большинства рабочих нагрузок целесообразно использовать уровень совместимости 130, прежде чем внедрить уровень совместимости для рабочей среды у вас по сути есть три варианта:

1. Перейдите к уровню совместимости 130 и понаблюдайте за производительностью. Если производительность ухудшилась, можно просто восстановить исходный уровень совместимости или оставить уровень 130 и восстановить устаревшую версию функции оценки количества элементов (как описано выше, такое изменение может решить проблему).
2. Тщательно проверьте существующие приложения при аналогичной рабочей нагрузке, настройте и проверьте производительность до внесения изменений в рабочую среду. При возникновении проблем, указанных выше, всегда можно вернуться к исходному уровню совместимости или просто вернуться к старой версии функции оценки количества элементов.
3. Последний и самый новый вариант — использовать хранилище запросов. Это рекомендуемый вариант для современной среды. Чтобы упростить анализ запросов на уровне совместимости 120 или ниже и на уровне 130, лучше всего использовать хранилище запросов. Хранилище запросов доступно в последней версии Базы данных SQL Azure (версия 12). Оно позволяет устранить проблемы с производительностью запросов. Рассматривайте хранилище запросов как черный ящик для базы данных, который собирает и предоставляет подробные статистические сведения обо всех запросах. Это значительно упрощает экспертизу производительности за счет сокращения периода диагностики и устранения проблем. Дополнительные сведения см. в записи блога [Query Store: A flight data recorder for your database](https://azure.microsoft.com/blog/query-store-a-flight-data-recorder-for-your-database/) (Хранилище данных: черный ящик для базы данных).


В общем, если уже есть набор баз данных на уровне совместимости 120 или ниже и планируется переместить некоторые из них на уровень 130 или из-за того, что рабочая нагрузка автоматически подготавливает к работе новые базы данных, для которых вскоре будет по умолчанию установлен уровень 130, учитывайте следующее:

- Перед переходом к новому уровню совместимости в рабочей среде включите хранилище запросов. Дополнительные сведения см. в разделе [Change the Database Compatibility Mode and Use the Query Store](https://msdn.microsoft.com/library/bb895281.aspx) (Изменение уровня совместимости базы данных и использование хранилища запросов).
- Теперь необходимо проверить все критические рабочие нагрузки с использованием репрезентативных данных и запросов среды, аналогичной рабочей, и сравнить полученные показатели производительности с показателями производительности, сообщаемыми хранилищем запросов. При ухудшении производительности благодаря хранилищу запросов можно определить запросы, которые к этому привели, и использовать функцию принудительного применения плана хранилища (то есть закрепление плана). В этом случае вы точно сможете оставить уровень совместимости 130 и использовать предыдущий план запроса, как рекомендует хранилище запросов.
- Если вы хотите использовать новые функции и возможности Базы данных SQL Azure (которая работает под управлением SQL Server 2016), но ваша система чувствительна к изменениям уровня совместимости 130, в качестве последнего средства можно принудительно восстановить уровень совместимости, подходящий для рабочей нагрузки, с помощью инструкции ALTER DATABASE. Но учтите, что возможность закрепления плана хранилища запроса — лучший вариант, так как если не используется уровень 130, система по сути работает на уровне функций более старой версии SQL Server.
- При наличии мультитенантных приложений, охватывающих несколько баз данных, возможно, потребуется обновить логику подготовки к работе баз данных, чтобы установить один и тот же уровень совместимости во всех базах данных (в старых и новых). Производительность рабочей нагрузки приложения может изменяться, если некоторые базы данных работают на разных уровнях совместимости. Таким образом, требуется обеспечить согласованность уровней совместимости, чтобы всем клиентам предоставлялись одинаковые возможности. Обратите внимание, что это не обязательное требование. Все зависит от того, насколько уровень совместимости влияет на работу приложения.
- И, наконец, относительно оценки количества элементов. Так же, как и при изменении уровня совместимости, прежде чем перенести изменения в рабочую среду, рекомендуется проверить рабочую нагрузку в новых условиях, чтобы определить, появляются ли какие-либо преимущества для приложения при улучшении оценки количества элементов.


## Заключение


Производительность выполнения запросов можно повысить, используя Базу данных SQL Azure, что в свою очередь позволяет воспользоваться преимуществами усовершенствований SQL Server 2016. Все очень просто. Конечно же как и для любой новой функции необходимо провести достоверную оценку, чтобы определить точные условия, при которых достигается максимальная производительность рабочей нагрузки базы данных. Опыт показывает, что большинство рабочих нагрузок должны по крайней мере прозрачно выполняться на уровне совместимости 130 при использовании новых функций обработки запросов и оценки количества элементов. Говорят, что в действительности всегда находятся некоторые исключения. Комплексная экспертиза представляет собой важную оценку, позволяющую определить преимущества этих улучшений. И снова хранилище запросов может пригодиться для этой задачи.

По мере развития SQL Azure становится понятно, что в будущем следует ожидать создания уровня совместимости 140. Тогда мы расскажем о возможностях уровня совместимости 140 так же, как сделали это для уровня совместимости 130.

А пока не забывайте, что начиная с июня 2016 года уровень совместимости по умолчанию 120 для новых баз данных в Базе данных SQL Azure будет изменен на 130. Помните об этом.


## Ссылки


- [Новые возможности (компонент Database Engine)](https://msdn.microsoft.com/library/bb510411.aspx#InMemory)

- [Запись блога. Query Store: A flight data recorder for your database (Хранилище данных: черный ящик для базы данных). Автор: Борко Новакович (Borko Novakovic). 8 июня 2016 года](https://azure.microsoft.com/blog/query-store-a-flight-data-recorder-for-your-database/)

- [Уровень совместимости инструкции ALTER DATABASE (Transact-SQL)](https://msdn.microsoft.com/library/bb510680.aspx)

- [ALTER DATABASE SCOPED CONFIGURATION](https://msdn.microsoft.com/library/mt629158.aspx)

- [Compatibility Level 130 for Azure SQL Database V12](https://azure.microsoft.com/updates/compatibility-level-130-for-azure-sql-database-v12/) (Уровень совместимости 130 для Базы данных Azure SQL версии 12)

- [Optimizing Your Query Plans with the SQL Server 2014 Cardinality Estimator](https://msdn.microsoft.com/library/dn673537.aspx) (Оптимизация планов запросов с помощью механизма оценки количества элементов SQL Server 2014)

- [Описание индексов columnstore](https://msdn.microsoft.com/library/gg492088.aspx)

- [Запись блога. Повышение производительности запросов с использованием уровня совместимости 130 в базе данных SQL Azure. Автор: Ален Лиссуар (Alain Lissoir). 6 мая 2016 года](https://blogs.msdn.microsoft.com/sqlserverstorageengine/2016/05/06/improved-query-performance-with-compatibility-level-130-in-azure-sql-database/)



<!--
Improved Query Performance with Compatibility Level 130 in Azure SQL Database

May 6, 2016 by Alain Lissoir (AlainL), on GitHub 'alainlissoir'.

https://blogs.msdn.microsoft.com/sqlserverstorageengine/2016/05/06/improved-query-performance-with-compatibility-level-130-in-azure-sql-database/

..... Now, above.
....................
..... Soon, below?

CAPS / MSDN ideally, but instead on ACom:
.. # Assess effects of latest compatibility level on query performance, how to

sql-database-compatibility-level-query-performance-130.md

genemi = MightyPen , 2016-05-20  Friday  17:00pm
-->

<!---HONumber=AcomDC_0525_2016-->