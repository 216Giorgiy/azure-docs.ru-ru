<properties 
	pageTitle="Управление размещением сегментов" 
	description="Использование ShardMapManager, клиентской библиотеки гибких базы данных" 
	services="sql-database" 
	documentationCenter="" 
	manager="jeffreyg" 
	authors="sidneyh" 
	editor=""/>

<tags 
	ms.service="sql-database" 
	ms.workload="sql-database" 
	ms.tgt_pltfrm="na" 
	ms.devlang="na" 
	ms.topic="article" 
	ms.date="04/17/2015" 
	ms.author="sidneyh"/>

# Управление размещением сегментов
В среде сегментированных баз данных **карта сегментов** хранит информацию, позволяющую приложению связываться с корректной базой данных согласно значению **ключа сегментирования**. Понимание того, как построены эти карты, является ключевым для управления сегментами с применением клиентской библиотеки гибкой базы данных.

## Карты сегментов и сопоставление сегментов
 
### Поддерживаемые типы .net для ключей сегментирования

Средство эластичного масштабирования поддерживает следующие типы .Net Framework в качестве ключей сегментирования.

* целое число
* длинное целое число
* guid
* byte.  
* datetime;
* интервал времени
* datetimeoffset;

### Списочные и диапазонные карты сегментов
Карты сегментов могут быть созданы с использованием **списков индивидуальных величин сегментных ключей** или с использованием **диапазонов величин сегментных ключей**.

###Списочные карты сегментов
**Сегменты** содержат **шардлеты**, и сопоставление шардлетов сегментам производится с помощью карты сегментов. **Списочная карта сегментов** представляет ассоциацию между отдельными значениями ключа, определяющими шардлеты, и базами данных, обслуживающими сегменты. **Списки сопоставлений** являются явными (например, база данных A, раздел 1 соответствует), и различные значения ключа могут быть сопоставлены с одной базой данных (значения ключа 3 и 6 ссылки базы данных B). <table> <tr> <td>Ключ</td> <td>расположение сегментов</td> </tr> <tr> <td>1</td> <td>База данных Database_A</td> </tr> <tr> <td>3</td> <td>База данных Database_B</td> </tr> <tr> <td>4</td> <td>Database_C</td> </tr> <tr> <td>6</td> <td>База данных Database_B</td> </tr> <tr> <td>...</td> <td>...</td> </tr> </table>

### Диапазонные карты сегментов 
В **диапазонных картах сегментов**, диапазон ключей описывается парой **[Нижнее значение, Верхнее значение)** где *Нижнее значение* — минимальный ключ в диапазоне и *Верхнее значение* — первое значение, превышающее диапазон.

Например **[0, 100)** включает все целые числа, которые больше или равны 0 и меньше 100. Обратите внимание, что несколько диапазонов могут указывать на одну и ту же базу данных, а также поддерживаются перекрытие диапазонов (например, в примере ниже оба диапазона[100,200) и [400,600) указывают на базы данных C.) <table> <tr> <td><b>Диапазон ключей</b></td> <td><b>Расположение сегментов</b></td> </tr> <tr> <td>[1, 50)</td> <td>База данных Database_A</td> </tr> <tr> <td>[50, 100)</td> <td>База данных Database_B</td> </tr> <tr> <td>[100, 200)</td> <td>Database_C</td> </tr> <tr> <td>[400, 600)</td> <td>Database_C</td> </tr> <tr> <td>...</td> <td>...</td> </tr> </table>

Каждая из приведенных выше таблиц является примером объекта **ShardMap**. Каждая строка представляет упрощенный пример отдельного **PointMapping** (для сопоставления списка сегментов) или **RangeMapping** (для сопоставления диапазона сегментов) объекта.

## Диспетчер карты сегментов 

В клиентской библиотеке диспетчер карты сегментов — это набор карт сегментов. Данные, контролируемые объектом **ShardMapManager** .Net, хранятся в трех местах:

1. **Глобальная карта сегментов (GSM)**: при создании **ShardMapManager** укажите базу данных для использования в качестве репозитория для всех карт сегментов и сопоставлений сегментов. Для управления этой информацией автоматически создаются специальные таблицы и хранимые процедуры. Обычно это небольшая и база данных с простым доступом, но её не рекомендуется использовать для других прикладных задач. Таблицы расположены в специальной схеме с именем **__ShardManagement **. 
2. **Карта локального сегмента (LSM)**: каждая база данных, которая указывается как сегмент в карте сегментов, будет модифицирована для хранения небольших таблиц и специальных процедур, поддерживающих информацию карты сегментов, специфичную для данного сегмента. Эта информация повторяет информация, размещенную в GSM, но позволяет приложению проверять кэшированные данные карты сегментов без нагрузки на GSM; при помощи LSM приложение проверяет правильность кэшированного сопоставления. Таблицы, соответствующие LSM в каждом сегменте, находятся в схеме **__ShardManagement **.

3. **Кэш приложения**: каждый экземпляр приложения имеет доступ к объекту **ShardMapManager** и поддерживает локальный кэш в памяти своих сопоставлений. Хранятся использованные за последнее время сведения о маршрутизации.

## Создание объекта ShardMapManager
В приложении объект **ShardMapManager** создается с помощью готового шаблона. Метод **ShardMapManagerFactory.GetSqlShardMapManager** использует учетные данные (включая имя сервера и имя базы данных, содержащей GSM) в форме **ConnectionString** и возвращает экземпляр **ShardMapManager**.

**ShardMapManager** должен создаваться только один раз на каждый домен приложения, в код инициализации для приложения. **ShardMapManager** может содержать любое число карт сегментов. Многим приложениям достаточно одной карты сегментов, но в некоторых случаях применяются разные наборы баз данных, которые используются в разных схемах или имеют уникальное назначение. В таком случае желательно использовать несколько карт сегментов.

В этом коде приложение пытается открыть существующий **ShardMapManager**. Если объекты, представляющие Global **ShardMapManager** (GSM), еще не существуют в базе данных, клиентская библиотека создает их.

    // Try to get a reference to the Shard Map Manager via the Shard Map Manager database.  
    // If it doesn't already exist, then create it. 
    ShardMapManager shardMapManager; 
    bool shardMapManagerExists = ShardMapManagerFactory.TryGetSqlShardMapManager(
                                        connectionString, 
                                        ShardMapManagerLoadPolicy.Lazy, 
                                        out shardMapManager); 

    if (shardMapManagerExists) 
     { 
        Console.WriteLine("Shard Map Manager already exists");
    } 
    else
    {
        // Create the Shard Map Manager. 
        ShardMapManagerFactory.CreateSqlShardMapManager(connectionString);
        Console.WriteLine("Created SqlShardMapManager"); 

        shardMapManager = ShardMapManagerFactory.GetSqlShardMapManager(
            connectionString, 
            ShardMapManagerLoadPolicy.Lazy);

        // The connectionString contains server name, database name, and admin credentials 
        // for privileges on both the GSM and the shards themselves.
    } 
 

### Учетные данные для администрирования карты сегментов

Как правило, приложения для администрирования и обработки карт сегментов отличаются от приложений, использующих карты сегментов для маршрутизации подключений.

Для приложений, которые поддерживают карты сегментов (добавление или изменение сегментов, карт сегментов, сопоставления сегментов и т. д.) необходимо создать экземпляр **ShardMapManager** с использованием **учетных данных, имеющих права на чтение и запись в базе GSM и в каждой базе данных, служащей сегментом**. Учетные данные должны давать право записи в таблицы в GSM и LSM при вводе или изменения информации карт сегментов, а также право создавать таблицы LSM в новых сегментах.

### Воздействует только на метаданные 

Методы, используемые для заполнения и изменения данных **ShardMapManager**, не воздействуют на данные пользователя, хранящиеся в сегментах. К примеру, такие методы, как **CreateShard**, **DeleteShard**, **UpdateMapping** и т. д., влияют на только на метаданные карт сегментов. Они не удаляют, не добавляют и не изменяют пользовательские данные, содержащиеся в сегментах. На самом деле, эти методы предназначены для использования с отдельными операциями, с помощью которых вы создаете и удаляете фактические базы данных, либо перемещаете строки между сегментами для выравнивания сегментированной среды. (Инструмент **Разбиения и объединения**, входящий в состав средств эластичных баз данных, использует эти API-интерфейсы и управляет перемещением фактических данных между сегментами.)

## Заполнение карты сегментов: пример
 
Ниже приведен пример последовательности операций для заполнения конкретной карты сегментов. Этот код выполняет делает следующее:

1. При помощи диспетчера сопоставления сегментов создается новое сопоставление сегментов. 
2. В сопоставление сегментов добавляются метаданные двух разных сегментов. 
3. Добавляется ряд сопоставлений диапазонов ключей, отображается все содержимое сопоставление сегментов. 

Код программы написан таким образом, что весь метод можно безопасно повторить при возникновении неизвестной ошибки: перед попыткой создания сегмента или сопоставления при каждом запросе проверяется наличие такого сегмента или сопоставления. В следующем примере кода предполагается, что базы данных с именем **sample_shard_0**, **sample_shard_1** и **sample_shard_2** уже созданы на сервере **shardServer**.

    public void CreatePopulatedRangeMap(ShardMapManager smm, string mapName) 
        {            
            RangeShardMap<long> sm = null; 

            // check if shardmap exists and if not, create it 
            if (!smm.TryGetRangeShardMap(mapName, out sm)) 
            { 
                sm = smm.CreateRangeShardMap<long>(mapName); 
            } 

            Shard shard0 = null, shard1=null; 
            // check if shard exists and if not, 
            // create it (Idempotent / tolerant of re-execute) 
            if (!sm.TryGetShard(new ShardLocation(shardServer, "sample_shard_0"), out shard0)) 
            { 
                Shard0 = sm.CreateShard(new ShardLocation(shardServer, "sample_shard_0")); 
            } 

            if (!sm.TryGetShard(new ShardLocation(shardServer, "sample_shard_1"), out shard1)) 
            { 
                Shard1 = sm.CreateShard(new ShardLocation(shardServer, "sample_shard_1"));  
            } 

            RangeMapping<long> rmpg=null; 

            // Check if mapping exists and if not,
            // create it (Idempotent / tolerant of re-execute) 
            if (!sm.TryGetMappingForKey(0, out rmpg)) 
            { 
                sm.CreateRangeMapping(new RangeMappingCreationInfo<long> 
                    (new Range<long>(0, 50), shard0, MappingStatus.Online)); 
            } 

            if (!sm.TryGetMappingForKey(50, out rmpg)) 
            { 
                sm.CreateRangeMapping(new RangeMappingCreationInfo<long> 
                    (new Range<long>(50, 100), shard1, MappingStatus.Online)); 
            } 

            if (!sm.TryGetMappingForKey(100, out rmpg)) 
            { 
                sm.CreateRangeMapping(new RangeMappingCreationInfo<long> 
                    (new Range<long>(100, 150), shard0, MappingStatus.Online)); 
            } 

            if (!sm.TryGetMappingForKey(150, out rmpg)) 
            { 
                sm.CreateRangeMapping(new RangeMappingCreationInfo<long> 
                    (new Range<long>(150, 200), shard1, MappingStatus.Online)); 
            } 

            if (!sm.TryGetMappingForKey(200, out rmpg)) 
            { 
               sm.CreateRangeMapping(new RangeMappingCreationInfo<long> 
                   (new Range<long>(200, 300), shard0, MappingStatus.Online)); 
            } 

            // List the shards and mappings 
            foreach (Shard s in sm.GetShards()
                                    .OrderBy(s => s.Location.DataSource)
                                    .ThenBy(s => s.Location.Database))
            { 
               Console.WriteLine("shard: "+ s.Location); 
            } 

            foreach (RangeMapping<long> rm in sm.GetMappings()) 
            { 
                Console.WriteLine("range: [" + rm.Value.Low.ToString() + ":" 
                        + rm.Value.High.ToString()+ ")  ==>" +rm.Shard.Location); 
            } 
        } 
 
В качестве альтернативы для достижения такого же результата можно использовать скрипты PowerShell.

После заполнения карт сегментов можно создавать приложения для доступа к данным, либо приспособить для работы с этими картами существующие приложения. Заполнение и управление картами не требуется до момента, когда **макет карты** необходимо будет изменить.

## Маршрутизация, зависящая от данных 

Основная польза диспетчера карт сегментов проявляется при работе приложений, которым требуются подключения к базам данных для выполнения особых действий. В сегментированном приложении эти подключения должны устанавливаться с правильной целевой базой данных. Это называется **маршрутизацией, управляемой данными **. Для таких приложений необходимо объявить объект диспетчера карт сегментов в фабричном режиме, пользуясь учетными данными с доступом к базе данных GSM только для чтения. Учетные данные для подключения к нужной базе данных сегмента впоследствии будут передаваться в отдельных запросах подключения.

Обратите внимание, что эти приложения (с использованием **ShardMapManager**, открытого с учетными данными только для чтения) не смогут вносить изменения в карты и сопоставления. Для этого создайте специальные административные приложения или сценарии PowerShell, которые будут передавать учетные данные с более высокими правами доступа, как об этом говорилось ранее.

Дополнительные сведения см. в разделе [Управляемая данными маршрутизация](sql-database-elastic-scale-data-dependent-routing.md).

## Изменение карты сегментов 

Карту сегментов можно изменять различными способами. Любым из приведенных способов можно изменить метаданные сегментов и сопоставления сегментов, но нельзя изменить данные самих сегментов, создать или удалить базу данных. Некоторые из описанных ниже операций над сопоставлениями сегментов необходимо выполнять согласованно с административными действиями для физического перемещения данных, добавления и удаления баз данных, выступающих в качестве сегментов.

Эти методы работают совместно, как строительные блоки, доступные для изменения общего распределения данных в среде сегментированной базы данных.

* Для добавления или удаления сегментов используйте **CreateShard** и **DeleteShard**. 
    
    Для успешного выполнения этих операций необходимо указать существующие сервер и базу данных, которая играет роль целевого сегмента. Эти методы не изменяют сами базы данных, они изменяют только метаданные в сопоставлении сегментов.

* Для создания или удаления точек или диапазонов, сопоставляемых с сегментами, используйте **CreateRangeMapping**, **DeleteMapping**, **CreatePointMapping**.
    
    Один сегмент может быть сопоставлен со множеством разных точек или диапазонов. Эти методы изменяют только метаданные, но не изменяют данные, хранящиеся в сегментах. Если данные должны быть удалены из базы данных для обеспечения согласованности с операциями **DeleteMapping**, необходимо будет выполнить эти операции отдельно, но с использованием этих методов.

* Чтобы разбить существующий диапазон на два или слить смежные диапазоны в один, используйте **SplitMapping** и **MergeMappings**.

    Обратите внимание, что операции разбиения и объединения **не изменяют сегментов, с которыми сопоставляются ключевые значения**. Функция разбиения разделяет существующий диапазон на две части, но оставляет их обе привязанными к одному сегменту. Функция объединения соединяет два соседних диапазона, привязанных к одному сегменту, в один целый диапазон. Перемещение точек или самих диапазонов между сегментами необходимо координировать с помощью **UpdateMapping** в сочетании с фактическим перемещением данных. Можно использовать службу **разделения и слияния**, являющуюся частью средств гибких баз данных для координации изменений в карте сегментов с перемещением данных, при необходимости перемещения.

* Для повторного сопоставления (или перемещения) отдельных точек или диапазонов для разных сегментов используйте **UpdateMapping**.

    Поскольку данные придется перемещать из одного сегмента в другой для согласования с операциями **UpdateMapping**, будет необходимо выполнить перемещение отдельно, но с помощью этих методов.

* Для отображения в сети и вне сети используйте **MarkMappingOffline** и **MarkMappingOnline** для контроля состояния online сопоставления.

    Определенные операции на сопоставлении сегментов допустимы только в состоянии offline, включая **UpdateMapping** и **DeleteMapping**. Если сопоставление находится в автономном режиме, то запрос данных с ключом, указывающим на это сопоставление, возвратит ошибку. Кроме того, при первом переходе диапазона в автономный режим все соединения с соответствующим сегментом автоматически разрываются с целью предотвращения сбоев и обрыва результатов запросов, направленных на изменяемые диапазоны.

Сопоставления являются неизменяемыми объектами в .net. Все описанные выше методы, изменяющие сопоставление, также проверяют все ссылки на них в коде. Для облегчения выполнения последовательности операций, изменяющих состояние сопоставления, все методы, изменяющие сопоставление, возвращают новую ссылку сопоставления, так что операции могут быть объединены в цепочку. Например, для удаления существующего сопоставления в sm shardmap, содержащего ключ 25, можно выполнить следующее:

        sm.DeleteMapping(sm.MarkMappingOffline(sm.GetMappingForKey(25)));

## Добавление сегмента 

Часто необходимо, чтобы приложение просто добавило в существующую карту сегментов новые сегменты для обработки данных, поступление которых ожидается из новых ключей и диапазонов ключей. Например, приложение с сегментированием по идентификатору клиента должно подготовить новый сегмент для нового клиента, или при обработке данных с сегментированием по месяцам требуется создание нового сегмента перед началом следующего месяца.

Если новый диапазон ключей не входит в существующую карту и нет необходимости перемещения данных, добавление сегментов и привязка к нему нового ключа или диапазона становится довольно простой задачей. Дополнительные сведения о добавлении новых сегментов см. в разделе [Добавление нового сегмента](sql-database-elastic-scale-add-a-shard.md).

Однако для случая, когда требуется перемещение данных, необходимо использовать инструмент разбиения и объединения для выполнения перемещения данных между сегментами в сочетании с необходимым обновлением карты сегментов. Сведения об использовании инструмента разбиения и объединения см. в разделе [Обзор разбиения и объединения](sql-database-elastic-scale-overview-split-and-merge.md)

[AZURE.INCLUDE [elastic-scale-include](../../includes/elastic-scale-include.md)]
 

<!---HONumber=July15_HO2-->