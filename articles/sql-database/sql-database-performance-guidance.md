<properties
	pageTitle="Руководство по производительности базы данных SQL Azure"
	description="Эта статья содержит инструкции, которые помогут определить, подойдет ли тот или иной уровень служб для вашего приложения, а также рекомендации по настройке приложения для эффективного использования функциональности базы данных SQL Azure."
	services="sql-database"
	documentationCenter="na"
	authors="rothja"
	manager="jeffreyg"
	editor="monicar" />


<tags
	ms.service="sql-database"
	ms.devlang="na"
	ms.topic="article"
	ms.tgt_pltfrm="na"
	ms.workload="data-management"
	ms.date="10/13/2015"
	ms.author="jroth" />

# Руководство по производительности базы данных SQL Azure

## Обзор

База данных SQL Microsoft Azure поддерживает три [уровня служб](sql-database-service-tiers.md): Basic, Standard и Premium. Строго контролируя объем ресурсов базы данных SQL Azure и вторичных реплик, уровень служб Premium обеспечивает более предсказуемую производительность облачных приложений. База данных SQL Azure реализует эту концепцию для уровня Standard, обеспечивая прогнозируемую производительность для баз данных с меньшими требованиями к производительности по сравнению с уровнем служб Premium. Уровень служб Basic предназначен для сценариев с небольшими бюджетами и невысокими требованиями к производительности баз данных.

>[AZURE.NOTE]Поддержка уровней служб Business и Web будет прекращена в сентябре 2015 г. Дополнительные сведения см. в статье [Вопросы и ответы по остановке Web Edition и Business Edition](https://msdn.microsoft.com/library/azure/dn741330.aspx). Подробные сведения об обновлении существующих баз данных Web и Business до новых уровней служб см. в разделе [Обновление баз данных SQL уровня Web или Business до новых уровней служб](sql-database-upgrade-new-service-tiers.md).

В этой статье содержатся инструкции, которые помогут определить, подойдет ли тот или иной уровень служб для вашего приложения, а также рекомендации по настройке приложения для эффективного использования функциональности базы данных SQL Azure.

>[AZURE.NOTE]В ней приводятся рекомендации по производительности отдельной базы данных в базе данных SQL. Сведения о производительности пулов эластичных баз данных см. в статье [Вопросы цены и производительности для пула эластичных баз данных](sql-database-elastic-pool-guidance.md). Обратите внимание, что многие рекомендации и связанные с ними преимущества, описанные в этой статье, могут быть применимы к пулам эластичных баз данных.

**Авторы:** Конор Каннингем (Conor Cunningham), Кун Ченг (Kun Cheng), Ян Энгельсберг (Jan Engelsberg)

**Технические редакторы:** Морган Ослейк (Morgan Oslake), Джоан Марон (Joanne Marone), Кейт Элмор (Keith Elmore), Хосе Батиста-Нето (José Batista-Neto), Рохит Найак (Rohit Nayak)

## Общие сведения о базе данных SQL

Чтобы понять, как уровни служб Basic, Standard и Premium оптимизируют работу базы данных SQL Azure, необходимо иметь о ней хорошее общее представление. У базы данных SQL Azure есть несколько преимуществ. Одно из них заключается в том, что она позволяет избежать затяжной процедуры приобретения и установки оборудования. База данных SQL Azure позволяет создавать и удалять базы данных в обычном режиме: не нужно ждать, пока будет подтвержден заказ, доставлено оборудование, обновлены системы питания и охлаждения или выполнена установка. Корпорация Майкрософт берет на себя решение всех этих проблем и значительно сокращает время реализации за счет заблаговременной подготовки оборудования в соответствии с общим спросом в каждом из наших центров обработки данных. Это позволяет сэкономить недели или даже месяцы по сравнению с самостоятельным приобретением и развертыванием оборудования.

Кроме того, корпорация Майкрософт добавила несколько автоматических функций управления базой данных SQL Azure, например автоматический режим высокой доступности, балансировку нагрузки и встроенное управление.

### Автоматический режим высокой доступности (HA) 
 База данных SQL Azure поддерживает как минимум три реплики для каждой пользовательской базы данных и имеет логику автоматического синхронного распространения изменений на все реплики. Благодаря этому сбой одного сервера не приведет к потере данных. Более того, все реплики размещаются в разных аппаратных стойках, поэтому внезапное отключение питания или проблемы с сетью не окажут влияния на вашу базу данных. Наконец, предусмотрена логика автоматического воссоздания реплик при сбое одного из серверов: когда сервер выходит из строя, система автоматически воспроизводит нужные параметры работоспособности. Такие механизмы позволяют сэкономить время, которое в обычных условиях требуется на установку и настройку решений высокой доступности. Предварительно настроенное решение высокой доступности также позволяет избавиться от хлопот, связанных с построением решений для работы с критически важными данными традиционными методами.

### Балансировка нагрузки 
 В отличие от традиционных виртуальных машин, в базе данных SQL Azure есть механизм автоматической балансировки нагрузки между несколькими компьютерами. Балансировщик нагрузки динамически отслеживает использование ресурсов в кластере и перемещает реплики баз данных с одного сервера на другой для динамического и равномерного распределения нагрузки между несколькими пользователями. При этом расширяются возможности работы с базами данных по запросу. Теперь пользователь может рассматривать требования к производительности каждой базы данных отдельно друг от друга, так как подсистема балансировки нагрузки способна переносить перегруженные базы данных на другие серверы. Во время создания решений с несколькими базами данных эта логика позволяет клиенту сконцентрироваться на требованиях к отдельным базам данных, а не на ограничениях определенной виртуальной машины.

### Встроенное управление 
 База данных SQL Azure запускается как служба. Это означает, что для каждой базы данных есть заданные цели непрерывной работы, которые позволяют избежать длительных перерывов на обслуживание. Решение Майкрософт — это решение единого поставщика, поэтому по любым вопросам можно обращаться в один и тот же центр поддержки. Кроме того, Майкрософт постоянно обновляет службу, добавляя новые функции и возможности и совершенствуя рабочую среду. Обновления выполняются прозрачно и без простоев, то есть они интегрированы в обычный механизм отработки отказов в режиме высокой доступности. Это позволяет клиентам сразу использовать новые функции после их анонсирования, а не ждать, пока сервер будет обновлен в рамках планового перерыва на обслуживание.

Все эти возможности доступны для всех уровней служб, цены на использование которых начинаются всего с нескольких долларов США в месяц. Это значительно дешевле, чем приобретать и обслуживать собственный сервер, поэтому преимуществами Azure можно воспользоваться даже в рамках очень небольших проектов с весьма скромным бюджетом.

## Что изменилось в уровнях служб?

Корпорация Майкрософт в тесном сотрудничестве с рядом клиентов в рамках перехода к работе с базой данных SQL Azure разработала специальный подход, позволяющий учитывать особенности разных компаний. Было установлено, что набор новых функций очень понравился определенным категориям клиентов. Например, стартапы, разрабатывающие новые облачные службы, признавали, что масштабирование ресурсов по запросу и сокращение административных задач упрощали им жизнь и позволяли уделять больше времени самым важным бизнес-задачам. В то же время другие клиенты сталкивались с определенными трудностями, связанными с жесткими требованиями к производительности: в настоящее время база данных SQL Azure не подходит для работы с решениями многоуровневых баз данных. Отзывы показали, что некоторым клиентам понравилась идея переменной производительности, позволяющей снизить издержки, в то время как другие были больше заинтересованы в определенной гарантии производительности, чтобы у них всегда была возможность использовать свои базы данных максимально эффективно.

Майкрософт предоставляет три уровня служб, удовлетворяющих любые требования: Basic, Standard и Premium. У каждого уровня служб есть один или несколько уровней производительности, обеспечивающих предсказуемую работу баз данных. Их мощность исчисляется в [единицах пропускной способности базы данных (DTU)](sql-database-technical-overview.md#understand-dtus).

Уровень служб Basic предназначен для обеспечения предсказуемой почасовой производительности для каждой базы данных. Значение DTU базы данных Basic позволяет предоставлять достаточные ресурсы небольшим базам данных без большого количества параллельных запросов.

Уровень служб Standard предлагает улучшенную предсказуемость производительности и повышенную эффективность работы баз данных с множеством параллельных запросов, например для рабочих групп и веб-приложений. Данный уровень позволяет клиентам определять размер приложения на основе поминутной предсказуемой производительности.

Выделение ресурсов на уровне служб Premium — это посекундная предсказуемая производительность для каждой базы данных Premium. Уровень служб Premium позволяет клиентам определять размер приложения на основе пиковой загрузки базы данных и устраняет отклонения производительности, из-за которых небольшие запросы могут выполняться дольше, чем требуется, в операциях, чувствительных к задержке. Эта модель может значительно упростить разработку и проверку приложений, для которых большое значение имеют пиковая нагрузка, изменяемая производительность и задержка выполнения запросов. Теперь также возможен перенос некоторых локальных приложений без значительных изменений, поскольку среда во многом аналогична той, в которой они были изначально построены.

Как и уровень Standard, уровень служб Premium позволяет выбирать разные уровни производительности в зависимости от требуемой изоляции клиента.

С помощью настроек производительности уровней Standard и Premium клиенты могут платить только за потребляемые ресурсы с учетом изменений рабочей нагрузки. Например, если рабочая нагрузка базы данных повышается в начале учебного года, то можно повысить уровень производительности на этот период, а затем снизить его после снижения пиковой нагрузки. В результате клиенты минимизируют издержки и оптимизируют облачную среду в соответствии с сезонными потребностями бизнеса. Кроме того, такая модель подходит для поддержки жизненного цикла программных продуктов. Команда тестирования может увеличивать мощность на время тестирования и снижать ее после завершения тестирования. В результате этого оплачиваться будет только используемая мощность, а не ресурсы, которые используются редко. Такой порядок работы напоминает традиционную модель выделенного оборудования, к которой привыкли многие клиенты Майкрософт, использующие SQL Server. Теперь с базой данных SQL Azure сможет работать широкий спектр приложений.

Дополнительные сведения об уровнях служб, производительности и DTU см. в статье [Уровни служб Базы данных SQL](sql-database-service-tiers.md).

## Преимущества уровней служб

Хотя рабочие нагрузки могут отличаться, цель уровней служб — обеспечить высокую предсказуемость производительности на разных уровнях. Они помогают клиентам с высокими требованиями к ресурсам работать в более изолированной вычислительной среде.

### Сценарии, в которых применяется уровень Basic

- **Начало работы с базой данных SQL Azure**. Для приложений на первых этапах разработки часто не требуется высокий уровень производительности. Базы данных Basic предоставляют идеальную среду для разработки по низкой цене.
- **Базы данных с одним пользователем**. Для приложений, связывающих одного пользователя с базой данных, обычно не применяются строгие требования к параллелизму и производительности. Таким приложениям, вероятно, подойдет уровень служб Basic.

### Сценарии, в которых применяется уровень Standard

- **Базы данных с большим количеством параллельных запросов**. Приложениям, обслуживающим множество пользователей одновременно, таким как веб-сайты с умеренным объемом трафика или приложения для различных подразделений, требующие большого объема ресурсов подойдет уровень служб Standard.

### Сценарии, в которых применяется уровень Premium

- **Высокая пиковая нагрузка**. Приложения, которым для выполнения операций требуется высокая скорость процессора, большой объем памяти или широкие возможности ввода-вывода данных. Например, если известно, что работа базы данных задействует несколько ядер процессора на длительное время, то для такого приложения, скорее всего, подойдут базы данных уровня Premium.
- **Множество параллельных запросов**. Некоторые приложения обслуживают множество параллельных запросов, например веб-сайты с большим объемом трафика. Уровни служб Basic и Standard накладывают ограничения на число параллельных запросов. Приложения, которым требуется больше подключений, должны зарезервировать соответствующий размер, чтобы справиться с максимальным числом запросов.
- **Минимальная задержка**. Некоторым приложениям требуется минимальное время отклика базы данных. Если определенная хранимая процедура вызывается в рамках более широкого взаимодействия с клиентом, то в 99 % случаев отклик на такой запрос должен выполняться не более чем за 20 миллисекунд. Такое приложение будет эффективно работать с базой данных Premium, которая обеспечивает необходимую вычислительную мощность.

Уровень, который потребуется приложению, зависит от пиковой нагрузки для каждого измерения ресурсов. Некоторые приложения могут использовать небольшие объемы одного ресурса и значительные — другого.

Дополнительные сведения об уровнях служб см. в статье [Уровни служб Базы данных SQL](sql-database-service-tiers.md).

## Основные сведения об использовании ресурсов

На следующей диаграмме показано почасовое использование ресурсов процессора для базы данных Premium с уровнем производительности P2 в течение недели. Диаграмма начинается в понедельник, охватывает пять рабочих дней и выходные, когда нагрузка заметно ниже.

![Использование ресурсов базы данных SQL](./media/sql-database-performance-guidance/sql_db_resource_utilization.png)

Судя по этим данным, пиковая нагрузка на процессор составляет чуть более 50 % от максимальной нагрузки на уровне производительности P2 (полдень вторника). Если мощность процессора была главным фактором ресурсного профиля приложения, то клиент может решить, что P2 — оптимальный уровень производительности, который гарантирует стабильную работу с учетом средней нагрузки. Если ожидается рост нагрузки с течением времени, то целесообразно немного увеличить запас ресурсов, чтобы приложение не смогло достигнуть предела производительности. Это позволит избежать заметных пользователю ошибок на стороне базы данных в результате нехватки мощности для эффективной обработки запросов, особенно в средах с небольшими задержками (например, для базы данных приложения, создающего веб-страницы на основе запросов к базе данных).

Стоит отметить, что для других приложений эту диаграмму можно интерпретировать иначе. Например, если приложение обрабатывало данные по зарплате каждый день и получало ту же диаграмму, то выполнение таких «пакетных заданий» будет эффективным и на уровне производительности P1. P1 предоставляет 100 DTU, а P2 — 200 DTU. Это означает, что P1 обеспечивает производительность в два раза меньше, чем P2. Поэтому 50 % максимальной нагрузки на процессор на уровне P2 эквивалентно 100 % максимальной нагрузки на процессор на уровне P1. Если в работе приложения не возникает пауз, возможно, не имеет значения, сколько выполняется большое задание — 2 или 2,5 часа, а важно только, чтобы оно было завершено сегодня. Приложение такой категории вполне может использовать уровень Р1. Вы можете воспользоваться тем, что в определенное время дня использование ресурсов ниже и пиковая нагрузка может быть перенесена именно на этот период. Уровень производительности Р1 может отлично подойти для такого приложения (и сэкономить деньги), если задания будут завершаться вовремя в течение одного дня.

База данных SQL Azure предоставляет сведения об использовании ресурсов по каждой активной базе данных в представлении **sys.resource\_stats** для базы данных master на каждом сервере. Данные в таблице агрегируются каждые 5 минут. На уровнях служб Basic, Standard и Premium может потребоваться более 5 минут, прежде чем данные появятся в таблице, то есть эти данные лучше подходят для ретроспективного анализа, чем для анализа в режиме реального времени. При запросе представления **sys.resource\_stats** отображается журнал базы данных, позволяющий проверить, обеспечил ли выбранный уровень резервирования требуемую производительность. В следующем примере показано, как выглядят данные в этом представлении.

	SELECT TOP 10 * 
	FROM sys.resource_stats 
	WHERE database_name = 'resource1' 
	ORDER BY start_time DESC

![sys resource stats](./media/sql-database-performance-guidance/sys_resource_stats.png)

>[AZURE.NOTE]Некоторые столбцы из таблицы были усечены. Полное описание выводимых данных см. в разделе [sys.resource\_stats](https://msdn.microsoft.com/library/dn269979.aspx).

## Отслеживание использования ресурсов

В этом разделе описываются способы мониторинга использования ресурсов базы данных SQL Azure для сравнения фактически используемых ресурсов с разными уровнями производительности.

1. Представление каталога **sys.resource\_stats** содержит также ретроспективные сведения об использовании ресурсов на уровне базы данных. Например, с учетом использования ресурсов базы данных userdb1 за неделю можно выполнить следующий запрос:
	
		SELECT * 
		FROM sys.resource_stats 
		WHERE database_name = 'userdb1' AND 
		      start_time > DATEADD(day, -7, GETDATE())
		ORDER BY start_time DESC;
	
2. Чтобы определить, какой уровень производительности лучше всего подходит для конкретной рабочей нагрузки, нужно детализировать все ресурсные метрики: процессор, операции чтения и записи, количество рабочих потоков и количество сеансов. Ниже приводится измененный запрос к представлению sys.resource\_stats для получения отчета о средних и максимальных параметрах использования ресурсов.
	
		SELECT 
		    avg(avg_cpu_percent) AS 'Average CPU Utilization In Percent',
		    max(avg_cpu_percent) AS 'Maximum CPU Utilization In Percent',
		    avg(avg_physical_data_read_percent) AS 'Average Physical Data Read Utilization In Percent',
		    max(avg_physical_data_read_percent) AS 'Maximum Physical Data Read Utilization In Percent',
		    avg(avg_log_write_percent) AS 'Average Log Write Utilization In Percent',
		    max(avg_log_write_percent) AS 'Maximum Log Write Utilization In Percent',
		    avg(active_session_count) AS 'Average # of Sessions',
		    max(active_session_count) AS 'Maximum # of Sessions',
		    avg(active_worker_count) AS 'Average # of Workers',
		    max(active_worker_count) AS 'Maximum # of Workers'
		FROM sys.resource_stats 
		WHERE database_name = 'userdb1' AND start_time > DATEADD(day, -7, GETDATE());
	
3. С помощью средних и максимальных значений по каждому ресурсу можно оценить, насколько выбранный уровень производительности подходит для вашей рабочей нагрузки. В большинстве случаев средние значения из sys.resource\_stats дают хорошую основу для определения целевого резервирования. Эти сведения следует использовать в качестве отправной точки анализа. Например, если вы используете уровень служб Standard с уровнем производительности S2, средняя нагрузка на процессор (число операций чтения и записи) меньше 40 %, среднее число рабочих потоков меньше 50, а среднее количество сеансов меньше 200, для этой рабочей нагрузки может подойти уровень S1. Вы легко можете определить, отвечает ли уровень базы данных ограничениям рабочих потоков и сеансов. Чтобы узнать, можно ли для базы данных использовать более низкий уровень производительности с учетом нагрузки на процессор (количества операций чтения и записи), разделите число DTU более низкого уровня на DTU текущего уровня производительности и умножьте результат на 100:
	
	**DTU S1 / DTU S2 * 100 = 20 / 50 * 100 = 40**
	
	Результатом будет относительная разница производительности между двумя уровнями в процентах. Если ваша нагрузка не превышает полученное значение, для нее можно использовать более низкий уровень производительности. Однако необходимо рассмотреть все диапазоны значений использования ресурсов, а также определить (в процентном отношении), как часто рабочая нагрузка будет вписываться в рамки более низкого уровня производительности. Следующий запрос отображает процентное отношение на измерение ресурсов, основанное на 40-процентном пороге, вычисленном выше:
	
		SELECT 
		    (COUNT(database_name) - SUM(CASE WHEN avg_cpu_percent >= 40 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'CPU Fit Percent'
		    ,(COUNT(database_name) - SUM(CASE WHEN avg_log_write_percent >= 40 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Log Write Fit Percent'
		    ,(COUNT(database_name) - SUM(CASE WHEN avg_physical_data_read_percent >= 40 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Physical Data Read Fit Percent'
		FROM sys.resource_stats
		WHERE database_name = 'userdb1' AND start_time > DATEADD(day, -7, GETDATE());
	
	В зависимости от целевого уровня обслуживания (SLO) базы данных вы можете определить, подходит ли более низкий уровень производительности для вашей рабочей нагрузки. Если SLO составляет 99,9 % и указанный выше запрос возвращает значение больше 99,9 для всех трех измерений ресурсов, весьма вероятно, что рабочую нагрузку можно выполнять на более низком уровне производительности.
	
	Если посмотреть на процент, можно также понять, следует ли перейти на следующий уровень производительности для выполнения требований SLO. Например, для userdb1 мы видим следующую нагрузку за прошлую неделю:
	
	| Средняя нагрузка ЦП, % | Максимальная нагрузка ЦП, % |
	|---|---|
	| 24,5 | 100,00 |
	
	Средняя нагрузка процессора равна приблизительно одной четвертой ограничения уровня производительности, что вполне соответствует уровню производительности базы данных. Однако максимальное значение показывает, что база данных достигла ограничения уровня производительности. Требуется ли перейти на следующий уровень производительности? Снова необходимо определить, сколько раз рабочая нагрузка достигает 100 %, и сравнить это значение с SLO рабочей нагрузки базы данных.
	
		SELECT 
		(COUNT(database_name) - SUM(CASE WHEN avg_cpu_percent >= 100 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'CPU Fit Percent'
		,(COUNT(database_name) - SUM(CASE WHEN avg_log_write_percent >= 100 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Log Write Fit Percent’
		,(COUNT(database_name) - SUM(CASE WHEN avg_physical_data_read_percent >= 100 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Physical Data Read Fit Percent'
		FROM sys.resource_stats
		WHERE database_name = 'userdb1' AND start_time > DATEADD(day, -7, GETDATE());
	
	Если указанный выше запрос возвращает значение меньше 99,9 для любого из трех измерений ресурсов, следует перейти на следующий уровень или использовать методы оптимизации приложения для сокращения нагрузки на базу данных SQL Azure.
	
4. В таких расчетах также следует учитывать возможное увеличение рабочей нагрузки в будущем.

## Настройка приложения

В традиционной локальной среде SQL Server процесс изначального планирования загрузки часто отделен от процесса запуска приложения в рабочей среде. Другими словами, сначала происходит приобретение оборудования и связанных лицензий для запуска SQL Server и только потом — настройка производительности. При использовании базы данных SQL Azure обычно рекомендуется (и, поскольку счет выставляется ежемесячно, это также распространенный вариант) объединить процесс настройки и запуска приложения. Оплата только за используемые ресурсы позволяет клиентам настраивать приложение на использование минимального объема ресурсов, которые нужны в данный момент, а не выполнять избыточную подготовку согласно прогнозам будущего роста нагрузки на приложение. Часто такие прогнозы ошибочны, поскольку уходят слишком далеко в будущее. Обратите внимание, что некоторые пользователи предпочитают не настраивать приложение и вместо этого используют избыточную подготовку ресурсов оборудования. Такой подход может оказаться целесообразным, если клиент не желает изменять ключевое приложение в период высокой нагрузки. Настройка приложения позволяет минимизировать потребление ресурсов и снизить ежемесячные расходы благодаря новым уровням служб в базе данных SQL Azure.

### Характеристики приложения

Уровни служб предназначены для оптимизации стабильности и предсказуемости производительности приложения. Вместе с тем существуют рекомендации по настройке приложения с целью максимально эффективного использования доступных возможностей. Многие приложения получат значительный прирост производительности после простого перехода на более высокий уровень производительности, в то время как другие не начнут работать лучше без дополнительной настройки. Для повышения производительности при использовании функций базы данных SQL Azure приложения со следующими характеристиками должны пройти дополнительную настройку.

- **Приложения, которые обладают низкой производительностью в силу «нестабильной» работы**. В эту категорию входят приложения, которые совершают избыточные операции доступа к данным, несмотря на чувствительность к сетевым задержкам. Возможно, в такие приложения лучше внести изменения, сократив число операций доступа к данным в базе данных SQL Azure. Например, приложение можно улучшить за счет пакетной обработки неструктурированных запросов или перемещения запросов в хранимые процедуры. Дополнительные сведения см. в разделе «Пакетные запросы» ниже.
- **Базы данных с интенсивной рабочей нагрузкой, которые не могут работать на одном сервере**. Базы данных, которым требуется больше ресурсов, чем предоставляет уровень Premium, можно оптимизировать за счет масштабирования рабочей нагрузки. Дополнительные сведения см. в разделах «Сегментирование баз данных» и «Функциональное секционирование».
- **Приложения, содержащие неоптимальные запросы**. Если в приложениях (особенно на уровне доступа к данным) используются неоптимальные запросы, то более высокий уровень производительности, скорее всего, не улучшит их работу. К таким запросам относятся запросы, в которых нет предложения WHERE, отсутствуют индексы или используется устаревшая статистика. Больше пользы таким приложениям принесут стандартные методы оптимизации производительности. Дополнительные сведения см. в разделах «Недостающие индексы» и «Настройка запросов и указания запросов» далее.
- **Приложения с неоптимальной схемой доступа к данным**. Если в приложениях есть проблемы параллельного доступа к данным, например при одновременном доступе возникает блокировка, то более высокий уровень производительности, скорее всего, не улучшит их работу. Разработчики приложений могут попробовать снизить количество циклических запросов к базе данных SQL Azure за счет кэширования данных на стороне клиента с помощью службы Azure Caching Service или других технологий кэширования. См. раздел «Кэширование на уровне приложения» далее.

## Методы настройки

В этом разделе рассматриваются некоторые методы, которые можно использовать для настройки базы данных SQL Azure с целью повышения производительности приложения и использования наименьшего уровня производительности. Ряд методов совпадает с традиционными рекомендациями по настройке SQL Server, однако есть и специфические методы настройки базы данных SQL Azure. В некоторых случаях можно изучить использование ресурсов в SQL Server и воспользоваться традиционными методами в базе данных SQL Azure.

### Отсутствующие индексы
Одна из распространенных проблем производительности баз данных OLTP связана с физической схемой базы данных. Часто схемы базы данных создаются и поставляются без проверки масштабируемости по нагрузке или объему данных. К сожалению, производительность плана запроса, приемлемая при небольшом масштабе, может существенно снижаться при использовании объема данных уровня большой компании. Наиболее распространенный источник проблем связан с отсутствием индексов, которые позволили бы сортировать и ограничивать данные в запросе. Часто запрос должен сканировать всю таблицу, в то время как поиска по индексу было бы достаточно.

В следующем примере воспроизводится как раз такой случай.

	DROP TABLE dbo.missingindex;
	CREATE TABLE dbo.missingindex (col1 INT IDENTITY PRIMARY KEY, col2 INT);
	DECLARE @a int = 0;
	SET NOCOUNT ON;
	BEGIN TRANSACTION
	WHILE @a < 20000
	BEGIN
	    INSERT INTO dbo.missingindex(col2) VALUES (@a);
	    SET @a += 1;
	END
	COMMIT TRANSACTION;
	GO
	SELECT m1.col1 
	FROM dbo.missingindex m1 INNER JOIN dbo.missingindex m2 ON(m1.col1=m2.col1) 
	WHERE m1.col2 = 4;

![план запроса c отсутствующими индексами](./media/sql-database-performance-guidance/query_plan_missing_indexes.png)

База данных SQL Azure содержит функцию, которая указывает администраторам баз данных, как выявить условия, при которых индекс становится необходимым. Динамические административные представления (DMV), встроенные в базу данных SQL Azure, учитывают во время компиляции запроса случаи, когда индекс мог бы значительно снизить нагрузку, связанную с выполнением запроса. Во время выполнения запроса представление отслеживает, как часто выполнялся план запроса, а также вычисляет разницу между выполненным планом запроса и возможным планом с индексом. Это помогает администратору баз данных быстро выяснить, какие изменения схемы базы данных могли бы существенно уменьшить рабочую нагрузку для определенной базы данных.

Для оценки потенциально отсутствующих индексов можно использовать следующий запрос.

	SELECT CONVERT (varchar, getdate(), 126) AS runtime, 
	    mig.index_group_handle, mid.index_handle, 
	    CONVERT (decimal (28,1), migs.avg_total_user_cost * migs.avg_user_impact * 
	            (migs.user_seeks + migs.user_scans)) AS improvement_measure, 
	    'CREATE INDEX missing_index_' + CONVERT (varchar, mig.index_group_handle) + '_' + 
	              CONVERT (varchar, mid.index_handle) + ' ON ' + mid.statement + ' 
	              (' + ISNULL (mid.equality_columns,'') 
	              + CASE WHEN mid.equality_columns IS NOT NULL 
	                          AND mid.inequality_columns IS NOT NULL 
	                     THEN ',' ELSE '' END + ISNULL (mid.inequality_columns, '')
	              + ')' 
	              + ISNULL (' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement, 
	    migs.*, 
	    mid.database_id, 
	    mid.[object_id]
	FROM sys.dm_db_missing_index_groups AS mig
	INNER JOIN sys.dm_db_missing_index_group_stats AS migs 
	    ON migs.group_handle = mig.index_group_handle
	INNER JOIN sys.dm_db_missing_index_details AS mid 
	    ON mig.index_handle = mid.index_handle
	ORDER BY migs.avg_total_user_cost * migs.avg_user_impact * (migs.user_seeks + migs.user_scans) DESC

В данном случае предлагается следующий индекс:

	CREATE INDEX missing_index_5006_5005 ON [dbo].[missingindex] ([col2])  

После создания та же инструкция SELECT выбирает другой план, который теперь использует поиск вместо сканирования, и выполняется более эффективно, как показано в следующем плане запроса.

![план запроса c исправленными индексами](./media/sql-database-performance-guidance/query_plan_corrected_indexes.png)

Важно понимать, что пропускная способность общей среды обычно более ограниченна, чем пропускная способность выделенного сервера. Можно минимизировать избыточное число операций ввода-вывода и максимально использовать ресурсы каждого уровня производительности, доступные в рамках уровней служб базы данных SQL Azure. Улучшение физической схемы базы данных может значительно повысить отклик для определенных запросов, пропускную способность при параллельных запросах и минимизировать затраты, необходимые на выполнение одного запроса. Дополнительные сведения о динамических административных представлениях для отсутствующих индексов см. в разделе [sys.dm\_db\_missing\_index\_details](https://msdn.microsoft.com/library/ms345434.aspx).

### Настройка запросов и указания запросов
Оптимизатор запросов в базе данных SQL Azure очень напоминает традиционный оптимизатор запросов SQL Server. Многие рекомендации по настройке запросов и ограничения оптимизатора запросов применимы к базе данных SQL Azure. Настройка запросов в базе данных SQL Azure позволяет дополнительно снизить требования к ресурсам и фактические затраты, так как в результате можно будет использовать более низкий уровень производительности.

Распространенный пример работы с SQL Server, который также применим к базе данных SQL Azure, имеет отношение к параметрам, которые вносятся «на лету» во время компиляции с целью создания более оптимального плана. Такое внесение параметров «на лету» означает, что оптимизатор запросов пересчитывает текущее значение параметра во время компиляции запроса с целью создания более оптимального плана запроса. Хотя такая стратегия часто позволяет создать план запроса, значительно более быстрый, чем план, созданный без такой оптимизации, текущее поведение SQL Server и базы данных SQL Azure несовершенно. Возможны случаи, когда параметры не вносятся либо параметры вносятся, но созданный план не является оптимальным для полного набора параметров в рабочей нагрузке. Майкрософт включает указания запросов (директивы), которые позволяют указать, следует ли изменить поведение по умолчанию. Часто использование подсказок позволяет устранить проблемы, когда работа SQL Server и базы данных SQL Azure не подходят идеально для конкретной рабочей нагрузки.

В следующем примере показано, как обработчик запросов может создать план, который не является оптимальным в отношении производительности и требований к ресурсам, и как использование указаний запросов может снизить время выполнения запроса и используемые ресурсы для базы данных SQL Azure.

Ниже представлен пример настройки.

	DROP TABLE psptest1;
	CREATE TABLE psptest1(col1 int primary key identity, col2 int, col3 binary(200));
	
	DECLARE @a int = 0;
	SET NOCOUNT ON;
	BEGIN TRANSACTION
	WHILE @a < 20000
	BEGIN
	    INSERT INTO psptest1(col2) values (1);
	    INSERT INTO psptest1(col2) values (@a);
	    SET @a += 1;
	END
	COMMIT TRANSACTION
	CREATE INDEX i1 on psptest1(col2);
	GO
	
	CREATE PROCEDURE psp1 (@param1 int)
	AS
	BEGIN
	    INSERT INTO t1 SELECT * FROM psptest1 
	    WHERE col2 = @param1
	    ORDER BY col2;
	END
	GO
	
	CREATE PROCEDURE psp2 (@param2 int)
	AS
	BEGIN
	    INSERT INTO t1 SELECT * FROM psptest1 WHERE col2 = @param2
	    ORDER BY col2
	    OPTION (OPTIMIZE FOR (@param2 UNKNOWN))
	END
	GO
	
	CREATE TABLE t1 (col1 int primary key, col2 int, col3 binary(200));
	GO

Установочный код создает таблицу, которая содержит неравномерное распределение данных. Оптимальный план запроса зависит от выбранного параметра. К сожалению, при кэшировании плана запрос не всегда повторно компилируется в зависимости от наиболее подходящего значения, то есть может получиться так, что будет кэширован неоптимальный план. После этого код создает две хранимые процедуры, которые идентичны друг другу, за исключением того, что одна из них содержит специальное указание запроса (см. пояснения ниже).

**Пример (часть 1).**

	-- Prime Procedure Cache with scan plan
	EXEC psp1 @param1=1;
	TRUNCATE TABLE t1;
	
	-- Iterate multiple times to show the performance difference
	DECLARE @i int = 0;
	WHILE @i < 1000
	BEGIN
	    EXEC psp1 @param1=2;
	    TRUNCATE TABLE t1;
	    SET @i += 1;
	END

**Пример (часть 2; подождите 10 минут, прежде чем проверять эту часть, чтобы получить очевидную разницу в итоговых данных телеметрии).**

	EXEC psp2 @param2=1;
	TRUNCATE TABLE t1;
	
	DECLARE @i int = 0;
	WHILE @i < 1000
	BEGIN
	    EXEC psp2 @param2=2;
	    TRUNCATE TABLE t1;
	    SET @i += 1;
	END

Каждая часть примера пытается выполнить параметризованную вставку 1000 раз (это необходимо для создания достаточной нагрузки). При выполнении хранимых процедур обработчик запросов учитывает значение параметра, переданное в процедуру во время первой компиляции (то, что называется «вставкой на лету»). Результирующий план кэшируется и используется в дальнейшем, даже если значение параметра будет другим. То есть оптимальный план может подойти не для всех случаев. Иногда нужно указывать оптимизатору, какой план выбрать, чтобы этот план был относительно универсальным, а не просто подходящим для определенного случая. В этом примере изначальный план создает сканирование, при котором считываются все строки, и находится значение, которое отвечает параметру.

![Настройка запросов](./media/sql-database-performance-guidance/query_tuning_1.png)

Так как процедура выполнена со значением 1, результирующий план был оптимальным для 1, но неоптимальным для всех остальных значений в таблице. Если пользователь будет выбирать каждый план случайно, скорее всего, результат не будет оптимальным, так как план будет выполняться медленнее и задействовать больше ресурсов.

Выполнение теста с параметром SET STATISTICS IO ON показывает работу логического сканирования. Видно, что план выполнил 1148 операций чтения, то есть его эффективность очень низкая, особенно если нужно вернуть только одну строку.

![Настройка запросов](./media/sql-database-performance-guidance/query_tuning_2.png)

Во второй части примера используется указание запроса, которое позволяет дать оптимизатору инструкцию использовать конкретное значение во время компиляции. В данном случае обработчик запросов должен пропустить переданное значение и вместо этого предположить значение UNKNOWN, то есть значение, которое будет иметь среднюю частоту в таблице (независимо от искажения распределения). В результате мы получим план на основе поиска, который работает быстрее и использует меньше ресурсов, чем план из части 1.

![Настройка запросов](./media/sql-database-performance-guidance/query_tuning_3.png)

Эффект можно увидеть в таблице **sys.resource\_stats** (примечание: между временем выполнения теста и появлением данных в таблице будет задержка). В этом примере первая часть выполнялась в рамках временного окна 22:25:00, а вторая — в 22:35:00. Обратите внимание, что в первой части было использовано больше ресурсов, чем во второй (в силу повышения эффективности).

	SELECT TOP 1000 * 
	FROM sys.resource_stats 
	WHERE database_name = 'resource1' 
	ORDER BY start_time DESC

![Настройка запросов](./media/sql-database-performance-guidance/query_tuning_4.png)

>[AZURE.NOTE]Использованный пример достаточно прост, однако последствия неоптимальных параметров могут быть существенными, особенно для больших баз данных. Разница для быстрых и медленных запросов в некоторых случаях может достигать от нескольких секунд до нескольких часов.

Рекомендуется просмотреть таблицу **sys.resource\_stats**, чтобы определить, использует ли один тест больше ресурсов, чем другой. При сравнении данных нужно закладывать между тестами достаточно времени, чтобы они не группировались вместе в одном 5-минутном окне в представлении **sys.resource\_stats**. Кроме того, обратите внимание, что цель расчетов — минимизировать общее использование ресурсов, а не пиковую нагрузку. Обычно оптимизация части кода с целью уменьшения задержки выполнения также приводит к сокращению использования ресурсов. Убедитесь, что вносимые изменения действительно нужны и не сказываются на работе приложения отрицательным образом при использовании указаний запроса.

Если рабочая нагрузка содержит ряд повторяющихся запросов, то часто бывает целесообразно отследить и проверить оптимальность планов, так как это, скорее всего, позволит уменьшить минимальный размер ресурсов, необходимых базе данных. После проверки выборочный пересмотр планов позволит убедиться, что их производительность со временем не ухудшилась. Дополнительные сведения об указаниях запросов см. в разделе [Указания запросов (Transact-SQL)](https://msdn.microsoft.com/library/ms181714.aspx).

### Сегментирование баз данных
Поскольку база данных SQL Azure работает на неспециализированном оборудовании, ограничения для одной базы данных будут ниже, чем в традиционной локальной среде SQL Server. В силу этого ряд пользователей использует сегментирование баз данных, если размеры одной базы данных в базе данных SQL Azure недостаточны. Большинство клиентов, реализующих сегментирование в базе данных SQL Azure на сегодняшний день, разбивают данные одного измерения на несколько баз данных. Этот подход предполагает, что часто приложения OLTP выполняют транзакции, которые применимы к одной строке или небольшой группе строк внутри одной схемы. Например, если база данных содержит сведения о заказчике, заказе и цене (как можно увидеть в стандартном примере базы данных Northwind, который используется для SQL Server), эти данные можно разбить на несколько баз, группируя все сведения и обеспечивая целостность данных. Приложение должно разбивать заказчиков по разным базам данных и эффективно распределять нагрузку. В результате можно не только не превышать существующее ограничение максимального размера базы данных, но и обрабатывать в базе данных SQL Azure рабочие нагрузки, которые существенно превышают ограничения различных уровней производительности, если каждая отдельная база данных будет работать в соответствии с ограничениями DTU.

Несмотря на то что сегментирование баз данных не снижает общую нагрузку на решение, такой подход будет эффективен для очень крупных решений, в которых используется несколько баз данных. Он также позволяет запускать базы данных на разных уровнях производительности, чтобы добиться максимальной эффективности каждой из них.

Обратите внимание, что база данных SQL теперь предоставляет библиотеку для упрощения сегментирования. Дополнительные сведения см. в статье [Обзор клиентской библиотеки для эластичных баз данных](sql-database-elastic-database-client-library.md).

### Функциональное секционирование
Пользователи SQL Server часто объединяют несколько функций в одной базе данных. Например, если приложение содержит логику управления запасами склада, то база данных может содержать логику, связанную с запасами, отслеживанием заказов на покупку, хранимыми процедурами, индексированными представлениями ежемесячных отчетов и т. д. Такой подход позволяет легко администрировать базы данных и выполнять такие операции как резервное копирование. Однако в этом случае нужно также умело распределять пиковую нагрузку функций одного приложения.

В рамках масштабируемой архитектуры внутри базы данных SQL Azure часто лучше разнести функции приложения по разным базам данных. Это позволит масштабировать отдельные базы данных независимо друг от друга. По мере повышения нагрузки на приложение (и, как следствие, нагрузки на базу данных) администратор сможет определить уровни производительности отдельно для каждой функции одного приложения. Такая архитектура позволит приложению расширяться за пределы одного сервера за счет распределения нагрузки по разным серверам.

### Пакетные запросы
Для приложений, которые обращаются к данным путем частых неструктурированных запросов, скорость взаимодействия по сети между приложением и базой данных SQL Azure сильно падает. Даже если приложение и база данных SQL Azure находятся в одном центре обработки данных, сетевая задержка между ними может вырасти пропорционально числу операций доступа к данным. Чтобы снизить циклические операции, разработчик приложения должен создавать пакетные запросы, включающие несколько неструктурированных запросов, и компилировать их в хранимые процедуры. Пакетная обработка, включающая несколько неструктурированных запросов, отсылается в базу данных SQL Azure за одну операцию. Компилирование неструктурированных запросов в одну хранимую процедуру позволяет достигнуть того же результата, что и пакетная обработка. Использование хранимой процедуры также позволяет расширить возможности кэширования планов запросов в базе данных SQL Azure для последующего выполнения одной и той же хранимой процедуры.

Некоторые приложения требуют большого количества операций записи. Иногда можно уменьшить общую нагрузку операций ввода-вывода для базы данных путем правильного пакетирования операций записи. Часто достаточно просто использовать явные транзакции вместо автоматической фиксации внутри хранимой процедуры. Оценка различных подходов рассматривается в разделе [Методы пакетирования для приложений баз данных SQL в среде Azure](https://msdn.microsoft.com/library/windowsazure/dn132615.aspx). Рекомендуется экспериментировать с рабочей нагрузкой для нахождения оптимальной модели пакетной обработки с учетом того, что не все модели обеспечивают целостность при выполнении транзакций. Определение наиболее оптимальной рабочей нагрузки минимизирует использование ресурсов.

### Кэширование на уровне приложения
Некоторые приложения базы данных содержат рабочие нагрузки, выполняющие много операций чтения. Чтобы снизить нагрузку на базу данных, а вслед за ней и уровень производительности, необходимый для поддержки базы данных с помощью базы данных SQL Azure, можно использовать уровни кэширования. [Кэш Redis для Azure](https://azure.microsoft.com/services/cache) позволяет в сценариях с большим количеством операций чтения считывать данные один раз (или, в зависимости от конфигурации, один раз на каждом сервере) и хранить их вне базы данных SQL Azure. В результате снижается нагрузка на базу данных (загрузка ЦП и число операций ввода-вывода), однако теряется транзакционная целостность, так как данные в кэше могут быть устаревшими по сравнению с данными в базе данных. Для многих приложений определенный уровень целостности приемлем, однако это верно не для всех рабочих нагрузок. Рекомендуется внимательно изучить требования приложения, прежде чем использовать стратегию кэширования на уровне приложения.

## Заключение

Уровни служб в базе данных SQL Azure расширяют возможности приложений, которые могут быть собраны в облачной среде. В сочетании с надлежащей настройкой приложения эти возможности обеспечивают мощную и прогнозируемую производительность всего приложения. В этой статье описаны рекомендуемые способы оптимизации использования ресурсов базы данных для применения одного из новых уровней служб. Тонкая настройка — это рутинная операция в облачной модели. Уровни служб и связанные с ними уровни производительности позволяют администраторам добиться максимальной производительности и минимизировать затраты при работе с платформой Microsoft Azure.

<!---HONumber=Oct15_HO3-->