---
title: "Производительность отдельных баз данных в Базе данных SQL Azure | Документация Майкрософт"
description: "С помощью этой статьи вы сможете определить, какой уровень служб подходит для вашего приложения. Здесь также описываются рекомендованные способы настройки приложения для эффективного использования Базы данных SQL Azure."
services: sql-database
documentationcenter: na
author: CarlRabeler
manager: jhubbard
editor: 
ms.assetid: dd8d95fa-24b2-4233-b3f1-8e8952a7a22b
ms.service: sql-database
ms.custom: monitor and tune
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: data-management
ms.date: 03/06/2017
ms.author: carlrab
translationtype: Human Translation
ms.sourcegitcommit: 8a531f70f0d9e173d6ea9fb72b9c997f73c23244
ms.openlocfilehash: a9d496d696298d800bc40b1f3880c95f84e5f29f
ms.lasthandoff: 03/10/2017


---
# <a name="azure-sql-database-and-performance-for-single-databases"></a>База данных SQL Azure и производительность отдельных баз данных
База данных SQL Azure предлагает четыре [уровня служб](sql-database-service-tiers.md): "Базовый", "Стандартный", "Премиум" и Premium RS. Каждый уровень службы строго изолирует ресурсы, которые может использовать ваша База данных SQL, и гарантирует соответствующую прогнозируемую производительность. В этой статье представлены рекомендации, с помощью которых вы сможете выбрать уровень служб для своего приложения. Здесь также описываются способы настройки приложения для эффективного использования Базы данных SQL Azure.

> [!NOTE]
> В статье приведены рекомендации по производительности отдельных баз данных в Базе данных SQL Azure. Сведения о производительности пулов эластичных баз данных см. в статье [Когда следует использовать эластичный пул?](sql-database-elastic-pool-guidance.md) Обратите внимание, что многие из рекомендаций по настройке в этой статье можно применить к базам данных в пуле эластичных баз данных, чтобы получить аналогичные преимущества в отношении производительности.
> 
> 

## <a name="why-service-tiers"></a>Зачем нужны уровни служб?
Хотя рабочие нагрузки баз данных могут отличаться, цель уровней служб — обеспечить предсказуемость производительности на различных уровнях. Благодаря этим уровням клиенты с высокими требованиями к ресурсам базы данных могут работать в более изолированной вычислительной среде.

### <a name="common-service-tier-use-cases"></a>Распространенные варианты использования
#### <a name="basic"></a>базовая;
* **Вы только начали работать с базой данных SQL Azure.** Для приложений на первых этапах разработки часто не требуется высокий уровень производительности. Базы данных уровня "Базовый" — идеальная среда для разработки по низкой цене.
* **У вас есть база данных с одним пользователем.** Для приложений, связывающих одного пользователя с базой данных, обычно не применяются строгие требования к параллелизму и производительности. Таким приложениям, вероятно, подойдет уровень служб "Базовый".

#### <a name="standard"></a>Standard
* **База данных содержит большое количество параллельных запросов.** Для приложений, обслуживающих несколько пользователей одновременно, обычно требуется более высокий уровень производительности. Например, веб-сайтам с умеренным объемом трафика или приложениям для различных подразделений, требующим большого объема ресурсов, подойдет уровень служб "Стандартный".

#### <a name="premium"></a>Premium
Большинство вариантов использования уровня служб "Премиум" имеют одну или несколько из этих характеристик:

* **Высокая пиковая нагрузка.** Приложениям, которым для выполнения операций требуется мощный процессор, большой объем памяти или широкие возможности ввода-вывода данных, необходим уровень высокой производительности. Например, если известно, что работа базы данных задействует несколько ядер процессора на длительное время, то для такого приложения, скорее всего, подойдет уровень служб "Премиум".
* **Множество параллельных запросов.** Некоторые приложения баз данных обслуживают множество параллельных запросов, например веб-сайты с большим объемом трафика. Уровни служб "Базовый" и "Стандартный" накладывают ограничения на число параллельных запросов на базу данных. Приложения, которым требуется больше подключений, должны зарезервировать соответствующий размер, чтобы справиться с максимальным числом запросов.
* **Минимальная задержка.** Некоторым приложениям требуется минимальное время отклика базы данных. Если определенная хранимая процедура вызывается в рамках более широкого взаимодействия с клиентом, то в 99 % случаев отклик на такой запрос должен выполняться не более чем за 20 миллисекунд. Приложение такого типа эффективно работает с уровнем служб "Премиум", который обеспечивает необходимую вычислительную мощность.

* **Premium RS**. Предназначен для клиентов с рабочими нагрузками, интенсивно использующими ввод-вывод, но не требующими гарантий максимальной доступности. К примерам относятся тестовые высокопроизводительные рабочие нагрузки или рабочие нагрузки анализа, для которых база данных не является системой учета.

Уровень, который требуется для Базы данных SQL, зависит от требований к пиковой нагрузке для каждого измерения ресурсов. Некоторые приложения могут использовать небольшой объем одного ресурса и значительный — других.

## <a name="service-tier-capabilities-and-limits"></a>Возможности и ограничения уровней служб
Каждый уровень службы и уровень производительности связан с различными ограничениями и характеристиками производительности. В следующей таблице описываются эти характеристики для отдельной базы данных.

[!INCLUDE [SQL DB service tiers table](../../includes/sql-database-service-tiers-table.md)]

> [!IMPORTANT]
> Клиенты, использующие уровни производительности P11 и P15, могут использовать до 4 ТБ предоставленного хранилища без дополнительной платы. Сейчас эта возможность находится на этапе общедоступной предварительной версии и доступна в следующих регионах: восточная часть США 2, западная часть США, Западная Европа, Юго-Восточная Азия, восточная Япония, восточная Австралия, Центральная Канада и Восточная Канада. Текущие ограничения приведены в разделе [Параметры базы данных SQL и производительность: возможности разных уровней служб](sql-database-service-tiers.md#current-limitations-of-p11-and-p15-databases-with-4-tb-maxsize).
>

### <a name="maximum-in-memory-oltp-storage"></a>Максимальный объем хранилища OLTP в памяти
Вы можете использовать представление **sys.dm_db_resource_stats**, чтобы отслеживать использование хранилища Azure в памяти. Дополнительные сведения об отслеживании см. в разделе [Мониторинг хранилища OLTP в памяти](sql-database-in-memory-oltp-monitoring.md).

### <a name="maximum-concurrent-requests"></a>Максимальное количество параллельных запросов
Чтобы просмотреть число параллельных запросов, выполните в Базе данных SQL этот запрос Transact-SQL:

    SELECT COUNT(*) AS [Concurrent_Requests]
    FROM sys.dm_exec_requests R

Чтобы проанализировать рабочую нагрузку локальной базы данных SQL Server, следует изменить этот запрос для фильтрации конкретной базы данных, которую необходимо проанализировать. Например, если у вас есть локальная база данных с именем MyDatabase, для получения числа параллельных запросов в этой базе данных можно использовать следующий запрос Transact-SQL:

    SELECT COUNT(*) AS [Concurrent_Requests]
    FROM sys.dm_exec_requests R
    INNER JOIN sys.databases D ON D.database_id = R.database_id
    AND D.name = 'MyDatabase'

Это только моментальный снимок в один момент времени. Для лучшего понимания рабочей нагрузки и требований к параллельным запросам потребуется собрать большое количество примеров с течением времени.

### <a name="maximum-concurrent-logins"></a>Максимальное число параллельных операций входа
Чтобы получить представление о частоте входа, можно проанализировать шаблоны работы пользователей и приложений. Кроме того, можно запустить реальные нагрузки в тестовой среде, чтобы убедиться в том, что вы не приближаетесь к этим или другим ограничениям, описанным в этой статье. Нет единого запроса или динамического административного представления, с помощью которых можно просмотреть количество параллельных операций входа или журнал.

Если несколько клиентов используют ту же строку подключения, служба проверяет подлинность каждого входа. Если 10 пользователей одновременно подключаются к базе данных с использованием того же имени пользователя и пароля, это будет 10 параллельных операций входа. Это ограничение применяется только на время входа и проверки подлинности. Если те же 10 пользователей последовательно подключатся к базе данных, количество параллельных операций входа никогда не будет больше 1.

> [!NOTE]
> Сейчас это ограничение не применимо к базам данных в пулах эластичных баз данных.
> 
> 

### <a name="maximum-sessions"></a>Максимальное число сеансов
Чтобы просмотреть число текущих активных сеансов, выполните в Базе данных SQL этот запрос Transact-SQL:

    SELECT COUNT(*) AS [Sessions]
    FROM sys.dm_exec_connections

При анализе рабочей нагрузки локального SQL Server измените запрос, чтобы сосредоточиться на определенной базе данных. Это поможет определить возможные потребности в сеансах для этой базы данных, если вы собираетесь переместить ее в Базу данных SQL Azure.

    SELECT COUNT(*)  AS [Sessions]
    FROM sys.dm_exec_connections C
    INNER JOIN sys.dm_exec_sessions S ON (S.session_id = C.session_id)
    INNER JOIN sys.databases D ON (D.database_id = S.database_id)
    WHERE D.name = 'MyDatabase'

Опять же, эти запросы возвращают значение счетчика на определенный момент времени. Сбор нескольких образцов за определенный период времени обеспечивает лучшее понимание использования сеансов.

Для анализа базы данных SQL можно получить журнал статистики использования сеансов, запросив представление [sys.resource_stats](https://msdn.microsoft.com/library/dn269979.aspx) и просмотрев столбец **active_session_count**. 

## <a name="monitor-resource-use"></a>Отслеживание использования ресурсов

Использование ресурсов можно отслеживать с помощью [анализа производительности запросов базы данных SQL](sql-database-query-performance.md) и [хранилища запросов](https://msdn.microsoft.com/library/dn817826.aspx).

Кроме того, для отслеживания использования можно применять два приведенных ниже представления.

* [sys.dm_db_resource_stats](https://msdn.microsoft.com/library/dn800981.aspx)
* [sys.resource_stats](https://msdn.microsoft.com/library/dn269979.aspx)

### <a name="sysdmdbresourcestats"></a>sys.dm_db_resource_stats
Представление [sys.dm_db_resource_stats](https://msdn.microsoft.com/library/dn800981.aspx) можно использовать в каждой базе данных SQL. В представлении **sys.dm_db_resource_stats** отображаются последние данные использования ресурсов в соответствии с уровнем служб. Средний процент нагрузки ЦП, показатели операций ввода-вывода данных, записи в журнал и данные о памяти записываются каждые 15 секунд и хранятся 1 час.

Так как это представление содержит более подробные сведения об использовании ресурсов, сначала используйте представление **sys.dm_db_resource_stats** для любого анализа текущего состояния и устранения неполадок. Например, этот запрос показывает среднее и максимальное использование ресурсов для текущей базы данных за последний час:

    SELECT  
        AVG(avg_cpu_percent) AS 'Average CPU use in percent',
        MAX(avg_cpu_percent) AS 'Maximum CPU use in percent',
        AVG(avg_data_io_percent) AS 'Average data I/O in percent',
        MAX(avg_data_io_percent) AS 'Maximum data I/O in percent',
        AVG(avg_log_write_percent) AS 'Average log write use in percent',
        MAX(avg_log_write_percent) AS 'Maximum log write use in percent',
        AVG(avg_memory_usage_percent) AS 'Average memory use in percent',
        MAX(avg_memory_usage_percent) AS 'Maximum memory use in percent'
    FROM sys.dm_db_resource_stats;  

Примеры других запросов см. в [sys.dm_db_resource_stats](https://msdn.microsoft.com/library/dn800981.aspx).

### <a name="sysresourcestats"></a>sys.resource_stats
Представление [sys.resource_stats](https://msdn.microsoft.com/library/dn269979.aspx) в базе данных **master** предоставляет дополнительные сведения, с помощью которых можно контролировать производительность базы данных SQL в рамках конкретного уровня службы и производительности. Данные собираются каждые 5 минут и хранятся приблизительно 14 дней. Это представление полезно для анализа использования ресурсов Базы данных SQL за более долгий период.

На следующей диаграмме показано почасовое использование ресурсов процессора для базы данных уровня "Премиум" с уровнем производительности P2 в течение недели. Диаграмма начинается в понедельник, охватывает 5 рабочих дней и выходные, когда нагрузка заметно ниже.

![Использование ресурсов Базы данных SQL](./media/sql-database-performance-guidance/sql_db_resource_utilization.png)

Судя по этим данным, пиковая нагрузка на процессор составляет чуть более 50 % от максимальной нагрузки на уровне производительности P2 (полдень вторника). Если мощность процессора была главным фактором ресурсного профиля приложения, то клиент может решить, что P2 — оптимальный уровень производительности, который гарантирует стабильную работу с учетом средней нагрузки. Если ожидается рост нагрузки на приложение с течением времени, рекомендуется увеличить запас ресурсов, чтобы приложения не достигло предела производительности. Увеличив уровень производительности, можно избежать заметных пользователю ошибок, которые могут возникнуть из-за нехватки в базе данных мощности для эффективной обработки запросов, особенно в средах, чувствительных к задержкам. Это может быть база данных, поддерживающая приложение, создающее веб-страницы на основе запросов к базе данных.

Для других приложений эту диаграмму можно интерпретировать иначе. Например, если приложение обрабатывало данные по зарплате каждый день и получало ту же диаграмму, то выполнение таких "пакетных заданий" будет эффективным и на уровне производительности P1. Уровень производительности P1 предоставляет 100 DTU, а P2 — 200 DTU. P1 обеспечивает производительность в два раза меньше, чем P2. Таким образом, 50 процентов использования ЦП на уровне P2 равняется 100 процентам использования ЦП на уровне P1. Если в работе приложения не возникает пауз, возможно, не имеет значения, сколько времени выполняется задание — 2 или 2,5 часа, а важно только, чтобы оно было завершено сегодня. Приложение такой категории может использовать уровень Р1. Вы можете воспользоваться тем, что в определенное время дня использование ресурсов ниже, и перенести пиковую нагрузку именно на этот период. Уровень производительности Р1 может отлично подойти для такого приложения (и сэкономить деньги), если задания будут завершаться вовремя в течение одного дня.

База данных SQL Azure предоставляет сведения об использовании ресурсов по каждой активной базе данных в представлении **sys.resource_stats** для базы данных **master** на каждом сервере. Данные в таблице агрегируются каждые 5 минут. На уровнях служб "Базовый", "Стандартный" и "Премиум" может потребоваться более 5 минут, прежде чем данные появятся в таблице, то есть эти данные лучше подходят для ретроспективного анализа, чем для анализа в режиме реального времени. Выполните запрос представления **sys.resource_stats**, чтобы просмотреть журнал базы данных и проверить, обеспечил ли выбранный уровень резервирования требуемую производительность.

> [!NOTE]
> Вы должны быть подключены к базе данных **master** логического сервера базы данных SQL, чтобы отправить запрос **sys.resource_stats** в следующих примерах.
> 
> 

В этом примере показано, как отображаются данные в этом представлении.

    SELECT TOP 10 *
    FROM sys.resource_stats
    WHERE database_name = 'resource1'
    ORDER BY start_time DESC

![Представление каталога sys.resource_stats](./media/sql-database-performance-guidance/sys_resource_stats.png)

Ниже показаны различные способы использования представления каталога **sys.resource_stats** для получения сведений об использовании ресурсов в базе данных SQL.

1. Чтобы просмотреть данные использования ресурсов на прошлой неделе для базы данных userdb1, можно выполнить следующий запрос:
   
        SELECT *
        FROM sys.resource_stats
        WHERE database_name = 'userdb1' AND
              start_time > DATEADD(day, -7, GETDATE())
        ORDER BY start_time DESC;
2. Чтобы определить, какой уровень производительности лучше всего подходит для конкретной рабочей нагрузки, нужно детализировать все значения использования ресурсов: процессор, операции чтения и записи, количество рабочих ролей и количество сеансов. Ниже приведен измененный запрос, использующий **sys.resource_stats** для получения отчета о средних и максимальных значениях использования ресурсов.
   
        SELECT
            avg(avg_cpu_percent) AS 'Average CPU use in percent',
            max(avg_cpu_percent) AS 'Maximum CPU use in percent',
            avg(avg_data_io_percent) AS 'Average physical data I/O use in percent',
            max(avg_data_io_percent) AS 'Maximum physical data I/O use in percent',
            avg(avg_log_write_percent) AS 'Average log write use in percent',
            max(avg_log_write_percent) AS 'Maximum log write use in percent',
            avg(max_session_percent) AS 'Average % of sessions',
            max(max_session_percent) AS 'Maximum % of sessions',
            avg(max_worker_percent) AS 'Average % of workers',
            max(max_worker_percent) AS 'Maximum % of workers'
        FROM sys.resource_stats
        WHERE database_name = 'userdb1' AND start_time > DATEADD(day, -7, GETDATE());
3. С помощью средних и максимальных значений по каждому ресурсу можно оценить, насколько выбранный уровень производительности подходит для вашей рабочей нагрузки. Как правило, средние значения из **sys.resource_stats** дают хорошую основу для определения целевого резервирования. Эти сведения следует использовать в качестве отправной точки анализа. Например, вы можете использовать уровень служб "Стандартный" с уровнем производительности S2. При этом средняя нагрузка на процессор и число операций чтения и записи ввода-вывода составляют меньше 40 %, среднее число рабочих ролей — меньше 50, а среднее количество сеансов — меньше 200. Для такой рабочей нагрузки может подойти уровень производительности S1. Вы легко можете определить, отвечает ли уровень базы данных ограничениям рабочих ролей и сеансов. Чтобы узнать, можно ли для базы данных использовать более низкий уровень производительности с учетом нагрузки на процессор, количества операций чтения и записи, разделите число DTU более низкого уровня на DTU текущего уровня производительности и умножьте результат на 100.
   
    **S1 DTU / S2 DTU * 100 = 20 / 50* 100 = 40 **
   
    Результатом будет относительная разница производительности между двумя уровнями в процентах. Если использование ресурсов не превышает это значение, для рабочей нагрузки может подойти более низкий уровень производительности. Однако необходимо рассмотреть все диапазоны значений использования ресурсов, а также определить (в процентном отношении), как часто рабочая нагрузка будет вписываться в рамки более низкого уровня производительности. Следующий запрос отображает процентный показатель измерения ресурсов, исходя из 40-процентного порога, вычисленного в предыдущем примере.
   
        SELECT
            (COUNT(database_name) - SUM(CASE WHEN avg_cpu_percent >= 40 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'CPU Fit Percent'
            ,(COUNT(database_name) - SUM(CASE WHEN avg_log_write_percent >= 40 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Log Write Fit Percent'
            ,(COUNT(database_name) - SUM(CASE WHEN avg_data_io_percent >= 40 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Physical Data IO Fit Percent'
        FROM sys.resource_stats
        WHERE database_name = 'userdb1' AND start_time > DATEADD(day, -7, GETDATE());
   
    В зависимости от целевого уровня обслуживания (SLO) базы данных вы можете определить, подходит ли более низкий уровень производительности для вашей рабочей нагрузки. Если SLO составляет 99,9 % и указанный выше запрос возвращает значение больше 99,9 % для всех трех измерений ресурсов, весьма вероятно, что рабочую нагрузку можно выполнять на более низком уровне производительности.
   
    Процентное значение также поможет вам понять, следует ли перейти на следующий уровень производительности для выполнения требований SLO. Например, для userdb1 мы видим следующую нагрузку ЦП за прошлую неделю.
   
   | Средняя нагрузка ЦП, % | Максимальная нагрузка ЦП, % |
   | --- | --- |
   | 24,5 |100,00 |
   
    Средняя нагрузка процессора равна приблизительно одной четвертой ограничения уровня производительности, что вполне соответствует уровню производительности базы данных. Однако максимальное значение показывает, что база данных достигла ограничения уровня производительности. Требуется ли перейти на следующий уровень производительности? Определите, сколько раз рабочая нагрузка достигает 100 %, и сравните это значение с SLO рабочей нагрузки базы данных.
   
        SELECT
        (COUNT(database_name) - SUM(CASE WHEN avg_cpu_percent >= 100 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'CPU fit percent'
        ,(COUNT(database_name) - SUM(CASE WHEN avg_log_write_percent >= 100 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Log write fit percent'
        ,(COUNT(database_name) - SUM(CASE WHEN avg_data_io_percent >= 100 THEN 1 ELSE 0 END) * 1.0) / COUNT(database_name) AS 'Physical data I/O fit percent'
        FROM sys.resource_stats
        WHERE database_name = 'userdb1' AND start_time > DATEADD(day, -7, GETDATE());
   
    Если этот запрос возвращает значение меньше 99,9 для любого из трех измерений ресурсов, следует перейти на следующий уровень или использовать методы оптимизации приложения для сокращения нагрузки на Базу данных SQL Azure.
4. В таких расчетах также следует учитывать возможное увеличение рабочей нагрузки в будущем.

## <a name="tune-your-application"></a>Настройка приложения
В традиционной локальной среде SQL Server процесс изначального планирования загрузки часто отделен от процесса запуска приложения в рабочей среде. Сначала приобретаются лицензии на оборудование и продукт, а затем настраивается производительность. При использовании Базы данных SQL Azure рекомендуется объединить процессы настройки и запуска приложения. Оплата только за используемые ресурсы позволяет настраивать приложение на использование минимального объема ресурсов, которые нужны в данный момент, а не выполнять избыточную подготовку согласно прогнозам будущего роста нагрузки на приложение, так как часто такие прогнозы ошибочны. Некоторые пользователи предпочитают не настраивать приложение и вместо этого используют избыточную подготовку ресурсов оборудования. Этот подход может подойти, если вы не желаете изменять ключевое приложение в период высокой нагрузки. Но настройка приложения позволяет минимизировать потребление ресурсов и снизить ежемесячные расходы благодаря новым уровням служб в Базе данных SQL Azure.

### <a name="application-characteristics"></a>Характеристики приложения
Уровни служб Базы данных SQL Azure предназначены для оптимизации стабильности и предсказуемости производительности приложения. Вместе с тем с помощью некоторых рекомендаций по настройке приложения можно настроить приложение для максимально эффективного использования ресурсов на уровне производительности. Многие приложения получают значительный прирост производительности после простого перехода на более высокий уровень производительности или уровень служб, в то время как для лучшей работы других приложений на новом уровне требуется дополнительная настройка. Для повышения производительности приложений со следующими характеристиками необходима дополнительная настройка:

* **Приложения с низкой производительностью из-за "нестабильной" работы.**В эту категорию входят приложения, которые совершают избыточные операции доступа к данным, несмотря на их чувствительность к сетевым задержкам. Возможно, в такие приложения понадобится внести изменения, сократив число операций доступа к данным в Базе данных SQL. Например, производительность приложения можно улучшить за счет пакетной обработки нерегламентированных запросов или перемещения запросов в хранимые процедуры. Дополнительные сведения см. в разделе [Пакетные запросы](#batch-queries).
* **Базы данных с интенсивной рабочей нагрузкой, которые не могут работать на одном сервере.**Базы данных, которым требуется больше ресурсов, чем предоставляет уровень производительности "Премиум", можно оптимизировать за счет масштабирования рабочей нагрузки. Дополнительные сведения см. Дополнительные сведения см. в разделах [Сегментирование баз данных](#cross-database-sharding) и [Функциональное секционирование](#functional-partitioning).
* **Приложения с неоптимальными запросами.**Приложениям, особенно тем, которые находятся на уровне доступа к данным и используют неоптимальные запросы, может не подойти более высокий уровень производительности. К таким запросам относятся запросы, в которых нет предложения WHERE, отсутствуют индексы или используется устаревшая статистика. Больше пользы таким приложениям приносят стандартные методы оптимизации производительности запросов. Дополнительные сведения см. Дополнительные сведения см. в разделах [Отсутствующие индексы](#missing-indexes) и [Настройка запросов и указания на них](#query-tuning-and-hinting).
* **Приложения с неоптимальной схемой доступа к данным.**Если в приложениях есть проблемы параллельного доступа к данным, например при одновременном доступе возникает блокировка, то более высокий уровень производительности, скорее всего, не улучшит их работу. Попробуйте снизить количество циклических запросов к Базе данных SQL Azure за счет кэширования данных на стороне клиента с помощью службы кэша Azure или других технологий кэширования. См. раздел [Кэширование на уровне приложения](#application-tier-caching).

## <a name="tuning-techniques"></a>Методы настройки
В этом разделе рассматриваются некоторые методы, которые можно использовать для настройки Базы данных SQL Azure с целью повышения производительности приложения и использования наименьшего уровня производительности. Некоторые из этих методов совпадают с традиционными рекомендациями по настройке SQL Server, однако есть и специфические методы настройки базы данных SQL Azure. В некоторых случаях можно изучить использование ресурсов в базе данных, чтобы настроить и улучшить традиционные методы SQL Server для работы в Базе данных SQL Azure.

### <a name="azure-portal-tools"></a>Инструменты портала Azure
На портале Azure есть инструменты, с помощью которых можно проанализировать и устранить проблемы производительности в базе данных SQL:

* [Анализ производительности запросов](sql-database-query-performance.md)
* [Помощник по работе с базами данных SQL](sql-database-advisor.md)

На портале Azure содержатся дополнительные сведения об этих средствах и способах их использования. Для более эффективной диагностики и устранения неполадок рекомендуется сначала попробовать средства на портале Azure. В особых случаях для отсутствующих индексов и запросов мы рекомендуем использовать методы настройки вручную, которые описываются ниже.

### <a name="missing-indexes"></a>Отсутствующие индексы
Одна из распространенных проблем производительности баз данных OLTP связана с физической схемой базы данных. Часто схемы базы данных создаются и поставляются без проверки масштабируемости по нагрузке или объему данных. К сожалению, производительность плана запроса, приемлемая при небольшом масштабе, может существенно снижаться при использовании объема данных уровня большой компании. Самый распространенный источник проблем связан с отсутствием индексов, которые позволили бы сортировать и ограничивать данные в запросе. Часто при этом сканируется вся таблица, в то время как поиска по индексу было бы достаточно.

В этом примере в выбранном плане запроса используется сканирование, хотя здесь было бы достаточно поиска.

    DROP TABLE dbo.missingindex;
    CREATE TABLE dbo.missingindex (col1 INT IDENTITY PRIMARY KEY, col2 INT);
    DECLARE @a int = 0;
    SET NOCOUNT ON;
    BEGIN TRANSACTION
    WHILE @a < 20000
    BEGIN
        INSERT INTO dbo.missingindex(col2) VALUES (@a);
        SET @a += 1;
    END
    COMMIT TRANSACTION;
    GO
    SELECT m1.col1
    FROM dbo.missingindex m1 INNER JOIN dbo.missingindex m2 ON(m1.col1=m2.col1)
    WHERE m1.col2 = 4;

![План запроса c отсутствующими индексами](./media/sql-database-performance-guidance/query_plan_missing_indexes.png)

База данных SQL Azure может помочь выявить условия, при которых индекс становится необходимым. Динамические административные представления, встроенные в Базу данных SQL Azure, учитывают во время компиляции запроса случаи, когда индекс мог бы значительно снизить стоимость, связанную с выполнением запроса. Во время выполнения запроса База данных SQL отслеживает, как часто выполнялся план запроса, а также вычисляет разницу между выполненным планом запроса и возможным планом с индексом. Эти представления можно использовать, чтобы быстро выяснить, какие изменения схемы базы данных могли бы существенно уменьшить рабочую нагрузку для базы данных.

Этот запрос можно использовать для оценки потенциально отсутствующих индексов:

    SELECT CONVERT (varchar, getdate(), 126) AS runtime,
        mig.index_group_handle, mid.index_handle,
        CONVERT (decimal (28,1), migs.avg_total_user_cost * migs.avg_user_impact *
                (migs.user_seeks + migs.user_scans)) AS improvement_measure,
        'CREATE INDEX missing_index_' + CONVERT (varchar, mig.index_group_handle) + '_' +
                  CONVERT (varchar, mid.index_handle) + ' ON ' + mid.statement + '
                  (' + ISNULL (mid.equality_columns,'')
                  + CASE WHEN mid.equality_columns IS NOT NULL
                              AND mid.inequality_columns IS NOT NULL
                         THEN ',' ELSE '' END + ISNULL (mid.inequality_columns, '')
                  + ')'
                  + ISNULL (' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement,
        migs.*,
        mid.database_id,
        mid.[object_id]
    FROM sys.dm_db_missing_index_groups AS mig
    INNER JOIN sys.dm_db_missing_index_group_stats AS migs
        ON migs.group_handle = mig.index_group_handle
    INNER JOIN sys.dm_db_missing_index_details AS mid
        ON mig.index_handle = mid.index_handle
    ORDER BY migs.avg_total_user_cost * migs.avg_user_impact * (migs.user_seeks + migs.user_scans) DESC

В этом примере при выполнении запроса возникло такое предложение:

    CREATE INDEX missing_index_5006_5005 ON [dbo].[missingindex] ([col2])  

После его создания инструкция SELECT выбирает другой план, в котором используется поиск вместо сканирования, а затем выполняет план более эффективно.

![План запроса c исправленными индексами](./media/sql-database-performance-guidance/query_plan_corrected_indexes.png)

Важно понимать, что пропускная способность общей среды более ограничена, чем пропускная способность выделенного сервера. Вы можете минимизировать избыточное число операций ввода-вывода и максимально использовать ресурсы каждого уровня производительности, доступные в рамках уровней служб Базы данных SQL Azure. Улучшение физической схемы базы данных может значительно уменьшить задержку для определенных запросов, улучшить пропускную способность при параллельных запросах, обрабатываемых на единицу масштабирования, и минимизировать затраты, необходимые на выполнение одного запроса. Дополнительные сведения о динамических административных представлениях для отсутствующих индексов см. в разделе [sys.dm_db_missing_index_details](https://msdn.microsoft.com/library/ms345434.aspx).

### <a name="query-tuning-and-hinting"></a>Настройка запросов и указания на них
Оптимизатор запросов в Базе данных SQL Azure напоминает традиционный оптимизатор запросов SQL Server. Большинство рекомендаций по настройке запросов и ограничения оптимизатора запросов применимы к Базе данных SQL Azure. Настроив запросы в Базе данных SQL Azure, можно снизить общие требования к ресурсам. Кроме того, с помощью настройки можно снизить затраты на приложение, так как в результате можно будет использовать более низкий уровень производительности.

Примером является то, как оптимизатор запросов вносит параметры "на лету". Это распространено в SQL Server и также применяется к Базе данных SQL Azure. Во время компиляции оптимизатор запросов вычисляет текущее значение параметра с целью создания более оптимального плана запроса. Хотя такая стратегия часто позволяет создать более быстрый план запроса, чем план, скомпилированный без известных значений параметров, сейчас в SQL Server и Базе данных SQL Azure она работает несовершенно. Иногда параметр не вносится или вносится, но созданный план является неэффективным для полного набора значений параметров в рабочей нагрузке. Майкрософт предусматривает использование указаний запросов (директив), которые позволяют указать, следует ли изменить поведение по умолчанию. Часто использование указаний позволяет устранить проблемы, когда работа SQL Server и Базы данных SQL Azure не подходит для конкретной рабочей нагрузки.

В следующем примере показано, как обработчик запросов может создать план, который не соответствует требованиям к производительности и ресурсам. В этом примере также показано, что при использовании указания запроса можно сократить время выполнения запроса и снизить требования к ресурсам для Базы данных SQL.

    DROP TABLE psptest1;
    CREATE TABLE psptest1(col1 int primary key identity, col2 int, col3 binary(200));

    DECLARE @a int = 0;
    SET NOCOUNT ON;
    BEGIN TRANSACTION
    WHILE @a < 20000
    BEGIN
        INSERT INTO psptest1(col2) values (1);
        INSERT INTO psptest1(col2) values (@a);
        SET @a += 1;
    END
    COMMIT TRANSACTION
    CREATE INDEX i1 on psptest1(col2);
    GO

    CREATE PROCEDURE psp1 (@param1 int)
    AS
    BEGIN
        INSERT INTO t1 SELECT * FROM psptest1
        WHERE col2 = @param1
        ORDER BY col2;
    END
    GO

    CREATE PROCEDURE psp2 (@param2 int)
    AS
    BEGIN
        INSERT INTO t1 SELECT * FROM psptest1 WHERE col2 = @param2
        ORDER BY col2
        OPTION (OPTIMIZE FOR (@param2 UNKNOWN))
    END
    GO

    CREATE TABLE t1 (col1 int primary key, col2 int, col3 binary(200));
    GO

Код установки создает таблицу с неравномерным распределением данных. Оптимальный план запроса зависит от выбранного параметра. К сожалению, при кэшировании плана запрос не всегда повторно компилируется в зависимости от наиболее подходящего значения параметра. Таким образом, может получиться так, что будет кэширован неоптимальный план, который будет использоваться во многих случаях, когда можно было бы использовать более эффективный план. После этого план запроса создает две хранимые процедуры, которые идентичны друг другу, за исключением того, что одна из них содержит специальное указание запроса.

**Пример, часть 1.**

    -- Prime Procedure Cache with scan plan
    EXEC psp1 @param1=1;
    TRUNCATE TABLE t1;

    -- Iterate multiple times to show the performance difference
    DECLARE @i int = 0;
    WHILE @i < 1000
    BEGIN
        EXEC psp1 @param1=2;
        TRUNCATE TABLE t1;
        SET @i += 1;
    END

**Пример, часть 2.**

(Мы советуем подождать около 10 минут, прежде чем приступить ко второй части примера, чтобы в итоговых данных телеметрии была очевидная разница.)

    EXEC psp2 @param2=1;
    TRUNCATE TABLE t1;

    DECLARE @i int = 0;
    WHILE @i < 1000
    BEGIN
        EXEC psp2 @param2=2;
        TRUNCATE TABLE t1;
        SET @i += 1;
    END

Каждая часть примера пытается выполнить параметризованную вставку 1000 раз (это необходимо для создания достаточной нагрузки). При выполнении хранимых процедур обработчик запросов проверяет значение параметра, переданное в процедуру во время первой компиляции ("вставка на лету"). Обработчик кэширует результирующий план и использует его в дальнейшем, даже если значение параметра будет другим. Оптимальный план может подойти не для всех случаев. Иногда нужно указывать оптимизатору, какой план выбрать, чтобы этот план был относительно универсальным, а не просто подходящим для определенного случая, когда впервые происходит компиляция запроса. В этом примере изначальный план создает сканирование, при котором считываются все строки, чтобы найти значение, которое отвечает параметру.

![Настройка запроса с использованием плана сканирования](./media/sql-database-performance-guidance/query_tuning_1.png)

Так как процедура выполнена с использованием значения 1, результирующий план был оптимальным для значения 1, но неоптимальным для всех остальных значений в таблице. Если вы будете выбирать каждый план случайным образом, скорее всего, результат не будет оптимальным, так как план будет выполняться медленнее и задействовать больше ресурсов.

При выполнении теста с параметром `SET STATISTICS IO` со значением `ON` логическое сканирование в этом примере будет проходить в фоновом режиме. Вы можете увидеть, что план выполнил 1148 операций чтения (что является неэффективным, если обычно нужно вернуть только одну строку).

![Настройка запроса с использованием логического сканирования](./media/sql-database-performance-guidance/query_tuning_2.png)

Во второй части примера используется указание запроса, которое позволяет дать оптимизатору инструкцию использовать конкретное значение во время компиляции. В этом случае обработчик запросов принудительно игнорирует значение, которое передается в качестве параметра, и вместо этого использует значение `UNKNOWN`. Это значение со средней частотой в таблице (независимо от искажения распределения). В результате мы получим план на основе поиска, который работает быстрее и использует меньше ресурсов, чем план из части 1 этого примера.

![Настройка запроса с помощью указания запроса](./media/sql-database-performance-guidance/query_tuning_3.png)

Просмотреть результат можно в таблице **sys.resource_stats** (между временем выполнения теста и появлением данных в таблице есть задержка). В этом примере первая часть выполнялась в рамках временного окна 22:25:00, а вторая часть — в 22:35:00. В первой части использовано больше ресурсов, чем во второй (в силу повышения эффективности).

    SELECT TOP 1000 *
    FROM sys.resource_stats
    WHERE database_name = 'resource1'
    ORDER BY start_time DESC

![Пример результатов настройки запроса](./media/sql-database-performance-guidance/query_tuning_4.png)

> [!NOTE]
> В этом примере преднамеренно использовались небольшие значения, однако последствия неоптимальных параметров могут быть существенными, особенно для больших баз данных. Разница для быстрых и медленных запросов в некоторых случаях может достигать от нескольких секунд до нескольких часов.
> 
> 

Вы можете просмотреть таблицу **sys.resource_stats**, чтобы определить, использует ли один тест больше ресурсов, чем другой. При сравнении данных между тестами необходимо установить интервалы, чтобы они не группировались в одном 5-минутном окне в представлении **sys.resource_stats**. Цель расчетов — минимизировать общее использование ресурсов, а не пиковую нагрузку. Обычно оптимизация части кода с целью уменьшения задержки выполнения также приводит к сокращению использования ресурсов. Убедитесь, что изменения, внесенные в приложение, необходимы и что они не оказывают негативное влияние на работу приложения при использовании указаний запроса.

Если рабочая нагрузка содержит ряд повторяющихся запросов, то часто бывает целесообразно отследить и проверить оптимальность планов, так как это позволит уменьшить минимальный размер ресурсов, необходимых базе данных. После проверки иногда пересматривайте планы, чтобы убедиться, что их производительность не ухудшилась. Дополнительные сведения об указаниях запроса (Transact-SQL) см. [в этой статье](https://msdn.microsoft.com/library/ms181714.aspx).

### <a name="cross-database-sharding"></a>Сегментирование баз данных
Так как База данных SQL Azure работает на стандартном оборудовании, ограничения емкости для отдельной базы данных будут ниже, чем в традиционной локальной среде SQL Server. Некоторые пользователи используют сегментирование баз данных, если размеры отдельной базы данных в Базе данных SQL Azure недостаточны. Большинство клиентов, использующих сегментирование в Базе данных SQL Azure, разбивают данные одного измерения на несколько баз данных. При использовании этого подхода необходимо понимать, что часто приложения OLTP выполняют транзакции, которые применимы только к одной строке или небольшой группе строк внутри одной схемы.

> [!NOTE]
> База данных SQL теперь предоставляет библиотеку для упрощения сегментирования. Дополнительные сведения см. в статье [Обзор клиентской библиотеки для эластичных баз данных](sql-database-elastic-database-client-library.md).
> 
> 

Например, если база данных содержит сведения об имени клиента, заказе и цене (как можно увидеть в стандартном примере базы данных Northwind, который используется для SQL Server), эти данные можно разбить на несколько баз данных, группируя вместе сведения о клиенте и заказе. Это гарантирует, что данные клиента останутся в пределах отдельной базы данных. Приложение должно разбивать заказчиков по разным базам данных и эффективно распределять нагрузку. В результате можно не только не превышать имеющееся ограничение максимального размера базы данных, но и обрабатывать в Базе данных SQL Azure рабочие нагрузки, которые существенно превышают ограничения различных уровней производительности, если каждая отдельная база данных будет работать в соответствии с ограничениями DTU.

Несмотря на то что сегментирование баз данных не снижает общую нагрузку для решения, такой подход очень эффективен для поддержки очень больших решений, распределенных по нескольким базам данных. Каждую базу данных можно запускать на разных уровнях производительности для поддержки очень больших "эффективных" баз данных с высокими требованиями к ресурсам.

### <a name="functional-partitioning"></a>Функциональное секционирование
Пользователи SQL Server часто объединяют несколько функций в отдельной базе данных. Например, если приложение содержит логику управления запасами склада, то база данных может содержать логику, связанную с запасами, отслеживанием заказов на покупку, хранимыми процедурами, индексированными или материализованными представлениями для управления ежемесячными отчетами. Такой подход позволяет легко администрировать базы данных и выполнять такие операции, как резервное копирование. Однако в этом случае нужно также изменить размер оборудования, чтобы распределять пиковую нагрузку функций одного приложения.

Если в Базе данных SQL Azure используется масштабируемая архитектура, лучше распределить функции приложения по разным базам данных. При использовании этого метода приложения масштабируются независимо друг от друга. По мере повышения нагрузки на приложение (и нагрузки на базу данных) администратор сможет определить уровни производительности отдельно для каждой функции одного приложения. Такая архитектура позволит приложению расширяться за пределы одного сервера за счет распределения нагрузки по разным серверам.

### <a name="batch-queries"></a>Пакетные запросы
Для приложений, которые получают доступ к данным с использованием частых нерегламентированных запросов большого объема, время отклика значительно увеличивается за счет взаимодействия по сети между уровнем приложения и уровнем Базы данных SQL Azure. Даже если приложение и База данных SQL Azure находятся в одном центре обработки данных, сетевая задержка между ними может увеличиться пропорционально количеству операций доступа к данным. Чтобы уменьшить количество циклических операций доступа к данным, попробуйте выполнить пакетную обработку нерегламентированных запросов или скомпилировать их в качестве хранимых процедур. Если выполнить пакетную обработку нерегламентированных запросов, несколько запросов будут отсылаться как один большой пакет в Базу данных SQL Azure за одну операцию. Выполнив компилирование нерегламентированных запросов в одну хранимую процедуру, можно достигнуть того же результата, что и при пакетной обработке. Использование хранимой процедуры также позволяет расширить возможности кэширования планов запросов в Базе данных SQL Azure, чтобы снова использовать хранимую процедуру.

Некоторые приложения требуют большого количества операций записи.  Иногда можно уменьшить общую нагрузку операций ввода-вывода на базы данных путем правильной пакетной обработки операций записи. Часто для этого нужно просто использовать явные транзакции вместо автоматических в хранимых процедурах и пакетах нерегламентированных запросов. Оценку различных подходов см. в статье [Как повысить производительность приложений базы данных SQL с помощью пакетной обработки](https://msdn.microsoft.com/library/windowsazure/dn132615.aspx). Поэкспериментируйте со своей рабочей нагрузкой, чтобы найти оптимальную модель пакетной обработки. Необходимо учитывать, что гарантии согласованности транзакций разных моделей могут немного отличаться. Чтобы определить наиболее оптимальную рабочую нагрузку, которая минимизирует использование ресурсов, необходимо добиться правильного сочетания компромиссов согласованности и производительности.

### <a name="application-tier-caching"></a>Кэширование на уровне приложения
Некоторые приложения базы данных содержат рабочие нагрузки, выполняющие много операций чтения. Уровни кэширования могут снизить нагрузку на базу данных, а вслед за ней и уровень производительности, необходимый для поддержки базы данных с помощью Базы данных SQL Azure. [Кэш Redis для Azure](https://azure.microsoft.com/services/cache/)позволяет при рабочих нагрузках с большим количеством операций чтения считывать данные один раз (или, в зависимости от конфигурации, один раз на каждом сервере) и хранить их вне Базы данных SQL. Это помогает снизить нагрузку на базу данных (загрузка ЦП и число операций ввода-вывода), однако это может повлиять на согласованность транзакций, так как данные в кэше могут быть не синхронизированы с данными в базе данных. Для многих приложений определенный уровень несогласованности приемлем, однако это подходит не для всех рабочих нагрузок. Мы советуем внимательно изучить требования к приложению, прежде чем использовать стратегию кэширования на уровне приложения.

## <a name="next-steps"></a>Дальнейшие действия
* Дополнительные сведения об уровнях служб см. в статье [Параметры базы данных SQL и производительность](sql-database-service-tiers.md).
* Дополнительные сведения о пулах эластичных баз данных Azure см. в статье [Что такое пул эластичных БД Azure?](sql-database-elastic-pool.md)
* Сведения о производительности и пулах эластичных баз данных см. в статье [Когда следует использовать эластичный пул?](sql-database-elastic-pool-guidance.md)


