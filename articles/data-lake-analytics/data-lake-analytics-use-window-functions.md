<properties 
   pageTitle="Использование оконных функций U-SQL для заданий в службе аналитики озера данных Azure | Azure" 
   description="Узнайте, как использовать оконные функции U-SQL. " 
   services="data-lake-analytics" 
   documentationCenter="" 
   authors="edmacauley" 
   manager="jhubbard" 
   editor="cgronlun"/>
 
<tags
   ms.service="data-lake-analytics"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="big-data" 
   ms.date="05/16/2016"
   ms.author="edmaca"/>


# Использование оконных функций U-SQL для заданий в службе аналитики озера данных Azure  

Оконные функции были добавлены в стандарт SQL ISO/ANSI в 2003 году. В языке U-SQL используется ряд оконных функций, определенных в стандарте SQL ANSI.

Оконные функции используются для выполнения вычислений в наборах строк, именуемых *окнами*. Окна определяются предложением OVER. Оконные функции очень эффективны в некоторых случаях.

В этом обучающем руководстве мы продемонстрируем несколько вариантов использования оконных функций на двух примерах наборов данных. Дополнительные сведения см. в [справке по U-SQL](http://go.microsoft.com/fwlink/p/?LinkId=691348).

Оконные функции разделены на несколько категорий:

- [статистические функции для создания отчетов](#reporting-aggregation-functions), например SUM и AVG;
- [ранжирующие функции](#ranking-functions), например DENSE\_RANK, ROW\_NUMBER, RANK и NTILE;
- [аналитические функции](#analytic-functions), например интегральная функция распределения, процентили или обращение к данным из предыдущей строки того же результирующего набора без использования самосоединения.

**Предварительные требования**

- Изучите два руководства:

    - [Начало работы со средствами озера данных Azure для Visual Studio](data-lake-analytics-data-lake-tools-get-started.md);
    - [Начало работы с языком U-SQL для заданий в службе аналитики озера данных Azure](data-lake-analytics-u-sql-get-started.md).
- Создайте учетную запись в службе аналитики озера данных, как описано в статье [Начало работы со средствами озера данных Azure для Visual Studio](data-lake-analytics-data-lake-tools-get-started.md).
- Создайте в Visual Studio проект U-SQL, как описано в статье [Начало работы с языком U-SQL для заданий в службе аналитики озера данных Azure](data-lake-analytics-u-sql-get-started.md).

## Типовые наборы данных

В этом руководстве используются два набора данных.

- Журнал запросов.

    Журнал запросов — это список поисковых запросов пользователей в поисковой системе. Каждый журнал запросов включает в себя следующую информацию.
    
        - Query - What the user was searching for.
        - Latency - How fast the query came back to the user in milliseconds.
        - Vertical - What kind of content the user was interested in (Web links, Images, Videos).
    
    Скопируйте и вставьте в проект U-SQL следующий сценарий. Он создает набор строк в журнале запросов.
    
        @querylog = 
            SELECT * FROM ( VALUES
                ("Banana"  , 300, "Image" ),
                ("Cherry"  , 300, "Image" ),
                ("Durian"  , 500, "Image" ),
                ("Apple"   , 100, "Web"   ),
                ("Fig"     , 200, "Web"   ),
                ("Papaya"  , 200, "Web"   ),
                ("Avocado" , 300, "Web"   ),
                ("Cherry"  , 400, "Web"   ),
                ("Durian"  , 500, "Web"   ) )
            AS T(Query,Latency,Vertical);
    
    На практике данные обычно хранятся в файле данных. Данные из файла с разделителями-табуляциями извлекаются с помощью следующего кода.
    
        @querylog = 
        EXTRACT 
            Query    string, 
            Latency  int, 
            Vertical string
        FROM "/Samples/QueryLog.tsv"
        USING Extractors.Tsv();

- Сотрудники.

    Набор данных о сотрудниках содержит такие поля:
   
        - EmpID - Employee ID.
        - EmpName  Employee name.
        - DeptName - Department name. 
        - DeptID - Deparment ID.
        - Salary - Employee salary.

    Скопируйте и вставьте в проект U-SQL следующий сценарий. Он создает набор строк с данными о сотрудниках.

        @employees = 
            SELECT * FROM ( VALUES
                (1, "Noah",   "Engineering", 100, 10000),
                (2, "Sophia", "Engineering", 100, 20000),
                (3, "Liam",   "Engineering", 100, 30000),
                (4, "Emma",   "HR",          200, 10000),
                (5, "Jacob",  "HR",          200, 10000),
                (6, "Olivia", "HR",          200, 10000),
                (7, "Mason",  "Executive",   300, 50000),
                (8, "Ava",    "Marketing",   400, 15000),
                (9, "Ethan",  "Marketing",   400, 10000) )
            AS T(EmpID, EmpName, DeptName, DeptID, Salary);
    
    Приведенная ниже инструкция создает набор строк путем их извлечения из файла данных.
    
        @employees = 
        EXTRACT 
            EmpID    int, 
            EmpName  string, 
            DeptName string, 
            DeptID   int, 
            Salary   int
        FROM "/Samples/Employees.tsv"
        USING Extractors.Tsv();

При работе с примерами из этого руководства необходимо добавлять определения наборов строк. Для U-SQL необходимо определять только те наборы, которые используются. Для некоторых примеров требуется только один набор строк.

Обязательно добавьте следующую инструкцию. Она выводит результирующий набор строк в файл данных.

    OUTPUT @result TO "/wfresult.csv" 
        USING Outputters.Csv();
 
 Для обозначения результатов в большинстве примеров используется переменная **@result**.

## Сравнение оконных функций с функцией группирования

Оконные функции и функция группирования концептуально связаны, но между ними есть различия. Давайте разберемся в том, что их объединяет и отличает.

### Использование агрегирования и группирования

Приведенный ниже запрос рассчитывает совокупную заработную плату всех сотрудников с помощью агрегирования.

    @result = 
        SELECT 
            SUM(Salary) AS TotalSalary
        FROM @employees;
    
>[AZURE.NOTE] Инструкции по использованию запроса и проверке выходных данных см. в статье [Начало работы с языком U-SQL для заданий в службе аналитики озера данных Azure](data-lake-analytics-u-sql-get-started.md).

Результатом будет одна строка с одним столбцом. 165 000 $ — это сумма всех зарплат в таблице.

|TotalSalary
|-----------
|165 000

>[AZURE.NOTE] Если вы раньше не работали с оконными функциями, запоминайте числа в выходных данных.

Приведенная ниже инструкция вычисляет совокупную зарплату каждого отдела с помощью предложения GROUP BY.

    @result=
        SELECT DeptName, SUM(Salary) AS SalaryByDept
        FROM @employees
        GROUP BY DeptName;

Получаются такие результаты:

|DeptName|SalaryByDept
|--------|------------
|Engineering|60 000
|HR|30 000
|Executive|50 000
|Marketing|25 000

Сумма значений в столбце SalaryByDept равна 165 000 $, что соответствует сумме в сценарии выше.
 
В каждом из этих примеров количество выходных строк меньше количества входных.
 
- Если предложение GROUP BY не используется, агрегирование сворачивает все строки в одну.
- Если предложение GROUP BY используется, вы получаете N выходных строк, где N — это количество уникальных значений в отображаемых данных. В нашем случае вы получите 4 строки выходных данных.

###  Использование оконной функции

В следующем примере предложение OVER пустое. Это означает, что в «окно» будут включены все строки. Функция SUM в этом примере применяется к предложению OVER, перед которым она стоит.

Этот запрос можно прочитать так: сумма зарплат в окне всех строк.

    @result=
        SELECT
            EmpName,
            SUM(Salary) OVER( ) AS SalaryAllDepts
        FROM @employees;

В отличие от функции GROUP BY, количество выходных строк равно количеству входных.

|EmpName|TotalAllDepts
|-------|--------------------
|Noah|165 000
|Sophia|165 000
|Liam|165 000
|Emma|165 000
|Jacob|165 000
|Olivia|165 000
|Mason|165 000
|Ava|165 000
|Ethan|165 000


Значение 165 000 (сумма всех зарплат) помещается в каждую выходную строку. Итоговое значение берется из «окна» всех строк, поэтому оно включает все зарплаты.

В следующем примере показано, как уточнить "окно", чтобы получить список всех сотрудников, названия соответствующих отделов и совокупную зарплату в каждом отделе. В предложение OVER добавляется предложение PARTITION BY.

    @result=
    SELECT
        EmpName, DeptName,
        SUM(Salary) OVER( PARTITION BY DeptName ) AS SalaryByDept
    FROM @employees;

Получаются такие результаты:

|EmpName|DeptName|SalaryByDep
|-------|--------|-------------------
|Noah|Engineering|60 000
|Sophia|Engineering|60 000
|Liam|Engineering|60 000
|Mason|Executive|50 000
|Emma|HR|30 000
|Jacob|HR|30 000
|Olivia|HR|30 000
|Ava|Marketing|25000
|Ethan|Marketing|25000

Количество входных строк опять равно количеству выходных, но в каждой строке указан совокупный размер зарплаты всего отдела.




## Статистические функции для создания отчетов

Оконные функции поддерживают также такие статистические функции:

- COUNT
- SUM
- MIN
- MAX
- AVG
- STDEV
- VAR

Синтаксис выглядит вот так:

    <AggregateFunction>( [DISTINCT] <expression>) [<OVER_clause>]

Примечание.

- По умолчанию статистические функции, за исключением COUNT, игнорируют значения NULL.
- Если статистическая функция указана вместе с предложением OVER, предложение ORDER BY не допускается в предложении OVER.

### Использование функции SUM

В следующем примере в каждую входную строку добавляется совокупная зарплата соответствующего отдела.
 
    @result=
        SELECT 
            *,
            SUM(Salary) OVER( PARTITION BY DeptName ) AS TotalByDept
        FROM @employees;

Результат выглядит так:

|EmpID|EmpName|DeptName|DeptID|Salary|TotalByDept
|-----|-------|--------|------|------|-----------
|1|Noah|Engineering|100|10 000|60 000
|2|Sophia|Engineering|100|20 000|60 000
|3|Liam|Engineering|100|30 000|60 000
|7|Mason|Executive|300|50 000|50 000
|4|Emma|HR|200|10 000|30 000
|5|Jacob|HR|200|10 000|30 000
|6|Olivia|HR|200|10 000|30 000
|8|Ava|Marketing|400|15 000|25000
|9|Ethan|Marketing|400|10 000|25000

### Использование функции COUNT

В следующем примере в каждую строку добавляется дополнительное поле, в котором показывается общее количество сотрудников в каждом отделе.

    @result =
        SELECT *, 
            COUNT(*) OVER(PARTITION BY DeptName) AS CountByDept 
        FROM @employees;

Получаются такие результаты:

|EmpID|EmpName|DeptName|DeptID|Salary|CountByDept
|-----|-------|--------|------|------|-----------
|1|Noah|Engineering|100|10 000|3
|2|Sophia|Engineering|100|20 000|3
|3|Liam|Engineering|100|30 000|3
|7|Mason|Executive|300|50 000|1
|4|Emma|HR|200|10 000|3
|5|Jacob|HR|200|10 000|3
|6|Olivia|HR|200|10 000|3
|8|Ava|Marketing|400|15 000|2
|9|Ethan|Marketing|400|10 000|2


### Использование функций MIN и MAX

В следующем примере в каждую строку добавляется дополнительное поле, в котором показывается минимальная зарплата в отделе.

    @result =
        SELECT 
            *,
            MIN(Salary) OVER( PARTITION BY DeptName ) AS MinSalary
        FROM @employees;

Получаются такие результаты:

|EmpID|EmpName|DeptName|DeptID|Salary|MinSalary
|-----|-------|--------|------|-------------|----------------
|1|Noah|Engineering|100|10 000|10 000
|2|Sophia|Engineering|100|20 000|10 000
|3|Liam|Engineering|100|30 000|10 000
|7|Mason|Executive|300|50 000|50 000
|4|Emma|HR|200|10 000|10 000
|5|Jacob|HR|200|10 000|10 000
|6|Olivia|HR|200|10 000|10 000
|8|Ava|Marketing|400|15 000|10 000
|9|Ethan|Marketing|400|10 000|10 000

Вставьте вместо MIN функцию MAX и посмотрите, что из этого получится.


## Ранжирующие функции

Ранжирующие функции возвращают ранжирующее значение (длинное целое) для каждой строки в каждой секции, которые определены предложениями PARTITION BY и OVER. Порядок ранжирования определяется предложением ORDER BY в предложении OVER.

Поддерживаются такие ранжирующие функции:

- RANK;
- DENSE\_RANK;
- NTILE;
- ROW\_NUMBER.

**Синтаксис**

	[ RANK() | DENSE_RANK() | ROW_NUMBER() | NTILE(<numgroups>) ]
	    OVER (
	        [PARTITION BY <identifier, > …[n]]
	        [ORDER BY <identifier, > …[n] [ASC|DESC]] 
	) AS <alias>

- В ранжирующих функциях использовать предложение ORDER BY необязательно. Если предложение ORDER BY указано, оно определяет порядок ранжирования. Если предложение ORDER BY не указано, U-SQL присваивает значения в порядке считывания записей. Таким образом, если предложение ORDER BY не указано, получается недетерминированное значение ROW NUMBER, RANK или DENSE\_RANK.
- Для функции NTILE требуется выражение, результатом которого является положительное целое число. Это число определяет количество групп, на которое необходимо разделить каждую секцию. Этот идентификатор используется только с ранжирующей функцией NTILE.

Дополнительные сведения о предложении OVER см. в [справке по U-SQL]().

Функции ROW\_NUMBER, RANK и DENSE\_RANK назначают строкам в окне номера. Мы не будем разбирать эти функции по отдельности, а рассмотрим, как они работают с одинаковыми входными данными.

    @result =
    SELECT 
        *,
        ROW_NUMBER() OVER (PARTITION BY Vertical ORDER BY Latency) AS RowNumber,
        RANK() OVER (PARTITION BY Vertical ORDER BY Latency) AS Rank, 
        DENSE_RANK() OVER (PARTITION BY Vertical ORDER BY Latency) AS DenseRank 
    FROM @querylog;
        
Обратите внимание, что предложения OVER идентичны. Получаются такие результаты:

|Запрос|Latency:int|Vertical|RowNumber|Rank|DenseRank
|-----|-----------|--------|--------------|---------|--------------
|Banana|300|Образ —|1|1|1
|Cherry|300|Образ —|2|1|1
|Durian|500|Образ —|3|3|2
|Apple|100|Web|1|1|1
|Fig|200|Web|2|2|2
|Papaya|200|Web|3|2|2
|Fig|300|Web|4|4|3
|Cherry|400|Web|5|5|4
|Durian|500|Web|6|6|5

### ROW\_NUMBER

В каждом окне (Vertical — Image или Web) номер строки увеличивается на 1 и упорядочивание выполняется по полю Latency.

![Оконная функция ROW\_NUMBER, язык U-SQL](./media/data-lake-analytics-use-windowing-functions/u-sql-windowing-function-row-number-result.png)

### RANK

В отличие от ROW\_NUMBER() функция RANK() учитывает значение поля Latency, указанное в предложении ORDER BY для окна.

Так как первые два значения в поле Latency одинаковые, RANK начинается с двух единиц. Затем идет тройка, так как значение Latency изменилось на 500. Несмотря на то, что повторяющиеся значения получают одинаковый ранг, число RANK сменяется следующим значением ROW\_NUMBER. В этом и заключается основной момент. То же самое происходит в вертикали Web: наблюдается последовательность 2, 2 и 4.

![Оконная функция RANK, язык U-SQL](./media/data-lake-analytics-use-windowing-functions/u-sql-windowing-function-rank-result.png)

### DENSE\_RANK
	
Функция DENSE\_RANK работает так же, как RANK, за исключением того, что она не переходит к следующему значению ROW\_NUMBER. Вместо этого она переходит к следующему числу в последовательности. Обратите внимание на последовательности 1, 1, 2 и 2, 2, 3 в примере.

![Оконная функция DENSE\_RANK, язык U-SQL](./media/data-lake-analytics-use-windowing-functions/u-sql-windowing-function-dense-rank-result.png)

### Примечания

- Если предложение ORDER BY не указано, ранжирующая функция будет применяться к набору строк без какого-либо упорядочения. Результатом будет недетерминированное применение ранжирующей функции.
- Строки, возвращаемые запросом с функцией ROW\_NUMBER, каждый раз будут упорядочиваться одинаково, только если выполняются следующие условия:

	- значения в секционированном столбце — уникальные;
	- значения в столбцах ORDER BY — уникальные;
	- комбинации значений в секционированном столбце и столбце ORDER BY — уникальные.

### NTILE

Функция NTILE распределяет строки упорядоченной секции в заданное количество групп. Группы нумеруются, начиная с единицы.


В примере ниже набор строк в каждой секции (вертикали) разбивается на 4 группы в порядке задержки обработки запроса, после чего возвращается номер группы каждой строки.

Вертикаль Image имеет три строки, поэтому в ней может быть только три группы.

Вертикаль Web имеет шесть строк, поэтому в первую и вторую группы добавляется по одной дополнительной строке. Именно поэтому в группах 1 и 2 есть по две строки, а в группах 3 и 4 — только по одной.

    @result =
        SELECT 
            *,
            NTILE(4) OVER(PARTITION BY Vertical ORDER BY Latency) AS Quartile   
        FROM @querylog;
		
Получаются такие результаты:

|Запрос|Задержка|Vertical|Quartile
|-----|-----------|--------|-------------
|Banana|300|Образ —|1
|Cherry|300|Образ —|2
|Durian|500|Образ —|3
|Apple|100|Web|1
|Fig|200|Web|1
|Papaya|200|Web|2
|Fig|300|Web|2
|Cherry|400|Web|3
|Durian|500|Web|4

Функция NTILE принимает параметр (numgroups). Numgroups — это положительное выражение целого числа или длинной константы, определяющее количество групп, на которые необходимо разделить каждую секцию.

- Если количество строк в секции делится на значение numgroups без остатка, все группы будут иметь одинаковый размер.
- Если количество строк в секции не делится на значение numgroups, будут созданы группы двух размеров, отличающихся на единицу. Сначала идут большие группы, а затем — маленькие. Порядок определяется предложением OVER.

Например:

- 100 строк делятся на 4 группы: 25, 25, 25, 25.
- 102 строки делятся на 4 группы: 26, 26, 25, 25.


### Получение N первых записей из каждой секции с помощью функции RANK, DENSE\_RANK или ROW\_NUMBER

Часто пользователям нужно выбрать только N первых строк из каждой группы. Используя предложение GROUP BY, сделать это невозможно.

Приведенный ниже пример продемонстрирован в начале раздела о функциях ранжирования. Он не показывает N первых записей в каждой секции.

    @result =
    SELECT 
        *,
        ROW_NUMBER() OVER (PARTITION BY Vertical ORDER BY Latency) AS RowNumber,
        RANK() OVER (PARTITION BY Vertical ORDER BY Latency) AS Rank,
        DENSE_RANK() OVER (PARTITION BY Vertical ORDER BY Latency) AS DenseRank
    FROM @querylog;

Получаются такие результаты:

|Запрос|Задержка|Vertical|Rank|DenseRank|RowNumber
|-----|-----------|--------|---------|--------------|--------------
|Banana|300|Образ —|1|1|1
|Cherry|300|Образ —|1|1|2
|Durian|500|Образ —|3|2|3
|Apple|100|Web|1|1|1
|Fig|200|Web|2|2|2
|Papaya|200|Web|2|2|3
|Fig|300|Web|4|3|4
|Cherry|400|Web|5|4|5
|Durian|500|Web|6|5|6

### Получение N первых записей с помощью функции DENSE\_RANK

В следующем примере возвращаются 3 первых записи из каждой группы. Разрывы в последовательной нумерации рангов строк в каждой оконной секции не допускаются.

    @result =
    SELECT 
        *,
        DENSE_RANK() OVER (PARTITION BY Vertical ORDER BY Latency) AS DenseRank
    FROM @querylog;
    
    @result = 
        SELECT *
        FROM @result
        WHERE DenseRank <= 3;

Получаются такие результаты:

|Запрос|Задержка|Vertical|DenseRank
|-----|-----------|--------|--------------
|Banana|300|Образ —|1
|Cherry|300|Образ —|1
|Durian|500|Образ —|2
|Apple|100|Web|1
|Fig|200|Web|2
|Papaya|200|Web|2
|Fig|300|Web|3

### Получение N первых записей с помощью функции RANK

    @result =
        SELECT 
            *,
            RANK() OVER (PARTITION BY Vertical ORDER BY Latency) AS Rank
        FROM @querylog;
    
    @result = 
        SELECT *
        FROM @result
        WHERE Rank <= 3;

Получаются такие результаты:

|Запрос|Задержка|Vertical|Rank
|-----|-----------|--------|---------
|Banana|300|Образ —|1
|Cherry|300|Образ —|1
|Durian|500|Образ —|3
|Apple|100|Web|1
|Fig|200|Web|2
|Papaya|200|Web|2


### Получение N первых записей с помощью функции ROW\_NUMBER

    @result =
        SELECT 
            *,
            ROW_NUMBER() OVER (PARTITION BY Vertical ORDER BY Latency) AS RowNumber
        FROM @querylog;
    
    @result = 
        SELECT *
        FROM @result
        WHERE RowNumber <= 3;

Получаются такие результаты:
    
|Запрос|Задержка|Vertical|RowNumber
|-----|-----------|--------|--------------
|Banana|300|Образ —|1
|Cherry|300|Образ —|2
|Durian|500|Образ —|3
|Apple|100|Web|1
|Fig|200|Web|2
|Papaya|200|Web|3

### Назначение глобального уникального номера строки

Зачастую лучше каждой строке назначать глобальный уникальный номер. Это легко сделать с помощью ранжирующих функций, и во многих случаях такой подход более эффективен, чем использование преобразователя данных.

    @result =
        SELECT 
            *,
            ROW_NUMBER() OVER () AS RowNumber
        FROM @querylog;

<!-- ################################################### -->
## Аналитические функции

Аналитические функции используются для анализа распределения значений в окнах. Чаще всего аналитические функции используют для вычисления процентилей.

**Поддерживаемые аналитические функции для окон**

- CUME\_DIST
- PERCENT\_RANK
- PERCENTILE\_CONT
- PERCENTILE\_DISC

### Функция CUME\_DIST  

Функция CUME\_DIST вычисляет относительное положение указанного значения в группе значений. Она вычисляет процент запросов, задержка которых меньше или равна задержке текущего запроса в той же вертикали. Если упорядочение выполняется по возрастанию, для строки R функция CUME\_DIST возвращает количество строк, значения которых равны значению R или меньше него, деленное на полученное количество строк в секции или результирующем наборе запроса. CUME\_DIST возвращает числа в диапазоне 0 < x < = 1.

**Синтаксис**

    CUME_DIST() 
        OVER (
            [PARTITION BY <identifier, > …[n]]
            ORDER BY <identifier, > …[n] [ASC|DESC] 
    ) AS <alias>

В следующем примере функция CUME\_DIST используется для вычисления процентиля задержки каждого запроса в вертикали.

    @result=
        SELECT 
            *,
            CUME_DIST() OVER(PARTITION BY Vertical ORDER BY Latency) AS CumeDist
        FROM @querylog;

Получаются такие результаты:
    
|Запрос|Задержка|Vertical|CumeDist
|-----|-----------|--------|---------------
|Durian|500|Image|1
|Banana|300|Образ —|0,666666666666667
|Cherry|300|Образ —|0,666666666666667
|Durian|500|Web|1
|Cherry|400|Web|0,833333333333333
|Fig|300|Web|0,666666666666667
|Fig|200|Web|0,5
|Papaya|200|Web|0,5
|Apple|100|Web|0,166666666666667

В секции есть 6 строк с ключом секции Web (4-я строка и ниже).

- Есть 6 строк, значение которых меньше или равно 500, поэтому CUME\_DIST равно 6/6=1.
- Есть 5 строк, значение которых меньше или равно 400, поэтому CUME\_DIST равно 5/6=0,83.
- Есть 4 строки, значение которых меньше или равно 300, поэтому CUME\_DIST равно 4/6=0.66.
- Есть 3 строки, значение которых меньше или равно 200, поэтому CUME\_DIST равно 3/6=0,5. Существуют две строки с одинаковым значением задержки.
- Есть 1 строка, значение которой меньше или равно 100, поэтому CUME\_DIST равно 1/6=0,16.


**Примечания об использовании**

- Равные значения всегда дают одно и то же значение интегральной функции распределения.
- Значения NULL рассматриваются как минимально возможные значения.
- Для вычисления CUME\_DIST необходимо указать предложение ORDER BY.
- Функция CUME\_DIST подобна функции PERCENT\_RANK.

Примечание. Предложение ORDER BY не допускается, если после инструкции SELECT не идет инструкция OUTPUT. Таким образом, предложение ORDER BY в инструкции OUTPUT определяет порядок отображения результирующего набора строк.


### Функция PERCENT\_RANK

Функция PERCENT\_RANK вычисляет относительный ранг строки в группе строк. Функция используется для определения относительного положения значения в набор строк или секции. Диапазон значений, возвращаемых функцией PERCENT\_RANK, больше 0 и меньше 1 или равен ей. В отличие от функции CUME\_DIST, функция PERCENT\_RANK всегда возвращает 0 для первой строки.
	
**Синтаксис**

    PERCENT_RANK() 
        OVER (
            [PARTITION BY <identifier, > …[n]]
            ORDER BY <identifier, > …[n] [ASC|DESC] 
        ) AS <alias>

**Примечания**

- Для первой строки в любом наборе функция PERCENT\_RANK возвращает 0.
- Значения NULL рассматриваются как минимально возможные значения.
- Для вычисления PERCENT\_RANK необходимо указать предложение ORDER BY.
- Функция CUME\_DIST подобна функции PERCENT\_RANK.


В следующем примере функция PERCENT\_RANK используется для вычисления процентиля задержки каждого запроса в вертикали.

Предложение PARTITION BY указано для того, чтобы секционировать строки результирующего набора по вертикали. Предложение ORDER BY в предложении OVER упорядочивает строки в каждой секции.

Значение, возвращаемое функцией PERCENT\_RANK, обозначает выраженный в процентах ранг задержки запросов в вертикали.


    @result=
        SELECT 
            *,
            PERCENT_RANK() OVER(PARTITION BY Vertical ORDER BY Latency) AS PercentRank
        FROM @querylog;

Получаются такие результаты:

|Запрос|Latency:int|Vertical|PercentRank
|-----|-----------|--------|------------------
|Banana|300|Образ —|0
|Cherry|300|Образ —|0
|Durian|500|Image|1
|Apple|100|Web|0
|Fig|200|Web|0,2
|Papaya|200|Web|0,2
|Fig|300|Web|0,6
|Cherry|400|Web|0,8
|Durian|500|Web|1

### Функции PERCENTILE\_CONT и PERCENTILE\_DISC

Эти две функции вычисляют процентиль на основе непрерывного или дискретного распределения значений в столбце.

**Синтаксис**

    [PERCENTILE_CONT | PERCENTILE_DISC] ( numeric_literal ) 
        WITHIN GROUP ( ORDER BY <identifier> [ ASC | DESC ] )
        OVER ( [ PARTITION BY <identifier,>…[n] ] ) AS <alias>

**numeric\_literal** — вычисляемый процентиль. Значение должно быть в диапазоне от 0,0 до 1,0.

WITHIN GROUP ( ORDER BY <идентификатор> [ ASC | DESC ]) . Указывает список числовых значений для сортировки и вычисления процентиля. Допускается только один идентификатор столбца. Выражение должно возвращать числовое значение. Другие типы данных не допускаются. По умолчанию значения сортируются по возрастанию.

OVER ([ PARTITION BY <идентификатор>…[n] ] ). Делит входной набор строк на секции (на основе ключей секций), к которым применяется функция вычисления процентиля. Дополнительные сведения см. в этой статье в разделе «Ранжирующие функции». Примечание. Все значения NULL в наборе данных игнорируются.

**PERCENTILE\_CONT** вычисляет процентиль на основе непрерывного распределения значений в столбце. Результат интерполируется и не может быть равен какому-либо конкретному значению в столбце.

**PERCENTILE\_DISC** вычисляет процентиль на основе дискретного распределения значений в столбце. Результат равен конкретному значению в столбце. Другими словами, функция PERCENTILE\_DISC, в отличие от PERCENTILE\_CONT, всегда возвращает фактическое (исходное входное) значение.

В приведенном ниже примере определяется медиана (процентиль равен 0,50) задержки в пределах каждой вертикали. На этом примере можно понять, как работают обе функции.

    @result = 
        SELECT 
            Vertical, 
            Query,
            PERCENTILE_CONT(0.5) 
                WITHIN GROUP (ORDER BY Latency)
                OVER ( PARTITION BY Vertical ) AS PercentileCont50,
            PERCENTILE_DISC(0.5) 
                WITHIN GROUP (ORDER BY Latency) 
                OVER ( PARTITION BY Vertical ) AS PercentileDisc50 
        
        FROM @querylog;

Получаются такие результаты:

|Запрос|Latency:int|Vertical|PercentileCont50|PercentilDisc50
|-----|-----------|--------|-------------------|----------------
|Banana|300|Образ —|300|300
|Cherry|300|Образ —|300|300
|Durian|500|Образ —|300|300
|Apple|100|Web|250|200
|Fig|200|Web|250|200
|Papaya|200|Web|250|200
|Fig|300|Web|250|200
|Cherry|400|Web|250|200
|Durian|500|Web|250|200


В случае с PERCENTILE\_CONT значения могут интерполироваться, поэтому медиана для вертикали Web будет равна 250, даже если в этой вертикали нет запроса с задержкой 250.

PERCENTILE\_DISC не интерполирует значения, поэтому медиана для вертикали Web будет равна 200, что есть одним из фактических значений входных строк.











## Дополнительные материалы

- [Обзор аналитики озера данных Microsoft Azure](data-lake-analytics-overview.md)
- [Начало работы с аналитикой озера данных с помощью портала Azure](data-lake-analytics-get-started-portal.md)
- [Начало работы с аналитикой озера данных с помощью Azure PowerShell](data-lake-analytics-get-started-powershell.md)
- [Разработка сценариев U-SQL с помощью средств озера данных для Visual Studio.](data-lake-analytics-data-lake-tools-get-started.md)
- [Использование интерактивных руководств по службе аналитики озера данных Azure](data-lake-analytics-use-interactive-tutorials.md)
- [Анализ журналов веб-сайта с помощью службы аналитики озера данных Azure](data-lake-analytics-analyze-weblogs.md)
- [Начало работы с языком U-SQL в аналитике озера данных Azure](data-lake-analytics-u-sql-get-started.md)
- [Управление аналитикой озера данных Azure с помощью портала Azure](data-lake-analytics-manage-use-portal.md)
- [Управление аналитикой озера данных Azure с помощью Azure PowerShell](data-lake-analytics-manage-use-powershell.md)
- [Мониторинг заданий аналитики озера данных Azure и устранение связанных с ними неполадок с помощью портала Azure](data-lake-analytics-monitor-and-troubleshoot-jobs-tutorial.md)

<!---HONumber=AcomDC_0914_2016-->