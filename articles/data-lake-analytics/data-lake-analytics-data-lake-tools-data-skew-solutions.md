---
title: "Возможные решения для устранения неравномерного смещения данных в Azure Data Lake | Документация Майкрософт"
description: "Возможные решения для устранения неполадок неравномерного смещения данных в Azure Data Lake."
services: data-lake-analytics
documentationcenter: 
author: yanancai
manager: 
editor: 
ms.assetid: 
ms.service: data-lake-analytics
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: big-data
ms.date: 12/16/2016
ms.author: yanacai
translationtype: Human Translation
ms.sourcegitcommit: f2b2a2230900ad5007500f9efb4c8e7ee0aca165
ms.openlocfilehash: 1ddad5c3dc7006895ee38e06b1134857f95c3e7a


---

# <a name="possible-data-skew-solutions-for-azure-data-lake"></a>Возможные решения для устранения неравномерного смещения данных в Azure Data Lake

## <a name="what-is-data-skew-problem"></a>Что представляет собой проблема неравномерного смещения данных?

Одним словом, неравномерное смещение данных — это чрезмерно представленное значение. Допустим, для инспекторов, которые выполняют аудит финансовой отчетности об уплате налогов, установлено значение 50 — по одному человеку для каждого штата. Аудитор из Вайоминга не будет загружен работой, так как этот штат не является густонаселенным, а инспекторы из Калифорнии будут работать допоздна, так как в этом штате многочисленное население. 
    ![Пример проблемы неравномерного смещения данных](./media/data-lake-analytics-data-lake-tools-data-skew-solutions/data-skew-problem.png) 

В приведенном выше случае данные между работниками распределены неравномерно, из-за чего одним приходится трудиться больше, чем другим. В ходе выполнения вашего задания, как правило, возникают похожие ситуации — одна вершина получает гораздо больше данных по сравнению с другими. Это приводит к тому, что она обрабатывается дольше других, и в конечном счете это замедляет выполнение всего задания. Что еще хуже, задание может завершиться сбоем, так как время обработки вершин ограничено до 5 часов, а объем памяти — до 6 ГБ.

## <a name="how-to-troubleshoot"></a>Как устранить эту проблему?

Инструменты Azure Data Lake помогают определить, есть ли в задании проблема неравномерного смещения. Чтобы устранить такую проблему, можно воспользоваться приведенными ниже решениями.

### <a name="solution-1-improve-table-partition"></a>Решение 1. Улучшение секционирования таблиц

#### <a name="option-1-filter-the-skewed-key-value-in-advance"></a>Вариант 1. Отфильтруйте неравномерное значение ключа заранее

Если это не влияет на вашу бизнес-логику, вы можете отфильтровать самое часто встречаемое значение заранее. Например, в столбце GUID много значений 000-000-000, но вы не хотите выполнять статистические вычисления на основе этого значения. В этом случае можно написать "WHERE GUID != "000-000-000"", чтобы отфильтровать значение, которое часто встречается, перед статистическими вычислениями.

#### <a name="option-2-pick-a-different-partitiondistribution-key"></a>Вариант 2. Выберите другой ключ секции или распределения

В примере выше, если все, что вам необходимо сделать, — это проверить налоги во всей стране, вы можете выбрать номер идентификатора в качестве ключа, чтобы улучшить распределение данных. Иногда, выбрав другой ключ секции или распределения, можно распределить данные более равномерно, однако следует убедиться, что это не повлияет на бизнес-логику. Например, если необходимо вычислить сумму налогов для каждого штата, лучше выбрать штат в качестве ключа секции. Если это ваш случай, можете воспользоваться вариантом 3.

#### <a name="option-3-add-more-partitiondistribution-key"></a>Вариант 3. Добавьте дополнительный ключ секции или распределения

Можно использовать несколько ключей для секционирования. Помимо штата добавьте в качестве ключа секции дополнительный параметр, например почтовый индекс. Это уменьшит размеры секций данных, что позволит распределить данные более равномерно.

#### <a name="option-4-round-robin-distribution"></a>Вариант 4. Распределение путем циклического перебора

Если не удается найти подходящий ключ для секции и распределения, попробуйте использовать распределение путем циклического перебора. При распределении путем циклического перебора все строки обрабатываются одинаково и случайным образом помещаются в соответствующий контейнер. В этом случае данные распределяются равномерно, но при этом теряются сведения о размещении, что также снижает производительность выполнения задания для некоторых операций. Более того, если вы выполняете статистическую обработку для неравномерного ключа, проблема неравномерного распределения никуда не исчезнет. Сведения об использовании циклического перебора см. [здесь](https://msdn.microsoft.com/en-us/library/mt706196.aspx#dis_sch).

### <a name="case-2-improve-query-plan"></a>Решение 2. Улучшение плана запроса

#### <a name="option-1-create-statistics-for-column"></a>Вариант 1. Используйте инструкцию CREATE STATISTICS для столбца

В U-SQL предусмотрена инструкция CREATE STATISTICS в таблицах, что предоставляет оптимизатору запросов дополнительные сведения о характеристиках данных, хранящихся в таблице, например распределение значений и т. д. Для большинства запросов оптимизатор создает необходимую статистику для плана запроса высокого качества. В некоторых случаях необходимо создать дополнительную статистику с помощью инструкции CREATE STATISTICS или изменить структуру запроса, чтобы повысить производительность запросов. Дополнительные сведения см. [здесь](https://msdn.microsoft.com/en-us/library/azure/mt771898.aspx).

**Пример кода:**

    CREATE STATISTICS IF NOT EXISTS stats_SampleTable_date ON SampleDB.dbo.SampleTable(date) WITH FULLSCAN;

>[!NOTE]
>Обратите внимание, что статистические данные не обновляются автоматически. Это означает, что если обновить данные в таблице и не создать статистику повторно, это приведет к снижению производительности запросов.
>
>

#### <a name="option-2-use-skewfactor"></a>Вариант 2. Используйте SKEWFACTOR

В примере с проверкой налогов единственный способ подсчитать сумму налогов для каждого штата — использовать группировку по штатам (с помощью выражения GROUP BY), что приведет к неравномерному распределению данных. Тем не менее в запросе можно указать подсказку данных, чтобы идентифицировать неравномерное распределение в ключах, благодаря чему оптимизатор сможет оптимизировать план выполнения.

Как правило, можно установить для параметра значение 0.5 и 1, где 0.5 означает незначительное смещение данных, а 1 — интенсивное. Подсказка влияет на оптимизацию плана выполнения для текущей инструкции и всех подчиненных инструкций, поэтому добавьте подсказку перед возможной статистической обработкой неравномерно распределенных ключей.

    SKEWFACTOR (columns) = x

    Provides hint that given columns have a skew factor x between 0 (no skew) and 1 (very heavy skew).

**Пример кода:**

    //Adding SKEWFACTOR hint
    @Impressions = 
        SELECT * FROM 
        searchDM.SML.PageView(@start, @end) AS PageView
        OPTION(SKEWFACTOR(Query)=0.5)
        ;

    //Query 1 for key: Query, ClientId
    @Sessions = 
        SELECT 
            ClientId, 
            Query, 
            SUM(PageClicks) AS Clicks
        FROM 
            @Impressions
        GROUP BY
            Query, ClientId
        ;

    // Query 2 for Key: Query
    @Display = 
        SELECT * FROM @Sessions 
            INNER JOIN @Campaigns 
                ON @Sessions.Query == @Campaigns.Query
        ;   

Помимо SKEWFACTOR для объединения неравномерно распределенных ключей в случае, когда один из наборов объединенных строк имеет небольшой размер, в инструкцию U-SQL можно добавить подсказку ROWCOUNT перед инструкцией JOIN, чтобы сообщить оптимизатору о наличии маленького набора строк. В результате этого оптимизатор выберет стратегию присоединения для повышения производительности. Но обратите внимание, что ROWCOUNT не устранит проблему неравномерного распределения, а только предоставит временное решение.

    OPTION(ROWCOUNT = n)

    Identify small row set before join by giving an estimated integer row count.

**Пример кода:**

    // Unstructured (24 hours daily log impressions)
    @Huge   = EXTRACT ClientId int, ... 
                FROM @"wasb://ads@wcentralus/2015/10/30/{*}.nif"
                ;

    // Small subset (ie: ForgetMe opt out)
    @Small  = SELECT * FROM @Huge 
                WHERE Bing.ForgetMe(x,y,z)
                OPTION(ROWCOUNT=500)
                ;

    // Result (not enough info to determine simple Broadcast join)
    @Remove = SELECT * FROM Bing.Sessions
                INNER JOIN @Small ON Sessions.Client == @Small.Client
                ;

### <a name="case-3-improve-user-defined-reducer-and-combiner"></a>Вариант 3. Улучшение определяемых пользователем редуктора и средства объединения

Иногда при работе со сложной логикой процессов вы используете пользовательский оператор, а хорошо написанный редуктор и средство объединения в некоторых случаях могут устранить проблему неравномерного распределения данных.

#### <a name="option-1-use-recursive-reducer-if-possible"></a>Вариант 1. По возможности используйте рекурсивный редуктор

По умолчанию определяемый пользователем редуктор будет выполняться как нерекурсивный режим, а это означает, что уменьшенный объем работы для ключа будет распределен в одну вершину. Но проблема заключается в том, что если данные распределены неравномерно, крупные наборы данных могут обрабатываться в одной вершине, что займет довольно много времени. 

Для повышения производительности в код можно добавить атрибут, чтобы определить редуктор как рекурсивный режим. После этого крупные наборы данных можно распределить по нескольким вершинам и выполнять параллельно, что ускорит вашу работу. 

Обратите внимание, чтобы изменить нерекурсивный редуктор на рекурсивный, ваш алгоритм должен быть ассоциативным. Например, сумма является ассоциативной, а медиана — нет. Кроме того, во входных и выходных данных для редуктора должна храниться одна и та же схема.

**Атрибут для рекурсивного редуктора:**

    [SqlUserDefinedReducer(IsRecursive = true)]

**Пример кода:**

    [SqlUserDefinedReducer(IsRecursive = true)]
    public class TopNReducer : IReducer
    {
        public override IEnumerable<IRow> 
            Reduce(IRowset input, IUpdatableRow output)
        {
            // your reducer code here
        }
    }

#### <a name="option-2-use-row-level-combiner-mode-if-possible"></a>Вариант 2. По возможности используйте режим средства объединения на уровне строк

Как и в случае с подсказкой ROWCOUNT для определенных случаев объединения неравномерно распределенных ключей, режим средства объединения пытается распределить огромные наборы неравномерно распределенных значений ключей по нескольким вершинам, чтобы операции могли выполняться одновременно. Это не устранит проблему смещения данных, но может временно помочь с обработкой огромных наборов неравномерно распределенных значений ключей.

По умолчанию режим средства объединения является полным, а это означает, что левый и правый наборы разделить невозможно. Установив для режима значение Left/Right/Inner, можно обеспечить объединение на уровне строк, благодаря чему система сможет разделить соответствующий набор строк, распределить их по нескольким вершинам и выполнять их параллельно. Тем не менее, прежде чем настроить режим средства объединения, необходимо убедиться, что соответствующий набор строк можно разделить.

Ниже приведен пример отделенного левого набора строк. В этом случае каждая строка выходных данных зависит от одной входной строки из левого входа и потенциально зависит от всех строк из правого входа с тем же значением ключа. В этом случае, если установить режим средства объединения как левый вход, система разделит большой левый набор строк на небольшие и назначит их нескольким вершинам.
![Иллюстрация режима средства объединения](./media/data-lake-analytics-data-lake-tools-data-skew-solutions/combiner-mode-illustration.png) 
   
>[!NOTE]
>Обратите внимание, что если задать неправильный режим средства объединения, объединение будет менее эффективным, а результаты могут исказиться еще больше!
>
>

**Атрибуты для средства объединения:**

- [SqlUserDefinedCombiner(Mode=CombinerMode.Full)]: Every output row potentially depends on all the input rows from left and right with the same key value.

- SqlUserDefinedCombiner(Mode=CombinerMode.Left) — каждая строка выходных данных зависит от одной входной строки из левого входа (и потенциально от всех строк из правого входа с тем же значением ключа).

- qlUserDefinedCombiner(Mode=CombinerMode.Right) — каждая строка выходных данных зависит от одной входной строки из правого входа (и потенциально от всех строк из левого входа с тем же значением ключа).

- SqlUserDefinedCombiner(Mode=CombinerMode.Inner) — каждая строка выходных данных зависит от одной входной строки из левого и правого входа с тем же значением.

**Пример кода:**

    [SqlUserDefinedCombiner(Mode = CombinerMode.Right)]
    public class WatsonDedupCombiner : ICombiner
    {
        public override IEnumerable<IRow> 
            Combine(IRowset left, IRowset right, IUpdatableRow output)
        {
        // your combiner code here
        }
    }


<!--HONumber=Dec16_HO3-->


