---
title: "Как создать приложение, поддерживающее вход любого пользователя Azure AD | Документация Майкрософт"
description: "Пошаговые инструкции по созданию приложения, которое может реализовать вход пользователя из любого клиента Azure Active Directory, также известного как мультитенантное приложение."
services: active-directory
documentationcenter: 
author: skwan
manager: mbaldwin
editor: 
ms.assetid: 35af95cb-ced3-46ad-b01d-5d2f6fd064a3
ms.service: active-directory
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: identity
ms.date: 01/23/2017
ms.author: skwan;bryanla
translationtype: Human Translation
ms.sourcegitcommit: c0c94960cc0a6a00f1db19867e622cda7f66a07b
ms.openlocfilehash: 80f7470bcaad07ff2e355a7b95155a329827e8e0


---
# <a name="how-to-sign-in-any-azure-active-directory-ad-user-using-the-multi-tenant-application-pattern"></a>Как реализовать вход любого пользователя Azure Active Directory (AD) с помощью шаблона мультитенантного приложения
Если вы предлагаете приложение "программное обеспечение как сервис" для многих организаций, то можете настроить приложение таким образом, чтобы оно поддерживало вход из любого клиента Azure AD.  В Azure AD это называется "сделать приложение мультитенантным".  Пользователи из любого клиента Azure AD смогут входить в приложение после того, как согласятся использовать свою учетную запись с вашим приложением.  

Если у вас есть приложение, которое имеет собственную систему учетных записей или другие способы входа от других поставщиков облачных служб, то добавить вход Azure AD из любого клиента будет так же просто, как и зарегистрировать приложение, добавить код входа посредством OAuth2, OpenID Connect или SAML и поместить в свое приложение кнопку "Войти в Майкрософт". Чтобы узнать больше о добавлении фирменной символики в приложение, нажмите кнопку ниже.

[![Sign in button][AAD-Sign-In]][AAD-App-Branding]

В этой статье предполагается, что вы уже знакомы с процессом создания однотенантного приложения для Azure AD.  Если это не так, вернитесь на страницу [Руководство разработчика по Azure Active Directory][AAD-Dev-Guide] и ознакомьтесь с одним из кратких руководств, указанных в разделе "Приступая к работе".

Преобразовать приложение в мультитенантное приложение Azure AD можно с помощью четырех простых шагов:

1. Обновите регистрацию приложения, изменив ее на мультитенантную.
2. Обновите код для отправки запросов в конечную точку "/common". 
3. Обновите код для обработки нескольких значений издателя.
4. Изучите особенности получения согласия пользователя и администратора и внесите соответствующие изменения в код.

Давайте рассмотрим каждый из этих шагов подробнее. Вы также можете сразу перейти к [этому списку примеров кода для мультитенантных приложений][AAD-Samples-MT].

## <a name="update-registration-to-be-multi-tenant"></a>Обновление регистрации с изменением ее на мультитенантную
По умолчанию регистрация веб-приложения или API в Azure AD предусматривает работу только с одним клиентом, то есть является однотенантной.  Чтобы сделать регистрацию мультитенантной, на [классическом портале Azure][AZURE-classic-portal] на странице настройки регистрации приложения найдите переключатель "Приложение является мультитенантным" и установите его в положение "Да".

Также обратите внимание, что прежде чем сделать приложение мультитенантным, Azure AD требуется, чтобы универсальный код ресурса (URI) кода приложения был глобально уникальным. URI кода приложения является одним из способов идентификации приложения в сообщениях протокола.  Для однотенантного приложения достаточно, чтобы URI кода приложения был уникальным в рамках клиента.  Для мультитенантного приложения он должен быть глобально уникальным, чтобы служба Azure AD могла найти приложение по всем клиентам.  Глобальная уникальность обеспечивается за счет требования, чтобы URI кода приложения имел имя узла, соответствующее проверенному домену клиента Azure AD.  Например, если имя клиента — contoso.onmicrosoft.com, то допустимым URI кода приложения будет `https://contoso.onmicrosoft.com/myapp`.  Если проверенный домен клиента — `contoso.com`, то допустимым URI кода приложения тоже будет `https://contoso.com/myapp`.  Вы не сможете сделать приложение мультитенантным, если URI кода приложения не будет соответствовать этому шаблону.

Регистрации собственных клиентов являются мультитенантными по умолчанию.  Чтобы сделать регистрацию собственного клиентского приложения мультитенантной, не нужно предпринимать каких-либо действий.

## <a name="update-your-code-to-send-requests-to-common"></a>Обновление кода для отправки запросов в конечную точку "/common"
В однотенантном приложении запросы на вход отправляются в конечную точку входа клиента.   Например, для contoso.onmicrosoft.com конечная точка имела бы следующий вид:

    https://login.microsoftonline.com/contoso.onmicrosoft.com

Запросы, отправленные в конечную точку клиента, могут выполнять вход пользователей (или гостей) этого клиента в приложения этого клиента.  Если используется мультитенантное приложение, то оно не знает заранее, из какого клиента тот или иной пользователь, поэтому невозможно отправить запрос в конечную точку клиента.  Вместо этого запросы отправляются в конечную точку, которая мультиплексируется по всем клиентам Azure AD:

    https://login.microsoftonline.com/common

Когда служба Azure AD получает запрос в конечной точке "/common", она выполняет вход пользователя и, как следствие, выясняет, из какого клиента этот пользователь.  Конечная точка /common работает со всеми протоколами проверки подлинности, поддерживаемыми Azure AD: OpenID Connect, OAuth 2.0, SAML 2.0 и WS-Federation.

Ответ приложению на вход содержит маркер, представляющий пользователя.  Значение издателя в маркере сообщает приложению, из какого клиента этот пользователь.  Когда из конечной точки "/common" возвращается ответ, значение издателя в маркере соответствует клиенту пользователя.  Важно отметить, что конечная точка "/common" — это просто мультиплексор, а не клиент или издатель.  Учитывая этот факт, при использовании "/common" логику проверки маркеров в приложении необходимо обновить. 

Как упоминалось ранее, мультитенантные приложения также должны предоставлять согласованную процедуру входа для пользователей. Эта процедура должна соответствовать рекомендациям по фирменной символике приложений Azure AD. Чтобы узнать больше о добавлении фирменной символики в приложение, нажмите кнопку ниже.

[![Sign in button][AAD-Sign-In]][AAD-App-Branding]

Рассмотрим подробнее реализацию вашего кода и использование конечной точки /common.

## <a name="update-your-code-to-handle-multiple-issuer-values"></a>Обновите код для обработки нескольких значений издателя.
Веб-приложения и веб-API получают маркеры из Azure AD и там же выполняют их проверку.  

> [!NOTE]
> А собственные клиентские приложения запрашивают и получают маркеры из Azure AD, чтобы затем отправить их в API, где они проходят проверку.  Собственные приложения не проверяют маркеры и воспринимают их как непрозрачные.
> 
> 

Давайте посмотрим, как приложение проверяет маркеры, полученные из Azure AD.  Однотенантное приложение обычно принимает значение конечной точки, подобное этому:

    https://login.microsoftonline.com/contoso.onmicrosoft.com

Оно используется для формирования URL-адреса метаданных (в данном случае — OpenID Connect), например:

    https://login.microsoftonline.com/contoso.onmicrosoft.com/.well-known/openid-configuration

С его помощью скачиваются два критически важных фрагмента данных, используемые для проверки маркеров: значение издателя и ключи подписи клиента.  Каждый клиент Azure AD имеет уникальное значение издателя, которое можно представить в такой форме:

    https://sts.windows.net/31537af4-6d77-4bb9-a681-d2394888ea26/

где значение GUID — это версия кода клиента, защищенная от переименования.  Если щелкнуть указанную выше ссылку на метаданные для `contoso.onmicrosoft.com`, то вы увидите это значение издателя в документе.

Когда однотенантное приложение выполняет проверку маркера, оно сверяет подпись маркера с ключами подписи из документа метаданных и гарантирует, чтобы значение издателя в маркере совпадало со значением, обнаруженным в документе метаданных.

Так как конечная точка "/common" не соответствует клиенту и не является издателем, то при проверке значения издателя в метаданных для точки "/common" вместо фактического значения отображается шаблон URL-адреса:

    https://sts.windows.net/{tenantid}/

Таким образом, мультитенантное приложение не может проверить маркеры, просто сопоставив значение издателя в метаданных со значением `issuer` в маркере.  Мультитенантному приложению требуется логика, чтобы решить, какие значения издателя являются допустимыми, а какие не являются, исходя из части значения издателя, в которой указан код клиента.  

Например, если мультитенантное приложение разрешает вход только из определенных клиентов, которые зарегистрировались в службе, то оно должно проверить значение издателя или значение утверждения `tid` в маркере, чтобы убедиться, что этот клиент внесен в его список подписчиков.  Если мультитенантное приложение работает только с отдельными пользователями и не принимает решений о доступе на основе данных клиентов, то оно может полностью игнорировать значение издателя.

В примерах мультитенантных приложений, которые можно найти в разделе [Связанная информация](#related-content) в конце этой статьи, проверка издателя отключена, чтобы можно было включить возможность входа для любого клиента Azure AD.

Теперь давайте взглянем на то, как осуществляется вход пользователей в мультитенантные приложения.

## <a name="understanding-user-and-admin-consent"></a>Получение согласия пользователя и администратора
Чтобы пользователь мог войти в приложение в Azure AD, это приложение должно быть представлено в клиенте пользователя.  Это дает возможность организации применять уникальные политики входа в приложение пользователей из клиента.  Регистрацию для однотенантного приложения легко выполнить. Это та же самая процедура, которая выполняется при регистрации приложения на [классическом портале Azure][AZURE-classic-portal].

Для мультитенантного приложения его начальная регистрация находится в клиенте Azure AD, используемом разработчиком.  При первом входе в приложение пользователя из другого клиента Azure AD предлагает принять разрешения, запрошенные приложением.  Если пользователь соглашается, то в его клиенте создается представление приложения, называемое *субъектом-службой*, после чего можно продолжить вход. В каталоге также создается делегирование, которое записывает согласие пользователя в приложение. Дополнительные сведения об объектах приложений и объектах субъектов-служб и их взаимосвязи см. в [этой статье][AAD-App-SP-Objects].

![Разрешения для одноуровневого приложения][Consent-Single-Tier] 

Для получения согласия используются разрешения, запрашиваемые приложением.  Azure AD поддерживает два типа разрешений: делегированные и только для приложения. Различия между ними описаны ниже.

* Делегированное разрешение предоставляет приложению возможность выступать в качестве выполнившего вход пользователя и выполнять ряд действий, доступных пользователю.  Например, можно предоставить приложению делегированное разрешение на чтение календаря выполнившего вход пользователя.
* Разрешение "только для приложения" предоставляется непосредственно удостоверению приложения.  Например, если предоставить приложению разрешение "только для приложения" на чтение списка пользователей в клиенте, то оно сможет делать это независимо от того, кто выполнил вход в приложение.

Некоторые разрешения могут быть приняты обычным пользователем, а для других требуется согласие администратора клиента. 

### <a name="admin-consent"></a>Согласие администратора
Для разрешений "только для приложения" всегда требуется согласие администратора клиента.  Если приложение запрашивает разрешение "только для приложения" и обычный пользователь пытается войти в него, то в приложении отобразится сообщение об ошибке, информирующее, что пользователь не может принять это разрешение.

Для некоторых делегированных разрешений также требуется согласие администратора клиента.  Например, оно требуется для возможности обратной записи в Azure AD в качестве выполнившего вход пользователя.  Как и в случае с разрешениями "только для приложения", если обычный пользователь пытается войти в приложение, запрашивающее делегированное разрешение, для которого требуется согласие администратора, то в приложении отобразится сообщение об ошибке.  Требует ли разрешение согласия администратора определяется разработчиком, опубликовавшим ресурс. Эти сведения можно найти в документации по данному ресурсу.  Ссылки на статьи, описывающие доступные разрешения для API Graph Azure AD и API Microsoft Graph, приведены в разделе [Связанная информация](#related-content) этой статьи.

Если приложение использует разрешения, требующие согласия администратора, то в приложении должен быть элемент, такой как кнопка или ссылка, с помощью которого администратор может инициировать действие.  Запрос, отправляемый приложением для этого действия, является обычным запросом авторизации OAuth2 или OpenID Connect, но он также включает в себя параметр строки запроса `prompt=admin_consent` .  После того как администратор предоставит свое согласие, а в клиенте пользователя будет создана субъект-служба, в последующих запросах входа не нужно будет указывать параметр `prompt=admin_consent` .   Когда администратор решил, что запрошенные разрешения являются приемлемыми, то с этого момента у других пользователей в клиенте согласие запрашиваться не будет.

Параметр `prompt=admin_consent` также можно использовать в приложениях, которые запрашивают разрешения, не требующие согласия администратора, но применяют практику одноразовой "регистрации" администратора клиента в приложении, после которой у других пользователей согласие не запрашивается.

Если приложению требуется согласие администратора и администратор выполняет вход в приложение, но параметр `prompt=admin_consent` не передается, администратор сможет дать свое согласие приложению, однако это будет только согласие для учетной записи пользователя.  Обычные пользователи по-прежнему не смогут выполнять вход и давать свое согласие приложению.  Это полезно, если требуется предоставить администратору клиента возможность просмотреть приложение, прежде чем предоставлять доступ другим пользователям.

Администратор клиента может отключить возможность обычным пользователям предоставлять согласие для приложений.  Если эта возможность отключена, то для настройки приложения в клиенте всегда требуется согласие администратора.  Чтобы протестировать приложение, в котором отключена возможность предоставления согласия для обычных пользователей, найдите соответствующий параметр в разделе конфигурации клиента Azure AD на [классическом портале Azure][AZURE-classic-portal].

> [!NOTE]
> В некоторых приложениях применяется следующая практика: сначала свое согласие имеют возможность предоставить обычные пользователи, а затем приложение может привлечь администратора и запросить разрешения, для которых требуется его согласие.  При регистрации однотенантного приложения такая возможность в Azure AD в данный момент отсутствует.  Предстоящий выпуск конечной точки Azure AD версии&2;.0 позволит приложениям запрашивать разрешения в среде выполнения, а не во время регистрации, что даст возможность реализовать этот сценарий.  Дополнительные сведения см. в статье [Вход для пользователей учетных записей Майкрософт и Azure AD в одном приложении][AAD-V2-Dev-Guide].
> 
> 

### <a name="consent-and-multi-tier-applications"></a>Согласие и многоуровневые приложения
Приложение может иметь несколько уровней, каждый из которых представлен в Azure AD собственной регистрацией.  Например, собственное приложение, выполняющее вызовы веб-API, или веб-приложение, выполняющее вызовы веб-API.  В обоих случаях клиент (собственное приложение или веб-приложение) запрашивает разрешения на вызов ресурса (веб-API).  Чтобы клиент мог получить согласие от клиента пользователя, все ресурсы, к которым он запрашивает разрешения, должны существовать в клиенте пользователя.  Если это условие не выполняется, то Azure AD выдаст ошибку и сообщит, что сначала необходимо добавить ресурс.

Это может быть проблемой, если ваше логические приложение состоит из двух или более регистраций приложения, например, отдельно для клиента и ресурса.  Как сначала поместить ресурс в клиент пользователя?  На этот случай в Azure AD предусмотрена возможность получения согласия для клиента и ресурса за один шаг, где пользователь видит общее число разрешений, запрошенных клиентом и ресурсом на странице получения согласия.  Чтобы активировать такое поведение, регистрация приложения ресурса должна включать в себя идентификатор приложения клиента как `knownClientApplications` в манифесте соответствующего приложения.  Например:

    knownClientApplications": ["94da0930-763f-45c7-8d26-04d5938baab2"]

Это свойство можно обновить посредством [манифеста приложения][AAD-App-Manifest] ресурса, что и демонстрируется в примере многоуровневого собственного клиента, выполняющего вызов веб-API, в разделе [Связанная информация](#related-content) в конце этой статьи. На схеме ниже представлен обзор согласия для многоуровневого приложения:

![Разрешения для известного многоуровневого приложения][Consent-Multi-Tier-Known-Client] 

Аналогичная ситуация складывается, когда различные уровни приложения регистрируются в разных клиентах.  Например, рассмотрим случай создания собственного клиентского приложения, выполняющего вызов API Office 365 Exchange Online.  Для разработки собственного приложения, а затем и для его запуска в клиенте пользователя необходимо наличие субъекта-службы Exchange Online.  В этом случае пользователь должен приобрести Exchange Online, чтобы в его клиенте был создан субъект-служба.  Если используется API, созданный не Майкрософт, а иной организацией, то разработчик API должен предоставить пользователям возможность получать согласие на связь своего приложения с клиентом пользователя, например, веб-страницу, на которой осуществляется получение согласия с помощью механизмов, описанных в этой статье.  После создания в клиенте субъекта-службы собственное приложение может получить маркеры для API.

На схеме ниже представлен обзор согласия для многоуровневого приложения, зарегистрированного в разных клиентах:

![Разрешения для многоуровневого приложения c несколькими участниками][Consent-Multi-Tier-Multi-Party] 

### <a name="revoking-consent"></a>Отзыв согласия
Пользователи и администраторы в любой момент могут отозвать свое согласие, предоставленное приложению.

* Чтобы отозвать доступ к отдельным приложениям, пользователям необходимо удалить их из списка [Приложения панели доступа][AAD-Access-Panel].
* Администраторы могут отозвать доступ к приложениям, удалив их из Azure AD с помощью раздела управления на [классическом портале Azure][AZURE-classic-portal].

Если администратор дает свое согласие на доступ к приложению для всех пользователей в клиенте, то пользователи не могут отзывать доступ индивидуально.  В этом случае отозвать доступ может только администратор и только для всего приложения.

### <a name="consent-and-protocol-support"></a>Согласие и поддерживаемые протоколы
Процедура получения согласия в Azure AD поддерживается для протоколов OAuth, OpenID Connect, WS-Federation и SAML.  Протоколы SAML и WS-Federation не поддерживают параметр `prompt=admin_consent` , поэтому получение согласия администратора возможно только с использованием протоколов OAuth и OpenID Connect.

## <a name="multi-tenant-applications-and-caching-access-tokens"></a>Мультитенантные приложения и кэширование маркеров доступа
Мультитенантные приложения также могут получать маркеры доступа для вызова API, защищенных службой Azure AD.  Распространенной ошибкой при использовании библиотеки проверки подлинности Active Directory (ADAL) с мультитенантным приложением является начальный запрос маркера для пользователя с помощью точки "/common", получение ответа, а затем запрос последующего маркера для того же пользователя с помощью той же точки "/common".  Так как ответ от Azure AD приходит из клиента, а не из "/common", то ADAL кэширует маркер как полученный из клиента. Последующий вызов точки "/common" для получения маркера доступа для пользователя не записывается в кэш (происходит промах кэша), и пользователю предлагается выполнить вход повторно.  Во избежание промахов кэша убедитесь, что последующие вызовы для выполнившего вход пользователя осуществляются в конечную точку клиента.

## <a name="related-content"></a>Связанная информация
* [Примеры мультитенантных приложений][AAD-Samples-MT]
* [Рекомендации по фирменной символике для приложений][AAD-App-Branding]
* [Руководство разработчика по Azure Active Directory][AAD-Dev-Guide]
* [Объекты приложения и субъекта-службы в Azure Active Directory][AAD-App-SP-Objects]
* [Интеграция приложений с Azure Active Directory][AAD-Integrating-Apps]
* [Обзор платформы согласия][AAD-Consent-Overview]
* [Microsoft Graph permission scopes (Области действия разрешений Microsoft Graph)][MSFT-Graph-AAD]
* [Области разрешений | Основные понятия API Graph][AAD-Graph-Perm-Scopes]

Оставляйте свои замечания и пожелания в разделе DISQUS ниже. Они помогают нам улучшать содержимое веб-сайта.

<!--Reference style links IN USE -->
[AAD-Access-Panel]:  https://myapps.microsoft.com
[AAD-App-Branding]: ./active-directory-branding-guidelines.md
[AAD-App-Manifest]: ./active-directory-application-manifest.md
[AAD-App-SP-Objects]: ./active-directory-application-objects.md
[AAD-Auth-Scenarios]: ./active-directory-authentication-scenarios.md
[AAD-Consent-Overview]: ./active-directory-integrating-applications.md#overview-of-the-consent-framework
[AAD-Dev-Guide]: ./active-directory-developers-guide.md
[AAD-Graph-Overview]: https://azure.microsoft.com/en-us/documentation/articles/active-directory-graph-api/
[AAD-Graph-Perm-Scopes]: https://msdn.microsoft.com/library/azure/ad/graph/howto/azure-ad-graph-api-permission-scopes
[AAD-Integrating-Apps]: ./active-directory-integrating-applications.md
[AAD-Samples-MT]: https://azure.microsoft.com/documentation/samples/?service=active-directory&term=multitenant
[AAD-Why-To-Integrate]: ./active-directory-how-to-integrate.md
[AZURE-classic-portal]: https://manage.windowsazure.com
[MSFT-Graph-AAD]: https://graph.microsoft.io/en-us/docs/authorization/permission_scopes

<!--Image references-->
[AAD-Sign-In]: ./media/active-directory-devhowto-multi-tenant-overview/sign-in-with-microsoft-light.png
[Consent-Single-Tier]: ./media/active-directory-devhowto-multi-tenant-overview/consent-flow-single-tier.png
[Consent-Multi-Tier-Known-Client]: ./media/active-directory-devhowto-multi-tenant-overview/consent-flow-multi-tier-known-clients.png
[Consent-Multi-Tier-Multi-Party]: ./media/active-directory-devhowto-multi-tenant-overview/consent-flow-multi-tier-multi-party.png

<!--Reference style links -->
[AAD-App-Manifest]: ./active-directory-application-manifest.md
[AAD-App-SP-Objects]: ./active-directory-application-objects.md
[AAD-Auth-Scenarios]: ./active-directory-authentication-scenarios.md
[AAD-Integrating-Apps]: ./active-directory-integrating-applications.md
[AAD-Dev-Guide]: ./active-directory-developers-guide.md
[AAD-Graph-Perm-Scopes]: https://msdn.microsoft.com/library/azure/ad/graph/howto/azure-ad-graph-api-permission-scopes
[AAD-Graph-App-Entity]: https://msdn.microsoft.com/Library/Azure/Ad/Graph/api/entity-and-complex-type-reference#application-entity
[AAD-Graph-Sp-Entity]: https://msdn.microsoft.com/Library/Azure/Ad/Graph/api/entity-and-complex-type-reference#serviceprincipal-entity
[AAD-Graph-User-Entity]: https://msdn.microsoft.com/Library/Azure/Ad/Graph/api/entity-and-complex-type-reference#user-entity
[AAD-How-To-Integrate]: ./active-directory-how-to-integrate.md
[AAD-Security-Token-Claims]: ./active-directory-authentication-scenarios/#claims-in-azure-ad-security-tokens
[AAD-Tokens-Claims]: ./active-directory-token-and-claims.md
[AAD-V2-Dev-Guide]: ../active-directory-appmodel-v2-overview.md
[AZURE-classic-portal]: https://manage.windowsazure.com
[Duyshant-Role-Blog]: http://www.dushyantgill.com/blog/2014/12/10/roles-based-access-control-in-cloud-applications-using-azure-ad/
[JWT]: https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32
[O365-Perm-Ref]: https://msdn.microsoft.com/en-us/office/office365/howto/application-manifest
[OAuth2-Access-Token-Scopes]: https://tools.ietf.org/html/rfc6749#section-3.3
[OAuth2-AuthZ-Code-Grant-Flow]: https://msdn.microsoft.com/library/azure/dn645542.aspx
[OAuth2-AuthZ-Grant-Types]: https://tools.ietf.org/html/rfc6749#section-1.3 
[OAuth2-Client-Types]: https://tools.ietf.org/html/rfc6749#section-2.1
[OAuth2-Role-Def]: https://tools.ietf.org/html/rfc6749#page-6
[OpenIDConnect]: http://openid.net/specs/openid-connect-core-1_0.html
[OpenIDConnect-ID-Token]: http://openid.net/specs/openid-connect-core-1_0.html#IDToken

















<!--HONumber=Feb17_HO1-->


