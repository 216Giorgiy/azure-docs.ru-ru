<properties
   pageTitle="Контрольный список для поддержания масштабируемости | Microsoft Azure"
   description="Руководство по контрольному списку для обеспечения масштабируемости во время проектирования для автоматического масштабирования Azure."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="masimms"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="04/28/2015"
   ms.author="masashin"/>

# Контрольный список для обеспечения масштабируемости

![](media/best-practices-scalability-checklist/pnp-logo.png)

## Проектирование службы
- **Разделяйте рабочую нагрузку**. Составные части процесса должны быть дискретными и разложимыми; минимизируйте размер каждой части согласно общим правилам для разделения проблем и принципу персональной ответственности. Это позволяет распространять компоненты способом, который расширяет возможности использования каждой единицы вычислений (например, роли или сервера базы данных) и упрощает масштабирование приложения путем добавления дополнительных экземпляров определенных ресурсов. Дополнительную информацию см. в разделе [Рекомендации по разделению вычислений](https://msdn.microsoft.com/library/dn568099.aspx).
- **Проектируйте с учетом масштабируемости**. Масштабирование позволяет приложениям реагировать на переменную нагрузку путем увеличения и уменьшения количества экземпляров ролей, очередей и других используемых служб. Тем не менее приложение должно быть спроектировано с учетом этого. Например, приложения и используемые им службы не должны сохранять состояния, чтобы разрешить маршрутизацию запросов к любому экземпляру и так, чтобы добавление или удаление отдельных экземпляров не оказывало отрицательного влияния на текущих пользователей. Также необходимо реализовать конфигурацию или автоматическое обнаружение экземпляров при их добавлении и удалении, чтобы код приложения мог выполнять необходимую маршрутизацию. Например, веб-приложение может использовать набор очередей в циклической модели для перенаправления запросов к фоновым службам, работающим в рабочих ролях. Веб-приложения должны иметь возможность обнаружения изменений количества очередей для успешного перенаправления запросов и балансировки нагрузки на приложение.
- **Масштабируйте систему как единое целое**. Планируйте добавление дополнительных ресурсов, чтобы учесть рост. Для каждого ресурса необходимо знать верхний предел масштабирования и использовать сегментирование или разбиение, чтобы выйти за рамки этих ограничений. Определите единицы масштабирования для системы с точки зрения четко определенных наборов ресурсов. Это упростит применение операций масштабирования и снизит отрицательное влияние на приложение через ограничения, налагаемые нехваткой ресурсов в определенной части всей системы. Например, добавление X рабочих и веб-ролей может потребовать Y дополнительных очередей и Z учетных записей хранения для обработки дополнительной рабочей нагрузки, созданной ролью, поэтому единица масштабирования может состоять из X рабочих и веб-ролей, _Y_ очередей и _Z_ учетных записей хранения. Проектируйте приложение таким образом, чтобы оно легко масштабировалось путем добавления одной или нескольких единиц масштабирования.
- **Избегайте привязки клиента**. Там, где это возможно, убедитесь, что приложение не требует привязки так, чтобы можно было направлять запросы к любому экземпляру без учета количества этих экземпляров. Этим также устраняются дополнительные издержки на хранение, получение и обслуживание информации о состоянии для каждого пользователя.
- **Используйте преимущества функций автомасштабирования платформы**. Если платформа размещения поддерживает возможность автоматического масштабирования, например как автоматическое масштабирование в Azure, старайтесь в первую очередь использовать именно такую возможность вместо пользовательских или сторонних механизмов масштабирования, до тех пор пока встроенный механизм продолжает удовлетворять требованиям. Используйте, где возможно, правила масштабирования по расписанию, чтобы ресурсы были доступны без задержки при запуске, но добавьте в правила реактивное автомасштабирование, если это уместно, чтобы справляться с неожиданными изменениями нагрузки. Операции автоматического масштабирования в API управления службами можно использовать для тонкой настройки автоматического масштабирования и добавления пользовательских счетчиков к правилам помимо параметров конфигурации, доступных на веб-портале. Дополнительную информацию см. на странице [Руководство по автоматическому масштабированию](best-practices-auto-scaling.md).
- **Выгрузите ресурсоемкие задачи процессора и ввода-вывода в фоновые задачи**. Если ожидается, что запрос к службе потребует значительного времени на выполнение или значительных ресурсов, выгрузите обработку запроса в отдельную задачу. Для выполнения этих задач можно использовать рабочие роли или фоновые задания (в зависимости от платформы размещения). Эта стратегия позволяет службе по-прежнему получать запросы и отвечать на них. Дополнительную информацию см. в статье [Руководство по фоновым заданиям](best-practices-background-jobs.md).
- **Распределяйте рабочую нагрузку для фоновых задач**. При наличии многих фоновых задач или задач, требующих значительного времени и ресурсов, распределяйте нагрузку среди нескольких вычислительных единиц (рабочих ролей или фоновых заданий). Одним из возможных решений выступает [Шаблон конкурирующих потребителей](https://msdn.microsoft.com/library/dn568101.aspx).
- **Стремитесь к _неразделяемой_ архитектуре**. Неразделяемая архитектура использует независимые и самостоятельные узлы, не имеющие единых точек конфликтов, например общих служб или общего хранилища. Теоретически такую систему можно масштабировать практически бесконечно. Хотя обычно неразделяемая архитектура для большинства приложений не подходит, она может обеспечить структурные возможности для повышения масштабируемости. Например, отказ от использования состояния сеанса на стороне сервера, привязки клиента и секционирование данных являются хорошими примерами перехода к неразделяемой архитектуре.

## Управление данными

- **Используйте разделение данных**. Разделяйте данные между несколькими базами данных и серверами баз данных или проектируйте приложения так, чтобы они использовали службы хранения данных, которые могут прозрачно реализовать такое разделение (например, Azure SQL Database Elastic Scale и табличное хранилище Azure). Этот подход может помочь добиться максимальной производительности и обеспечивает простоту масштабирования. Существуют различные методы, такие как горизонтальное, вертикальное и функциональное разделение, — эти методы можно совместно использовать для получения максимальной выгоды от повышения производительности при обработке запросов, более простой масштабируемости, более гибкого управления, более высокой доступности и для соответствия типу хранилища данных, в котором они будут содержаться. Кроме того, рекомендуется использовать разные виды хранилищ данных для разных типов данных, выбирая тип в зависимости от того, насколько хранилище оптимизировано для конкретного типа данных. Так, вы можете использовать хранилище таблиц, базу данных документов или хранилище данных семейства столбцов вместо или в качестве реляционной базы данных. Дополнительную информацию см. в разделе [Рекомендации по разделению данных](best-practices-data-partitioning.md).
- **Проектируйте, ориентируясь на окончательную согласованность**. Окончательная согласованность повышает масштабируемость за счет сокращения или удаления времени, необходимого для синхронизации взаимосвязанных данных, разделенных между несколькими хранилищами. Расплатой будет то, что данные не всегда будут согласованными при чтении и некоторые записи операций могут вызвать конфликт. Окончательная согласованность идеально подходит для ситуаций, где одни и те же данные часто считываются, но редко записываются. Дополнительную информацию см. в статье [Руководство по согласованности данных](#insertlink#).
- **Уменьшайте неаккуратные взаимодействия между компонентами и службами**. Избегайте проектирования _неаккуратных_ интерфейсов для служб, в которых приложению приходится делать несколько вызовов к службе (каждый из которых возвращает небольшой объем данных) вместо одного вызова, который может возвращать все данные сразу. Там, где это возможно, объединяйте несколько связанных операций в одном запросе к службе или компоненту, имеющим заметную задержку при вызове. Это облегчает мониторинг производительности и оптимизацию сложных операций. Например, используйте хранимые процедуры в базах данных для инкапсуляции сложной логики, уменьшения количества круговых путей и блокировки ресурсов. 
- **Используйте очереди до распределения нагрузки по уровням для высокоскоростной записи данных**. Всплески запросов к службе могут перегрузить службу и привести к росту количества сбоев. Чтобы избежать этого, попробуйте реализовать [Шаблон балансировки нагрузки на основе очередей](https://msdn.microsoft.com/library/dn589783.aspx). Используйте очередь, служащую буфером между задачей и вызываемой службой для снятия периодической высокой нагрузки, которая в противном случае может вызвать сбой службы или привести к истечению времени ожидания для задачи.
- **Сводите к минимуму нагрузку на хранилище данных**. Хранилище данных часто является узким местом обработки, который не всегда легко масштабировать. Там, где это возможно, удалите логику (например, для обработки XML-документов или объектов JSON) из хранилища данных и выполняйте обработку в самом приложении. Например, вместо передачи XML в базу данных (за исключением непрозрачной строки для хранения) выполните сериализацию или десериализацию XML на уровне приложения и передайте его в форму, встроенную в хранилище данных. Обычно гораздо проще развернуть приложение, чем хранилище данных. Поэтому рекомендуется выполнять большую часть обработки, потребляющей много вычислительных ресурсов, в приложении.
- **Сводите к минимуму объем получаемых данных**. Получайте только необходимые данные, указав столбцы и используя критерии для выбора строк. Регулярно используйте табличные параметры и соответствующий уровень изоляции. Используйте такие механизмы, как eTag, чтобы избежать ненужного извлечения данных.
- **Интенсивно используйте кэширование**. Используйте кэширование везде, где это возможно, чтобы снизить нагрузку на ресурсы и службы создания и доставки данных. Кэширование обычно подходит для относительно статичных или требующих значительной обработки при получении данных. Кэширование должно выполняться на всех уровнях в каждом слое приложения, где это возможно, включая доступ к данным и создание пользовательского интерфейса. Дополнительную информацию см. в статье [Руководство по кэшированию](best-practices-caching.md).
- **Решайте проблему увеличения объема данных и их хранения**. Объем данных, хранящихся в приложении, со временем будет увеличиваться. Такой рост объема данных приведет к росту затрат на хранение и увеличению задержки при доступе к данным, что повлияет на пропускную способность приложения и его производительность. Возможно, лучше архивировать некоторые старые данные, доступ к которым больше не требуется, или перенести данные, доступ к которым осуществляется редко, в долговременное хранилище. Это поможет оптимизировать расходы, даже если задержка вырастет.
- **Оптимизируйте объекты переноса данных, используя эффективный двоичный формат**. Объекты передачи данных многократно передаются между уровнями приложения, и поэтому уменьшение их размера позволяет снизить нагрузку на ресурсы и сеть. Однако здраво балансируйте экономию с издержками преобразования данных в требуемом формате в каждом используемом случае, и применяйте формат, который обеспечивает максимальную совместимость, чтобы легко можно было повторно использовать компонент.
- **Задайте управление кэшем**. Проектируйте и настраивайте приложения на использование кэширования выходных данных или фрагментарного кэширования, где можно свести к минимуму нагрузку при обработке.
- **Включайте кэширование на стороне клиента**. Веб-приложения должны поддерживать параметры кэширования содержимого, которое допускает кэширование. Как правило, эта возможность отключена по умолчанию. Настройте сервер для отправки соответствующих заголовков управления кэшем для включения кэширования содержимого на прокси-серверах и клиентах.
- **Используйте хранилище больших двоичных объектов Azure и CDN для снижения нагрузки на приложение**. Рассмотрите возможность хранения статического или относительно статического общедоступного содержимого, такого как изображения, ресурсы, сценарии и стили в хранилище больших двоичных объектов. Этот подход снимает нагрузку с приложения, вызванную динамической генерацией этого содержимого для каждого запроса. Кроме того, рассмотрите возможность использования CDN для кэширования этого содержимого и его доставки на клиенты. Использование CDN может повысить производительность на стороне клиента, поскольку содержимое доставляется из ближайшего центра обработки данных, содержащего кэш CDN. Дополнительную информацию см. в статье [Руководство по CDN](best-practices-cdn.md).

- **Оптимизируйте и настраивайте SQL-запросы и индексы**. Некоторые инструкции или конструкции T-SQL могут отрицательно повлиять на производительность, и это влияние можно уменьшить путем оптимизации кода в хранимой процедуре. Например, следует избегать преобразования типов **datetime** в **varchar** перед сравнением с литеральным значением **datetime**. Вместо этого используйте функции сравнения даты и времени. Отсутствие соответствующих индексов может также замедлить выполнение запроса. При использовании объектно-реляционного сопоставления учитывайте специфику платформы и то, как она может повлиять на производительность уровня доступа к данным. Дополнительную информацию см. в разделе [Настройка запросов](https://technet.microsoft.com/library/ms176005.aspx).
- **Используйте денормализацию данных**. Нормализация данных помогает избежать дублирования и несогласованности данных. Тем не менее обслуживание нескольких индексов, проверка целостности данных, выполнение нескольких обращений к небольшим блокам данных и соединение таблиц для пересборки данных вызывают нагрузку, которая может повлиять на производительность. Попробуйте использовать дополнительное пространство тома и дублирование данных для снижения нагрузки на хранилище данных. Кроме того, рекомендуется учесть возможность переложить такие задачи, как управление целостностью ссылок для снижения нагрузки на хранилище данных, на само приложение (которое, как правило, легче масштабировать). Дополнительную информацию см. в статье [Рекомендации по разделению данных](https://github.com/mspnp/azure-guidance/blob/master/Data%20partitioning.md).

## Реализация службы
- **Используйте асинхронные вызовы**. Чтобы избежать блокировки потока вызовов, по возможности используйте асинхронный код доступа к ресурсам или службам, которые могут быть ограничены пропускной способностью сети или подсистемы ввода-вывода, или иметь заметную задержку. Используйте асинхронную модель на основе задач для реализации асинхронных операций. Дополнительную информацию см. на странице [Асинхронный шаблон, основанный на задачах (TAP)](https://msdn.microsoft.com/library/hh873175.aspx) на веб-сайте Майкрософт.
- **Избегайте блокировки ресурсов и вместо этого используйте оптимистичный подход**. Никогда не блокируйте доступ к ресурсам хранилища или другим службам, имеющим ощутимую задержку, поскольку это — основная причина снижения производительности. Всегда используйте оптимистичный подход к управлению параллельными операциями, такими как запись в хранилище, и используйте возможности уровня хранилища для управления конфликтами. В распределенных приложениях данные могут быть согласованными только в конечном итоге.
- **Используйте данные с высокой степенью сжатия в сетях с высокими задержками и низкой пропускной способностью**. В большинстве случаев в веб-приложении наибольший объем данных, создаваемых приложением и передаваемых по сети, является HTTP-ответами на запросы клиентов. Сжатие HTTP позволяет значительно уменьшить объем этих данных, особенно для статического содержимого. Таким образом можно сэкономить на затратах, а также снизить нагрузку на сеть, хотя сжатие динамического содержимого создает чуть большую нагрузку на сервер. В более универсальных средах сжатие данных позволяет уменьшить объем передаваемых данных и свести к минимуму время передачи и затраты, но при этом добавляет издержки, связанные с процессами сжатия и распаковки. По существу сжатие следует использовать только при наличии очевидного выигрыша в производительности. Другие методы сериализации, например JSON или двоичное кодирование, могут уменьшить размер полезных данных, уменьшая отрицательное влияние на производительность, тогда как XML, вероятнее всего, увеличит это влияние.
- **Сводите к минимуму время использования ресурсов и подключений**. Обслуживайте подключения и ресурсы только тогда, когда необходимо использовать их. Например, как можно позже открывайте подключения и обеспечьте их как можно быстрый возврат в пул подключений. Получайте ресурсы как можно позднее и отпускайте их как можно раньше.
- **Сводите к минимуму число необходимых подключений**. Подключения к службе требуют ресурсов. По возможности ограничьте число обязательных подключений и обеспечьте повторное использование существующих подключений (если возможно). Например, после выполнения проверки подлинности, используйте олицетворение, где это необходимо, для запуска кода в качестве определенного удостоверения. Это позволяет наиболее эффективно использовать пул подключений путем повторного использования соединений. 

	> [AZURE.NOTE]
- **Отправляйте запросы пакетами, чтобы оптимизировать использование сети**. Например, при доступе к очереди выполняйте операции передачи и чтения сообщений в пакетах и при доступе к хранилищу или кэшу выполняйте по несколько операций чтения или записи в пакете. Этот подход может помочь добиться максимальной эффективности служб и хранилищ данных за счет сокращения числа вызовов по сети.
- **Избегайте обязательного хранения состояния сеанса на стороне сервера** там, где это возможно. Управление состоянием сеанса на стороне сервера обычно требует привязки клиента (т. е. маршрутизации каждого запроса к тому же экземпляру сервера), что влияет на возможность масштабирования системы. В идеале следует разрабатывать клиенты без отслеживания состояния по отношению к используемым серверам. Однако если в приложении нужно поддерживать состояние сеанса, храните конфиденциальные данные или данные большого объема для каждого клиента в распределенном кэше на стороне сервера, где все экземпляры приложения могут получить к ним доступ.
- **Оптимизируйте схемы табличного хранилища**. При использовании табличного хранилища, например табличного хранилища Azure, которые требуют при передаче и обработке каждого запроса указывать имена таблиц и столбцов, рассмотрите возможность использования более коротких имен, чтобы снизить издержки. Тем не менее не жертвуйте удобочитаемостью или управляемостью ради неинтуитивных и коротких имен.
- **Используйте библиотеку параллелизма по задачам для выполнения асинхронных операций**. Библиотека параллелизма по задачам (TPL) упрощает создание асинхронного кода, выполняющего операции ввода-вывода. Используйте _ConfigureAwait(false)_ везде, где можно устранить зависимость продолжения от конкретного контекста синхронизации и снизить вероятность взаимоблокировки потоков.
- **Создавайте зависимости ресурсов во время развертывания или при запуске приложения**. Избегайте повторяющихся вызовов методов, которые проверяют существование ресурса и затем создают новый ресурс, если он не существует (такие методы, как _CloudTable.CreateIfNotExists_ и _CloudQueue.CreateIfNotExists_ в клиентской библиотеке хранилища Azure следуют такому шаблону). Эти методы могут привести к значительным издержкам, если они вызываются перед каждым доступом к таблице или очереди хранилища. Вместо этого при развертывании приложения или при первом запуске создайте необходимые ресурсы (одного вызова _CreateIfNotExists_ для каждого ресурса в коде запуска для рабочих и веб-ролей будет достаточно). Тем не менее, необходимо обрабатывать исключения, которые могут возникнуть, если код пытается получить доступ к несуществующему ресурсу. В таких случаях следует занести исключение в журнал и уведомить оператора, что ресурс отсутствует. В некоторых случаях можно создать отсутствующий ресурс как часть кода обработки исключений, но вам следует внедрять этот подход с осторожностью, поскольку отсутствие ресурса может быть признаком программной ошибки (например, имя ресурса написано с ошибкой) или какой-либо другой проблемы на уровне инфраструктуры.
- **Используйте легковесные платформы**. Тщательно выбирайте интерфейсы API и платформы, которые позволяют свести к минимуму использование ресурсов, время выполнения и общую нагрузку на приложение. Например, с помощью веб-API для обработки запросов к службе можно уменьшить занимаемое место приложения и повысить скорость выполнения, но этот вариант может не подойти для более сложных сценариев, где требуются дополнительные возможности WCF.
- **Рекомендуем минимизировать количество учетных записей службы**. Используйте определенную учетную запись для доступа к ресурсам или службам, которые накладывают ограничения на подключения или выполняются быстрее, если обслуживается меньшее количество подключений. Этот подход часто используется для служб, таких как базы данных, но при этом он может повлиять на возможность точно контролировать операции из-за олицетворения исходного пользователя.
- **Выполняйте профилирование производительности и нагрузочного тестирования** во время разработки как часть процедуры тестирования и до выпуска окончательной версии, чтобы убедиться, что приложение надлежащим образом работает и масштабируется. Тестирование должно выполняться на том же типе оборудования, что и производственная платформа, и с теми же типами и объемами данных и пользовательской нагрузкой, которые будут встречаться в производственной среде. Дополнительную информацию см. на странице [Тестирование производительности облачной службы](https://msdn.microsoft.com/library/azure/hh369930.aspx) на веб-сайте Майкрософт.

<!---HONumber=July15_HO5-->