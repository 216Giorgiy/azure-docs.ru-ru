---
title: Контрольный список для поддержания масштабируемости | Microsoft Docs
description: Руководство по контрольному списку для обеспечения масштабируемости во время проектирования для автоматического масштабирования Azure.
services: ''
documentationcenter: na
author: dragon119
manager: christb
editor: ''
tags: ''

ms.service: best-practice
ms.devlang: na
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: na
ms.date: 07/13/2016
ms.author: masashin

---
# Контрольный список для обеспечения масштабируемости
[!INCLUDE [pnp-header](../includes/guidance-pnp-header-include.md)]

## Проектирование службы
* **Разделяйте рабочую нагрузку**. Проектируйте части процесса так, чтобы они были дискретными и делимыми. Минимизируйте размер каждой части, следуя общим правилам для разделения проблем и принципу персональной ответственности. Это позволяет распределить части компонента так, чтобы максимально увеличить возможности использования каждой вычислительной единицы (например, роли или сервера базы данных). Это также облегчает масштабирование приложения путем добавления экземпляров определенных ресурсов. Дополнительную информацию см. в разделе [Рекомендации по разделению вычислений](https://msdn.microsoft.com/library/dn589773.aspx).
* **Проектируйте с учетом масштабируемости**. Масштабирование позволяет приложениям реагировать на переменную нагрузку путем увеличения и уменьшения количества экземпляров ролей, очередей и других используемых служб. Тем не менее приложение должно быть спроектировано с учетом этого. Например, приложение и используемые им службы должны быть без отслеживания состояния, чтобы запросы можно было направлять в любой экземпляр. Это также предотвращает добавление или удаление определенных экземпляров для текущих пользователей, негативно влияющих на производительность. Кроме того, следует реализовать конфигурацию или автоматическое обнаружение экземпляров при их добавлении и удалении, чтобы код приложения мог выполнять необходимую маршрутизацию. Например, веб-приложение может использовать набор очередей в циклической модели для перенаправления запросов к фоновым службам, работающим в рабочих ролях. Веб-приложение должно иметь возможность обнаружения изменений количества очередей, чтобы успешно перенаправлять запросы и балансировать нагрузку на приложение.
* **Масштабируйте систему как единое целое**. Планируйте добавление ресурсов, чтобы учесть рост. Для каждого ресурса необходимо знать верхний предел масштабирования и использовать сегментирование или разбиение, чтобы выйти за рамки этих ограничений. Определите единицы масштабирования для системы с точки зрения четко определенных наборов ресурсов. Это упростит применение операций масштабирования и снизит отрицательное влияние на приложение ограничений, налагаемых нехваткой ресурсов в определенной части системы в целом. Например, добавление X рабочих и веб-ролей может потребовать Y дополнительных очередей и Z учетных записей хранения для обработки дополнительной рабочей нагрузки, созданной ролями. Поэтому единица масштабирования может состоять из X рабочих и веб-ролей, *Y* очередей и *Z* учетных записей хранения. Проектируйте приложение таким образом, чтобы его легко было масштабировать, путем добавляя одну или нескольких единиц масштабирования.
* **Избегайте привязки клиента**. Если возможно, сделайте так, чтобы приложению не требовалось сходство. Тогда запросы смогут передаваться в любой экземпляр, и число экземпляров будет несущественно. Этим также устраняются дополнительные издержки на хранение, получение и обслуживание информации о состоянии для каждого пользователя.
* **Используйте преимущества функций автомасштабирования платформы**. Если платформа размещения поддерживает возможность автомасштабирования, например автомасштабирование Azure, отдавайте ей предпочтение вместо пользовательских или сторонних механизмов масштабирования, если, конечно встроенный механизм удовлетворяет вашим требованиям. Используйте, где возможно, правила масштабирования по расписанию, чтобы ресурсы были доступны без задержки при запуске, но добавьте в правила реактивное автомасштабирование, если это уместно, чтобы справляться с неожиданными изменениями нагрузки. Вы можете использовать операции автомасштабирования в API управления службами для настройки автомасштабирования и добавления пользовательских счетчиков в правила. Дополнительную информацию см. в [руководстве по автомасштабированию](best-practices-auto-scaling.md).
* **Выгрузите ресурсоемкие задачи процессора и ввода-вывода в фоновые задачи**. Если ожидается, что выполнение запроса к службе потребует значительного времени или ресурсов, выгрузите обработку запроса в отдельную задачу. Для выполнения этих задач можно использовать рабочие роли или фоновые задания (в зависимости от платформы размещения). Эта стратегия позволяет службе по-прежнему получать запросы и отвечать на них. Дополнительную информацию см. в статье [Руководство по фоновым заданиям](best-practices-background-jobs.md).
* **Распределяйте рабочую нагрузку для фоновых задач**. При наличии многих фоновых задач или задач, требующих значительного времени и ресурсов, распределяйте нагрузку среди нескольких вычислительных единиц (рабочих ролей или фоновых заданий). Одним из возможных решений выступает [шаблон конкурирующих потребителей](https://msdn.microsoft.com/library/dn568101.aspx).
* **Стремитесь к *неразделяемой* архитектуре**. Неразделяемая архитектура использует независимые, самостоятельные узлы, не имеющие единых точек конфликтов, например общих служб или общего хранилища. Теоретически такую систему можно масштабировать практически бесконечно. Хотя обычно неразделяемая архитектура для большинства приложений не подходит, она может обеспечить структурные возможности для повышения масштабируемости. Например, отказ от использования состояния сеанса на стороне сервера, сходства клиента и секционирования данных являются хорошими примерами перехода к неразделяемой архитектуре.

## Управление данными
* **Используйте разделение данных**. Разделяйте данные между несколькими базами данных и серверами базы данных или проектируйте приложения так, чтобы они использовали службы хранения данных, которые могут прозрачно реализовать такое разделение (например, это может быть эластичная база данных SQL Azure и хранилище таблиц Azure). Этот подход может помочь добиться максимальной производительности и обеспечивает простоту масштабирования. Существуют различные методы секционирования, например горизонтальное, вертикальное и функциональное секционирование. Эти методы можно комбинировать, чтобы получить максимальную выгоду от повышения производительности при обработке запросов, упрощения масштабируемости, более гибкого управления, повышенной доступности и соответствия типа хранилища предназначенным для него данным. Кроме того, рекомендуется использовать разные виды хранилищ данных для разных типов данных, выбирая тип в зависимости от того, насколько хранилище оптимизировано для конкретного типа данных. Например, вы можете использовать хранилище таблиц, базу данных документов или хранилище данных семейства столбцов вместо или в качестве реляционной базы данных. Дополнительную информацию см. в разделе [Рекомендации по разделению данных](best-practices-data-partitioning.md).
* **Проектируйте, ориентируясь на окончательную согласованность**. Окончательная согласованность повышает масштабируемость за счет сокращения или удаления времени, необходимого для синхронизации взаимосвязанных данных, разделенных между несколькими хранилищами. Расплатой будет то, что данные не всегда будут согласованными при чтении и некоторые записи операций могут вызвать конфликт. Окончательная согласованность идеально подходит для ситуаций, где одни и те же данные часто считываются, но редко записываются. Дополнительную информацию см. в [руководстве по согласованности данных](https://msdn.microsoft.com/library/dn589800.aspx).
* **Уменьшайте неаккуратные взаимодействия между компонентами и службами**. Избегайте проектирования взаимодействий, в которых приложению приходится делать несколько вызовов к службе (каждый из которых возвращает небольшой объем данных) вместо одного вызова, который может вернуть все данные сразу. Там, где это возможно, объединяйте несколько связанных операций в одном запросе к службе или компоненту, имеющим заметную задержку при вызове. Это упрощает отслеживание производительности и оптимизацию сложных операций. Например, используйте хранимые процедуры в базах данных для инкапсуляции сложной логики и уменьшения количества круговых путей и блокировки ресурсов.
* **Используйте очереди до распределения нагрузки по уровням для высокоскоростной записи данных**. Всплески запросов к службе могут перегрузить службу и привести к росту количества сбоев. Чтобы избежать этого, попробуйте реализовать [Шаблон балансировки нагрузки на основе очередей](https://msdn.microsoft.com/library/dn589783.aspx). Используйте очередь, которая служит буфером между задачей и вызываемой ею службой. Это может сглаживать кратковременные всплески нагрузки, которые в противном случае могут привести к сбою службы или превышению времени ожидания задания.
* **Сводите к минимуму нагрузку на хранилище данных**. Хранилище данных часто является узким местом обработки, который не всегда легко масштабировать. Где это возможно, удалите логику (например, для обработки документов XML или объектов JSON) из хранилища данных и выполняйте обработку в самом приложении. Например, вместо передачи XML в базу данных (за исключением непрозрачной строки для хранения) выполните сериализацию или десериализацию XML на уровне приложения и передайте его в форму, встроенную в хранилище данных. Обычно гораздо проще развернуть приложение, чем хранилище данных. Поэтому рекомендуется выполнять как можно большую часть обработки, потребляющей много вычислительных ресурсов, в приложении.
* **Сводите к минимуму объем получаемых данных**. Получайте только необходимые данные, указав столбцы и используя критерии для выбора строк. Регулярно используйте табличные параметры и соответствующий уровень изоляции. Используйте такие механизмы, как теги сущности, чтобы избежать ненужного извлечения данных.
* **Интенсивно используйте кэширование**. Используйте кэширование везде, где это возможно, чтобы снизить нагрузку на ресурсы и службы создания и доставки данных. Кэширование обычно подходит для относительно статичных или требующих значительной обработки при получении данных. Кэширование должно выполняться на всех уровнях в каждом слое приложения, где это нужно, включая доступ к данным и создание пользовательского интерфейса. Дополнительную информацию см. в статье [Руководство по кэшированию](best-practices-caching.md).
* **Решайте проблему увеличения объема данных и их хранения**. Объем данных, хранящихся в приложении, со временем увеличивается. Такой рост объема данных приводит к росту затрат на хранение и увеличению задержки при доступе к данным, что влияет на пропускную способность приложения и его производительность. Возможно, лучше архивировать некоторые старые данные, доступ к которым больше не требуется, или перенести данные, доступ к которым осуществляется редко, в долговременное хранилище. Это поможет оптимизировать расходы, даже если задержка вырастет.
* **Оптимизируйте объекты переноса данных, используя эффективный двоичный формат**. Объекты переноса данных многократно передаются между уровнями приложения. Если свести к минимуму их размер, это уменьшит нагрузку на ресурсы и сеть. Тем не менее следует соотнести экономию с затратами на преобразование данных в требуемый формат в каждом расположении, в котором он используется. Применяйте формат, который обеспечивает максимальную совместимость, чтобы упростить повторное использование компонента.
* **Задайте управление кэшем**. Проектируйте и настраивайте приложение для использования кэширования вывода или фрагментарного кэширования, где это возможно, чтобы свести к минимуму нагрузку при обработке.
* **Включайте кэширование на стороне клиента**. Веб-приложения должны поддерживать параметры кэширования содержимого, которое допускает кэширование. Как правило, эта возможность отключена по умолчанию. Настройте сервер для отправки соответствующих заголовков управления кэшем для включения кэширования содержимого на прокси-серверах и клиентах.
* **Используйте хранилище BLOB-объектов Azure и сеть доставки содержимого Azure для снижения нагрузки на приложение**. Рассмотрите возможность хранения статического или относительно статического общедоступного содержимого, такого как изображения, ресурсы, сценарии и стили в хранилище BLOB-объектов. Этот подход снимает нагрузку с приложения, вызванную динамической генерацией этого содержимого для каждого запроса. Кроме того, рассмотрите возможность использования сети доставки содержимого для кэширования этого содержимого и его доставки на клиенты. Использование сети доставки содержимого может повысить производительность на стороне клиента, так как содержимое доставляется из ближайшего центра обработки данных, содержащего кэш сети доставки содержимого. Дополнительные сведения см. в [руководстве по сети доставки содержимого](best-practices-cdn.md).
* **Оптимизируйте и настраивайте SQL-запросы и индексы**. Некоторые инструкции или конструкции T-SQL могут отрицательно повлиять на производительность, и это влияние можно уменьшить путем оптимизации кода в хранимой процедуре. Например, избегайте преобразования типов **datetime** в **varchar** перед сравнением с литеральным значением **datetime**. Вместо этого используйте функции сравнения даты и времени. Отсутствие соответствующих индексов может также замедлить выполнение запроса. При использовании объектно-реляционного сопоставления учитывайте специфику платформы и то, как она может повлиять на производительность уровня доступа к данным. Дополнительную информацию см. в разделе [Настройка запросов](https://technet.microsoft.com/library/ms176005.aspx).
* **Используйте денормализацию данных**. Нормализация данных помогает избежать дублирования и несогласованности данных. Тем не менее обслуживание нескольких индексов, проверка целостности данных, выполнение нескольких обращений к небольшим блокам данных и соединение таблиц для пересборки данных вызывают нагрузку, которая может повлиять на производительность. Попробуйте использовать дополнительное пространство тома и дублирование данных для снижения нагрузки на хранилище данных. Кроме того, рекомендуется учесть возможность переложить такие задачи, как управление целостностью данных, на само приложение (которое, как правило, легче масштабировать), чтобы снизить нагрузку на хранилище данных. Дополнительную информацию см. в разделе [Рекомендации по разделению данных](https://github.com/mspnp/azure-guidance/blob/master/Data%20partitioning.md).

## Реализация службы
* **Используйте асинхронные вызовы**. Чтобы избежать блокировки потока вызовов, по возможности используйте асинхронный код доступа к ресурсам или службам, которые могут быть ограничены пропускной способностью сети или подсистемы ввода-вывода, или иметь заметную задержку. Используйте [асинхронную модель на основе задач](https://msdn.microsoft.com/library/hh873175.aspx) для реализации асинхронных операций.
* **Избегайте блокировки ресурсов и вместо этого используйте оптимистичный подход**. Никогда не блокируйте доступ к ресурсам хранилища или другим службам, имеющим ощутимую задержку, поскольку это — основная причина снижения производительности. Всегда используйте оптимистичные подходы к управлению параллельными операциями, такими как запись в хранилище. Используйте возможности хранилища для управления конфликтами. В распределенных приложениях данные могут быть согласованными только в конечном итоге.
* **Используйте данные с высокой степенью сжатия в сетях с высокими задержками и низкой пропускной способностью**. В большинстве случаев в веб-приложении наибольший объем данных, создаваемых приложением и передаваемых по сети, является HTTP-ответами на запросы клиентов. Сжатие HTTP позволяет значительно уменьшить объем этих данных, особенно для статического содержимого. Таким образом можно сэкономить на затратах, а также снизить нагрузку на сеть, хотя сжатие динамического содержимого создает чуть большую нагрузку на сервер. В более универсальных средах сжатие данных позволяет уменьшить объем передаваемых данных и свести к минимуму время передачи и затраты, но при этом добавляет издержки, связанные с процессами сжатия и распаковки. По существу сжатие следует использовать только при наличии очевидного выигрыша в производительности. Другие методы сериализации, например кодирование JSON или двоичное кодирование, могут уменьшить размер полезных данных, снижая отрицательное влияние на производительность, тогда как XML, вероятнее всего, увеличит это влияние.
* **Сводите к минимуму время использования ресурсов и подключений**. Обслуживайте подключения и ресурсы только тогда, когда необходимо использовать их. Например, как можно позже открывайте подключения и обеспечьте их как можно более быстрый возврат в пул подключений. Получайте ресурсы как можно позднее и освобождайте их как можно раньше.
* **Сводите к минимуму число необходимых подключений**. Подключения к службе требуют ресурсов. Ограничьте число обязательных подключений и обеспечьте повторное использование существующих подключений (если возможно). Например, после выполнения проверки подлинности, используйте олицетворение, где это необходимо, для запуска кода в качестве определенного удостоверения. Это позволяет наиболее эффективно использовать пул подключений путем повторного использования соединений.
  
  > [!NOTE]
  > Интерфейсы API некоторых служб автоматически используют готовые соединения при условии соблюдения требований конкретной службы. Важно понимать условия повторного использования имеющегося соединения каждой службой, используемой в вашем приложении.
  > 
  > 
* **Отправляйте запросы пакетами, чтобы оптимизировать использование сети**. Например, при доступе к очереди выполняйте операции передачи и чтения сообщений в пакетах и при доступе к хранилищу или кэшу выполняйте по несколько операций чтения или записи в пакете. Этот подход может помочь добиться максимальной эффективности служб и хранилищ данных за счет сокращения числа вызовов по сети.
* **Избегайте обязательного хранения состояния сеанса на стороне сервера** там, где это возможно. Управление состоянием сеанса на стороне сервера обычно требует сходства клиента (т. е. маршрутизации каждого запроса к тому же экземпляру сервера), что влияет на возможность масштабирования системы. В идеале следует разрабатывать клиенты без отслеживания состояния по отношению к используемым серверам. Однако если в приложении нужно поддерживать состояние сеанса, храните конфиденциальные данные или данные большого объема для каждого клиента в распределенном кэше на стороне сервера, где все экземпляры приложения могут получить к ним доступ.
* **Оптимизируйте схемы табличного хранилища**. При использовании хранилищ таблиц, например хранилища таблиц Azure, которые требуют при передаче и обработке каждого запроса указывать имена таблиц и столбцов, рассмотрите возможность использования более коротких имен, чтобы снизить затраты. Тем не менее не жертвуйте удобочитаемостью или управляемостью ради слишком сокращенных имен.
* **Используйте библиотеку параллельных задач (TPL) для выполнения асинхронных операций**. Библиотека TPL упрощает создание асинхронного кода, выполняющего операции ввода-вывода. Используйте *ConfigureAwait(false)* везде, где это возможно, чтобы устранить зависимость продолжения от конкретного контекста синхронизации. Это снижает вероятность взаимоблокировки потоков.
* **Создавайте зависимости ресурсов во время развертывания или при запуске приложения**. Избегайте повторяющихся вызовов методов, которые проверяют существование ресурса, а затем создают ресурс, если он не существует. (Так функционирует такие методы, как *CloudTable.CreateIfNotExists* и *CloudQueue.CreateIfNotExists* в клиентской библиотеке хранилища Azure.) Эти методы могут привести к значительным издержкам, если они вызываются перед каждым доступом к таблице или очереди хранилища. Вот как следует поступить вместо этого.
  * При развертывании приложения или при первом запуске создайте необходимые ресурсы (будет достаточно одного вызова *CreateIfNotExists* для каждого ресурса в коде запуска для рабочих и веб-ролей). Тем не менее необходимо обрабатывать исключения, которые могут возникнуть, если код пытается получить доступ к несуществующему ресурсу. В таких случаях следует занести исключение в журнал и уведомить оператора, что ресурс отсутствует.
  * В некоторых случаях можно добавить создание отсутствующего ресурса в код обработки исключений. Однако этот подход следует реализовать с осторожностью, так как отсутствие ресурса может быть признаком программной ошибки (например, имя ресурса написано с ошибкой) или какой-либо другой проблемы на уровне инфраструктуры.
* **Используйте легковесные платформы**. Тщательно выбирайте интерфейсы API и платформы, которые позволяют свести к минимуму использование ресурсов, время выполнения и общую нагрузку на приложение. Например, используя веб-API для обработки запросов к службе можно уменьшить занимаемое место приложения и повысить скорость выполнения, но этот вариант может не подойти для более сложных сценариев, где требуются дополнительные возможности Windows Communication Foundation.
* **Рекомендуем минимизировать количество учетных записей службы**. Используйте определенную учетную запись для доступа к ресурсам или службам, которые накладывают ограничения на подключения или выполняются быстрее, если обслуживается меньшее количество подключений. Этот подход часто используется для служб, таких как базы данных, но при этом он может повлиять на возможность точно контролировать операции из-за олицетворения исходного пользователя.
* **Выполняйте профилирование производительности и нагрузочного тестирования** во время разработки как часть процедуры тестирования и до выпуска окончательной версии, чтобы убедиться, что приложение надлежащим образом работает и масштабируется. Тестирование должно выполняться на том же типе оборудования, что и производственная платформа, и с теми же типами и объемами данных и пользовательской нагрузкой, которые будут встречаться в производственной среде. Дополнительную информацию см. на странице [Тестирование производительности облачной службы](vs-azure-tools-performance-profiling-cloud-services.md).

<!---HONumber=AcomDC_0720_2016-->