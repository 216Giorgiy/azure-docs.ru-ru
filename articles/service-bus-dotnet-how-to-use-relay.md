<properties linkid="dev-net-how-to-service-bus-relay" urlDisplayName="Ретрансляция Service Bus" pageTitle="Использование ретрансляции Service Bus (.NET) — Azure" metaKeywords="начало работы azure ретрансляция Service Bus C# " description="Узнайте, как использовать ретрансляцию Service Bus Azure для соединения двух приложений, размещенных в разных местах." metaCanonical="" services="service-bus" documentationCenter=".NET" title="Использование службы ретрансляции Service Bus" authors=""  solutions="" writer="sethm" manager="dwrede" editor="mattshel"  />







# Использование службы ретрансляции Service Bus

В этом руководстве показывается, как использовать службу ретрансляции Service Bus.
Примеры написаны на C# и используют интерфейс Windows Communication Foundation API с расширениями, содержащимися в сборке Service Bus, которая является частью библиотек .NET для Azure. Дополнительные
сведения о ретрансляции Service Bus см. в разделе [Дальнейшие действия][].
.

[WACOM.INCLUDE [create-account-note](../includes/create-account-note.md)]

<h2><span class="short-header">Что такое ретрансляция Service Bus</span>Что такое ретрансляция Service Bus</h2>

Служба **ретрансляции** Service Bus позволяет создавать **гибридные приложения**, работающие как в центре обработки данных Azure, так и на собственных средствах предприятия. Ретрансляция Service Bus обеспечивает такую возможность, позволяя безопасно предоставлять службы Windows Communication Foundation (WCF), находящиеся в корпоративной сети предприятия, в общедоступном облаке без необходимости открывать подключения брандмауэра или вносить заметные изменения в инфраструктуру корпоративной сети.

![Основные понятия ретрансляции](./media/service-bus-dotnet-how-to-use-relay/sb-relay-01.png)

Ретрансляция Service Bus позволяет размещать службы WCF в существующей корпоративной среде. Затем можно делегировать прослушивание входящих сеансов и запросов к этим службам WCF шине Service Bus, работающей в среде Azure. Это позволяет сделать эти службы доступными для кода приложения, выполняемого в Azure, для мобильных сотрудников или для сред экстрасети партнеров. Service Bus позволяет безопасно управлять предоставлением доступа к этим службам на детальном уровне. Эта шина обеспечивает мощный и безопасный способ предоставления функциональных возможностей приложения и данных существующих корпоративных решений, позволяя пользоваться этими преимуществами из облака.

В этом руководстве показывается, как использовать ретрансляцию Service Bus для создания веб-службы WCF, доступной с помощью привязки канала TCP, который реализует безопасный диалог между двумя сторонами.

<h2><span class="short-header">Создание пространства имен службы</span>Создание пространства имен службы</h2>

Чтобы начать использование ретрансляции Service Bus в Azure, необходимо сначала создать пространство имен службы. Это пространство имен службы предоставляет область ограничений для адресации ресурсов Service Bus в вашем приложении.

Создание пространства имен службы:

1.  Выполните вход на [Портал управления Azure][].

2.  В левой области навигации панели управления нажмите кнопку **Service Bus**.

3.  В нижней части портала управления нажмите кнопку **Создать**.   

	![](./media/service-bus-dotnet-how-to-use-relay/sb-queues-13.png)

4.  В диалоговом окне **Добавить новое пространство имен** введите имя пространства имен.
    Система немедленно проверяет, доступно ли оно.   

	![](./media/service-bus-dotnet-how-to-use-relay/sb-queues-04.png)


5.  После того как убедитесь, что имя пространства имен доступно, выберите страну или регион, в котором будет размещаться пространство имен (убедитесь, что используется та же страна или регион, где развертываются ресурсы среды выполнения приложений).

	ВНИМАНИЕ. Выберите **тот же регион**, который планируется использовать для развертывания приложения. Это обеспечит наилучшую производительность.

6.	Установите флажок. Теперь система создает пространство имен службы и делает его доступным. Возможно, придется подождать несколько минут, пока система инициализирует ресурсы для вашей учетной записи.

	![](./media/service-bus-dotnet-how-to-use-relay/getting-started-multi-tier-27.png)

	Созданное пространство имен появится на портале управления, его активация займет некоторое время. Прежде чем продолжать, подождите, пока состояние не изменится на **Активное**.

<h2><span class="short-header">Получение учетных данных управления</span>Получение учетных данных управления по умолчанию для пространства имен</h2>

Для выполнения операций управления, таких как подключение ретрансляции, над новым пространством имен необходимо получить учетные данные управления для пространства имен.

1.  В левой области навигационной панели щелкните узел **Service Bus**, чтобы отобразить список доступных пространств имен:   
	![](./media/service-bus-dotnet-how-to-use-relay/sb-queues-13.png)


2.  Выберите в появившемся списке только что созданное пространство имен:   
	![](./media/service-bus-dotnet-how-to-use-relay/sb-queues-09.png)


3.  Нажмите кнопку **Сведения о подключении**   
	![](./media/service-bus-dotnet-how-to-use-relay/sb-queues-06.png)
 
4.  В диалоговом окне **Сведения по доступу к подключению** найдите записи **Издатель по умолчанию** и **Ключ по умолчанию**. Запишите эти значения, так как эти сведения будут использованы ниже для выполнения операций с пространством имен.

<h2><span class="short-header">Получение пакета NuGet</span>Получение пакета NuGet для Service Bus</h2>

Пакет **NuGet** шины Service Bus является самым простым способом получить API шины Service Bus и настроить для приложения все зависимости шины Service Bus. Расширение Visual Studio для NuGet упрощает установку и обновления библиотек и инструментов в Visual Studio и в Visual Studio Express 2012 for Web. Пакет NuGet шины Service Bus является самым простым способом получить API шины Service Bus и настроить для приложения все зависимости шины Service Bus.

Для установки пакета NuGet в приложении выполните следующие действия:

1.  В обозревателе решений щелкните правой кнопкой мыши **Ссылки**, затем выберите команду **Управление пакетами NuGet**.
2.  Найдите WindowsAzure и выберите пункт **Azure Service Bus**. Нажмите кнопку **Установить**, чтобы закончить установку, затем закройте это диалоговое окно.

	![](./media/service-bus-dotnet-how-to-use-relay/getting-started-multi-tier-13.png)
  

<h2><span class="short-header">Предоставление и использование веб-службы SOAP</span>Применение Service Bus для предоставления и использования веб-служб SOAP с помощью TCP</h2>

Чтобы предоставить существующую веб-службу WCF SOAP для внешнего использования, необходимо внести изменения в привязки и адреса служб. Для этого может потребоваться изменить файл конфигурации либо внести изменения в код, в зависимости от способа установки и настройки служб WCF. Обратите внимание, что WCF позволяет использовать несколько сетевых конечных точек для одной службы, поэтому при добавлении конечных точек Service Bus для внешнего доступа можно одновременно сохранить существующие внутренние конечные точки.

В этом задании необходимо создать простую службу WCF и добавить для нее прослушиватель Service Bus. Это упражнение предполагает определенное знакомство с Visual Studio 2012, поэтому рассматриваются не все подробности создания проекта. Вместо этого в центре внимания оказывается код.

Перед началом описанных ниже действия выполните следующую процедуру, чтобы настроить используемую среду.

1.  В Visual Studio создайте в рамках решения консольное приложение, содержащее два проекта, "Client" и "Service".
2.  Определите в качестве целевой платформы обоих проектов платформу .NET Framework 4.
3.  Добавьте для обоих проектов пакет **Azure Service Bus NuGet**.
    Это добавит в проекты все необходимые ссылки на сборки.

### Создание службы

Во-первых, создайте саму службу. Каждая служба WCF состоит как минимум из трех частей:

-   Определение контракта, в котором описываются обмен сообщениями и вызываемые операции. 
-   Реализация указанного контракта.
-   Узел, на котором размещается эта служба и который предоставляет несколько конечных точек.

В примерах кода этого раздела рассматриваются каждый из этих компонентов.

Контракт определяет одну операцию, **AddNumbers**, которая складывает два числа и возвращает результат. Интерфейс **IProblemSolverChannel**
упрощает для клиента управление временем жизни прокси-сервера. Рекомендуется создать этот интерфейс. Стоит поместить это определение контракта в отдельный файл, чтобы на этот файл можно было ссылаться из проектов "Client" и "Service", но можно и скопировать код в оба проекта:

        using System.ServiceModel;
     
        [ServiceContract(Namespace = "urn:ps")]
        interface IProblemSolver
        {
            [OperationContract]
            int AddNumbers(int a, int b);
        }
     
        interface IProblemSolverChannel : IProblemSolver, IClientChannel {}

При наличии контракта реализация предельно проста:

        class ProblemSolver : IProblemSolver
        {
            public int AddNumbers(int a, int b)
            {
                return a + b;
            }
        }

**Программная настройка узла службы**

После создания контракта и реализации можно разместить службу. Размещение происходит внутри объекта
**System.ServiceModel.ServiceHost**, который отвечает за управление экземплярами службы и в котором размещаются конечные точки, прослушивающие сообщения. Для иллюстрации внешнего вида, работы бок о бок, внутренних и внешних конечных точек приведенный ниже код настраивает для службы обычную локальную конечную точку и конечную точку Service Bus. Замените строку
"\*\*namespace\*\*" на свое имя пространства имен, а "\*\*key\*\*"
— на ключ издателя, полученный на приведенном выше шаге настройки. 

    ServiceHost sh = new ServiceHost(typeof(ProblemSolver));

    sh.AddServiceEndpoint(
       typeof (IProblemSolver), new NetTcpBinding(), 
       "net.tcp://localhost:9358/solver");

    sh.AddServiceEndpoint(
       typeof(IProblemSolver), new NetTcpRelayBinding(), 
       ServiceBusEnvironment.CreateServiceUri("sb", "**namespace**", "solver"))
        .Behaviors.Add(new TransportClientEndpointBehavior {
              TokenProvider = TokenProvider.CreateSharedSecretTokenProvider( "owner", "**key**")});

    sh.Open();

    Console.WriteLine("Press ENTER to close");
    Console.ReadLine();

    sh.Close();

В примере создаются две конечные точки, предназначенные для одной и той же реализации контракта. Одна из них является локальной, а вторая проецируется с помощью Service Bus. Основным различием между ними являются привязки
(**NetTcpBinding** для локальной и **NetTcpRelayBinding** для конечной точки Service Bus) и адреса. Для локальной конечной точки используется локальный сетевой адрес с отдельным портом. Адрес конечной точки Service Bus состоит из строки "sb", имени пространства имен и "средства разрешения" пути. Результатом является URI "sb://[serviceNamespace].servicebus.windows.net/solver", определяющий конечную точку службы как конечную точку TCP шины Service Bus с полным внешним DNS-именем. Если поместить код, заменив заполнители, как описано выше в функции **Main** приложения "Service", будет создана функциональная служба. Если нужно, чтобы служба прослушивала только шину Service Bus, удалите объявление локальной конечной точки.

**Настройка узла службы в файле App.config**

Узел также можно настроить с помощью файла App.config. В этом случае размещение кода службы выглядит следующим образом:

    ServiceHost sh = new ServiceHost(typeof(ProblemSolver));
    sh.Open();
    Console.WriteLine("Press ENTER to close");
    Console.ReadLine();
    sh.Close();

Определения конечных точек перемещаются в файл App.config. Обратите внимание, что пакет **NuGet** уже добавил в файл App.config ряд определений, являющихся необходимыми расширениями Service Bus. Следующий фрагмент кода, который является точным эквивалентом кода, приведенного выше, должен появиться прямо под элементом **system.serviceModel**. В этом фрагменте предполагается, что пространство имен проекта C\# называется "Service".
Замените заполнители на пространство имен служб и ключ Service Bus.

    <services>
        <service name="Service.ProblemSolver">
            <endpoint contract="Service.IProblemSolver"
                      binding="netTcpBinding"
                      address="net.tcp://localhost:9358/solver"/>
            <endpoint contract="Service.IProblemSolver"
                      binding="netTcpRelayBinding"
                      address="sb://**namespace**.servicebus.windows.net/solver"
                      behaviorConfiguration="sbTokenProvider"/>
        </service>
    </services>
    <behaviors>
        <endpointBehaviors>
            <behavior name="sbTokenProvider">
                <transportClientEndpointBehavior>
                    <tokenProvider>
                        <sharedSecret issuerName="owner" issuerSecret="**key**" />
                    </tokenProvider>
                </transportClientEndpointBehavior>
            </behavior>
        </endpointBehaviors>
    </behaviors>

После этих изменений служба запускается как и раньше, но с двумя работающими конечными точками: одна локальная и одна прослушивающая в облаке.

### Создание клиента

**Программная настройка клиента**

Для использования службы можно создать клиент WCF с помощью объекта
**ChannelFactory**. Service Bus использует модель безопасности на основе утверждений, реализуемую с помощью службы Access Control (ACS). Класс
**TokenProvider** представляет поставщик маркеров безопасности со встроенными производителем методами, возвращающими ряд хорошо известные поставщиков маркеров. В приведенном ниже примере **SharedSecretTokenProvider** используется для хранения общих секретных учетных данных и обработки получения соответствующих маркеров от службы Access Control. Для имени и ключа используются значения, полученные из портала, как описано в предыдущем разделе.

Во-первых, создайте в проекте клиента ссылку или скопируйте в него код контракта **IProblemSolver** из службы.

Затем замените код в методе **Main** клиента, снова заменяя текст заполнителя на имя пространства служб и ключ Service Bus:

    var cf = new ChannelFactory<IProblemSolverChannel>(
        new NetTcpRelayBinding(), 
        new EndpointAddress(ServiceBusEnvironment.CreateServiceUri("sb", "**namespace**", "solver")));

    cf.Endpoint.Behaviors.Add(new TransportClientEndpointBehavior
                { TokenProvider = TokenProvider.CreateSharedSecretTokenProvider("owner","**key**") });
     
    using (var ch = cf.CreateChannel())
    {
        Console.WriteLine(ch.AddNumbers(4, 5));
    }

Теперь можно скомпилировать клиент и службу, запустить их (сначала запустите службу), и клиент вызовет службу и напечатает "9". Можно запустить клиент и сервер на разных компьютерах, даже в разных сетях, и связь по-прежнему будет работать. Код клиента также может работать в облаке или локально.

**Настройка клиента в файле App.config**

Клиент также можно настроить с помощью файла App.config. Для этого используется следующий код клиента:

    var cf = new ChannelFactory<IProblemSolverChannel>("solver");
    using (var ch = cf.CreateChannel())
    {
        Console.WriteLine(ch.AddNumbers(4, 5));
    }

Определения конечных точек перемещаются в файл App.config. Следующий фрагмент кода, в точности совпадающий с кодом, приведенным выше, должен появиться прямо под элементом **system.serviceModel**. Здесь, как и выше, нужно заменить заполнители на пространство имен служб и ключ Service Bus.

    <client>
        <endpoint name="solver" contract="Service.IProblemSolver"
                  binding="netTcpRelayBinding"
                  address="sb://**namespace**.servicebus.windows.net/solver"
                  behaviorConfiguration="sbTokenProvider"/>
    </client>
    <behaviors>
        <endpointBehaviors>
            <behavior name="sbTokenProvider">
                <transportClientEndpointBehavior>
                    <tokenProvider>
                        <sharedSecret issuerName="owner" issuerSecret="**key**" />
                    </tokenProvider>
                </transportClientEndpointBehavior>
            </behavior>
        </endpointBehaviors>
    </behaviors>

<h2><span class="short-header">Дальнейшие действия</span>Дальнейшие действия</h2>

Вы познакомились с основами службы **ретрансляции** Service Bus.
Для получения дополнительных сведений используйте следующие ссылки.

-   Создание службы: [Создание службы для Service Bus][]
-   Создание клиента: [Создание клиентского приложения для Service Bus][]
-   Примеры Service Bus: загрузка из [примеров Azure][]

  [Дальнейшие действия]: #next_steps
  [Описание ретрансляции Service Bus]: #what-is
  [Создание пространства имен службы]: #create_namespace
  [Получение учетных данных управления по умолчанию для пространства имен]: #obtain_credentials
  [Получение пакета NuGet шины Service Bus]: #get_nuget_package
  [Использование Service Bus для предоставления и использования веб-службы SOAP с помощью TCP]: #how_soap
  [Портал управления Azure]: http://manage.windowsazure.com
   [Создание службы для Service Bus]: http://msdn.microsoft.com/ru-ru/library/windowsazure/ee173564.aspx
  [Создание клиентского приложения для Service Bus]: http://msdn.microsoft.com/ru-ru/library/windowsazure/ee173543.aspx
  [примеров Azure]: http://code.msdn.microsoft.com/windowsazure

