<properties title="Производительность хранилища Microsoft Azure и контрольный список масштабируемости" pageTitle="Производительность хранилища Microsoft Azure и контрольный список масштабируемости" description="Обязательно" metaKeywords="Optional" services="Optional" solutions="Optional" documentationCenter="Optional" authors="Tamra Myers" videoId="Optional" scriptId="Optional" />

<tags ms.service="storage" ms.workload="storage" ms.tgt_pltfrm="na" ms.devlang="dotnet" ms.topic="article" ms.date="10/08/2014" ms.author="tamram" />

# Производительность хранилища Microsoft Azure и контрольный список масштабируемости

## Введение

С момента выпуска служб хранилища Microsoft Azure корпорация Microsoft разработала ряд проверенных принципов для эффективного использования этих служб. Эта статья служит для объединения наиболее важных из них в "контрольный список". Целью этой статьи является помочь разработчикам приложений убедиться, что они используют проверенные методы работы с хранилищем Azure, и найти другие проверенные методы, которые можно использовать в будущем. В данной статье не рассматриваются все возможные способы оптимизации производительности и масштабируемости. Мы не описываем методики, последствия применения которых несущественны, а также методики, которые не нашли широкого применения. Поскольку поведение приложения можно предвидеть в процессе разработки, важно помнить об этом на ранних стадиях во избежание создания проектов, которые приведут к проблемам с производительностью.

Каждый разработчик приложения, использующий хранилище Azure, должен уделить время прочтению этой статьи и убедиться в том, что его или ее приложение следует всем проверенным методикам, перечисленным ниже.

## Контрольный список

В этой статье методики поделены на следующие группы. Методики, применимые в отношении:

-   всех служб хранилища Azure (BLOB-объектов, таблиц, очередей и файлов);
-   BLOB-объекты
-   Таблицы
-   Очереди

Служба файлов Azure в настоящее время находится в окне предварительного просмотра, и в будущем мы добавим сюда проверенные методики.

<table>
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Готово</th>
<th align="left">Область</th>
<th align="left">Категория</th>
<th align="left">Вопрос</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"></td>
<td align="left">Все службы</td>
<td align="left">Целевые показатели масштабируемости</td>
<td align="left"><a href="#subheading1">Спроектировано ли приложение таким образом, чтобы избежать приближения к целевым показателям масштабируемости?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Все службы</td>
<td align="left">Работа в сети</td>
<td align="left"><a href="#subheading2">Имеют ли клиентские устройства достаточно высокую пропускную способность и низкую степень задержки для достижения необходимой производительности?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Все службы</td>
<td align="left">Работа в сети</td>
<td align="left"><a href="#subheading3">Имеют ли клиентские устройства достаточно высокое качество связи?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Все службы</td>
<td align="left">Работа в сети</td>
<td align="left"><a href="#subheading4">Расположено ли клиентское приложение &quot;вблизи&quot; учетной записи хранения?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Все службы</td>
<td align="left">Распространение содержимого</td>
<td align="left"><a href="#subheadin5">Используете ли вы CDN для распределения содержимого?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Все службы</td>
<td align="left">Прямой клиентский доступ</td>
<td align="left"><a href="#subheading6">Используете ли вы SAS и CORS для прямого доступа к хранилищу вместо прокси-сервера?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Все службы</td>
<td align="left">Caching</td>
<td align="left"><a href="#subheading7">Данные кэширования приложений используются постоянно и изменяются редко?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Все службы</td>
<td align="left">Caching</td>
<td align="left"><a href="#subheading8">Ваше приложение группирует обновления (кэширует на стороне клиента, а затем загружает в виде большого массива)?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Все службы</td>
<td align="left">Конфигурация .NET</td>
<td align="left"><a href="#subheading9">Вы настроили свой клиент на использование достаточного количества одновременных подключений?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Все службы</td>
<td align="left">Конфигурация .NET</td>
<td align="left"><a href="#subheading10">Вы настроили .NET на использование достаточного количества потоков?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Все службы</td>
<td align="left">Конфигурация .NET</td>
<td align="left"><a href="#subheading11">Используете ли вы .NET 4.5 или более позднюю версию, в которой улучшена функция сборки мусора?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Все службы</td>
<td align="left">Параллелизм</td>
<td align="left"><a href="#subheading12">Вы уверены в том, что параллелизм ограничен соответствующим образом, чтобы не перегружать ни возможности клиента, ни целевые показатели масштабируемости?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Все службы</td>
<td align="left">Средства</td>
<td align="left"><a href="#subheading13">Вы используете последние версии клиентских библиотек и инструментов, предоставленных корпорацией Microsoft?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Все службы</td>
<td align="left">Повторы</td>
<td align="left"><a href="#subheading14">Вы используете политику повтора экспоненциального откладывания для регулирования ошибок и времени ожидания?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Все службы</td>
<td align="left">Повторы</td>
<td align="left"><a href="#subheading15">Ваше приложение избегает повторов неповторяемых ошибок?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">BLOB-объекты</td>
<td align="left">Целевые показатели масштабируемости</td>
<td align="left"><a href="#subheading16">Ваше приложение придерживается уровня пропускной способности или рабочего целевого показателя масштабируемости для одинарного BLOB-объекта?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">BLOB-объекты</td>
<td align="left">Копирование BLOB-объектов</td>
<td align="left"><a href="#subheading17">Вы копируете BLOB-объекты эффективным способом?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">BLOB-объекты</td>
<td align="left">Копирование BLOB-объектов</td>
<td align="left"><a href="#subheading18">Используете ли вы AzCopy для массового копирования BLOB-объектов?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">BLOB-объекты</td>
<td align="left">Копирование BLOB-объектов</td>
<td align="left"><a href="#subheading19">Используете ли вы импорт и экспорт Azure для перемещения очень больших объемов данных?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">BLOB-объекты</td>
<td align="left">Использование метаданных</td>
<td align="left"><a href="#subheading20">Вы храните часто используемые метаданные, касающиеся BLOB-объектов, в их метаданных?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">BLOB-объекты</td>
<td align="left">Быстрая отправка</td>
<td align="left"><a href="#subheading21">При попытке быстро отправить один BLOB-объект вы осуществляете параллельную отправку блоков?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">BLOB-объекты</td>
<td align="left">Быстрая отправка</td>
<td align="left"><a href="#subheading22">При попытке быстро отправить множество BLOB-объектов вы отправляете BLOB-объекты параллельно?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">BLOB-объекты</td>
<td align="left">Правильный тип BLOB-объекта</td>
<td align="left"><a href="#subheading23">Используете ли вы при необходимости страничные BLOB-объекты или блочные BLOB-объекты?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Таблицы</td>
<td align="left">Целевые показатели масштабируемости</td>
<td align="left"><a href="#subheading24">Вы приближаетесь к целевым показателям масштабируемости для сущностей в секунду?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Таблицы</td>
<td align="left">Конфигурация</td>
<td align="left"><a href="#subheading25">Используете ли вы JSON в запросах таблиц?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Таблицы</td>
<td align="left">Конфигурация</td>
<td align="left"><a href="#subheading26">Вы отключили алгоритм Nagle для повышения производительность небольших запросов?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Таблицы</td>
<td align="left">Таблицы и разделы</td>
<td align="left"><a href="#subheading27">Вы правильно разделили свои данные?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Таблицы</td>
<td align="left">Горячие разделы</td>
<td align="left"><a href="#subheading28">Вы избегаете использования инкрементируемых и декрементируемых шаблонов?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Таблицы</td>
<td align="left">Горячие разделы</td>
<td align="left"><a href="#subheading29">Вы распределяете свои вставки и обновления по нескольким разделам?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Таблицы</td>
<td align="left">Область запроса</td>
<td align="left"><a href="#subheading30">Вы спроектировали свою схему таким образом, чтобы в большинстве случаев использовать точечные запросы, а табличные запросы использовать редко?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Таблицы</td>
<td align="left">Плотность запроса</td>
<td align="left"><a href="#subheading31">Ваши запросы обычно только сканируют и возвращают строки, которые будет использовать приложение?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Таблицы</td>
<td align="left">Ограничение возвращаемых данных</td>
<td align="left"><a href="#subheading32">Используете ли вы фильтрацию, чтобы избежать возвращения ненужных сущностей?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Таблицы</td>
<td align="left">Ограничение возвращаемых данных</td>
<td align="left"><a href="#subheading33">Используете ли вы проекцию, чтобы избежать возвращения ненужных свойств?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Таблицы</td>
<td align="left">Денормализация</td>
<td align="left"><a href="#subheading34">Вы денормализовали свои данные таким образом, чтобы избежать неэффективных или множественных запросов чтения при попытке получения данных?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Таблицы</td>
<td align="left">Вставить, обновить, удалить</td>
<td align="left"><a href="#subheading35">Вы применяете пакетную обработку запросов, которые должны быть транзакционными или могут быть выполнены в одно и то же время, чтобы уменьшить число циклов обработки?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Таблицы</td>
<td align="left">Вставить, обновить, удалить</td>
<td align="left"><a href="#subheading36">Вы избегаете извлечения сущности только для того, чтобы определить, какую операцию следует выполнить: вставку или обновление?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Таблицы</td>
<td align="left">Вставить, обновить, удалить</td>
<td align="left"><a href="#subheading37">Рассматривали ли вы возможность хранения ряда данных, которые будут часто извлекаться в качестве свойств вместе с единственной сущностью, а не в виде множества сущностей?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Таблицы</td>
<td align="left">Вставить, обновить, удалить</td>
<td align="left"><a href="#subheading38">Для сущностей, которые всегда будут извлекаться вместе и могут быть записаны в пакеты (например, данные временных рядов), рассматривали ли вы возможность использования BLOB-объектов вместо таблиц?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Очереди</td>
<td align="left">Целевые показатели масштабируемости</td>
<td align="left"><a href="#subheading39">Вы достигаете целевых показателей масштабируемости для сообщений в секунду?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Очереди</td>
<td align="left">Конфигурация</td>
<td align="left"><a href="#subheading40">Вы отключили алгоритм Nagle для повышения производительность небольших запросов?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Очереди</td>
<td align="left">Размер сообщения</td>
<td align="left"><a href="#subheading41">Ваши сообщения сжаты для повышения производительности очереди?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Очереди</td>
<td align="left">Массовое получение</td>
<td align="left"><a href="#subheading41">Вы получаете множество сообщений при выполнении одной операции &quot;Получить&quot;?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Очереди</td>
<td align="left">Частота опроса</td>
<td align="left"><a href="#subheading42">Частота опроса достаточна для уменьшения наблюдаемой задержки приложения?</a></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Очереди</td>
<td align="left">Сообщение об обновлении</td>
<td align="left"><a href="#subheading43">Используете ли вы UpdateMessage для хранения хода выполнения обработки сообщений, избегая повторной обработки всего сообщения при возникновении ошибки?</a></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Очереди</td>
<td align="left">Архитектура</td>
<td align="left"><a href="#subheading44">Используете ли вы очереди для того, чтобы сделать все приложение более масштабируемым, не допуская длительных рабочих нагрузок на критическом пути и масштабируя их самостоятельно?</a></td>
</tr>
</tbody>
</table>

## <a name="allservices"></a>Все службы

В этом разделе перечислены проверенные методики, применимые для использования любой из служб хранилища Azure (BLOB-объекты, таблицы, очереди или файлы).

### <a name="subheading1"></a>Целевые показатели масштабируемости

Каждая служба хранилища Azure имеет целевые показатели масштабируемости по производительности (ГБ), скорости транзакции и пропускной способности. Если приложение достигает одного из целевых показателей масштабируемости или превышает его, оно может столкнуться с увеличением задержки транзакций или запуском механизма регулировки количества запросов. Когда служба хранилища включает механизм регулировки количества запросов приложения, для некоторых транзакций с хранилищем она начинает возвращать коды ошибки "503 Сервер занят" или "500 Время ожидания операции истекло". В этом разделе рассматривается как подход к целевым показателям масштабируемости в целом, так и к целевым показателям масштабируемости в отношении пропускной способности в частности. В следующих разделах, которые касаются отдельных служб хранилища, обсуждаются целевые показатели масштабируемости в контексте конкретной службы:

-   [Пропускная способность BLOB-объектов и количество запросов в секунду][Ваше приложение придерживается уровня пропускной способности или рабочего целевого показателя масштабируемости для одинарного BLOB-объекта?]
-   [Таблица сущностей в секунду][Вы приближаетесь к целевым показателям масштабируемости для сущностей в секунду?]
-   [Сообщения очереди в секунду][Вы достигаете целевых показателей масштабируемости для сообщений в секунду?]

#### <a name="sub1bandwidth"></a>Целевой показатель масштабируемости пропускной способности для всех служб

На момент написания данной статьи целевыми показателями пропускной способности в США для учетной записи геоизбыточного хранилища (GRS) является скорость в 10 гигабит в секунду (Гбит/с) на входе (данные, отправленные в учетную запись хранения) и 20 Гбит/с на выходе (данные, отправленные из учетной записи хранения). Для учетной записи локально избыточного хранилища (LRS) эти ограничения выше и составляют до 20 Гбит/с на входе и 30 Гбит/с на выходе. Международные ограничения пропускной способности могут быть ниже. О них можно узнать на [странице целевых показателей масштабируемости][странице целевых показателей масштабируемости]. Для получения дополнительной информации о параметрах избыточности хранилищ см. ссылки в разделе [Полезные ресурсы][Полезные ресурсы], представленные ниже.

#### Действия при достижении целевого показателя масштабируемости

Если приложение достигает целевых показателей масштабируемости, когда речь идет об одной учетной записи хранения, рассмотрите вопрос об использовании одного из следующих подходов:

-   Пересмотрите рабочую нагрузку, которая приводит к достижению приложением целевого показателя масштабируемости или его превышению. Вы можете спроектировать его по-другому, чтобы использовать меньшую полосу пропускания или производительность, или меньшее количество транзакций?
-   Если приложение должно превышать один из целевых показателей масштабируемости, следует создать несколько учетных записей хранения и разделить по ним данные приложения. При использовании этого подхода необходимо разработать приложение таким образом, чтобы в будущем для балансировки нагрузки в него можно было добавлять другие учетные записи хранения. На момент написания данной статьи каждая подписка Azure может иметь до 100 учетных записей хранения. Кроме случаев использования с целью хранения данных, совершения транзакций или передачи данных плата за учетные записи хранения не взимается.
-   Если приложение достигает целевых показателей пропускной способности, рассмотрите вопрос сжатия данных на стороне клиента, чтобы уменьшить полосу пропускания, необходимую для отправки данных в службу хранилища. Обратите внимание, этот способ может как сэкономить полосу пропускания и повысить производительность сети, так и иметь некоторые негативные последствия. Вам следует оценить влияние на производительность этих дополнительных требований по сжатию и распаковке данных, выполняемых на стороне клиента. Кроме того, хранение сжатых данных может усложнить устранение обнаруженных в них неполадок, так как в этом случае может возникнуть трудность с просмотром сохраненных данных с помощью стандартных инструментов.
-   Если приложение достигает целевых показателей масштабируемости, убедитесь в том, что используется экспоненциальное откладывание для повторов (см. раздел [Повторы][Вы используете политику повтора экспоненциального откладывания для регулирования ошибок и времени ожидания?]). Лучше всего сделать так, чтобы ваше приложение никогда не приближалось к целевым показателям масштабируемости (с помощью одного из вышеуказанных методов), но это приведет к тому, что приложение просто не будет продолжать выполнять быстрые повторения, еще более активируя механизм регулировки количества запросов.

#### Полезные ресурсы

Приведенные ниже ссылки предоставляют дополнительную информацию о целевых показателях масштабируемости:

-   Текущие целевые показатели масштабируемости можно посмотреть на странице [Целевые показатели по масштабируемости и производительности хранилища Azure в MSDN][странице целевых показателей масштабируемости].
-   Подробнее о параметрах избыточности хранилищ можно узнать в сообщении блога[Параметры избыточности в службе хранилища Microsoft Azure и геоизбыточное хранилище с доступом на чтение][Параметры избыточности в службе хранилища Microsoft Azure и геоизбыточное хранилище с доступом на чтение]. См. подробнее в следующем разделе.
-   Для получения текущей информации о ценах за использование служб Azure см. раздел [Краткий обзор цен Azure][Краткий обзор цен Azure].

### Работа в сети

Хотя API вызывается независимо, часто физические ограничения сети, в котором работает приложение, оказывают существенное влияние на производительность. Ниже описаны некоторые ограничения, с которыми могут столкнуться пользователи.

#### Возможность клиентской сети

##### <a name="subheading2"></a>Пропускная способность

Что касается полосы пропускания, частой проблемой являются возможности клиента. Например, в то время как одна учетная запись хранения может обрабатывать данные со скоростью 10 Гбит/с или более на входе (см. [целевые показатели масштабируемости пропускной способности][целевые показатели масштабируемости пропускной способности]), скорость работы сети в “небольшом” экземпляре роли Azure Worker способна достигать только около 100 Мбит/с. Очень крупные экземпляры Azure имеют сетевые карты, обладающие большими возможностями, поэтому, если необходимы более высокие сетевые ограничения от одной машины, следует рассмотреть возможность использования более крупного экземпляра или наличия большего количества виртуальных машин. При обращении к службе хранилища из локального приложения применяется то же правило: понять сетевые возможности клиентского устройства и сетевого подключения к месту расположения хранилища Azure и либо улучшить их по мере необходимости, либо разработать приложение для работы в рамках их возможностей.

##### <a name="subheading3"></a>Качество линии связи

Как и при любом использовании сети, имейте в виду, что состояние сети, приводящее к ошибкам и потере пакетов, снижает эффективную пропускную способность. Использование инструмента WireShark или NetMon может помочь в диагностике этой проблемы.

##### Полезные ресурсы

Для получения дополнительной информации о размерах виртуальной машины и выделенной полосы пропускания см. раздел [Рекомендации по проектированию крупномасштабных служб на основе облачных служб Azure][Рекомендации по проектированию крупномасштабных служб на основе облачных служб Azure] в сети MSDN.

#### <a name="subheading4"></a>Расположение

В любой распределенной среде наилучшее быстродействие достигается при нахождении клиента рядом с сервером. Для доступа к хранилищу Azure с наименьшей задержкой лучшим местом для клиента будет его нахождение в том же регионе Azure. Например, при наличии веб-сайта Azure, который использует хранилище Azure, оба следует разместить внутри одного региона (например, на Западе США или в Юго-Восточной Азии). Это уменьшает задержку и стоимость. На момент написания этой статьи использование полосы пропускания в пределах одного региона является бесплатным.

Опять же, если клиентские приложения не размещены в Azure (например, в приложениях для мобильных устройств или в локальных корпоративных службах), размещение учетной записи хранения в регионе рядом с устройствами, которые будут к нему обращаться, как правило, уменьшает задержку. Если клиенты разбросаны по всему миру (например, одни находятся в Северной Америке, другие в Европе), следует рассмотреть возможность использования нескольких учетных записей хранения: одна размещенная в североамериканском регионе и одна — в европейском. Это поможет сократить задержку для пользователей в обоих регионах. Такой подход, как правило, легче реализовать, если данные, которые хранят приложения, предназначены для отдельных пользователей, и не требуют репликации между учетными записями хранения. Для широкого распространения содержимого рекомендуется использовать сеть CDN. Для получения более подробной информации см. ​следующий раздел.

### <a name="subheading5"></a>Распространение содержимого

Иногда приложению необходимо предоставить одинаковое содержимое множеству пользователей (например, демо-видео продукта, используемое на домашней странице веб-сайта), которые находятся в одном или в нескольких регионах. В этом случае следует использовать сеть доставки содержимого (CDN), такую как сеть Azure CDN, где CDN будет использовать хранилище Azure в качестве источника данных. В отличие от учетной записи хранилища Azure, которая существует в одном регионе и которая не может распространять содержимое с минимальной задержкой в другие регионы, сеть Azure CDN использует серверы, расположенные в нескольких центрах обработки данных по всему миру. Кроме того, сеть CDN может, как правило, поддерживать гораздо более высокие ограничения на выходе, чем одна учетная запись хранения.

Для получения дополнительной информации о сети Azure CDN см. раздел [Сеть Azure CDN][Сеть Azure CDN].

### <a name="subheading6"></a>Использование SAS и CORS

Когда для доступа к данным хранилища Azure в пользовательском браузере или приложении мобильного телефона необходимо авторизовать такой код, как JavaScript, один из способов — использовать в качестве прокси-сервера приложение с веб-ролью: пользовательское устройство выполняет проверку подлинности с помощью веб-роли, которая в свою очередь выполняет проверку подлинности с помощью службы хранилища. Таким образом, на небезопасных устройствах можно не сообщать ключи своей учетной записи хранения. Однако это приводит к большим затратам вычислительных ресурсов на обработку веб-роли, потому что все данные, передаваемые между пользовательским устройством и службой хранилища, должны пройти через эту веб-роль. Избежать использования веб-роли в качестве прокси-сервера для службы хранилища можно путем использования подписей совместного доступа (Shared Access Signatures, или SAS), иногда в сочетании с заголовками для общего доступа к ресурсам независимо от источника (Cross-Origin Resource Sharing, или CORS). Используя технологию SAS, пользовательскому устройству можно позволить осуществлять запросы непосредственно к службе хранилища с помощью ограниченного маркера доступа. Например, если пользователь хочет загрузить фото в приложение, веб-роль может создать и отправить на пользовательское устройство маркер SAS, который предоставляет разрешение на запись определенному BLOB-объекту или контейнеру в течение ближайших 30 минут (после чего срок действия маркера SAS истекает).

Обычно браузер не позволяет коду JavaScript, находящемуся на странице, размещенной на веб-сайте в одном домене, выполнять определенные операции, такие, как "PUT", направленными на другой домен. Например, если при размещении веб-роли в домене contosomarketing.cloudapp.net необходимо использовать код JavaScript, находящийся на стороне клиента, чтобы загрузить BLOB-объект в учетную запись хранения, расположенную в домене contosoproducts.blob.core.windows.net, "политика одинакового источника" браузера запретит эту операцию. Технология CORS является функцией браузера, которая позволяет целевому домену (в данном случае учетной записи хранения) связаться с браузером, которому она доверяет запросы, созданные в исходном домене (в данном случае веб-роли).

Обе эти технологии могут помочь избежать излишней нагрузки (и узких мест) веб-приложения.

#### Полезные ресурсы

Для получения дополнительной информации о технологии SAS см. раздел [Подписи совместного доступа. Часть 1. Основные сведения о модели SAS][Подписи совместного доступа. Часть 1. Основные сведения о модели SAS].

Для получения дополнительной информации о технологии CORS см. раздел [Поддержка общего доступа к ресурсам независимо от источника (CORS) для службы хранилища Azure в сети MSDN][Поддержка общего доступа к ресурсам независимо от источника (CORS) для службы хранилища Azure в сети MSDN].

### Caching

#### <a name="subheading7"></a>Получение данных

В большинстве случаев получение данных из службы с одной попытки лучше, чем с двух. Рассмотрим пример веб-приложения MVC, выполняющегося в веб-роли, которая уже получила 50 МБ BLOB-объекта из службы хранилища для его предоставления пользователю в качестве содержимого. Затем приложение может получать тот же самый BLOB-объект каждый раз, когда его запрашивает пользователь, или же оно может кэшировать его локально на диск и повторно использовать кэшированную версию для обработки последующих запросов пользователей. Кроме того, каждый раз, когда пользователь запрашивает данные, приложение может вызывать команду GET с условным заголовком для времени изменения, благодаря чему можно не получать весь BLOB-объект в том случае, если он не был изменен. Такую же схему можно применить для работы с сущностями таблицы.

В некоторых случаях можно решить, что приложение может считать BLOB-объект действующим в течение короткого периода времени после его получения и что в течение этого периода времени приложению не нужно проверять, был ли изменен этот BLOB-объект.

Прекрасными кандидатами на кэширование являются данные конфигурации, поиска, а также другие данные, которые используются приложением всегда.

Пример того, как получить свойства BLOB-объекта, необходимые для выяснения даты последнего изменения с помощью .NET, см. в разделе [Задание и получение свойств и метаданных][Задание и получение свойств и метаданных] в MSDN. Для получения дополнительной информации об условных загрузках см. раздел [Условное обновление локальной копии BLOB-объекта][Условное обновление локальной копии BLOB-объекта] в MSDN.

#### <a name="subheading8"></a>Отправка данных в пакетах

В некоторых случаях приложения могут объединять данные локально, а затем периодически отправлять их в пакете вместо немедленной отправки каждого фрагмента данных. Например, веб-приложение может хранить файл журнала операций: приложение может или отправлять сведения о каждой операции по мере их появления в виде табличной сущности (что требует выполнения множества операций хранилища), или оно может сохранять сведения об операциях в локальный файл журнала, а затем периодически отправлять все эти сведения в виде файла с разделителями на BLOB-объект. Если размер каждой записи журнала составляет 1 КБ, их можно отправлять тысячами в одной транзакции “Put Blob” (Положить в BLOB-объект) (в одной транзакции можно отправить BLOB-объект размером до 64 МБ). Конечно, в том случае, если локальная машина выходит из строя до завершения отправки, некоторые данные журнала будут потеряны: разработчик приложения должен предусмотреть возможность ошибок клиентского устройства или ошибок передачи. Если необходимо загрузить данные о действиях, совершенных в определенные временные интервалы (а не только за одиночную операцию), рекомендуются использовать BLOB-объекты, а не таблицы.

### Конфигурация .NET

В данном разделе перечислены несколько быстрых параметров конфигурации, которые можно использовать для значительного повышения производительности при использовании платформы .NET Framework. При использовании других языков проверьте, применяются ли в выбранном языке подобные концепции.

#### <a name="subheading9"></a>Увеличение ограничения числа подключений по умолчанию

В языке .NET указанный ниже код увеличивает ограничение числа подключений по умолчанию (которое обычно соответствует 2 в клиентской среде или 10 в серверной среде) до 100. В обычном случае следует установить значение, приблизительно соответствующее количеству потоков, используемых приложением.

    ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  

Ограничение числа подключений должно быть установлено до открытия каких-либо подключений.

Что касается других языков программирования, для определения механизма установки ограничения числа подключений см. документацию по соответствующему языку.

Для получения дополнительной информации см. публикацию [Веб-службы. Одновременные подключения][Веб-службы. Одновременные подключения] в MSDN.

#### <a name="subheading10"></a>Увеличение минимального количества потоков ThreadPool при использовании синхронного кода с помощью асинхронных задач

Данный код позволяет увеличить минимальное количество потоков в пуле потоков:

    ThreadPool.SetMinThreads(100,100); //(Determine the right number for your application)  

Для получения дополнительной информации см. раздел [Метод ThreadPool.SetMinThreads][Метод ThreadPool.SetMinThreads] в MSDN.

#### <a name="subheading11"></a>Воспользуйтесь преимуществами технологии сборки мусора .NET 4.5

Используйте для клиентского приложения .NET 4.5 или более поздней версии, чтобы воспользоваться новыми способами повышения производительности в технологии сборки серверного мусора.

Для получения дополнительной информации см. статью [Обзор новых способов повышения производительности в .NET 4.5][Обзор новых способов повышения производительности в .NET 4.5] в MSDN.

### <a name="subheading12"></a>Неограниченный параллелизм

Хотя параллелизм может быть привлекательным с точки зрения производительности, будьте внимательны при использовании неограниченного параллелизма (отсутствие ограничения на количество потоков и (или) параллельных запросов) для отправки или загрузки данных, наличии нескольких работников с доступом к нескольким разделам (контейнерам, очередям или разделам таблиц) в одной учетной записи хранения или доступом к нескольким элементам в одном разделе. Если параллелизм неограничен, приложение может превышать возможности клиентского устройства или целевые показатели масштабируемости учетных записей хранения из-за более длинных задержек и регулирования количества запросов.

### <a name="subheading13"></a>Клиентские библиотеки и инструменты хранилища

Всегда используйте самые последние версии клиентских библиотек и инструментов, предоставляемых корпорацией Microsoft. На момент написания данной статьи существуют RTM-библиотеки, доступные для .NET, Windows Phone, Windows Runtime и Java, а также библиотеки предварительного просмотра на других языках, таких как Node.js и C++. Кроме того, корпорация Microsoft выпустила командлеты PowerShell и кроссплатформенные программы командной строки, разработанные на языке Node.js для работы с хранилищем Azure. Корпорация Microsoft активно разрабатывает эти инструменты с учетом производительности, поддерживает их в соответствии с последними версиями служб и обеспечивает в них поддержку проверенных и производительных методов работы.

### Повторы

#### <a name="subheading14"></a>Регулирование количества запросов и состояние ServerBusy (Сервер занят)

В некоторых случаях служба хранилища может регулировать количество запросов приложения или может просто быть не в состоянии обслуживать запрос из-за некоего переходного состояния и возвращает сообщение "503 Сервер занят" или "500 Время ожидания операции истекло". Это может произойти в том случае, если приложение достигает одного из целевых показателей масштабируемости или если система занята повторной балансировкой секционированных данных для обеспечения более высокой пропускной способности. Клиентское приложение должно, как правило, повторить операцию, которая вызывает эту ошибку: попытка выполнить тот же самый запрос позже может быть успешной. Однако если служба хранилища запускает механизм регулировки количества запросов из приложения из-за превышения целевых показателей масштабируемости или даже если служба была не в состоянии обслуживать данный запрос по какой-то другой причине, настойчивые повторы обычно только усугубляют проблему. По этой причине следует использовать экспоненциальное откладывание (по умолчанию клиентские библиотеки настроены реагировать именно так). Например, приложение может повторить действие через 2 секунды, затем через 4 секунды, затем через 10 секунд, затем через 30 секунд, а затем полностью отказаться от повторения. Такое поведение приводит к тому, что приложение значительно снижает свою нагрузку на службу и не усугубляет проблем.

Обратите внимание: ошибки подключения могут вызывать немедленные повторы, так как они не являются результатом регулирования количества запросов и, как ожидается, будут временными.

#### <a name="subheading15"></a>Ошибки без повторов

Клиентским библиотекам известно, какие ошибки предполагают повторный запрос, а какие нет. Тем не менее при написании своего собственного кода в отношении API-интерфейса REST для служб хранилища помните, что существуют такие ошибки, после которых запрос не следует повторять: например, ответ 400 (Неправильный запрос) указывает на то, что клиентское приложение направило запрос, который не может быть обработан из-за того, что он не был представлен в ожидаемой форме. Повторная отправка этого запроса каждый раз будет приводить к такому же ответу, поэтому в его повторной попытке нет смысла. При написании своего собственного кода в отношении API-интерфейса REST для служб хранилища помните о значениях кодов ошибок и выбирайте правильный способ повторного запроса (или его отсутствия).

#### Полезные ресурсы

Для получения дополнительной информации о кодах ошибок хранилища см. раздел [Коды ошибок и состояний][Коды ошибок и состояний] на веб-сайте Microsoft Azure.

## BLOB-объекты

В дополнение к проверенным практическим подходам, ранее описанным в разделе [Все службы][Все службы], следующие проверенные подходы применяются специально для службы BLOB-объектов.

### Целевые показатели масштабируемости, характерные для BLOB-объекта

#### <a name="subheading16"></a>Пропускная способность и операции с BLOB-объектом

Данные одного BLOB-объекта можно считывать или записывать с максимальной скоростью до 60 МБ/с (это примерно 480 Мбит/с, что превышает возможности большинства клиентских сетей, в том числе физической сетевой карты на клиентском устройстве). Кроме того, один BLOB-объект поддерживает до 500 запросов в секунду. При наличии нескольких клиентов, которым необходимо выполнить чтение одного BLOB-объекта, и высокой вероятности превысить эти ограничения следует рассмотреть возможность использования сети CDN для распределения BLOB-объекта.

Для получения дополнительной информации о целевой пропускной способности для BLOB-объекта см. раздел [Целевые показатели по масштабируемости и производительности хранилища Azure][странице целевых показателей масштабируемости] в MSDN.

### Копирование и перемещение BLOB-объектов

#### <a name="subheading17"></a>Копирование BLOB-объекта

В API-интерфейсе REST для служб хранилища версии 2012-02-12 представлена полезная возможность копирования BLOB-объектов между учетными записями: клиентское приложение может отдать команду службе хранилища скопировать BLOB-объект из другого источника (возможно, в другой учетной записи хранения), а затем предоставить службе возможность выполнить асинхронное копирование. Это может значительно снизить пропускную способность, необходимую приложению при миграции данных из других учетных записей хранения, потому что при этом не нужно загружать и отправлять данные.

Однако существует один важный момент: при копировании между учетными записями хранения отсутствует гарантия по сроку завершения процесса копирования. Если приложение должно быстро и под контролем завершить копирование BLOB-объекта, лучшим вариантом для этого может быть его копирование путем загрузки BLOB-объекта на виртуальную машину с последующей его отправкой в место назначения. Для обеспечения полной предсказуемости в этой ситуации убедитесь в том, что копирование выполнено с помощью виртуальной машины, работающей в том же регионе Azure. В противном случае условия работы сети могут (и, вероятно, будут) влиять на скорость копирования. Кроме того, можно следить за ходом асинхронного копирования программным способом.

Обратите внимание на то, что копирование внутри одной учетной записи хранения, как правило, выполняется быстро.

Для получения дополнительной информации см. раздел [Копирование BLOB-объекта в MSDN][Копирование BLOB-объекта в MSDN].

#### <a name="subheading18"></a>Использование программы AzCopy

Команда хранилища Azure выпустила программу для операций с командной строкой "AzCopy", которая предназначена помочь с одновременной передачей большого количества BLOB-объектов между учетными записями хранения. Этот инструмент оптимизирован специально для такого случая и может достигать высоких скоростей передачи данных. Его использование рекомендуется для случаев массовой отправки, загрузки и копирования данных. Узнать больше об этом инструменте и загрузить его можно [здесь][здесь].

#### <a name="subheading19"></a>Служба импорта и экспорта Azure

Для очень больших объемов данных (более 1 ТБ) хранилище Azure предлагает службу импорта и экспорта, которая позволяет размещать или загружать данные хранилищ BLOB-объектов путем доставки жестких дисков. Можно поместить свои данные на жесткий диск и отправить его в корпорацию Microsoft для размещения в сети или отправить пустой жесткий диск в корпорацию Microsoft для загрузки данных из сети. Подробнее об этом можно прочитать[здесь][2]. Это может быть гораздо более эффективным, чем отправка или загрузка такого объема данных по сети.

### <a name="subheading20"></a>Использование метаданных

Служба BLOB-объектов поддерживает запросы HEAD, которые могут включать метаданные о BLOB-объекте. Например, если приложению необходимы EXIF-данные из фотографии, оно может получить фотографию и извлечь их из нее. Для сохранения пропускной способности и повышения производительности приложение может сохранить EXIF-данные в метаданных BLOB-объекта при загрузке фотографии приложением: можно получить EXIF-данные, находящиеся в метаданных, используя только HEAD-запрос, тем самым экономя значительную пропускную способность и время обработки, необходимые для извлечения EXIF-данных каждый раз при чтении BLOB-объекта. Это было бы полезным в ситуациях, когда необходимы только метаданные, а не полное содержимое BLOB-объекта. Обратите внимание, в BLOB-объекте могут храниться только 8 КБ метаданных (служба не будет принимать запрос на хранение большего, чем этот, объема данных), поэтому если данные превышают этот размер, использование такого подхода становится невозможным.

Пример того, как получить метаданные BLOB-объекта с помощью .NET, см. в разделе [Задание и получение свойств и метаданных][Задание и получение свойств и метаданных] в MSDN.

### Быстрая отправка

Чтобы быстро отправить BLOB-объекты, необходимо ответить на первый вопрос: вы отправляете один BLOB-объект или много? Чтобы правильно выбрать метод работы, используйте сведения из приведенного ниже руководства.

#### <a name="subheading21"></a>Быстрая отправка одного большого BLOB-объекта

Чтобы быстро отправить один большой BLOB-объект, клиентское приложение должно отправить его блоки или страницы параллельно (помня о целевых показателях масштабируемости для отдельных BLOB-объектов и учетной записи хранения в целом). Обратите внимание на то, что этой способностью обладают клиентские библиотеки хранилища RTM, официально предоставляемые корпорацией Microsoft (.NET, Java). Для установки уровня параллелизма для каждой библиотеки используйте указанный ниже объект или свойство:

-   .NET: Установите ParallelOperationThreadCount в объекте BlobRequestOptions, который будет использоваться.
-   Java/Android: Используйте функцию BlobRequestOptions.setConcurrentRequestCount()
-   Node.js: Используйте parallelOperationThreadCount в параметрах запроса или в службе BLOB-объекта.
-   C++: Используйте метод blob\_request\_options::set\_parallelism\_factor.

#### <a name="subheading22"></a>Быстрая отправка множества BLOB-объектов

Чтобы быстро отправить множество BLOB-объектов, отправьте их параллельно. Это быстрее по времени, чем отправка отдельных BLOB-объектов с параллельной отправкой блоков, потому что в данном случае отправка распределяется по нескольким разделам службы хранилища. Один BLOB-объект поддерживает пропускную способность не более 60 МБ/с (около 480 Мбит/с). На момент написания данной статьи учетная запись GRS поддерживает скорость до 20 Гбит/с на входе, которая гораздо больше пропускной способности, поддерживаемой отдельным BLOB-объектом. [AzCopy][Используете ли вы AzCopy для массового копирования BLOB-объектов?] выполняет параллельную отправку по умолчанию, как и рекомендуется для данного случая.

### <a name="subheading23"></a>Выбор правильного типа BLOB-объекта

Хранилище Azure поддерживает два типа BLOB-объектов: *страничные* BLOB-объекты и *блочные* BLOB-объекты. В данном случае использования выбор типа BLOB-объекта будет влиять на производительность и масштабируемость решения. Блочные BLOB-объекты подходят тогда, когда необходимо эффективно отправить большие объемы данных: например, клиентскому приложению может понадобиться отправить в хранилище BLOB-объекта фотографии или видео. Страничные BLOB-объекты подходят в том случае, если в данных необходимо выполнять случайные операции записи: например, виртуальные жесткие диски Azure хранятся в виде страничных BLOB-объектов.

Для получения дополнительной информации см. раздел [Что такое блочные и страничные BLOB-объекты][Что такое блочные и страничные BLOB-объекты] в MSDN.

## Таблицы

В дополнение к проверенным практическим подходам, ранее описанным в разделе [Все службы][Все службы], следующие проверенные подходы применяются специально для службы таблиц.

### <a name="subheading24"></a>Целевые показатели масштабируемости, характерные для таблицы

В дополнение к ограничениям пропускной способности всей учетной записи хранения таблицы имеют следующее ограничение масштабируемости. Обратите внимание: система будет распределять нагрузку по мере увеличения трафика, но если трафик имеет внезапные вспышки, вы будете не в состоянии получить немедленно весь объем пропускной способности. Если метод работает скачками, следует ожидать применения технологии регулировки запросов и (или) тайм-ауты во время скачков по мере того, как служба хранилища автоматически распределяет нагрузку по таблице. Медленное повышение, как правило, дает лучшие результаты, поскольку предоставляет системное время для распределения нагрузки.

#### Сущностей в секунду (учетная запись)

Ограничение масштабируемости для доступа к таблицам составляет до 20 000 сущностей (каждая по 1 КВ) в секунду для одной учетной записи. Обычно каждая сущность, которая вставляется, обновляется, удаляется или сканируется, идет в счет этой цели. Так, пакетная вставка, которая содержит 100 сущностей, будет считаться за 100 сущностей. Запрос, который сканирует 1000 сущностей и возвращает 5 из них, будет считаться за 1000 сущностей.

#### Сущностей в секунду (раздел)

В одном разделе целевой показатель масштабируемости для доступа к таблицам составляет 2 000 сущностей (каждая по 1 КБ) в секунду. Тут используется тот же принцип подсчета, что и описанный в предыдущем разделе.

### Конфигурация

В данном разделе перечислены несколько параметров быстрой конфигурации, которые можно использовать для значительного увеличения производительности в службе таблиц:

#### <a name="subheading25"></a>Использование JSON

Начиная со службы хранилища версии 2013-08-15, для передачи данных таблицы служба таблиц вместо формата AtomPub на базе XML поддерживает формат JSON. Это может уменьшить размеры полезной нагрузки не меньше, чем на 75 %, и может значительно увеличить производительность приложения.

Для получения дополнительной информации см. публикацию [Таблицы Windows Azure. Знакомство с JSON][Таблицы Windows Azure. Знакомство с JSON] и [Формат полезной нагрузки для операций службы таблиц][Формат полезной нагрузки для операций службы таблиц] в MSDN.

#### <a name="subheading26"></a>Отключение алгоритма Nagle

Алгоритм Nagle широко применяется во всех TCP/IP-сетях в качестве средства повышения производительности сети. Тем не менее он не является оптимальным во всех случаях (включая высокоинтерактивные среды). В хранилище Azure алгоритм Nagle оказывает негативное влияние на производительность запросов к таблице и службам очереди, и при возможности его следует отключать.

Для получения дополнительной информации см. публикацию в нашем блоге [Алгоритм Nagle не подходит для небольших запросов][Алгоритм Nagle не подходит для небольших запросов], в которой объясняется, почему алгоритм Nagle плохо взаимодействует с запросами к таблице и очереди и как его отключить в клиентском приложении.

### Схема

То, каким образом вы представляете и запрашиваете данные, является одним из основных факторов, влияющих на производительность службы таблиц. Поскольку приложения отличаются друг от друга, в данном разделе излагаются некоторые общие проверенные подходы, которые относятся к:

-   конструктору таблиц;
-   эффективным запросам;
-   эффективным обновлениям данных.

#### <a name="subheading27"></a>Таблицы и разделы

Таблицы разделены на разделы. Каждая сущность, хранящаяся в разделе, совместно использует один ключ раздела и имеет уникальный ключ строки для своей идентификации внутри этого раздела. Разделы предоставляют преимущества, но также вводят ограничения по масштабируемости.

-   Преимущества: можно обновить сущности в одном разделе с помощью одной атомарной, пакетной транзакции, которая содержит до 100 отдельных операций хранения (ограничение на общий размер 4 МБ). Предполагая некоторое количество сущностей, которые будут получены, также можно более эффективно запросить данные, хранящиеся внутри одного раздела, чем данные, охватывающие несколько разделов (в то время как чтение по дальнейшим рекомендациям необходимо проводить по запрашиваемым табличным данным).
-   Ограничение масштабируемости Доступ к сущностям, хранящимся в одном разделе, не может быть выполнен с распределением нагрузки, потому что разделы поддерживают атомарные пакетные транзакции. По этой причине целевой показатель масштабируемости для отдельного раздела таблицы ниже, чем для службы таблиц в целом.

Учитывая эти характеристики таблиц и разделов, следует принять следующие принципы проектирования:

-   Данные, которые клиентское приложение часто обновляет или запрашивает в одном логическом блоке работы, должны быть расположены в одном разделе. Эта необходимость может возникнуть потому, что приложение создает сводку записей, или потому, что вы хотите воспользоваться атомарной пакетной операцией. Кроме того, данные, находящиеся в одном разделе, могут быть с большим успехом запрошены в одном обращении, чем данные, которые находятся в разных разделах.
-   Данные, которые клиентское приложение не вставляет, не обновляет и не запрашивает в одном логическом блоке работы (одном запросе или пакетном обновлении), должны быть расположены в отдельных разделах. Важно отметить, что ограничения на количество ключей раздела в одной таблице не существует, так что наличие миллионов ключей раздела не является проблемой и не влияет на производительность. Например, если приложение является популярным веб-сайтом с механизмом входа пользователя в систему, в качестве ключа раздела может хорошо подойти идентификатор пользователя.

#### Горячие разделы

Горячий раздел — это раздел, который получает несоразмерный процент трафика на одну учетную запись и не может распределять нагрузку между разделами, так как является единственным разделом. Обычно горячие разделы создаются одним из двух способов:

##### <a name="subheading28"></a>Инкрементируемые и декрементируемые шаблоны

"Инкрементируемый" шаблон — это шаблон, в котором весь (или почти весь) трафик для данного ключа раздела увеличивается и уменьшается в зависимости от текущего времени. Примером может служить ситуация, при которой приложение использует текущую дату в качестве ключа раздела для данных журнала. Это приводит к тому, что все вставки попадают в самый последний раздел таблицы, и система не может распределять нагрузку, потому что все записи попадают в конец таблицы. Если объем трафика в этом разделе превышает целевой показатель масштабируемости на уровне раздела, это приведет к включению механизма регулировки количества запросов. Обеспечение отправки трафика к нескольким разделам — более удачный вариант, чем включение механизма распределения нагрузки при запросах по всей таблице.

##### <a name="subheading29"></a>Данные с интенсивным трафиком

Если схема создания разделов приводит к созданию одного раздела, в котором имеются только данные, которые используются значительно чаще, чем данные в других разделах, по мере достижения этим разделом целевого показателя масштабируемости для одного раздела можно также обнаружить, что включен механизм регулировки количества запросов. Лучше всего сделать так, чтобы в схеме разделов не было отдельных разделов, приближающихся к целевым показателям масштабируемости.

#### Выполнение запроса

В этом разделе описываются проверенные подходы, касающиеся выполнения запросов службы таблицы.

##### <a name="subheading30"></a>Область запроса

Существует несколько способов для определения диапазона сущностей для запросов. Ниже обсуждается использование каждого из них.

В целом, старайтесь избегать сканирования (запросы, превышающие одну сущность), но если это необходимо, попытайтесь организовать данные таким образом, чтобы сканирование извлекало необходимые данные без сканирования или возвращения значительного количества ненужных сущностей.

###### Точечные запросы

Точечный запрос извлекает ровно одну сущность. Он делает это, указав как ключ раздела, так и ключ строки сущности. Эти запросы являются очень эффективными, и их следует использовать везде, где это возможно.

###### Запросы разделов

Запрос раздела — это запрос, который извлекает набор данных, совместно использующих общий ключ раздела. Как правило, в запросе указывается диапазон значений ключа строки или — в дополнение к ключу раздела — диапазон значений для свойства некоторой сущности. Они менее эффективны, чем точечные запросы, и их следует использовать с осторожностью.

###### Табличные запросы

Табличный запрос — это запрос, который извлекает набор сущностей, не использующих совместно общий ключ раздела. Эти запросы не являются эффективными, и, если это возможно, следует избегать их использования.

##### <a name="subheading31"></a>Плотность запроса

Еще одним важным фактором в эффективности запроса является соотношение между количеством возвращенных сущностей и количеством сканированных сущностей, использованных при поиске возвращаемого набора. Если приложение выполняет табличный запрос с фильтром для значения свойства, которое соответствует только 1 % совместно используемых данных, запрос будет сканировать по 100 сущностей для каждой одной сущности, которую он возвращает. Все рассмотренные ранее целевые показатели масштабируемости таблицы относятся к количеству сканированных сущностей, а не к количеству возвращенных сущностей: низкая плотность запроса может легко привести службу таблиц к регулированию количества запросов приложения, потому что для извлечения искомой сущности она должно сканировать слишком много других сущностей. Для получения дополнительной информации о том, как этого избежать, см. представленный ниже раздел [Денормализация][Вы денормализовали свои данные таким образом, чтобы избежать неэффективных или множественных запросов чтения при попытке получения данных?].

##### Ограничение объема возвращаемых данных

###### <a name="subheading32"></a>Фильтрация

Если известно, что запрос вернет ненужные в клиентском приложении сущности, рассмотрите вопрос об использовании фильтра, позволяющего уменьшить размер возвращаемого набора. Несмотря на то, что не возвращаемые клиенту сущности учитываются в подсчете ограничений масштабируемости, производительность приложения увеличится из-за снижения полезной нагрузки на сеть и сокращения количества сущностей, которые должно обрабатывать клиентское приложение. См. выше примечание к разделу [Плотность запроса][Ваши запросы обычно только сканируют и возвращают строки, которые будет использовать приложение?]. Однако целевые показатели масштабируемости относятся к количеству сканированных сущностей, поэтому выполнение запроса, фильтрующего множество сущностей, может привести к запуску механизма регулирования количества запросов даже в том случае, если возвращается небольшое число сущностей.

###### <a name="subheading33"></a>Проекция

Если клиентскому приложению необходим лишь ограниченный набор свойств из сущностей таблицы, для ограничения размера возвращаемого набора данных можно использовать проекцию. Как и в случае с фильтрацией, это помогает снизить нагрузку на сеть и обработку запросов клиента.

##### <a name="subheading34"></a>Денормализация

В отличие от работы с реляционными базами данных, проверенные подходы для осуществления эффективного запроса данных таблицы ведут к денормализации данных. То есть дублирование одних данных в нескольких сущностях (для поиска данных можно использовать по одной сущности для каждого ключа) с целью минимизации количества сущностей, которые должен сканировать запрос для поиска необходимых клиенту данных, вместо того чтобы сканировать большое количество сущностей для поиска данных, необходимых приложению. Например, на веб-сайте электронной коммерции может понадобиться найти заказ как по идентификатору клиента (найти заказы данного клиента), так и по дате (найти заказы на определенную дату). В табличном хранилище лучше всего хранить сущность (или ссылку на нее) в двух видах: один с именем таблицы, ключом раздела и ключом строки для облегчения поиска по идентификатору клиента, один для облегчения его поиска по дате.

#### Вставить, обновить, удалить

В этом разделе описываются проверенные методики для изменения сущностей, хранящихся в службе таблиц.

##### <a name="subheading35"></a>Пакетная обработка

Пакетные транзакции в хранилище Azure называются транзакциями группы сущностей (Entity Group Transactions, ETG). Все операции, выполняющиеся в ETG, должны производиться в одном разделе и в одной таблице. Там, где это возможно, для выполнения пакетных команд вставки, обновления и удаления используйте транзакции группы сущностей. Это сокращает количество циклов обработки между клиентским приложением и сервером, снижает количество подсчитываемых транзакций (при подсчете транзакция группы сущностей считается одной транзакцией и может содержать до 100 операций хранения) и позволяет выполнять атомарные обновления (в транзакции группы сущностей операции завершаются или все успешно, или все с ошибкой). Среды с большими задержками, такие как мобильные устройства, в результате использования транзакций групп сущностей получают большие преимущества.

##### <a name="subheading36"></a>Операция Upsert

Используйте табличные операции **Upsert** как можно чаще. Существует два типа операций **Upsert**, оба из них могут быть более эффективными, чем обычные операции **Insert** и **Update**:

-   **InsertOrMerge**: Используйте эту команду тогда, когда необходимо отправить подмножество свойств сущности, но нет уверенности в наличии сущности. Если сущность существует, она вызывает обновление свойств, включенных в операцию **Upsert**, и оставляет все имеющиеся свойства нетронутыми, если же сущность не существует, вставляется новая сущность. Это похоже на использование проекции в запросе, в котором нужно отправить только изменяющиеся свойства.
-   **InsertOrReplace**: Используйте эту команду тогда, когда необходимо отправить совершенно новую сущность, но вы не уверены в ее существовании. Команду следует использовать только тогда, когда известно, что недавно отправленная сущность является абсолютно правильной, потому что она полностью заменяет старую сущность. Например, необходимо обновить сущность, в которой хранится текущее местоположение пользователя, независимо от того, сохраняло ли ранее приложение данные о местоположении пользователя. В данном случае создается сущность с новым местоположением пользователя, а потребность в какой-либо информации из любой предыдущей сущности отсутствует.

##### <a name="subheading37"></a>Хранение ряда данных в одной сущности

Иногда приложение хранит ряд данных, которые часто бывают необходимыми для их единовременного получения: например, приложение может отслеживать загрузку ЦП в течение долгого времени для того, чтобы построить волнообразный график из данных за последние 24 часа. Один подход заключается в том, чтобы для каждого часа иметь одну табличную сущность, при этом каждая сущность представляет определенный час и хранит значение загрузки ЦП для этого часа. Для построения этих данных приложению необходимо извлечь сущности, в которых хранятся данные за последние 24 часа.

Кроме того, приложение может хранить данные о загрузке ЦП для каждого часа в виде отдельного свойства одной сущности: для ежечасного обновления приложение может использовать один вызов **InsertOrMerge Upsert**, чтобы обновить значение за последний час. Для построения этих данных приложению необходимо получить только одну сущность, а не 24, выполняя при этом очень эффективный запрос (см. представленное выше обсуждение в разделе [Область запроса][Вы спроектировали свою схему таким образом, чтобы в большинстве случаев использовать точечные запросы, а табличные запросы использовать редко?]).

##### <a name="subheading38"></a>Хранение структурированных данных в BLOB-объектах

Иногда кажется, что структурированные данные должны попадать в таблицы, но диапазоны сущностей всегда извлекаются вместе и могут быть вставлены пакетным образом. Хорошим примером такой ситуации является файл журнала. В этом случае несколько минут из журнала можно укомплектовать в пакет, затем произвести их вставку и потом, с тем же успехом, извлекать несколько минут журнала за раз. В этом случае с точки зрения производительности вместо таблиц лучше использовать BLOB-объекты, так как при этом можно значительно уменьшить количество записываемых или возвращаемых объектов, а также, как правило, количество необходимых для выполнения запросов.

## Очереди

### <a name="subheading39&quot;"></a>Ограничение масштабируемости

Одна очередь может обрабатывать около 2000 сообщений (размером 1 КБ каждое) в секунду (здесь каждая операция AddMessage, GetMessage и DeleteMessage считается сообщением). Если для вашего приложения этого недостаточно, следует распределить сообщения по нескольким очередям.

Текущие целевые значения масштабируемости см. на странице [Целевые значения масштабируемости и производительности службы хранилища Azure][странице целевых показателей масштабируемости] на веб-сайте MSDN.

### <a name="subheading40&quot;"></a>Отключение алгоритма Nagle

См. раздел по конфигурации таблицы, в котором обсуждается алгоритм Nagle. Алгоритм Nagle, как правило, плохо влияет на производительность запросов в очереди, поэтому его следует отключать.

### <a name="subheading41&quot;"></a>Размер сообщения

Производительность и масштабируемость очередей уменьшается по мере увеличения размера сообщения. В сообщении следует размещать только те сведения, которые необходимы получателю.

### <a name="subheading42&quot;"></a>Пакетное извлечение

В одной операции из очереди можно извлечь до 32 сообщений. Это может уменьшить количество циклов обработки клиентского приложения, что особенно полезно в таких средах с большой задержкой, как мобильные устройства.

### <a name="subheading43&quot;"></a>Интервал опроса очередей

Большинство приложений опрашивают сообщения из такой очереди, которая может быть одним из самых крупных источников транзакций для этих приложений. Выбирайте интервал опроса тщательно: слишком высокая частота опросов может привести к тому, что будет достигнуто целевое значений масштабируемости очереди. Но при тарифе 0,01 долл. США за 200 000 транзакций (во время записи) опрос одного процессора с интервалом один раз в секунду будет стоить меньше 15 центов в месяц, поэтому стоимость обычно не влияет на выбор интервала опроса.

Актуальную информацию см. в разделе [Сведения о ценах на хранилище][Storage Pricing Details].

### <a name="subheading44&quot;"></a>UpdateMessage

Для увеличения невидимого времени ожидания или для обновления информации о состоянии сообщения можно использовать операцию **UpdateMessage**. Несмотря на ее эффективность, помните, что каждая операция **UpdateMessage** учитывается при подсчете целевого показателя масштабируемости. Тем не менее ее использование может быть гораздо более эффективным, чем наличие рабочего процесса, который передает работу из одной очереди в другую по мере завершения каждого этапа работы. Использование операции **UpdateMessage** позволяет приложению сохранить состояние работы в сообщении, а затем продолжить работу, вместо того чтобы повторно запрашивать сообщение для выполнения следующего этапа работы по мере завершения каждого предыдущего.

Для получения дополнительной информации см. статью [Что нужно сделать, чтобы изменить содержимое сообщения из очереди][Что нужно сделать, чтобы изменить содержимое сообщения из очереди].

### <a name=subheading45"></a>Архитектура приложения</h3> <p>Чтобы сделать архитектуру приложения масштабируемой, следует использовать очереди. Ниже перечислены некоторые способы использования очередей для того, чтобы сделать приложение более масштабируемым:</p> <ul> <li>Очереди можно использовать для создания отставания от работы, необходимого для обработки и сглаживания рабочих нагрузок в приложении. Например, запросы от пользователей можно поместить в очередь, чтобы позволить процессору выполнить трудоемкую работу, такую как изменение размера загружаемых изображений.</li> <li>Очереди можно использовать для отделения частей приложения, чтобы иметь возможность их независимого масштабирования. Например, клиент веб-интерфейса может разместить результаты опроса пользователей в очередь для последующего анализа и хранения. По мере необходимости для обработки данных очереди можно добавлять экземпляры роли worker.</li> </ul> <h2 id="conclusion">Заключение</h2> <p>В этой статье обсуждаются некоторые из наиболее распространенных, проверенных подходов для оптимизации производительности при использовании хранилища Azure. Мы призываем разработчиков оценить применимость описанных выше методик к их приложениям и рассмотреть, исходя из рекомендаций, возможность повышения производительности подобных приложений, использующих хранилище Azure.</p>

  [Вы используете политику повтора экспоненциального откладывания для регулирования ошибок и времени ожидания?]: #subheading14
  [Ваше приложение придерживается уровня пропускной способности или рабочего целевого показателя масштабируемости для одинарного BLOB-объекта?]: #subheading16
  [Используете ли вы AzCopy для массового копирования BLOB-объектов?]: #subheading18
  [Вы приближаетесь к целевым показателям масштабируемости для сущностей в секунду?]: #subheading24
  [Вы спроектировали свою схему таким образом, чтобы в большинстве случаев использовать точечные запросы, а табличные запросы использовать редко?]: #subheading30
  [Ваши запросы обычно только сканируют и возвращают строки, которые будет использовать приложение?]: #subheading31
  [Вы денормализовали свои данные таким образом, чтобы избежать неэффективных или множественных запросов чтения при попытке получения данных?]: #subheading34
  [Вы достигаете целевых показателей масштабируемости для сообщений в секунду?]: #subheading39
  [странице целевых показателей масштабируемости]: http://msdn.microsoft.com/ru-ru/library/azure/dn249410.aspx
  [Полезные ресурсы]: #sub1useful
  [Параметры избыточности в службе хранилища Microsoft Azure и геоизбыточное хранилище с доступом на чтение]: http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx
  [Краткий обзор цен Azure]: http://azure.microsoft.com/ru-ru/pricing/overview/
  [целевые показатели масштабируемости пропускной способности]: #sub1bandwidth
  [Рекомендации по проектированию крупномасштабных служб на основе облачных служб Azure]: http://msdn.microsoft.com/ru-ru/library/dn197896.aspx
  [Сеть Azure CDN]: http://azure.microsoft.com/ru-ru/services/cdn/
  [Подписи совместного доступа. Часть 1. Основные сведения о модели SAS]: http://azure.microsoft.com/ru-ru/documentation/articles/storage-dotnet-shared-access-signature-part-1/
  [Поддержка общего доступа к ресурсам независимо от источника (CORS) для службы хранилища Azure в сети MSDN]: http://msdn.microsoft.com/library/azure/dn535601.aspx
  [Задание и получение свойств и метаданных]: http://msdn.microsoft.com/ru-ru/library/hh225342.aspx
  [Условное обновление локальной копии BLOB-объекта]: http://msdn.microsoft.com/ru-ru/library/azure/dd179371.aspx
  [Веб-службы. Одновременные подключения]: http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx
  [Метод ThreadPool.SetMinThreads]: http://msdn.microsoft.com/ru-ru/library/system.threading.threadpool.setminthreads(v=vs.110).aspx
  [Обзор новых способов повышения производительности в .NET 4.5]: http://msdn.microsoft.com/ru-ru/magazine/hh882452.aspx
  [Коды ошибок и состояний]: http://msdn.microsoft.com/ru-ru/library/azure/dd179382.aspx
  [Все службы]: #allservices
  [Копирование BLOB-объекта в MSDN]: http://msdn.microsoft.com/ru-ru/library/dd894037.aspx
  [здесь]: http://azure.microsoft.com/ru-ru/documentation/articles/storage-use-azcopy/
  [2]: http://azure.microsoft.com/ru-ru/documentation/articles/storage-import-export-service/
  [Что такое блочные и страничные BLOB-объекты]: http://msdn.microsoft.com/ru-ru/library/azure/ee691964.aspx
  [Таблицы Windows Azure. Знакомство с JSON]: http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx
  [Формат полезной нагрузки для операций службы таблиц]: http://msdn.microsoft.com/ru-ru/library/azure/dn535600.aspx
  [Алгоритм Nagle не подходит для небольших запросов]: http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx
  [Storage Pricing Details]: http://azure.microsoft.com/ru-ru/pricing/details/storage/
  [Что нужно сделать, чтобы изменить содержимое сообщения из очереди]: http://azure.microsoft.com/ru-ru/documentation/articles/storage-dotnet-how-to-use-queues/#change-contents
