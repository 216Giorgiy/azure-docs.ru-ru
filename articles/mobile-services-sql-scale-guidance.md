<properties urlDisplayName="Scale mobile services backed by Azure SQL Database" pageTitle="Масштабирование мобильных служб, поддерживаемых базой данных SQL Azure - мобильные службы Azure" metaKeywords="" description="Узнайте, как определить и устранить проблемы масштабируемости в мобильных службах на основе Базы данных SQL" metaCanonical="" services="" documentationCenter="Mobile" title="Scale mobile services backed by Azure SQL Database" authors="donnam" solutions="" manager="dwrede" editor="mollybos" />

<tags ms.service="mobile-services" ms.workload="mobile" ms.tgt_pltfrm="mobile-multiple" ms.devlang="multiple" ms.topic="article" ms.date="11/11/2014" ms.author="donnam" />
# Масштабирование мобильных служб, поддерживаемых базой данных Azure SQL

Мобильные службы Azure обеспечивают очень простое начало работы и позволяют создавать приложения, которые подключаются к размещенному в облаке серверу базы данных, хранящему данные в базе данных SQL. По мере роста вашего приложения процедура масштабирования ваших экземпляров службы является такой же простой, как и настройка параметров масштабирования на портале для добавления дополнительных вычислительных и сетевых ресурсов. Однако для масштабирования базы данных SQL, поддерживающей вашу службу, требуется выполнить определенное предварительное планирование и мониторинг, так как нагрузка на службу возрастает. В этом документе представлен ряд рекомендаций по обеспечению высокой производительности мобильных служб, поддерживаемых базой данных SQL.

В этом разделе рассматриваются следующие основные разделы:

1. [Диагностирование проблем](#Diagnosing)
2. [Индексация](#Indexing)
3. [Структура схемы](#Schema)
4. [Структура запросов](#Query)
5. [Архитектура службы](#Architecture)
6. [Расширенный поиск проблем](#Advanced)

<a name="Diagnosing"></a>
## Диагностирование проблем

Если возникло подозрение, что мобильная служба испытывает проблемы под нагрузкой, то прежде всего следует открыть вкладку **Панель мониторинга** для этой службы на [портале управления Azure][]. Здесь необходимо проверить следующее:

- Показатели использования, включая **Вызовы API** и **Активные элементы**, на предмет превышения квоты
Состояние - **Мониторинг конечных точек** указывает на то, что служба находится в рабочем состоянии (доступно, только если служба использует стандартный уровень и мониторинг конечных точек включен) 

Если любое из вышеуказанных условий не соответствует действительности, рассмотрите возможность изменения настроек масштабирования на вкладке *Масштаб*. Если это не устраняет проблему, проанализируйте, может ли база данных Azure SQL быть источником данной проблемы. В следующих нескольких разделах рассматриваются несколько разных подходов к диагностированию возможных нарушений.

### Выбор правильного уровня базы данных SQL 

Важно понять, что в вашем распоряжении есть несколько уровней базы данных, из которых следует выбрать уровень, соответствующий потребностям приложения. В базе данных SQL Azure предлагаются два различных выпуска базы данных с различными уровнями:

- Выпуски Web и Business (подлежат замене)
- Выпуски Basic, Standard и Premium 

Безусловно, выпуски Web и Business полностью поддерживаются, но подлежат замене с 24 апреля 2015 г., как описано в разделе [Вопросы и ответы о замене выпусков Web и Business](http://msdn.microsoft.com/en-US/library/azure/dn741330.aspx). Рекомендуем новым заказчикам при подготовке к этому изменению начинать использование выпусков Basic, Standard и Premium. Этот новый выпуск содержит несколько новых уровней и имеет новые возможности мониторинга, которые еще более упрощают процесс понимания и обеспечения уровня производительности базы данных. Все новые мобильные службы создаются с использованием нового выпуска.

Чтобы преобразовать мобильную службу, использующую выпуск Web или Business, в службу на основе выпуска Basic, Standard или Premium, выполните следующие шаги.

1. Запустите [Портал управления Azure][].
2. Выберите **+НОВЫЙ** на панели инструментов, затем выберите **Службы данных**, **База данных SQL**, **Быстрое создание**.
3. Введите имя базы данных, затем выберите **Новый сервер базы данных SQL** в поле **Сервер**. Будет создан сервер, который использует новый выпуск Basic, Standard и Premium. 
4. Заполните остальные поля и выберите **Создать базу данных SQL**. В результате будет создана база данных на 100 Мбайт с использованием уровня Basic.
5. Настройте свою мобильную службу на использование только что созданной базы данных. Откройте вкладку **Настройка** для этой службы и выберите **Изменить базу данных** на панели инструментов. На следующем экране выберите **Использовать существующую базу данных SQL** в поле **База данных SQL**, и затем нажмите **Далее**. На следующем экране обязательно выберите базу данных, созданную в шаге 5, затем нажмите **ОК**.

Ниже приведены несколько рекомендаций по выбору правильного уровня для вашей базы данных:

- **Basic** - используется во время разработки или при создании небольших производственных служб, где предполагается выполнение только одного запроса к базе данных одновременно
- **Standard** - используется для производственных служб, где предполагается выполнение нескольких параллельных запросов к базе данных
- **Premium** - используется для крупномасштабных производственных служб со множеством параллельных запросов, высокой пиковой нагрузкой и предполагаемой малой латентностью для каждого запроса.

Дополнительные сведения о том, как использовать каждый уровень, см. в разделе [Основания для использования новых уровней служб](http://msdn.microsoft.com/en-US/library/azure/dn369873.aspx#Reasons)

### Анализ метрик базы данных

После знакомства с уровнями базы данных можно рассмотреть метрики производительности базы данных, которые помогают выбрать варианты масштабировании в пределах отдельного уровня, а также между уровнями.

1. Запустите [портал управления Azure][].
2. На вкладке "Мобильные службы" выберите службу, с которой вы хотите работать.
3. Выберите вкладку **Настройка**.
4. Выберите имя **базы данных SQL** в разделе **Параметры базы данных**. В результате вы перейдете на вкладку "База данных Azure SQL" на портале.
5. Откройте вкладку **Монитор**
6. Проверьте, чтобы отображались соответствующие показатели при нажатии кнопки **Добавить показатель**. Включите следующее
    - *Процент загрузки ЦП* (доступно только на уровнях Basic/Standard/Premium)
    - *Процент загрузки для физических операций чтения данных* (доступно только на уровнях Basic/Standard/Premium)
    - *Процент загрузки для операций записи в журнал* (доступно только на уровнях Basic/Standard/Premium)
    - *Хранилище* 
7. Проверьте показатели по окну временных графиков, чтобы определить, когда в службе возникали проблемы. 

    ![Azure Management Portal - SQL Database Metrics][PortalSqlMetrics]

If any metric превышением 80%-го использования в течение продолжительного времени; это может указывать на проблему производительности. Дополнительные сведения о показателях использования базы данных см. в разделе [Основные сведения об использовании ресурсов](http://msdn.microsoft.com/en-US/library/azure/dn369873.aspx#Resource).

Если показатели свидетельствуют о том, что уровень использования базы данных высок, рассмотрите возможность **масштабирования базы данных с переходом на более высокий уровень службы** в качестве первого шага к устранению проблемы. Для немедленного устранения проблем перейдите на вкладку **Масштаб** для базы данных и масштабируйте вверх базу данных. При этом придется размер оплаты увеличится.
![Azure Management Portal - SQL Database Scale][PortalSqlScale]

Как можно скорее рассмотрите следующие дополнительные шаги по уменьшению уровня нагрузки:

- **Настройте свою базу данных.**
 Благодаря оптимизации базы данных, во многих случаях степень использования базы данных можно уменьшить и предотвратить необходимость масштабирования вверх до более высокого уровня. 
- **Проанализируйте архитектуру своей службы.**
   Часто ваша нагрузка на службу не распределяется равномерно в течение времени, но содержит "всплески" с большим числом запросов. Вместо масштабирования базы данных для преодоления пиковых нагрузок, в результате чего будут возникать периоды низкого спроса, часто существует возможность откорректировать архитектуру службы для предотвращения пиковых нагрузок или обработки их без увеличения количества обращений к базе данных.

В остальных разделах этого документа изложены рекомендации по реализации таких способов уменьшения уровня нагрузки.


### Настройка предупреждений

Часто в качестве профилактической меры оказывается целесообразным настроить предупреждения по основным показателям базы данных, чтобы иметь запас времени для реагирования в случае исчерпания ресурсов. 

1. Откройте вкладку **Мониторинг** для базы данных, в которой нужно настроить предупреждения
2. Убедитесь, что отображаются соответствующие метрики (см. предыдущий раздел)
3. Выберите показатель, для которого необходимо задать предупреждение, а затем выберите **Добавить правило**
    ![Azure Management Portal - SQL Alert][PortalSqlAddAlert]
4. Задайте для предупреждения имя и описание
    ![Azure Management Portal - SQL Alert Name and Description][PortalSqlAddAlert2]
5. Укажите значение, которое должно использоваться в качестве аварийного порогового значения. Выберите значение **80%**, чтобы предусмотреть некоторое время на реагирование. Кроме этого, обязательно укажите адрес электронной почты, который вы активно отслеживаете. 
    ![Azure Management Portal - SQL Alert Threshold and Email][PortalSqlAddAlert3]

Дополнительные сведения о диагностировании проблем базы данных SQL см. в разделе [Расширенная диагностика](#AdvancedDiagnosing)  в нижней части этого документа.

<a name="Indexing"></a>
## Индексация

Как только возникнут проблемы с производительностью запросов, прежде всего необходимо исследовать структуру индексов. Индексы важны, поскольку они непосредственно влияют на то, каким образом подсистема SQL выполняет запрос. 

Например, если возникает необходимость часто выполнять поиск элемента по определенному полю, то следует предусмотреть добавление индекса для соответствующего столбца. В противном случае подсистема SQL будет вынуждена выполнять просмотр таблицы и считывать каждую физическую запись (или по крайней мере столбец, рассматриваемый в запросе), а сами записи могут располагаться на диске со значительным разбросом.

Таким образом, если часто выполняется инструкции WHERE или JOIN по конкретным столбцам, то их следует обязательно индексировать. Дополнительную информацию см. в разделе [Создание индексов](#CreatingIndexes) .

Если индексы настолько удобны, а просмотры таблицы так мешают в работе, то не значит ли это, что следует проиндексировать каждый столбец в таблице исключительно ради безопасности?  Если ответить коротко, то "вероятно нет". Индексы занимают место и сами создают дополнительную нагрузку: при любой вставке данных в таблицу структуры индекса для каждого из индексированных столбцов необходимо обновлять. См. рекомендации по выбору индексов столбцов.

### Рекомендации по структуре индексов

Как указано выше, не всегда целесообразно добавлять большое количество индексов в таблицу, так как сами индексы могут оказаться дорогостоящим инструментом (как с точки зрения производительности, так и с точки зрения расходования памяти).

#### Рекомендации по запросам

- Добавляйте индексы в столбцы, которые часто используются в предикатах (например, предложения WHERE) и условиях объединения, а также учитывайте рекомендации по базе данных, изложенные ниже.
- Пишите запросы, которые вставляют или изменяют как можно больше строк в таблице в одной инструкции, вместо того чтобы выдавать нескольких запросов для обновления одних и тех же строк. Если имеется всего одна инструкция, то компонент Database Engine может оптимизировать ее обработку с помощью индексов.
	
#### Рекомендации по базе данных

Большое количество индексов в таблице влияет на производительность операторов INSERT, UPDATE, DELETE и MERGE, так как при изменении данных в таблице все индексы необходимо будет соответствующим образом настраивать.

- Что касается **интенсивно обновляемых** таблиц, избегайте их индексирования.
- Для таблиц, которые **редко обновляются**, но содержат большие объемы данных, используйте множество индексов. Это позволит повысить производительность запросов, которые не изменяют данные (например, инструкции SELECT), поскольку оптимизатор запросов будет иметь больше возможностей для выбора лучшего метода доступа.

Индексирование небольших таблиц может оказаться нежелательным, поскольку оптимизатору запросов потребуется больше времени для перебора индекса, чем для простого просмотра таблицы. Поэтому может оказаться, что индексы на небольших таблицах никогда не будут использоваться, но должны поддерживаться в связи с изменениями данных в таблице.


<a name="CreatingIndexes"></a>
### Создание индексов

#### Серверная служба JavaScript

Для настройки индекса для столбца на сервере JavaScript выполните следующую процедуру:

1. Откройте свою мобильную службу на [Портале управления Azure][].
2. Откройте вкладку **Данные**.
3. Выберите таблицу, которую нужно изменить.
4. Щелкните вкладку **Столбцы**.
5. Выберите столбец. На панели инструментов щелкните **Задать индекс**:

	![Mobile Services Portal - Set Index][SetIndexJavaScriptPortal]

В этом представлении также можно удалять индексы.

#### Серверная служба .NET

Чтобы задать индекс в Entity Framework, используйте атрибут `[Index]` для полей, которые необходимо индексировать. Например: 

    public class TodoItem : EntityData
    {
        public string Text { get; set; }

		[Index]
        public bool Complete { get; set; }
    }
		 
Дополнительные сведения об индексах см. в разделе [Аннотации индексов в Entity Framework][]. Дополнительные рекомендации по оптимизации индексов см. в разделе [Усовершенствованные средства индексирования](#AdvancedIndexing)  в нижней части этого документа.

<a name="Schema"></a>
## Структура схемы

Ниже описано несколько проблем, о которых следует знать при выборе типов данных для объектов, от чего, в свою очередь, зависит схема базы данных SQL. Настройка схемы часто приводит к значительному повышению производительности, поскольку в базе данных SQL предусмотрены собственные оптимизированные способы обработки индексов и хранения данных различных типов:

- **Используйте предоставленный столбец идентификаторов**. Каждая таблица мобильной службы поступает со столбцом идентификаторов по умолчанию, настроенным как первичный ключ, и имеет свой индекс. Создавать дополнительный столбец идентификатора нет необходимости.
- **Используйте корректные типы данных в своей модели.** Если вы знаете, что некоторое свойство вашей модели будет численным или логическим значением, используйте его именно в таком виде в своей модели, а не в виде строки. В сервере базы данных JavaScript используйте литералы, такие как `true` вместо `"true"` и `5` вместо `"5"`. В сервере базы данных .NET используйте типы `int` и `bool` при объявлении свойств модели. Это позволит базе данных SQL создать правильную схему для данных типов, что в результате повысит эффективность запросов.  

<a name="Query"></a>
## Структура запросов

Ниже приведены несколько рекомендаций, которые следует учитывать при запросе базы данных:

- **Всегда выполняйте операции объединения в базе данных.** Часто будет необходимо объединять записи из двух или более таблиц, когда объединяемые записи используют совместно общее поле (это также называется *объединением (join)*). Данная операция может оказаться неэффективной, если она выполняется неправильно, так как она может извлекать все объекты из обеих таблиц, а затем выполнять итерации со всеми такими объектами. Операции такого типа лучше всего оставить для выполнения в самой базе данных, но иногда можно легко допустить ошибку, выполняя их на клиенте или в коде мобильной службы.
    - Не выполняйте операции объединения в коде своего приложения
    - Не выполняйте соединения в коде мобильной службы. При использовании сервера JavaScript убедитесь, что [объект таблицы](http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554210.aspx) не обрабатывает операции объединения. Используйте непосредственно [объект mssql](http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554212.aspx), чтобы обеспечить выполнение операций объединения в базе данных. Дополнительные сведения см. в разделе [Объединение реляционных таблиц](http://azure.microsoft.com/ru-ru/documentation/articles/mobile-services-how-to-use-server-scripts/#joins). Если используется сервер базы данных .NET и запрос осуществляется через LINQ, соединения автоматически обрабатываются на уровне базы данных с помощью Entity Framework.
- **Реализуйте постраничный просмотр.** Запросы, отправляемые в базу данных, иногда могут приводить к тому, что клиенту будет возвращаться большое количество записей. Чтобы снизить объемы данных и латентность операций, рассмотрите возможность реализации постраничного просмотра.
    - По умолчанию мобильная служба ограничивает любые входящие запросы размером страницы, равным 50, но можно вручную запросить до 1000 записей. Дополнительные сведения см. в разделах "Возврат данных с разбивкой на страницы" для [Магазина Windows](http://azure.microsoft.com/ru-ru/documentation/articles/mobile-services-windows-dotnet-how-to-use-client-library/#paging), [iOS](http://azure.microsoft.com/ru-ru/documentation/articles/mobile-services-ios-how-to-use-client-library/#paging), [Android](http://azure.microsoft.com/ru-ru/documentation/articles/mobile-services-android-how-to-use-client-library/#paging), [HTML/JavaScript](http://azure.microsoft.com/ru-ru/documentation/articles/mobile-services-html-how-to-use-client-library/#paging) и [Xamarin](http://azure.microsoft.com/ru-ru/documentation/articles/partner-xamarin-mobile-services-how-to-use-client-library/#paging).
    - Размер страницы по умолчанию для запросов, выполняемых из кода мобильной службы, не установлен. Если ваше приложение не реализует постраничный просмотр, применяйте для своих запросов ограничения по умолчанию (это можно использовать и в качестве профилактической меры). На сервере JavaScript в [объекте запроса](http://msdn.microsoft.com/ru-ru/library/azure/jj613353.aspx) используйте оператор **take**. Если используется сервер базы данных .NET, рассмотрите возможность применения [метода Take](http://msdn.microsoft.com/ru-ru/library/vstudio/bb503062(v=vs.110).aspx)  в составе запроса LINQ.  

Дополнительные сведения об улучшении организации запросов, включая то, как анализировать планы запросов, см. в разделе [Усовершенствованное проектирование запросов](#AdvancedQuery)  в нижней части этого документа.

<a name="Architecture"></a>
## Архитектура службы

Допустим, что необходимо отправить push-уведомление всем клиентам, чтобы они ознакомились с новым содержимым в приложении. В случае, когда клиенты отвечают, используя ссылку в уведомлении, будет запускаться приложение. В этом случае может отправляться вызов в вашу мобильную службу и выполняться запрос в вашей базы данных SQL. Так как потенциально миллионы клиентов выполняют данное действие в течение всего нескольких минут, это будет формировать скачок нагрузки на SQL, уровень которой может быть на несколько порядков выше, чем допустимый уровень нагрузки для вашего приложения в устойчивом состоянии. Для устранения такой проблемы можно масштабировать ваше приложение вверх на более высокий уровень SQL во время всплеска, а затем вниз, однако такое решение требует ручного вмешательства и приводит к увеличению затрат. Во многих случаях незначительные тонкие настройки архитектуры вашей мобильной службы могут существенно выравнивать нагрузку, создаваемую клиентами на вашу базу данных SQL, и устранять нежелательные всплески из-за большого числа запросов. Такие изменения можно часто реализовать очень легко при минимальном воздействии на удобство работы ваших клиентов. Ниже приведены некоторые примеры:

- **Распределение нагрузки по времени.** Если вы контролируете временные параметры определенных событий (например, широковещательную передачу push-уведомлений), которые, предположительно будут создавать всплеск запросов, и временные параметры таких событий не являются критически важными, распределяйте их по времени. В примере выше пользователям вашего приложения, возможно, будет удобно получать уведомления о новом контенте приложения в виде пакетов в течение всего дня, а не практически одновременно. Объединяйте своих клиентов в группы - это позволит обеспечивать поочередную доставку пакетов. В случае использования концентраторов уведомлений можно применять дополнительный тег для отслеживания пакета, а затем отправлять push-уведомление на этот тег - это очень удобный и несложный способ реализации данной стратегии. Дополнительные сведения о тегах см. в разделе [Использование концентраторов уведомлений для передачи новостей](http://azure.microsoft.com/ru-ru/documentation/articles/notification-hubs-windows-store-dotnet-send-breaking-news/).
- **Если это возможно, широко используйте хранилище больших двоичных объектов и таблиц.** Во многих случаях контент, который клиенты будут просматривать во время всплеска, является фактически статическим и не подлежит хранению в базе данных SQL, так как маловероятно, что вам будет нужна возможность реляционного запроса данного контента. В таком случае контент рекомендуется хранить в хранилище больших двоичных объектов или таблиц. Доступ к общедоступным большим двоичным объектам в хранилище больших двоичных объектов можно получать непосредственно из устройства. Чтобы получать безопасный доступ к большим двоичным объектам или использовать хранилище таблиц, для защиты своего ключа доступа к хранилищу вам будет нужно проходить через пользовательский интерфейс API мобильных служб. Дополнительные сведения см. в разделе [Передача изображений в хранилище Azure с использованием мобильных служб](http://azure.microsoft.com/ru-ru/documentation/articles/mobile-services-dotnet-backend-windows-store-dotnet-upload-data-blob-storage/).
- **Используйте кэш в памяти**. Другим возможным способом хранения данных, который может применяться во время всплесков трафика, является использование кэша в памяти, например, [кэша Azure](http://azure.microsoft.com/ru-ru/services/cache/). Это означает, что входящие запросы будут способны выбирать необходимую информацию из памяти, вместо неоднократной передачи запроса в базу данных.

<a name="Advanced"></a>
## Расширенный поиск проблем
В этом разделе рассматриваются некоторые расширенные диагностические задачи, которые могут оказаться полезными, если уже выполненные действия не позволили полностью устранить проблему.

### Предварительные требования
Чтобы выполнить некоторые диагностические задачи в этом разделе, необходимо иметь доступ к средствам управления для баз данных SQL, например, **SQL Server Management Studio**, или к встроенным функциям управления, таким как **Портал управления Azure**.

SQL Server Management Studio - бесплатное приложение Windows, которое дает в ваше распоряжении самые широкие возможности. Если у вас нет доступа к компьютеру Windows (например, если вы пользователь Mac), подготовьте виртуальную машину в Azure, как показано в разделе [Создание виртуальной машины, в которой эксплуатируется Windows Server](http://azure.microsoft.com/ru-ru/documentation/articles/virtual-machines-windows-tutorial/) , а затем дистанционно подключитесь к ней. Если вы планируете использовать ВМ, прежде всего, для выполнения пакета SQL Server Management Studio, то будет достаточно применить экземпляр **Basic A0** (ранее назывался "Очень мелкий"). 

Портал управления Azure содержит встроенные функции управления, которые несколько ограничены по своим возможностям, но доступны без локальной установки.

Следующие шаги показывают, как получить информацию о соединении для базы данных SQL, поддерживающей мобильную службу, затем воспользоваться любым из указанных двух средств для подключения к ней. Вы вправе выбрать любое предпочитаемое средство.

#### Получение информации о соединении SQL 
1. Запустите [портал управления Azure][].
2. На вкладке "Мобильные службы" выберите службу, с которой вы хотите работать.
3. Выберите вкладку **Настройка**.
4. Выберите имя **базы данных SQL** в разделе **Параметры базы данных**. В результате вы перейдете на вкладку "База данных Azure SQL" на портале.
5. Выберите **Настройка правил брандмауэра Windows Azure для этого IP-адреса**.
6. Сделайте заметку с адресом сервера в разделе **Подключение к базе данных**, например: *mcml4otbb9.database.windows.net*.

#### Среда SQL Server Management Studio
1. Откройте окно [Выпуски SQL Server - Express](http://www.microsoft.com/ru-ru/server-cloud/products/sql-server-editions/sql-server-express.aspx)
2. Найдите раздел **SQL Server Management Studio** и выберите внизу кнопку **Загрузка**.
3. Выполняйте процедуру настройки до тех пор, пока не будет запущено приложение:

    ![SQL Server Management Studio][SSMS]

4. В диалоговом окне **Подключение к серверу** введите следующие значения
    - Имя сервера: *адрес сервера, который вы получили ранее*
    - Проверка подлинности: *Проверка подлинности SQL Server*
    - Имя входа: *имя для входа в систему, которое вы выбрали при создании сервера*
    - Пароль: *пароль, который вы выбрали при создании сервера*
5. Теперь соединение должно быть установлено.

#### Портал управления базами данных SQL
1. На вкладке "База данных SQL Azure" для своей базы данных выберите кнопку **Управление** 
2. Настройте соединение со следующими значениями:
    - Сервер: *должно быть введено предварительно заданное правильное значение*
    - База данных: *оставьте поле пустым*
    - Имя пользователя: *имя для входа в систему, которое вы выбрали при создании сервера*
    - Пароль: *пароль, который вы выбрали при создании сервера*
3. Теперь соединение должно быть установлено.

    ![Azure Management Portal - SQL Database][PortalSqlManagement]

<a name="AdvancedDiagnosing" />
### Расширенная диагностика

На **Портале управления Azure** можно легко выполнять множество диагностических задач, однако некоторые сложные задачи осуществимы только с помощью **SQL Server Management Studio** или **Портала управления базой данных SQL**.  Мы будем использовать динамические административные представления, то есть, представления, в которых диагностическая информация о вашей базе данных появляется автоматически. В этом разделе рассматривается несколько запросов, которые можно выполнять в данных представлениях для анализа различных метрик. Дополнительные сведения см. в разделе [Мониторинг базы данных SQL с использованием динамических административных представлений][].

После выполнения шагов по подключению к базе данных в SQL Server Management Studio, описанных в предыдущем разделе, выберите базу данных в **обозревателе объектов**. Для вывода списка административных представлений разверните **Представления**, а затем **Системные представления**. Чтобы выполнить приведенные ниже запросы, выберите **Новый запрос**, указав базу данных в **обозревателе объектов**, затем вставьте запрос и нажмите **Выполнить**.

![SQL Server management Studio - dynamic management views][SSMSDMVs]

Или же, если используется портал управления базой данных SQL, сначала укажите базу данных, а затем выберите **Новый запрос**.

![SQL Database Management Portal - new query][PortalSqlManagementNewQuery]

Чтобы выполнить любой из приведенных ниже запросов, вставьте его в окно и нажмите **Выполнить **.

![SQL Database Management Portal - run query][PortalSqlManagementRunQuery]

#### Расширенные метрики

Портал управления предоставляет удобный доступ к определенным показателям, если используется уровень Basic, Standard или Premium. Однако при использовании уровней Web и Business на портале доступна только метрика хранилища. К счастью, этот и другие показатели можно просто получить с помощью административного представления **[sys.resource\_stats](http://msdn.microsoft.com/ru-ru/library/dn269979.aspx)** независимо от используемого уровня. Рассмотрим следующий запрос:

    SELECT TOP 10 * 
    FROM sys.resource_stats 
    WHERE database_name = 'todoitem_db' 
    ORDER BY start_time DESC

> [WACOM.NOTE] 
> Выполните этот запрос в базе данных **master** на своем сервере; в этой базе данных присутствует только представление **sys.resource\_stats**.

Результат будет содержать следующие полезные показатели: ЦП (% от лимита уровня), хранилище (мегабайты), физические операции чтения данных (% от лимита уровня), операции записи в журнал (% от лимита уровня), память (% от лимита уровня), количество рабочих процессов, количество сеансов и т.д.

#### События связности SQL

Представление **[sys.event\_log](http://msdn.microsoft.com/ru-ru/library/azure/jj819229.aspx)** содержит сведения, касающиеся событий подключения.

    select * from sys.event_log 
    where database_name = 'todoitem_db'
    and event_type like 'throttling%'
    order by start_time desc

> [WACOM.NOTE] 
> Выполните этот запрос к базе данных **master** на своем сервере; в этой базе данных присутствует только представление **sys.event\_log**.

<a name="AdvancedIndexing" />
### Расширенная индексация

Таблица или представление могут содержать следующие типы индексов:

- **Кластеризованный**. Кластеризованный индекс указывает, как записи физически хранятся на диске. Должен быть только один кластеризованный индекс в расчете на таблицу, поскольку сами строки данных могут быть одновременно отсортированы только в одном порядке.

- **Некластеризованный**. Некластеризованные индексы хранятся отдельно от строк данных и используются для поиск на основе значения индекса. Во всех некластеризованных индексах на таблице используются значения ключей из кластеризованного индекса в качестве ключа поиска.

Рассмотрим аналогию из реального мира: рассмотрим книгу или техническое описание. Содержимое каждой страницы представляет собой запись, номер страницы - кластеризованный индекс, а индекс разделов в конце книги - некластеризованный индекс. Каждая запись в тематическом индексе указывает на кластеризованный индекс, номер страницы.

> [WACOM.NOTE] 
> По умолчанию сервер базы данных JavaScript мобильных служб Azure задает **\_createdAt** в качестве кластеризованного индекса. Если нужно удалить этот столбец или использовать другой кластеризованный индекс, то необходимо обязательно придерживаться приведенных ниже [рекомендаций по проектированию кластеризованного индекса](#ClusteredIndexes) . На сервере базы данных .NET класс `EntityData` определяет `CreatedAt` как кластеризованный индекс с использованием аннотации `[Index(IsClustered = true)]`.

<a name="ClusteredIndexes"></a>
#### Рекомендации по структуре кластеризованного индекса

Каждая таблица должна иметь кластеризованный индекс в столбце (или столбцах, в случае составного ключа) со следующими свойствами:

- Свойство narrow использует малый тип данных или является [составным ключом][Primary and Foreign Key Constraints]  для небольшого количества узких столбцов
- Unique или mostly unique (Уникальный или практически уникальный)
- Static - значение изменяется редко
- Ever-increasing (Постоянно увеличивающийся) 
- (необязательно) Fixed-width (С фиксированной шириной)
- (необязательно) nonnull (непустой)

Причина этого заключается в том, что свойство **narrow** обеспечивает использование всех остальных индексов в таблице как ключевых значений из кластеризованного индекса в качестве ключей поиска. В примере индекса разделов в конце книги кластеризованный индекс представляет собой номер страницы и является небольшим числом. Если бы заголовок этой главы был включен в кластеризованный индекс, то сам тематический индекс стал бы намного длиннее, потому что в качестве значения ключа применялось бы (название главы, номер страницы). 

Ключ должен быть объявлен как **static** и **ever-increasing**, чтобы не пришлось поддерживать физическое расположение записей (иначе говоря, либо перемещать записи физически, либо допускать фрагментацию памяти в результате разбиения страниц, на которых хранятся записи). 

Кластеризованный индекс будет самым удобным для запросов, выполняющим следующие действия:

- Возвращает диапазон значений с использованием таких операторов, как BETWEEN, >, >=, < и <=. 
	- После обнаружения строки с первым значением с использованием кластеризованного индекса гарантируется физическая смежность строк с последующими индексированными значениями. 
- Использовать предложения JOIN; обычно они представляют собой столбцы внешних ключей.
- Использовать предложения ORDER BY или GROUP BY.
	- Наличие индексов на столбцах, указанных в предложении ORDER BY или GROUP BY, может исключить необходимость сортировки данных компонентом Database Engine, поскольку строки уже отсортированы. Это способствует повышению производительности выполнения запросов.

#### Создание кластеризованных индексов на платформе Entity Framework

Чтобы задать кластеризованный индекс в сервере базы данных .NET с использованием Entity Framework, задайте свойство аннотации `IsClustered`. Например, ниже приведено определение `CreatedAt` в `Microsoft.WindowsAzure.Mobile.Service.EntityData`:

	[Index(IsClustered = true)]
	[DatabaseGenerated(DatabaseGeneratedOption.Identity)]
	[TableColumnAttribute(TableColumnType.CreatedAt)]
	public DateTimeOffset? CreatedAt { get; set; }

#### Создание индексов в схеме базы данных

Для сервера JavaScript кластеризованный индекс таблицы можно модифицировать только путем прямого изменения схемы базы данных либо в SQL Server Management Studio, либо на портале базы данных Azure SQL.

Следующие руководства описывают, как задать кластеризованный или некластеризованный индекс, непосредственно изменяя схему базы данных:  

- [Создание и изменение ограничений для ПЕРВИЧНОГО КЛЮЧА][]
- [Создание некластеризованных индексов][]
- [Создание кластеризованных индексов][]
- [Создание уникальных индексов][]

#### Поиск верхних N отсутствующих индексов 
SQL-запросы можно создавать в динамических административных представлениях, которые будут содержать более подробные сведения об использовании ресурсов отдельными запросами или эвристические данные о том, какие индексы следует добавить. Следующий запрос определяет, какие 10 отсутствующих индексов будут обеспечивать самое большое ожидаемое совокупное усовершенствование (в порядке убывания) для запросов пользователя.

    SELECT TOP 10 *
    FROM sys.dm_db_missing_index_group_stats
    ORDER BY avg_total_user_cost * avg_user_impact * (user_seeks + user_scans)
    DESC;

В следующем примере запроса выполняется соединение по всем этим таблицам для получения списка столбцов, которые должны войти в состав каждого недостающего индекса, и вычисления 'преимущества индексирования' для определения того, следует ли рассматривать данный индекс:

    SELECT * from 
    (
        SELECT 
        (user_seeks+user_scans) * avg_total_user_cost * (avg_user_impact * 0.01) AS index_advantage, migs.*
        FROM sys.dm_db_missing_index_group_stats migs
    ) AS migs_adv,
      sys.dm_db_missing_index_groups mig,
      sys.dm_db_missing_index_details mid
    WHERE
      migs_adv.group_handle = mig.index_group_handle and
      mig.index_handle = mid.index_handle
      AND migs_adv.index_advantage > 10
    ORDER BY migs_adv.index_advantage DESC;

Дополнительные сведения см. в разделах [Мониторинг базы данных SQL с использованием динамических административных представлений][] и [Отсутствие индексов в динамических административных представлениях](sys-missing-index-stats).

<a name="AdvancedQuery" />
### Усовершенствованная структура запросов 

Часто трудно диагностировать, какие запросы являются наиболее дорогостоящими для базы данных. 

#### Поиск верхних N запросов

В следующем примере возвращается информация о лучших пяти запросах, ранжированных по среднему времени ЦП. В этом примере запросы агрегируются в соответствии со своими хэшами запросов, поэтому эквивалентные запросы группируются по совокупному потреблению ресурсов.

	SELECT TOP 5 query_stats.query_hash AS "Query Hash", 
	    SUM(query_stats.total_worker_time) / SUM(query_stats.execution_count) AS "Avg CPU Time",
	    MIN(query_stats.statement_text) AS "Statement Text"
	FROM 
	    (SELECT QS.*, 
	    SUBSTRING(ST.text, (QS.statement_start_offset/2) + 1,
	    ((CASE statement_end_offset 
	        WHEN -1 THEN DATALENGTH(st.text)
	        ELSE QS.statement_end_offset END 
	            - QS.statement_start_offset)/2) + 1) AS statement_text
	     FROM sys.dm_exec_query_stats AS QS
	     CROSS APPLY sys.dm_exec_sql_text(QS.sql_handle) as ST) as query_stats
	GROUP BY query_stats.query_hash
	ORDER BY 2 DESC;

Дополнительные сведения см. в разделе [Мониторинг базы данных SQL с использованием динамических административных представлений][]. Кроме выполнения запроса, **Портал управления базой данных SQL** предоставляет удобный доступ к инструментам для просмотра этих данных, выбора **Сводки** для базы данных, а затем определения **производительности запроса**:

![SQL Database Management Portal - query performance][PortalSqlManagementQueryPerformance]

#### Анализ плана запроса

После выявления дорогостоящих запросов или с началом работы по развертыванию кода с использованием новых запросов, когда хотелось бы исследовать их производительность, набор инструментов предоставляет превосходную поддержку для анализа **плана запроса**. План запроса позволяет увидеть, какие операции занимают основные время ЦП и ресурсы ввода-вывода в ходе выполнения заданного SQL-запроса. Чтобы проанализировать план запроса в **SQL Server Management Studio**, используйте выделенные подсветкой кнопки панели инструментов.

![SQL Server Management Studio - query plan][SSMSQueryPlan]

Чтобы проанализировать план запроса на **Портале управления базой данных SQL**, используйте выделенные подсветкой кнопки панели инструментов.

![SQL Database Management Portal - query plan][PortalSqlManagementQueryPlan]

## См. также

- [Документация по базе данных Azure SQL][]
- [Производительность и масштабирование базы данных Azure SQL][]
- [Устранение неполадок базы данных SQL Azure][]

### Индексация

- [Основы индексирования][]
- [Общие правила проектирования индекса][]
- [Правила проектирования уникального индекса][]
- [Правила проектирования кластеризованного индекса][]
- [Ограничения для первичного и внешнего ключей][]
- [Сколько стоит ключ?][]

### Entity Framework
- [Вопросы производительности для платформы Entity Framework 5][]
- [Кодирование аннотаций для первых данных][]

<!-- IMAGES -->
 
[SSMS]: ./media/mobile-services-sql-scale-guidance/1.png
[PortalSqlManagement]: ./media/mobile-services-sql-scale-guidance/2.png
[PortalSqlMetrics]: ./media/mobile-services-sql-scale-guidance/3.png
[PortalSqlScale]: ./media/mobile-services-sql-scale-guidance/4.png
[PortalSqlAddAlert]: ./media/mobile-services-sql-scale-guidance/5.png
[PortalSqlAddAlert2]: ./media/mobile-services-sql-scale-guidance/6.png
[PortalSqlAddAlert3]: ./media/mobile-services-sql-scale-guidance/7.png
[SetIndexJavaScriptPortal]: ./media/mobile-services-sql-scale-guidance/set-index-portal-ui.png
[SSMSDMVs]: ./media/mobile-services-sql-scale-guidance/8.png
[PortalSqlManagementNewQuery]: ./media/mobile-services-sql-scale-guidance/9.png
[PortalSqlManagementRunQuery]: ./media/mobile-services-sql-scale-guidance/10.png
[PortalSqlManagementQueryPerformance]: ./media/mobile-services-sql-scale-guidance/11.png
[SSMSQueryPlan]: ./media/mobile-services-sql-scale-guidance/12.png
[PortalSqlManagementQueryPlan]: ./media/mobile-services-sql-scale-guidance/13.png

<!-- LINKS -->

[Портал управления Azure]: http://manage.windowsazure.com

[Документация по базе данных Azure SQL]: http://azure.microsoft.com/ru-ru/documentation/services/sql-database/
[Управление базой данных SQL с помощью SQL Server Management Studio]: http://go.microsoft.com/fwlink/p/?linkid=309723&clcid=0x409
[Мониторинг базы данных SQL с помощью динамических административных представлений]: http://go.microsoft.com/fwlink/p/?linkid=309725&clcid=0x409
[Производительность и масштабирование базы данных Azure SQL]: http://go.microsoft.com/fwlink/p/?linkid=397217&clcid=0x409
[Устранение неполадок базы данных SQL Azure]: http://msdn.microsoft.com/ru-ru/library/azure/ee730906.aspx

<!-- MSDN -->
[Создание и изменение ограничений для ПЕРВИЧНОГО КЛЮЧА]: http://technet.microsoft.com/ru-ru/library/ms181043(v=sql.105).aspx
[Создание кластеризованных индексов]: http://technet.microsoft.com/ru-ru/library/ms186342(v=sql.120).aspx
[Создание уникальных индексов]: http://technet.microsoft.com/ru-ru/library/ms187019.aspx
[Создание некластеризованных индексов]: http://technet.microsoft.com/ru-ru/library/ms189280.aspx

[Ограничения для первичного и внешнего ключей]: http://msdn.microsoft.com/ru-ru/library/ms179610(v=sql.120).aspx
[Основы индексирования]: http://technet.microsoft.com/ru-ru/library/ms190457(v=sql.105).aspx
[Общие рекомендации по проектированию индексов]: http://technet.microsoft.com/ru-ru/library/ms191195(v=sql.105).aspx 
[Правила проектирования уникального индекса]: http://technet.microsoft.com/ru-ru/library/ms187019(v=sql.105).aspx
[Правила проектирования кластеризованного индекса]: http://technet.microsoft.com/ru-ru/library/ms190639(v=sql.105).aspx

[sys-missing-index-stats]: http://technet.microsoft.com/ru-ru/library/ms345421.aspx

<!-- EF -->
[Вопросы производительности для платформы Entity Framework 5]: http://msdn.microsoft.com/ru-ru/data/hh949853
[Кодирование аннотаций для первых данных]: http://msdn.microsoft.com/ru-ru/data/jj591583.aspx
[Аннотации индексов в Entity Framework]:http://msdn.microsoft.com/ru-ru/data/jj591583.aspx#Index

<!-- BLOG LINKS -->
[Сколько стоит ключ?]: http://www.sqlskills.com/blogs/kimberly/how-much-does-that-key-cost-plus-sp_helpindex9/
