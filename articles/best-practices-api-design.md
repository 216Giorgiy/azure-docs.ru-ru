<properties
   pageTitle="Руководство по проектированию API | Microsoft Azure"
   description="Рекомендации по созданию качественно спроектированного API."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="masimms"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="rest-api"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="04/28/2015"
   ms.author="masashin"/>

# Руководство по проектированию API

![](media/best-practices-api-design/pnp-logo.png)

Некоторые разделы в этом руководстве находятся в процессе обсуждения и могут быть изменены в дальнейшем. Будем рады вашим отзывам!


## Обзор

Многие современные веб-решения используют веб-службы, размещенные на веб-серверах, для обеспечения работы удаленных клиентских приложений. Предоставляемые веб-службой операции составляют веб-API. Качественно спроектированный API должен поддерживать следующее:

- **Независимость от платформы**. Клиентские приложения должны иметь возможность использовать API, предоставляемый веб-службой, независимо от физической реализации предоставления данных или операций через API. Для этого API должен соответствовать общепринятым стандартам, позволяющим клиентскому приложению и веб-службе согласовывать между собой используемые форматы данных и структуру данных, которыми обмениваются клиентские приложения и веб-служба.

- **Развитие службы**. Веб-служба должна иметь возможность развиваться и расширять (или сокращать) набор функций независимо от клиентских приложений. У существующих клиентских приложений должна быть возможность продолжать работу без изменений независимо от изменения функций, предоставляемых веб-службой. Все функции также должны быть доступными, чтобы клиентские приложения могли полноценно их использовать.

Цель этого руководства — описать вопросы, на которые следует обратить внимание при разработке веб-API.

## Общие сведения о передаче репрезентативного состояния (REST)

В 2000 году Рой Филдинг в своей диссертации предложил альтернативный архитектурный подход к структурированию операций, предоставляемых веб-службами, — REST. REST — это архитектурная концепция создания распределенных систем на основе гиперсред. Основное достоинство модели REST в том, что она основана на открытых стандартах и не требует какой-либо конкретной реализации модели или использующих ее клиентских приложений. Например, веб-службу REST можно реализовать при помощи веб-API Microsoft ASP.NET, а клиентские приложения можно разработать с помощью любого языка и набора инструментов, позволяющего создавать HTTP-запросы и анализировать HTTP-ответы.

> [AZURE.NOTE]Модель REST не зависит от каких-либо базовых протоколов и не требует привязки к HTTP. Однако в большинстве наиболее распространенных реализаций систем на основе REST в качестве протокола приложений для отправки и получения запросов используется HTTP. В этом документе основное внимание уделяется сопоставлению принципов REST с системами, использующими в работе протокол HTTP.

Модель REST использует схему переходов для представления объектов и служб (называющихся _ресурсами_) по сети. Во многих системах, реализующих REST, для передачи запросов с целью получения доступа к этим ресурсам обычно используется протокол HTTP. В таких системах клиентское приложение отправляет запрос в виде универсального кода ресурса (URI), определяющего ресурс, и метод HTTP (чаще всего используются GET, POST, PUT или DELETE), определяющего операцию, выполняемую на указанном ресурсе. Текст HTTP-запроса содержит данные, необходимые для выполнения операции. Важно понять, что концепция REST определяет модель запроса без отслеживания состояния. HTTP-запросы должны быть независимыми и могут создаваться в любом порядке, поэтому сохранение сведений о переходном состоянии между запросами не представляется возможным. Сведения хранятся только в самих ресурсах, и каждый запрос должен быть атомарной операцией. В сущности, модель REST реализует конечный автомат, в котором запрос проход через ресурс от одного четко определенного непереходного состояния к другому.

> [AZURE.NOTE]Характер отдельных запросов в модели REST, не предусматривающий отслеживание состояния, позволяет создать высокомасштабируемую систему на основе этих принципов. Нет необходимости сохранять сходство между клиентским приложением, создающим серию запросов, и обрабатывающими их веб-серверами.

При реализации эффективной модели REST также крайне важно понять структуру связей между различными ресурсами, к которым модель предоставляет доступ. Как правило, эти ресурсы организованы в виде коллекций и связей. Например, предположим, что быстрый анализ системы электронной коммерции выявляет наличие двух коллекций, которыми скорее всего будут пользоваться клиентские приложения: заказы и клиенты. У каждого заказа и клиента должен быть собственный уникальный ключ для идентификации. Универсальный код ресурса (URI) для доступа к коллекции заказов может быть довольно простым, например _/orders_, как и URI для получения всех клиентов, например _/customers_. При отправке HTTP-запроса GET на универсальный код ресурса (URI) _/orders_ возвращается список всех заказов в коллекции, закодированный в виде HTTP-ответа:

```HTTP
GET http://adventure-works.com/orders HTTP/1.1
...
```

В ответе, приведенном ниже, заказы закодированы в виде структуры XML-списка. Список содержит 7 заказов:

```HTTP
HTTP/1.1 200 OK
...
Date: Fri, 22 Aug 2014 08:49:02 GMT
Content-Length: ...
<OrderList xmlns:i="..." xmlns="..."><Order><OrderID>1</OrderID><OrderValue>99.90</OrderValue><ProductID>1</ProductID><Quantity>1</Quantity></Order><Order><OrderID>2</OrderID><OrderValue>10.00</OrderValue><ProductID>4</ProductID><Quantity>2</Quantity></Order><Order><OrderID>3</OrderID><OrderValue>16.60</OrderValue><ProductID>2</ProductID><Quantity>4</Quantity></Order><Order><OrderID>4</OrderID><OrderValue>25.90</OrderValue><ProductID>3</ProductID><Quantity>1</Quantity></Order><Order><OrderID>7</OrderID><OrderValue>99.90</OrderValue><ProductID>1</ProductID><Quantity>1</Quantity></Order></OrderList>
```
Для получения отдельного заказа требуется указать его идентификатор из ресурса _orders_, например _/orders/2_:

```HTTP
GET http://adventure-works.com/orders/2 HTTP/1.1
...
```

```HTTP
HTTP/1.1 200 OK
...
Date: Fri, 22 Aug 2014 08:49:02 GMT
Content-Length: ...
<Order xmlns:i="..." xmlns="...">
<OrderID>2</OrderID><OrderValue>10.00</OrderValue><ProductID>4</ProductID><Quantity>2</Quantity></Order>
```

> [AZURE.NOTE]Для простоты сведения в этих примерах возвращаются в виде текстовых XML-данных. Однако ресурсы вполне могут содержать другие типы данных, поддерживаемые HTTP, например двоичные или зашифрованные данные. Тип данных указывается в строке "content-type" в HTTP-ответе. Кроме того, модель REST может возвращать одни и те же данные в разных форматах, таких как XML или JSON. В этом случае веб-служба должна иметь возможность согласовать содержимое с клиентским приложением, отправившим запрос. Запрос может включать заголовок _Accept_, указывающий на предпочтительный для клиентского приложения формат получения, а веб-служба должна попытаться по возможности выполнить это требование.

Обратите внимание, что в ответе на запрос REST используются стандартные коды состояния HTTP. Например, запрос, возвращающий допустимые данные, должен включать код HTTP-ответа 200 (ОК), в то время как запрос, по которому не удалось найти или удалить указанный ресурс, должен вернуть ответ, включающий код состояния HTTP 404 (не найдено).

## Схема и структура веб-API RESTful

Залог разработки эффективного веб-API — простота и согласованность. Веб-API, обладающий этими двумя свойствами, упрощает создание клиентских приложений, которым требуется использовать API.

Основная задача веб-API RESTful — предоставление набора взаимосвязанных ресурсов и базовых операций, позволяющих приложению использовать эти ресурсы и беспрепятственно перемещаться между ними. По этой причине универсальные коды ресурсов (URI), составляющие стандартный веб-API RESTful, должны быть ориентированы на предоставляемые данные и использовать средства HTTP для работы с ними. Этот метод требует иного подхода, нежели тот, что обычно используется при разработки набора классов в объектно-ориентированном API, в основе которого, как правило, лежит поведение объектов и классов. Кроме того, веб-API RESTful должен характеризоваться отсутствием отслеживания состояния и быть независимым от операций, вызываемых в конкретной последовательности. В следующих разделах описаны моменты, которые следует учесть при разработке веб-API RESTful.

### Организация структуры веб-API на основе ресурсов

> [AZURE.TIP]В основе универсальных кодов ресурсов (URI), предоставляемых веб-службой REST, должны лежать существительные (данные, к которым предоставляет доступ веб-API), а не глаголы (действия, которые приложение может выполнить с данными).

Сосредоточьтесь на бизнес-сущностях, предоставляемых веб-API. Например, в веб-API, созданном для поддержки ранее описанной системы электронной коммерции, основные сущности — клиенты и заказы. Выполнение таких процессов, как размещение заказа, можно обеспечить путем предоставления операции HTTP POST, добавляющей сведения о заказе в список заказов для клиента. Внутри системы операция POST может выполнять такие задачи, как проверка количества продукции на складе и выставление счетов клиенту. HTTP-ответ может указывать на успешность размещения заказа. Кроме того, обратите внимание, что ресурс не обязательно должен быть основан на одном физическом элементе данных. К примеру, ресурс заказа можно реализовать внутри системы с использованием сводных данных из множества строк, содержащихся в нескольких таблицах в реляционной базе данных, но представленных клиентскому приложению в виде единой сущности.

> [AZURE.TIP]Не следует создавать интерфейс REST, зеркально отображающий внутреннюю структуру предоставляемых данных или зависящий от нее. Модель REST позволяет не только реализовывать простые операции CRUD (создание, чтение, обновление, удаление) в отдельных таблицах в реляционной базе данных. Задача модели REST — сопоставление бизнес-сущностей и операций, которые приложение может выполнить с ними, с физической реализацией этих сущностей. При этом физические сведения должны быть скрыты от клиентского приложения.

Отдельные бизнес-сущности редко существуют изолированно (хотя это возможно для некоторых одноэлементых объектов) и чаще сгруппированы в коллекциях. В рамках модели REST каждая сущность и коллекция являются ресурсами. В веб-API RESTful у каждой коллекции есть собственный универсальный код ресурса (URI) в веб-службе. При выполнении HTTP-запроса GET посредством универсального кода ресурса (URI) для коллекции возвращается список элементов в этой коллекции. У каждого отдельного элемента также есть собственный универсальный код ресурса (URI). Приложение может отправлять дополнительный HTTP-запрос GET с использованием этого универсального кода ресурса (URI) для получения сведений о соответствующем элементе. Вам следует упорядочить универсальные коды ресурсов (URI) для коллекций и элементов в виде иерархии. В системе электронной коммерции универсальный код ресурса (URI) _/customers_ обозначает коллекцию клиента, а _/customers/5_ получает сведения для одного клиента из этой коллекции с идентификатором 5. Этот подход позволяет обеспечивать простоту веб-API.

> [AZURE.TIP]Используйте единое соглашение об именовании в универсальных кодах ресурсов (URI). В целом это помогает использовать существительные во множественном числе для универсальных кодов ресурсов (URI), ссылающихся на коллекции.

Вам также следует продумать связи между разными типами ресурсов и способы предоставления этих связей. Например, клиенты могут размещать ноль и более заказов. Естественный способ представления этой связи — использование универсального кода ресурса (URI), такого как _/customers/5/orders_, чтобы найти все заказы для клиента 5. Вы также можете представить связь между заказом и конкретным клиентом посредством универсального кода ресурса (URI), такого как _/orders/99/customer_, чтобы найти клиента для заказа 99, но чрезмерное расширение этой модели может вызвать трудности. Более рациональное решение — предоставить ссылки с возможностью перехода на связанные ресурсы, такие как клиент, в тексте HTTP-ответа, возвращаемого при отправке запроса на заказ. Это механизм более подробно описан далее в этом руководстве в разделе "Использование подхода HATEOAS для обеспечения возможности перехода к связанным ресурсам".

В более сложных системах может быть гораздо больше типов сущностей, и очевидным решением может показаться предоставление универсальных кодов ресурсов (URI), позволяющих клиентскому приложению переходить между несколькими уровнями связей, например _/customers/1/orders/99/products_ для получения списка продуктов в заказе 99, размещенном клиентом 1. Однако такой уровень сложности трудно обслуживать и адаптировать в случае дальнейшего изменения связей между ресурсами. Вместо этого постарайтесь сделать универсальные коды ресурсов (URI) максимально простыми. Следует помнить, что как только у приложения появляется ссылка на ресурс, оно может использовать эту ссылку для поиска элементов, связанных с указанным ресурсом. Предыдущий запрос можно заменить на универсальный код ресурса (URI) _/customers/1/orders_ для поиска всех заказов для клиента 1, а затем запросить универсальный код ресурса (URI) _/orders/99/products_ для поиска продуктов в указанном порядке (предполагая, что заказ 99 размещен клиентом 1).

> [AZURE.TIP]Старайтесь использовать универсальные коды ресурсов не сложнее _collection/item/collection_.

Кроме того, следует учесть, что все веб-запросы увеличивают нагрузку на веб-сервер, которая растет вместе с числом запросов. Старайтесь определять ресурсы таким образом, чтобы избежать создания "избыточных" веб-API, предоставляющих множество небольших ресурсов. Такой API может потребовать от клиентского приложения отправки нескольких запросов для поиска всех необходимых данных. Возможно, следует денормализовать данные и объединить связанную информацию в более крупные ресурсы, которые можно получить с помощью одного запроса. Однако следует сохранять равновесие в этом подходе, чтобы избежать получения чрезмерного объема данных, потребность в которых у клиентского приложения возникает нечасто. Получение крупных объектов может увеличить задержку запроса и повлечь за собой дополнительные затраты пропускной способности с малой выгодой в случае редкого использования дополнительных данных.

Избегайте зависимостей между веб-API и структурой, типом или расположением базовых ресурсов данных. Например, если данные находятся в реляционной базе данных, веб-API не требуется предоставлять каждую таблицу в виде коллекции ресурсов. Представьте веб-API в виде абстракции базы данных и при необходимости создайте уровень сопоставления между базой данных и веб-API. Таким образом, при изменении структуры или реализации базы данных (например, при перемещении от реляционной базы данных, содержащей коллекцию нормализованных таблиц, к денормализованной системе хранения NoSQL, такой как база данных документов) клиентские приложения изолированы от вносимых изменений.
> [AZURE.TIP]Источником данных, лежащим в основе веб-API, не обязательно должно быть хранилище данных. Вместо него можно использовать другую службу или бизнес-приложение, либо приложение прежних версий, выполняемое локально внутри организации.

Наконец, сопоставление каждой операции, реализованной веб-API, с конкретным источником не всегда возможно. Такие _безресурсные_ сценарии можно обрабатывать с помощью HTTP-запросов GET, вызывающих определенную функцию и возвращающих результаты в виде ответного HTTP-сообщения. Веб-API, реализующий простые расчетные операции, такие как добавление и вычитание, может предоставить универсальные коды ресурсов (URI), представляющие эти операции в виде псевдоресурсов, и использовать строку запроса для указания требуемых параметров. Например, запрос GET для универсального кода ресурса (URI) _/add?operand1=99&operand2=1_ может вернуть ответное сообщение, содержащее значение 100, а запрос GET для универсального кода ресурса (URI) _/subtract?operand1=50&operand2=20_ может вернуть ответное сообщение, содержащее значение 30. Однако следует использовать эти формы универсальных кодов ресурсов (URI) с осторожностью.

### Определение операций с точки зрения методов HTTP

Протокол HTTP определяет несколько методов, назначающих запросу семантическое значение. Ниже приведены наиболее распространенные методы HTTP, используемые большинством веб-API RESTful:

- **GET**. Возвращает копию ресурса по указанному универсальному коду ресурса (URI). Текст ответного сообщения содержит сведения о запрашиваемом ресурсе.

- **POST**. Создает новый ресурс по указанному универсальному коду ресурса (URI). Текст запроса содержит сведения о новом ресурсе. Обратите внимание, что метод POST также можно использовать для запуска операций, не относящихся непосредственно к созданию ресурсов.

- **PUT**. Заменяет или обновляет ресурс по указанному универсальному коду ресурса (URI). В тексте запроса указывается изменяемый ресурс и устанавливаемые значения.

- **DELETE**. Удаляет ресурс по указанному универсальному коду ресурса (URI).

> [AZURE.NOTE]Протокол HTTP также определяет другие менее распространенные методы, такие как PATCH, используемый для запроса выборочных обновлений ресурса, HEAD, используемый для запроса описания ресурса, OPTIONS, позволяющий клиентскому приложению получать сведения о параметрах обмена данными, поддерживаемых сервером, и TRACE, позволяющий клиентскому приложению запрашивать сведения, которые можно использовать в целях тестирования и диагностики.

Результат конкретного запроса должен зависеть от того, является ли целевой ресурс коллекцией или отдельным элементов. В следующей таблице перечислены общие соглашения, принятые в большинстве реализаций RESTful, на примере системы электронной коммерции. Обратите внимание, что возможность реализации некоторых запросов зависит от конкретного сценария.

| **Ресурс** | **POST** | **GET** | **PUT** | **DELETE** |
|--------------|----------|---------|---------|------------|
| /customers | Создание нового клиента | Получение всех клиентов | Массовое обновление клиентов (_если реализовано_) | Удаление всех клиентов |
| /customers/1 | Ошибка | Получение сведений для клиента 1 | Обновление сведений клиента 1, если он существует; в противном случае — возврат сообщения об ошибке | Удаление клиента 1 |
| /customers/1/orders | Создание нового заказа для клиента 1 | Получение всех заказов для клиента 1 | Массовое обновление заказов для клиента 1 (_если реализовано_) | Удаление всех заказов для клиента 1 (_если реализовано_) |

Цель запросов GET и DELETE вполне ясна, однако в отношении цели и результатов запросов POST и PUT может возникать неопределенность.

Запрос POST должен создавать новый ресурс на основе данных, предоставленных в тексте запроса. В модели REST запросы POST часто применяются к ресурсам-коллекциям. При этом новый ресурс добавляется в коллекцию.

> [AZURE.NOTE]Вы также можете определять запросы POST, запускающие какую-либо функцию и при этом не обязательно возвращающие данные. Эти типы запросов можно применять к коллекциям. Например, вы можете использовать запрос POST для передачи расписания службе обработки платежных ведомостей и получения вычисленной суммы налогов в качестве ответа.

Запрос PUT предназначен для изменения существующего ресурса. Если указанный ресурс не существует, запрос PUT может вернуть сообщение об ошибке (в некоторых случаях он может фактически создать ресурс). Запросы PUT чаще всего применяются к ресурсам-отдельным элементам (таким как конкретный клиент или заказ). Их также можно применять к коллекциям, хотя подобная практика менее распространена. Обратите внимание, что запросы PUT идемпотентны, в отличие от запросов POST. Если приложение многократно отправляет один и тот же запрос PUT, результаты всегда должны быть одинаковыми (одинаковые значения будут применяться для одного и того же ресурса), но если приложение повторно отправляет один и тот же запрос POST, в результате будут созданы несколько ресурсов.

> [AZURE.NOTE]Строго говоря, HTTP-запрос PUT заменяет существующий ресурс указанным в тексте запроса. Если требуется изменить лишь часть свойств ресурса, не затрагивая остальные свойства, необходимо использовать HTTP-запрос PATCH. Однако во многих реализациях RESTful это правило не всегда соблюдается и в обеих ситуациях используется запрос PUT.

### Обработка HTTP-запросов
Данные, включенные клиентским приложением во множество HTTP-запросов, и соответствующие ответные сообщения от веб-сервера можно представить в различных форматах (или типах мультимедиа). Например, данные, содержащие сведения для клиента или заказа, можно предоставить в формате XML, JSON или другом закодированном и сжатом формате. Веб-API RESTful должен поддерживать различные типы носителей, согласно требованиям клиентского приложения, отправляющего запрос.

При отправке запроса, возвращающего данные в тексте сообщения, клиентское приложение может указать поддерживаемые типы носителей в заголовке "Accept" запроса. Следующий код демонстрирует HTTP-запрос GET, получающий сведения клиента 1 и требующий возврата результата в формате JSON (клиентскому приложению все равно следует просмотреть тип носителя данных в ответе, чтобы проверить формат возвращаемых данных):

```HTTP
GET http://adventure-works.com/orders/2 HTTP/1.1
...
Accept: application/json
...
```

Если веб-сервер поддерживает этот тип носителя, он может вернуть ответ, включающий заголовок "Content-Type", который указывает формат данных в тексте сообщения:

> [AZURE.NOTE]Для максимального взаимодействия типы носителей, указанные в заголовках "Accept" и "Content-Type", должны быть распознанными MIME-типами, а не пользовательскими типами носителей.

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"OrderID":2,"ProductID":4,"Quantity":2,"OrderValue":10.00}
```

Если веб-сервер не поддерживает запрашиваемый тип носителя, он может отправить данные в другом формате. В любом случае он должен указать тип носителя (например, _text/xml_) в заголовке "Content-Type". Клиентское приложение отвечает за анализ ответного сообщения и правильную интерпретацию результатов в тексте сообщения.

Обратите внимание, что в этом примере веб-сервер успешно получает запрашиваемые данные и сообщает об успешном завершении операции путем передачи кода состояния 200 в заголовке ответа. Если соответствующие данные не обнаружены, веб-сервер должен вернуть код состояния 404 (не найдено), а текст ответного сообщения может содержать дополнительные сведения. Формат этих сведений указывается в заголовке "Content-Type", как показано в следующем примере:

```HTTP
GET http://adventure-works.com/orders/222 HTTP/1.1
...
Accept: application/json
...
```

Заказ 222 не существует, поэтому ответное сообщение выглядит следующим образом:

```HTTP
HTTP/1.1 404 Not Found
...
Content-Type: application/json; charset=utf-8
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"Message":"No such order"}
```

При отправке HTTP-запроса PUT для обновления ресурса приложение указывает универсальный код ресурса (URI) и предоставляет изменяемые данные в тексте запроса. Приложение также должно указать формат этих данных с помощью заголовка "Content-Type". Для текстовой информации часто используется формат _application/x-www-form-urlencoded_, включающий набор пар "имя-значение", разделенных символом &. В следующем примере показан HTTP-запрос PUT, изменяющий сведения в заказе 1:

```HTTP
PUT http://adventure-works.com/orders/1 HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
ProductID=3&Quantity=5&OrderValue=250
```

Если изменение прошло успешно, в идеале должен вернуться ответ с кодом состояния HTTP 204, указывающим на успешное завершение процесса и отсутствие дополнительных сведений в тексте ответа. Заголовок "Location" в ответе содержит универсальный код (URI) обновленного ресурса:

```HTTP
HTTP/1.1 204 No Content
...
Location: http://adventure-works.com/orders/1
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
```

> [AZURE.TIP]Если данные в HTTP-запросе PUT включают сведения о дате и времени, убедитесь, что ваша веб-служба принимает сведения о дате и времени, отформатированные согласно стандарту ISO 8601.

Если ресурс, который требуется обновить, не существует, веб-сервер может ответить сообщением "Не найдено", как было описано выше. Кроме того, если сервер фактически создает сам объект, он может вернуть коды состояния HTTP 200 (ОК) или HTTP 201 (создано), а текст ответа может содержать данные для нового ресурса. Если в заголовке "Content-Type" запроса указан формат данных, не поддерживаемый веб-сервером, сервер должен вернуть ответ с кодом состояния HTTP 415 (неподдерживаемый тип носителя).

> [AZURE.TIP]Рассмотрите возможность реализации массовых HTTP-операций PUT, поддерживающих пакетные обновления нескольких ресурсов в коллекции. В запросе PUT должен быть указан универсальный код ресурса (URI) коллекции, а текст запроса должен содержать сведения о ресурсах, которые требуется изменить. Такой подход помогает сократить избыточность и повысить производительность.

Формат HTTP-запросов POST, создающих новые ресурсы, аналогичен формату запросов PUT: текст сообщения содержит сведения о новом ресурсе, который требуется добавить. Однако универсальный код ресурса (URI), как правило, указывает коллекцию, в которую следует добавить ресурс. В следующем примере создается новый заказ, который затем помещается в коллекцию заказов:

```HTTP
POST http://adventure-works.com/orders HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
ProductID=5&Quantity=15&OrderValue=400
```

При успешном выполнении запроса веб-сервер должен отправить ответное сообщение с кодом состояния HTTP 201 (создано). Заголовок "Location" должен содержать универсальный код (URI) созданного ресурса, а текст ответа — копию нового ресурса. Заголовок "Content-Type" указывает формат этих данных:

```HTTP
HTTP/1.1 201 Created
...
Content-Type: application/json; charset=utf-8
Location: http://adventure-works.com/orders/99
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"OrderID":99,"ProductID":5,"Quantity":15,"OrderValue":400}
```

> [AZURE.TIP]Если данные в запросе PUT или POST неверны, веб-сервер должен отправить ответное сообщение с кодом состояния HTTP 400 (неверный запрос). Текст этого сообщения может содержать дополнительные сведения о проблеме, связанной с запросом, и ожидаемых форматах, либо ссылку на URL-адрес с дополнительными сведениями.

Для удаления ресурса HTTP-запрос DELETE предоставляет универсальный код ресурса (URI), который требуется удалить. В следующем примере предпринимается попытка удаления заказа 99:

```HTTP
DELETE http://adventure-works.com/orders/99 HTTP/1.1
...
```

Если операция удаления прошла успешно, веб-сервер должен отправить ответ с кодом состояния HTTP 204, указывающим на успешное завершение процесса и отсутствие дополнительных сведений (такой же ответ возвращается при успешном выполнении операции PUT, но в этом случае в ответе нет заголовка "Location", поскольку ресурс больше не существует). Запрос DELETE может также вернуть код состояния HTTP 200 (ОК) или 202 (принято), если удаление выполняется асинхронно.

```HTTP
HTTP/1.1 204 No Content
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
```

Если ресурс не найден, веб-сервер должен вернуть сообщение с кодом 404 (не найдено).

> [AZURE.TIP]Если требуется удалить все ресурсы в коллекции, назначьте HTTP-запрос DELETE для универсального кода ресурса (URI) коллекции, вместо того чтобы вынуждать приложение по очереди удалять каждый ресурс из коллекции.

### Фильтрация и разбивка данных на страницы

Старайтесь поддерживать максимальную простоту и удобство универсальных кодов ресурсов (URI). Предоставление коллекции ресурсов через один универсальный код ресурса (URI) упрощает эту задачу, но может привести к тому, что приложения будут получать крупные объемы данных, когда нужно лишь подмножество информации. Создание больших объемов трафика влияет не только на производительность и масштабируемость веб-сервера, но и негативно сказывается на скорости реагирования клиентских приложений, запрашивающих данные.

Например, если заказы содержат уплаченную за них сумму, клиентскому приложению, перед которым стоит задача получить все заказы с суммой выше заданного значения, может потребоваться получить все заказы через универсальный код ресурса (URI) _/orders_, после чего локально отфильтровать эти запросы. Очевидно, что это крайне неэффективный процесс. Он впустую использует пропускную способность сети и вычислительные ресурсы сервера, на котором размещен веб-API.

Возможное решение — предоставить схему URI, такую как _/orders/ordervalue\_greater\_than\_n_, где _n_ — стоимость заказа. Но такой подход непрактичен для большинства уровней стоимости, за исключением лишь некоторых. Кроме того, если вам требуется отправлять запросы по заказам на основе других критериев, в конце концов вам, вероятно, придется предоставлять длинный список универсальных кодов ресурсов (URI) со сложными именами.

Более рациональный подход к фильтрации данных — предоставление условий фильтра в строке запроса, передаваемой веб-API, например _/orders?ordervaluethreshold=n_. В этом примере соответствующая операция в веб-API отвечает за анализ и обработку параметра `ordervaluethreshold` в строке запроса и возврат фильтрованных результатов в HTTP-ответе.

Некоторые HTTP-запросы GET по ресурсам коллекций потенциально могут возвращать большое число элементов. Чтобы снизить эту вероятность, при проектировании веб-API следует ввести ограничение на объем данных, возвращаемый одним запросом. Этого можно добиться путем поддержки строк запроса, позволяющих пользователю указывать максимальное число получаемых элементов (которое само может быть ограничено верхним пределом для предотвращения атак типа "отказ в обслуживании") и начальное смещение внутрь коллекции. Например, строка запроса в универсальном коде ресурса (URI) _/orders?limit=25&offset=50_ должна вернуть 25 заказов, начиная с 50 заказа в коллекции заказов. Как и при фильтрации данных, операция, реализующая запрос GET в веб-API, отвечает за анализ и обработку параметров `limit` и `offset` в строке запроса. Для поддержки клиентских приложений запросы GET, возвращающие разбитые по страницам данные, должны также включать какие-либо метаданные, указывающие общее число ресурсов, доступных в коллекции. Вы также можете рассмотреть другие стратегии интеллектуального разбиения по страницам. Подробнее — в статье [Замечания по проектированию API: интеллектуальное разбиение по страницам](http://bizcoder.com/api-design-notes-smart-paging)

Вы можете следовать аналогичной стратегии для сортировки данных при их получении. Вы можете указать параметр сортировки, использующий имя поля в качестве значения, например _/orders?sort=ProductID_. Однако обратите внимание, что такой подход может негативно отразиться на кэшировании (параметры строки запроса составляют часть идентификатора ресурса, используемого многими реализациями кэша в качестве ключа к кэшированным данным).

Вы можете расширить этот подход и ограничить (спроецировать) возвращаемые поля, если один элемент ресурса содержит большой объем данных. Например, вы можете использовать параметр строки запроса, принимающий разделенный запятыми список полей, например _/orders?fields=ProductID,Quantity_.

> [AZURE.TIP]Присвойте содержательные значения по умолчанию всем необязательным параметрам в строках запроса. Например, установите параметру `limit` значение 10, а параметру `offset` — 0, если вы реализуете разбиение по страницам, параметру сортировки в качестве значения задайте ключ ресурса, если вы реализуете упорядочение, а в параметре `fields` укажите все поля в ресурсе при поддержке проекций.

### Обработка больших двоичных ресурсов

Один ресурс может содержать большие двоичные поля, такие как файлы или изображения. Чтобы преодолеть проблемы передачи, вызванные ненадежными и непостоянными соединениями, и сократить время ответа, вы можете предоставить операции, позволяющие клиентскому приложению получать такие ресурсы поблочно. Для этого веб-API должен поддерживать заголовок "Accept-Ranges" для запросов GET по большим ресурсам, а в идеале также реализовывать HTTP-запросы HEAD для этих ресурсов. Заголовок "Accept-Ranges" указывает, что операция GET поддерживает частичные результаты и что клиентское приложение может отправлять запросы GET, возвращающие подмножество ресурса, указанное в виде диапазона байтов. Запрос HEAD аналогичен запросу GET с тем исключением, что он возвращает только заголовок, описывающий ресурс, и пустое сообщение. Клиентское приложение может отправить запрос HEAD, чтобы определить необходимость получения ресурса с помощью частичных запросов GET. В следующем примере показан запрос HEAD, получающий сведения об изображении продукта:

```HTTP
HEAD http://adventure-works.com/products/10?fields=ProductImage HTTP/1.1
...
```

Ответное сообщение содержит заголовок с размером ресурса (4580 байт) и заголовок "Accept-Ranges", согласно которому соответствующая операция GET поддерживает частичные результаты:

```HTTP
HTTP/1.1 200 OK
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 4580
...
```

Клиентское приложение может использовать эти сведения, чтобы создать ряд операций GET для получения изображения небольшими блоками. Первый запрос возвращает первые 2500 байт с помощью заголовка "Range":

```HTTP
GET http://adventure-works.com/products/10?fields=ProductImage HTTP/1.1
Range: bytes=0-2499
...
```

Ответное сообщение указывает, что это частичный ответ, возвращая код состояния HTTP 206. Заголовок "Content-Length" указывает фактическое число возвращаемых байтов в тексте сообщения (не размер ресурса), а заголовок "Content-Range" указывает, какая это часть ресурса (байты 0–2499 из 4580):

```HTTP
HTTP/1.1 206 Partial Content
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2500
Content-Range: bytes 0-2499/4580
...
_{binary data not shown}_
```

Последующий запрос от клиентского приложения может получить оставшуюся часть ресурса с помощью соответствующего заголовка "Range":

```HTTP
GET http://adventure-works.com/products/10?fields=ProductImage HTTP/1.1
Range: bytes=2500-
...
```

Соответствующее ответное сообщение должно выглядеть следующим образом:

```HTTP
HTTP/1.1 206 Partial Content
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2080
Content-Range: bytes 2500-4580/4580
...
```

## Обеспечение перехода к связанным ресурсам с помощью подхода HATEOAS

Одна из основных целей реализации модели REST — получение возможности перемещаться внутри всего набора ресурсов без предварительного знания схемы универсальных кодов ресурсов (URI). Каждый HTTP-запрос GET должен возвращать сведения, необходимые для поиска ресурсов, напрямую связанных с запрашиваемым объектом, посредством гиперссылок, включенных в ответ. Запросу GET также необходимо предоставить сведения, описывающие операции, доступные в каждом из этих ресурсов. Этот принцип называется HATEOAS (гипертекст как обработчик состояния приложения). Система фактически представляет собой конечный автомат. Ответ по каждому запросу содержит сведения, необходимые для перемещения между состояниями. Другие сведения не требуются.

> [AZURE.NOTE]На сегодняшний день не существует стандартов или спецификаций, определяющих правила моделирования принципа HATEOAS. Примеры в этом разделе демонстрируют одно из возможных решений.

Например, для обработки связи между клиентами и заказами данные, возвращаемые в ответе по определенному заказу, должны содержать универсальные коды ресурсов (URI) в виде гиперссылки, определяющей клиента, разместившего заказ, и операции, которые можно выполнить для этого клиента.

```HTTP
GET http://adventure-works.com/orders/3 HTTP/1.1
Accept: application/json
...
```

Текст ответного сообщения содержит массив `Links` (выделен в примере кода), указывающий характер связи (_клиент_), универсальный код ресурса (URI) клиента (\__http://adventure-works.com/customers/3_), способ получения сведений об этом клиенте (_GET_), и MIME-типы, поддерживаемые веб-сервером для получения этих сведений (_text/xml_ и _application/json_). Это все сведения, необходимые клиентскому приложению для получения сведений о клиенте. Помимо этого, массив "Links" также включает ссылки для других возможных операций, таких как PUT (для изменения клиента, включая формат, который веб-сервер ожидает получить от клиентского приложения) и DELETE.

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"OrderID":3,"ProductID":2,"Quantity":4,"OrderValue":16.60,"Links":[(some links omitted){"Relationship":"customer","HRef":" http://adventure-works.com/customers/3", "Action":"GET","LinkedResourceMIMETypes":["text/xml","application/json"]},{"Relationship":"
customer","HRef":" http://adventure-works.com /customers/3", "Action":"PUT","LinkedResourceMIMETypes":["application/x-www-form-urlencoded"]},{"Relationship":"customer","HRef":" http://adventure-works.com /customers/3","Action":"DELETE","LinkedResourceMIMETypes":[]}]}
```

Для полноты массив "Links" также должен включать автореферентные сведения, относящиеся к полученному ресурсу. Эти ссылки опущены в предыдущем примере, но выделены в следующем коде. Обратите внимание, что связь _self_ в этих ссылках используется для указания на то, что это ссылка на ресурс, возвращаемый операцией:

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"OrderID":3,"ProductID":2,"Quantity":4,"OrderValue":16.60,"Links":[{"Relationship":"self","HRef":" http://adventure-works.com/orders/3", "Action":"GET","LinkedResourceMIMETypes":["text/xml","application/json"]},{"Relationship":" self","HRef":" http://adventure-works.com /orders/3", "Action":"PUT","LinkedResourceMIMETypes":["application/x-www-form-urlencoded"]},{"Relationship":"self","HRef":" http://adventure-works.com /orders/3", "Action":"DELETE","LinkedResourceMIMETypes":[]},{"Relationship":"customer",
"HRef":" http://adventure-works.com /customers/3", "Action":"GET","LinkedResourceMIMETypes":["text/xml","application/json"]},{"Relationship":" customer" (customer links omitted)}]}
```

Чтобы такой подход оказался эффективным, клиентские приложения должны быть готовы к получению и анализу этих дополнительных сведений.

## Управление версиями веб-API RESTful

Маловероятно, что веб-API останется статическим, за исключением самых простых ситуаций. По мере изменения бизнес-требований добавляются новые коллекции ресурсов, изменяются связи между ресурсами и структура данных в ресурсах. Несмотря на то что обновление веб-API для соответствия новым или измененным требованиям — довольно простой процесс, вам необходимо учесть, какое воздействие эти изменения окажут на клиентские приложения, использующие веб-API. Проблема в том, что хотя разработчик, занимающийся проектированием и реализацией веб-API, полностью контролирует этот API, у него нет того же уровня контроля над клиентскими приложениями, которые порой создаются сторонними организациями, работающими в удаленном режиме. В первую очередь необходимо позволить существующим клиентским приложениям продолжать работу без изменений, при этом предоставляя новым клиентским приложениям доступ к новым функциям и ресурсам.

Управление версиями позволяет веб-API указывать предоставляемые функции и ресурсы, за счет чего клиентское приложение может отправлять запросы для определенной версии функции или ресурса. В следующих разделах описано несколько различных подходов со своими преимуществами и недостатками.

### Отсутствие управления версиями

Эта простейший подход, приемлемый для некоторых внутренних API. Масштабные изменения можно представлять в виде новых ресурсов или ссылок. Добавление содержимого к существующим ресурсам не всегда является значительным изменением, поскольку клиентские приложения, не ожидающие увидеть это содержимое, просто пропустят его.

Например, запрос на универсальный код ресурса (URI) \__http://adventure-works.com/customers/3_ должен вернуть сведения одного клиента с полями `Id`, `Name` и `Address`, ожидаемыми клиентским приложением.

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","Address":"1 Microsoft Way Redmond WA 98053"}]
```

> [AZURE.NOTE]Для простоты и понятности примеры ответов в этом разделе не содержат ссылок HATEOAS.

Если поле `DateCreated` добавить в схему ресурса клиента, ответ будет выглядеть следующим образом:

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","DateCreated":"2014-09-04T12:11:38.0376089Z","Address":"1 Microsoft Way Redmond WA 98053"}]
```

Существующие клиентские приложения могут продолжить работать без ошибок, если они могут пропускать нераспознанные поля, в то время как при проектировании новых клиентских приложений можно обеспечить поддержку новых полей. Однако внесение более серьезных изменений в схему ресурсов (таких как удаление или переименование полей) или изменение связей между ресурсами могут быть значительными изменениями, мешающими корректной работе существующих клиентских приложений. В такой ситуации вам следует рассмотреть один из следующих подходов.

### Управление версиями через универсальные коды ресурсов (URI)

При каждом изменении веб-API или схемы ресурсов вы добавляете номер версии в универсальный код (URI) каждого ресурса. Уже существующие универсальные коды ресурсов (URI) должны продолжить функционировать без изменений, возвращая ресурсы, соответствующие их исходной схеме.

Расширим предыдущий пример. Если изменить структуру поля `Address` и добавить подполя, содержащие каждую составляющую часть адреса (например, `StreetAddress`, `City`, `State` и `ZipCode`), эту версию ресурса можно предоставить посредством универсального кода ресурса (URI) с номером версии, например http://adventure-works.com/v2/customers/3:

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","DateCreated":"2014-09-04T12:11:38.0376089Z","Address":{"StreetAddress":"1 Microsoft Way","City":"Redmond","State":"WA","ZipCode":98053}}]
```

Этот механизм управления версиями очень прост, но для него требуется, чтобы сервер направлял запрос к соответствующей конечной точке. Однако этот подход может стать чрезмерно сложным по мере прохождения веб-API через несколько итераций и необходимости поддержки сервером нескольких различных версий. Кроме того, c пуристической точки зрения, во всех случаях клиентские приложения получают одни и те же данные (клиент 3), поэтому универсальный код ресурса (URI) фактически не должен отличаться в зависимости от версии. Эта схема также усложняет реализацию HATEOAS, поскольку потребуется включать номер версии в универсальные коды ресурсов (URI) всех ссылок.

### Управление версиями через строку запроса

Чтобы избежать предоставления множества универсальных кодов ресурсов (URI), вы можете указывать версию ресурса с помощью параметра в строке запроса, добавленного к HTTP-запросу, например \__http://adventure-works.com/customers/3?version=2_. Значение по умолчанию параметра версии должно быть содержательным, например 1, если оно опускается клиентскими приложениями прежних версий.

Этот подход обладает семантическим преимуществом в том плане, что один и тот же ресурс всегда возвращается по одинаковому универсальному коду ресурса (URI). Однако он зависит от кода, обрабатывающего запрос для анализа строки запроса и возврата соответствующего HTTP-ответа. Кроме того, этот подход также усложняет реализацию HATEOAS, как и механизм управления версиями через универсальные коды ресурсов (URI).

> [AZURE.NOTE]Некоторые браузеры прежних версий и веб-прокси не могут кэшировать ответы по запросам, содержащим строку запроса в URL-адресе. Это может негативно сказаться на производительности веб-приложений, использующих веб-API и выполняемых через такой веб-браузер.

### Управление версиями через заголовок

Вместо того чтобы добавлять номер версии в виде параметра строки запроса, вы можете реализовать пользовательский заголовок, указывающий версию ресурса. Этот подход требует от клиентского приложения добавления соответствующего заголовка во все запросы. При этом в коде, обрабатывающем запрос клиентского приложения, можно использовать значение по умолчанию (версия 1), если заголовок с номером версии опускается. В следующих примерах используется пользовательский заголовок с именем _Custom-Header_. Значение этого заголовка указывает версию веб-API.

Версия 1:

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Custom-Header: api-version=1
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","Address":"1 Microsoft Way Redmond WA 98053"}]
```

Версия 2:

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Custom-Header: api-version=2
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","DateCreated":"2014-09-04T12:11:38.0376089Z","Address":{"StreetAddress":"1 Microsoft Way","City":"Redmond","State":"WA","ZipCode":98053}}]
```

Обратите внимание, что, как и в двух предыдущих подходах, для реализации HATEOAS потребуется включать соответствующий пользовательский заголовок во все ссылки.

### Управление версиями через тип носителя

При отправке HTTP-запроса GET на веб-сервер клиентское приложение должно указывать поддерживаемый формат содержимого с помощью заголовка "Accept", как описано ранее в этом руководстве. Нередко заголовок _Accept_ используется для того, чтобы позволить клиентскому приложению указать требуемый формат текста ответа: XML, JSON или другой формат, который клиентское приложение может анализировать. Однако можно определить пользовательские типы носителей, которые содержат сведения, позволяющие клиентскому приложению указывать предпочтительную версию ресурса. В следующем примере показан запрос, в котором используется заголовок _Accept_ со значением _application/vnd.adventure-works.v1+json_. Элемент _vnd.adventure-works.v1_ указывает веб-серверу на необходимость возврата ресурса версии 1, в то время как элемент _json_ указывает JSON в качестве предпочтительного формата текста ответа:

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Accept: application/vnd.adventure-works.v1+json
...
```

Код, обрабатывающий запрос, отвечает за обработку заголовка _Accept_ и максимальное выполнение содержащихся в нем требований (клиентское приложение может указать в заголовке _Accept_ несколько форматов, в случае чего веб-сервер может выбрать наиболее подходящий формат текста ответа). Веб-сервер подтверждает формат данных в тексте ответа с помощью заголовка "Content-Type":

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/vnd.adventure-works.v1+json; charset=utf-8
...
Content-Length: ...
[{"Id":3,"Name":"Contoso LLC","Address":"1 Microsoft Way Redmond WA 98053"}]
```

Если в заголовке "Accept" не указан ни один из известных типов носителя, веб-сервер может отправить ответное сообщение с кодом HTTP 406 (неприемлемо) или вернуть сообщение с типом носителя по умолчанию.

Вероятно, это самый полноценный механизм управления версиями, беспрепятственно поддерживающий принцип HATEOAS, который может включать MIME-тип связанных данных в ссылках ресурсов.

> [AZURE.NOTE]При выборе стратегии управления версиями вам также следует учесть воздействие на производительность, особенно при кэшировании на веб-сервере. Управление версиями через универсальные коды ресурсов (URI) и строку запроса поддерживает кэширование, поскольку одинаковое сочетание универсального кода ресурса (URI) и строки запроса каждый раз соотносится с одними и теми же данными.

> Механизмы управления версиями через заголовок и тип носителя, как правило, требуют дополнительной логики для проверки значений в пользовательском заголовке или заголовке "Accept". Использование многочисленными клиентами разных версий веб-API в крупномасштабной среде может привести к образованию большого объема повторяющихся данных в кэше на стороне сервера. Эта проблема может усложниться, если клиентское приложение обменивается данными с веб-сервером через прокси-сервер, реализующий кэширование, который перенаправляет запрос на веб-сервер лишь в том случае, если в его кэше на текущий момент не содержится копия запрашиваемых данных.

## Подробнее

- [Подробная инструкция по RESTful](http://restcookbook.com/) содержит общие сведения о создании API RESTful.
- [Контрольный список веб-API](https://mathieu.fenniak.net/the-api-checklist/) содержит полезный список элементов, которые следует учесть при проектировании и реализации веб-API.

<!---HONumber=Oct15_HO3-->