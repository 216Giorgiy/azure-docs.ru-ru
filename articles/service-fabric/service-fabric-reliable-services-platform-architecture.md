<properties
   pageTitle="Архитектура надежной службы | Microsoft Azure"
   description="Обзор архитектуры надежной службы для служб с отслеживанием состояния и без него."
   services="service-fabric"
   documentationCenter=".net"
   authors="AlanWarwick"
   manager="timlt"
   editor=""/>

<tags
   ms.service="Service-Fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="09/03/2015"
   ms.author="alanwar"/>

# Архитектура для надежных служб с отслеживанием состояния и без него

Надежная служба Service Fabric может быть службой с отслеживанием состояния или без него. Каждый тип службы выполняется в конкретной архитектуре, описанной в этой статье. Дополнительные сведения о различиях между службой с отслеживанием состояния и без него см. в разделе [Обзор надежных служб](service-fabric-reliable-services-introduction.md).

## Надежные службы с отслеживанием состояния

### Архитектура службы с отслеживанием состояния
![Схема архитектуры](./media/service-fabric-reliable-services-platform-architecture/reliable-stateful-service-architecture.png)

### Надежная служба с отслеживанием состояния

Надежную службу с отслеживанием состояния можно создать на основе класса StatefulService или StatefulServiceBase. Оба этих базовых класса, предоставляемых службой Service Fabric, обеспечивают разные уровни поддержки и абстракции, позволяющие вашей службе с отслеживанием состояния взаимодействовать со службой Service Fabric и участвовать в качестве службы в кластере Service Fabric. Класс StatefulService является производным от класса StatefulServiceBase. Последний делает работу служб более разноплановой, но требует более глубокого понимания функций Service Fabric. Дополнительные сведения о создании служб с помощью классов StatefulService и StatefulServiceBase см. в статьях [Обзор надежных служб](service-fabric-reliable-services-introduction.md) и [Расширенное использование надежных служб](service-fabric-reliable-services-advanced-usage.md).

Оба базовых класса определяют продолжительность и роль реализации службы. Реализация службы может переопределить виртуальные методы обоих базовых классов, если у реализации службы есть работа в этих моментах жизненного цикла реализации или если требуется создать коммуникационный объект-прослушиватель. Обратите внимание, что, хотя в приведенной выше схеме реализация службы может реализовать собственный коммуникационный объект-прослушиватель с ICommunicationListener, все же этот прослушиватель реализует служба Service Fabric и именно его использует реализация службы.

Ваша надежная служба с отслеживанием состояния использует надежные коллекции с помощью диспетчера надежных состояний. Надежные коллекции — это локальные структуры данных высокой надежности, то есть для вашей службы они доступны всегда, даже во время отработки отказа службы. Каждый тип надежной коллекции реализуется поставщиком надежных состояний. Дополнительные сведения о надежных коллекциях см. в статье [Обзор надежных коллекций](service-fabric-reliable-services-reliable-collections.md).

### Диспетчер надежных состояний и поставщики состояний

Диспетчер надежных состояний —это объект, который управляет поставщиками надежных состояний, который может создавать, удалять и перечислять поставщиков надежных состояний и обеспечивать их высокую надежность. Поставщик надежных состояний — это хранимая структура данных с высокой надежностью, например словарь или очередь. Каждый поставщик надежных состояний содержит интерфейс, с помощью которого ваша служба с отслеживанием состояния взаимодействует с поставщиком надежных состояний. Например, с помощью IReliableDictionary служба взаимодействует с надежным словарем, а с помощью IReliableQueue — с надежной очередью. Все поставщики надежных состояний реализуют интерфейс IReliableState.

Диспетчер надежных состояний содержит интерфейс IReliableStateManager, с помощью которого к диспетчеру получает доступ служба с отслеживанием состояния. Интерфейсы для поставщиков надежных состояний возвращаются при помощи класса IReliableStateManager.

Диспетчер надежных состояний использует архитектуру подключаемого модуля, поэтому возможно динамическое подключение новых типов надежных коллекций.

Надежный словарь и надежная очередь основаны на реализации высокопроизводительного дифференциального хранилища с контролем версий.

### Репликатор транзакций

Репликатор транзакций обеспечивает одинаковость состояния службы (то есть состояния в надежных коллекциях и диспетчере надежных состояний) во всех репликах, которые используют вашу службу, а также хранение состояния в журнале. Диспетчер надежных состояний взаимодействует с репликатором транзакций через закрытый механизм.

Чтобы передавать состояния на другие реплики экземпляра службы, репликатор транзакций использует сетевой протокол. Благодаря этому все реплики получают актуальную информацию о состоянии.

Репликатор транзакций хранит информацию о состоянии в журнале, поэтому в случае аварийного завершения работы узла или процесса эта информация не исчезает. Интерфейс работы с журналом работает с помощью закрытого механизма.

### Журнал

Компонент журнала дает возможность пользоваться постоянным высокопроизводительным хранилищем. Это хранилище можно оптимизировать как для того, чтобы стала возможна запись на вращающийся или твердотельный накопитель, так и для того, чтобы место на диске использовалось с максимальной эффективностью. Журнал устроен так, чтобы постоянные хранилища (например, жесткие диски) располагались локально по отношению к узлам, использующим вашу надежную службу. По сравнению с постоянными хранилищами, которые по отношению к узлу расположены не локально, это снижает задержки и увеличивает пропускную способность.

Компонент журнала использует два типа файлов журнала. Есть доступный для всего узла файл журнала, который должен находиться на диске, используемом только для этого файла журнала. Этот файл находится в рабочем каталоге узла Service Fabric. Кроме того, каждая реплика для вашей службы имеет выделенный файл журнала и находится в рабочем каталоге службы. Информация о состоянии попадает в общий журнал лишь на время. На постоянное хранение эта информация помещается в выделенный файл журнала. Информация о состоянии сначала записывается в общий файл журнала, а затем — в фоновом режиме в выделенный файл журнала. Таким образом, при записи в общий журнал задержки минимизируются, а пропускная способность достигает пика. Это позволяет службе работать быстрее.

Но когда компонент журнала с помощью параметра OptimizeForLocalSSD оптимизирован под твердотельные накопители, информация о состоянии записывается непосредственно в выделенный файл журнала в обход общего файла журнала. Так как твердотельные диски не подвержены задержкам из-за состязания за движение головки диска, то в этом случае нет никакого штрафа за запись непосредственно в выделенный файл журнала.

Когда с помощью параметра OptimizeLogForLowerDiskUsage компонент журнала оптимизируется для того, чтобы минимизировать используемое место на диске, выделенные файлы журнала создаются как разреженные NTFS-файлы. Так как обычно файлы журналов заполнены информацией о состоянии не полностью, использование разреженных файлов позволяет увеличить резервное место на диске, чтобы оно стало доступным большему количеству реплик. Если же компонент журнала не настроить таким образом, то место в файле журнала выделяется предварительно и компонент журнала может записывать информацию непосредственно в файл с самой высокой производительностью.

Кроме минимального интерфейса, работающего в режиме пользователя, журнал создается как работающий в режиме ядра драйвер. Работая как драйвер в режиме ядра, журнал может повысить производительность использующих его служб до максимума.

Дополнительные сведения о настройке журнала см. в разделе [Настройка надежных служб с отслеживанием состояния](service-fabric-reliable-services-configuration.md).

## Надежная служба без отслеживания состояния

### Архитектура службы без отслеживания состояния
![Схема архитектуры](./media/service-fabric-reliable-services-platform-architecture/reliable-stateless-service-architecture.png)

### Надежная служба без отслеживания состояния

Реализации службы без отслеживания состояния пользуются классом StatelessService или StatelessServiceBase. Последний обеспечивает дополнительную гибкость. Оба базовых класса определяют продолжительность и роль вашей службы. Реализация службы может переопределить виртуальные методы обоих базовых классов, если у службы есть работа в этих моментах жизненного цикла службы или если требуется создать коммуникационный объект-прослушиватель. Обратите внимание, что, хотя в приведенной выше схеме ваша служба может реализовать собственный коммуникационный объект-прослушиватель с ICommunicationListener, все же этот прослушиватель реализует служба Service Fabric и именно его использует реализация службы.

Дополнительные сведения о создании служб с помощью классов StatelessService и StatelessServiceBase см. в статьях [Обзор надежных служб](service-fabric-reliable-services-introduction.md) и [Продвинутое использование надежных служб](service-fabric-reliable-services-advanced-usage.md).

<!--Every topic should have next steps and links to the next logical set of content to keep the customer engaged-->
## Дальнейшие действия

Дополнительные сведения о Service Fabric см. в таких статьях:

[Обзор надежных служб](service-fabric-reliable-services-introduction.md)

[Быстрый запуск](service-fabric-reliable-services-quick-start.md)

[Обзор надежных коллекций](service-fabric-reliable-services-reliable-collections.md)

[Продвинутое использование надежных служб](service-fabric-reliable-services-advanced-usage.md)

[Настройка надежных служб](service-fabric-reliable-services-configuration.md)
 

<!---HONumber=Nov15_HO2-->