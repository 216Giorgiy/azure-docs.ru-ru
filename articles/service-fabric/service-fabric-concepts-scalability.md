---
title: "Масштабируемость служб Service Fabric | Документация Майкрософт"
description: "Описывает процесс выполнения служб структурой служб"
services: service-fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: 
ms.assetid: ed324f23-242f-47b7-af1a-e55c839e7d5d
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 12/30/2016
ms.author: masnider
translationtype: Human Translation
ms.sourcegitcommit: dafaf29b6827a6f1c043af3d6bfe62d480d31ad5
ms.openlocfilehash: 52dcf341a34478bf4e800d8f1b9d44867b5feaf6


---
# <a name="scaling-service-fabric-applications"></a>Масштабирование приложений Service Fabric
Azure Service Fabric упрощает создание масштабируемых приложений, обеспечивая управление службами, разделами и репликами на всех узлах кластера. Это позволяет добиться максимально эффективного использования ресурсов.

Два указанных ниже способа позволяют добиться широких возможностей масштабирования для приложений Service Fabric:

1. Масштабирование на уровне разделов служб
2. Масштабирование на уровне именованных экземпляров служб

## <a name="scaling-at-the-partition-level"></a>Масштабирование на уровне раздела
Service Fabric поддерживает секционирование. Секционирование позволяет разделять отдельную службу на несколько независимых разделов, каждый из которых сохраняет некоторую часть общего состояния службы. В разделе [Обзор по разделам](service-fabric-concepts-partitioning.md) содержится информация о поддерживаемых типах схем секционирования на разделы. Реплики на каждом разделе распределяются по узлам в кластере. Рассмотрим службу, использующую схему секционирования по диапазонам, в которой нижний ключ равен 0, верхний ключ равен 99, а количество разделов равно 4. В кластере с тремя узлами служба может состоять из четырех реплик, совместно использующих ресурсы каждого узла, как показано ниже:

<center>
![Распределение разделов с тремя узлами](./media/service-fabric-concepts-scalability/layout-three-nodes.png)
</center>

Если вы увеличите число узлов, Service Fabric сможет использовать ресурсы на новых узлах, и для этого переместит на них несколько существующих реплик. После повышения количества узлов до четырех служба будет иметь на каждом узле по три реплики (принадлежащие к разным разделам), что обеспечивает более эффективное использование ресурсов и более высокую производительность.

<center>
![Распределение разделов с четырьмя узлами](./media/service-fabric-concepts-scalability/layout-four-nodes.png)
</center>

## <a name="scaling-at-the-service-name-level"></a>Масштабирование на уровне имени службы
Экземпляр службы представляет собой конкретный экземпляр приложения с определенным именем и именем типа службы (см. статью [Жизненный цикл приложения Service Fabric](service-fabric-application-lifecycle.md)). Во время создания службы необходимо указать схему секционирования, которая будет использоваться (см. статью [Секционирование служб Reliable Services в Service Fabric](service-fabric-concepts-partitioning.md)).

Первый уровень масштабирования опирается на имя службы. При повышении загрузки старых экземпляров службы вы можете создавать новые экземпляры, в том числе с другими уровнями секционирования. Это позволяет новым клиентам службы использовать менее загруженные экземпляры служб вместо более загруженных.

Одна из возможностей увеличения мощности заключается в создании нового экземпляра службы с новой схемой секционирования. Однако, это повышает сложность системы. Все клиенты-потребители должны знать, когда и как использовать службу с другим именем. Еще один вариант — это служба диспетчера или служба посредника, которая будет принимать решения о том, в какие службы и разделы направлять каждый запрос.

### <a name="example-scenario-embedded-dates"></a>Пример сценария: встроенные даты
Один возможный сценарий заключается в использовании сведений о дате как части имени службы. Например, вы могли бы использовать экземпляр службы с конкретным именем для всех клиентов, зарегистрировавшихся в 2013 году, и другим именем для клиентов, зарегистрировавшихся в 2014 году. Такая схема именования позволяет программно повысить количество имен в зависимости от даты (к началу 2014 года можно по запросу создать экземпляр службы для 2014 года).

Однако этот подход основывается на клиентах, использующих сведения об именовании приложений, которые лежат за пределами сведений Service Fabric.

* *Использование соглашения об именовании.* В 2013 году, когда приложение было создано, вы создали одну службу с именем fabric:/app/service2013. Ближе к второму кварталу 2013 года вы создали другую службу под названием fabric:/app/service2014. Обе эти службы принадлежат к одному типу. При таком подходе вашему клиенту потребуется логическое решение, позволяющее формировать соответствующее имя службы с учетом года.
* *Использование службы поиска.* Другой способ заключается в использовании вторичной "службы поиска", которая может предоставлять имя службы для желаемого ключа. Новые экземпляры служб могут быть созданы при помощи службы поиска. В самой службе поиска данные приложения не сохраняются, а сохраняются только данные об именах экземпляров службы, которые она создает. Таким образом, в описанном выше примере, связанном с годами, клиенту сначала пришлось бы связаться со службой поиска, чтобы узнать имя службы, в которой выполняется обработка данных для определенного года. После этого клиент обращается к найденной службе для выполнения фактической операции. Результат первого поиска можно сохранить в кэше.

## <a name="putting-it-all-together"></a>Сборка
Давайте рассмотрим все идеи, которые мы уже обсудили, на следующем примере.

Предположим, что вы пытаетесь создать службу, которая выступает в качестве адресной книги для хранения имен и контактной информации. Сколько у вас будет пользователей? Сколько контактов будет хранить каждый пользователь? Очень трудно ответить на все эти вопросы при первом развертывании службы. Неправильный выбор числа разделов может позже привести к серьезным проблемам с масштабированием. Но нужно ли нам выбирать для всех пользователей единую схему секционирования?

В таких ситуациях мы рекомендуем следующий подход.
1. Не пытайтесь сразу выбрать единственно верную и универсальную схему секционирования, а создайте службу диспетчера.
2. Эта служба будет изучать информацию о каждом клиенте, который регистрируется в вашей основной службе. На основе этой информации она будет создавать экземпляр _реальной_ службы хранилища контактов _только для этого клиента_. Такой подход с динамическим созданием служб имеет множество преимуществ.

    * Вам не нужно точно предугадывать правильное число разделов для всех пользователей.
    * Данные сегментируются, так как каждый клиент имеет свою собственную копию службы.
    * Каждую клиентскую службу можно настроить по-разному, например с большим или меньшим числом разделов или реплик, с учетом прогнозируемого масштаба.
      * Если, например, клиент оплатил уровень Gold, ему можно выделить дополнительные реплики или увеличить число секций.
      * Если же данные, предоставленные клиентом, предполагают относительно небольшое число контактов, для него можно использовать малое число разделов.
    * Вам не нужно поддерживать множество экземпляров или реплик службы, пока не появились клиенты.
    * Если клиент откажется от ваших услуг, для удаления его информации достаточно, чтобы служба диспетчера удалила созданную для этого клиента службу.

## <a name="next-steps"></a>Дальнейшие действия
Дополнительные сведения о понятиях Service Fabric см. в следующих статьях:

* [Доступность служб структуры служб](service-fabric-availability-services.md)
* [Разделение служб Service Fabric](service-fabric-concepts-partitioning.md)
* [Определение состояния и управление им](service-fabric-concepts-state.md)



<!--HONumber=Jan17_HO1-->


