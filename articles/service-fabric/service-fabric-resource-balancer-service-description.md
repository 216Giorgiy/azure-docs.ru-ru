<properties
   pageTitle="Описания служб для балансировщика ресурсов"
   description="Общие сведения о настройке описаний служб, которые будет использовать балансировщик ресурсов."
   services="service-fabric"
   documentationCenter=".net"
   authors="masnider"
   manager="timlt"
   editor=""/>

<tags
   ms.service="Service-Fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="09/15/2015"
   ms.author="masnider"/>

# Обзор описаний служб

## Ограничения на размещение
[Ограничения на размещение](../service-fabric-placement-constraint) службы — это механизм, позволяющий определенному экземпляру службы выбирать необходимые ему свойства узла. Как и свойства узла, эти ограничения представляют собой пары «ключ — значение», описывающие имя свойства и требования службы к значению. Из отдельных инструкций можно сформировать необходимое ограничение, сгруппировав их с помощью простой булевой логики. Обратите внимание, что эти ограничения интерпретирует балансировщик ресурсов Service Fabric.

Ограничения на размещение службы можно определить в манифесте служб или приложений либо прямо в коде.

В манифесте служб указываются определения типов служб (ServiceTypes).

``` xml
<ServiceTypes>
    <StatefulServiceType ServiceTypeName="QueueReplica" HasPersistedState="false" >
      <PlacementConstraints>(HasDisk == true  &amp;&amp; SpindleCount &gt;= 4)</PlacementConstraints>
    </StatefulServiceType>
</ServiceTypes>

```

В манифесте приложения указываются определения шаблонов служб (ServiceTemplates) или служб по умолчанию (DefaultServices).

``` xml
<ServiceTemplates>
    <StatefulService ServiceTypeName="QueueReplica">
      <SingletonPartition></SingletonPartition>
      <PlacementConstraints>(HasDisk == true  &amp;&amp; SpindleCount &gt;= 4)</PlacementConstraints>
    </StatefulService>
  </ServiceTemplates>

  <DefaultServices>
    <Service Name="QR">
      <StatefulService MinReplicaSetSize="3" ServiceTypeName="QueueReplica" TargetReplicaSetSize="3">
        <SingletonPartition/>
        <PlacementConstraints>(HasDisk == true  &amp;&amp; SpindleCount &gt;= 4)</PlacementConstraints>
      </StatefulService>
    </Service>
  </DefaultServices>
```

``` cpp
StatefulServiceDescription serviceDescription = new StatefulServiceDescription();
serviceDescription.PlacementConstraints = "(HasDisk == true  && SpindleCount >= 4)";
Task t = fabricClient.ServiceManager.CreateServiceAsync(serviceDescription);
```

На следующей диаграмме показано, что в кластере с несколькими узлами эту службу можно разместить только на узле N5.

![Ограничения на размещение][Image1]

Если служба использует для свойства ограничение, которое не определено на каком-то узле, такой узел считается неподходящим независимо от указанного значения.

## Сходство служб
Будучи особой формой ограничения на размещение службы, определение сходства служб позволяет описывать разные службы, которые по различным причинам имеют локальную зависимость друг от друга (иными словами, обе службы должны быть установлены на одном узле, иначе они не будут работать). Такая архитектура не должна широко применяться для приложений Service Fabric. Тем не менее, Service Fabric умеет распознавать переходные архитектуры определенных типов приложений прежних версий и позволяет размещать службы на одном узле.

Благодаря возможности установки сходства между двумя службами первичные реплики этих служб всегда размещаются на одном узле.

Связи по сходству представлены в виде иерархии с родительскими и дочерними объектами. Служба, установленная первой, становится родительским объектом, а служба, установленная второй, — дочерним. Связь моделируется как жесткое ограничение.

Для определения сходства служб действуют следующие ограничения.

- Нельзя сравнивать службы без отслеживания и с отслеживанием состояния.
- Нельзя сравнивать службы без отслеживания состояния, которые имеют разное количество экземпляров (при создании обе службы без отслеживания состояния должны иметь одинаковое свойство InstanceCount).
- Нельзя сравнивать временные или постоянные службы с отслеживанием состояния, которые имеют разное количество реплик (значения параметров Target ReplicaSetSizes и Min ReplicaSetSizes должны быть одинаковыми в обеих службах).
- Нельзя сравнивать секционированные службы. У каждой службы должна быть схема секционирования FABRIC\_PARTITION\_SCHEME\_SINGLETON.
- Как и другие свойства описания службы, связи по сходству задаются при создании службы и впоследствии не могут быть изменены.
- Цепочки служб нельзя использовать. Если необходимо установить связь по сходству между несколькими службами, нужно использовать модель звезды.

``` xml
<ServiceTemplates>
  <StatelessService ServiceTypeName="StatelessCalculatorService" InstanceCount="5">
    <SingletonPartition></SingletonPartition>
      <ServiceCorrelations>
        <ServiceCorrelation Scheme="Affinity" ServiceName="fabric:/otherApplication/parentService"/>
      </ServiceCorrelations>
  </StatelessService>
</ServiceTemplates>
```

В этом примере кода показан дополнительный способ использования определений служб по умолчанию (DefaultServices).

``` xml
<DefaultServices>
  <Service Name="childService">
    <StatelessService InstanceCount="3" ServiceTypeName="calculatorService">
      <SingletonPartition/>
     <ServiceCorrelations>
        <ServiceCorrelation Scheme="Affinity" ServiceName="fabric:/otherApplication/parentService"/>
      </ServiceCorrelations>
    </StatelessService>
  </Service>
</DefaultServices>
```

В этом примере кода показано, как создать связь по сходству после создания приложения-контейнера.

``` cpp
StatefulServiceDescription serviceDescription = new StatefulServiceDescription();
ServiceCorrelationDescription affinityDescription = new ServiceCorrelationDescription();
affinityDescription.Scheme = ServiceCorrelationScheme.Affinity;
affinityDescription.ServiceName = new Uri("fabric:/otherApplication/parentService");
serviceDescription.Correlations.Add(affinityDescription);
Task t = fabricClient.ServiceManager.CreateServiceAsync(serviceDescription);
```

## Метрики балансировки ресурсов
Если свойства узла и ограничения на размещение службы представляют собой жесткие правила и политики, которые описывают правильное расположение служб, то метрики балансировки ресурсов, в общих чертах, помогают описать оптимальное размещение служб в кластере. Определяемые службой метрики имеют несколько различных свойств, которые описывают, как эти метрики используются в пределах кластера.

### Использование метрик по умолчанию
В первую очередь нужно понять, что использовать для служб метрики ресурсов совершенно необязательно. По умолчанию балансировщик ресурсов Service Fabric использует «встроенные» системные метрики, с помощью которых он выполняет простую балансировку без вмешательства администраторов служб и кластеров. Метрики по умолчанию, которые балансировщик ресурсов Service Fabric отслеживает и балансирует в кластере, включают PrimaryCount, ReplicaCount и Count. PrimaryCount — это количество первичных реплик службы с отслеживанием состояния на узле. ReplicaCount — количество всех реплик службы с отслеживанием состояния на узле. Count — общее число объектов службы на узле, включая службы без отслеживания и с отслеживанием состояния. Обычно метрика PrimaryCount считается наиболее важной и имеет максимальный вес (см. следующий раздел). Второй по важности идет метрика ReplicaCount, а за ней — Count.

На диаграмме ниже показан пример стандартной балансировки трех служб с отслеживанием состояния, каждая из которых имеет три реплики.

![Метрики по умолчанию][Image2]

Обычно этих метрик хватает для многих служб. Метрики по умолчанию рекомендуется использовать в том случае, если нет требований относительно других метрик или возможностей.

### Определение пользовательских метрик
Если стандартных метрик не хватает для определенной службы или для службы выдвигаются конкретные требования относительно определенного ресурса, например памяти или места на диске, следует использовать пользовательские метрики. Пользовательские метрики полезны в случаях, когда в службе необходимо сбалансировать один или несколько ресурсов и предотвратить так называемое состязание между ними. Использование таких метрик в кластере может существенно варьироваться от реплики к реплике, например одна первичная реплика может использовать 100 % метрики, а другая — только 20 %. С помощью пользовательских метрик также можно определять ресурсы, которых очень не хватает на том или ином компьютере (например, память, место на диске или подключения). В некоторых случаях можно создать дополнительные пользовательские метрики, отслеживающие или представляющие метрики, у которых на узлах нет ограничений для максимального значения, но которые с точки зрения службы представляют работу и потребление ресурсов (например, метрика «текущие необработанные транзакции»). Даже если у такой метрики на узле и нет ограничений по емкости, она сможет повысить быстродействие, если работа службы будет равномерно распределена по всему кластеру.

Обратите внимание, что если в службе определены какие-то пользовательские метрики, стандартные системные метрики использоваться не будут. Стандартные метрики можно использовать, но для этого при создании службы их необходимо повторно включить в список служебных метрик.

### Имена метрик
Чтобы создать пользовательскую метрику, нужно только определить ее имя при создании службы. Обратите внимание, что балансировщик ресурсов Service Fabric связывает метрики по их именам. Поэтому, если метрика емкости используется в определениях узлов или в нескольких службах, имена метрик должны быть совершенно одинаковыми, иначе балансировщик ресурсов Service Fabric не сможет связать их.

### Веса метрик
Если в службе определены несколько метрик, для них целесообразно определить веса. Разные веса метрик указывают балансировщику ресурсов Service Fabric на то, какая метрика имеет большую важность для работы службы. Например, на очередь в памяти может влиять пропускная способность сети, но больше всего на нее может влиять фактическое использование памяти на узле. Таким образом, если у очереди есть несколько метрик, наибольший вес будет иметь метрика, которая представляет использование памяти. Аналогичным образом работа постоянной базы данных может зависеть от объема памяти и места на диске, но если меньший объем памяти всего лишь сокращает возможности по обработке сложных запросов, то нехватка места на диске может заблокировать все дальнейшие операции по хранению, что, вероятно, является более критической ситуацией. Поэтому для постоянного хранилища метрикой с наибольшим весом будет, вероятно, место на диске.

Обратите внимание, что балансировщик ресурсов Service Fabric использует данные о весах только тогда, когда не может полностью сбалансировать набор метрик и ему нужно решить проблему, когда одна метрика менее сбалансирована, чем другая. В такой ситуации баланс метрики с меньшим весом будет иметь меньший приоритет, чем баланс метрики с более высоким весом, и балансировщик ресурсов Service Fabric отдаст предпочтение последней.

Кроме того, когда балансировщик ресурсов Service Fabric распознает, что для нескольких служб определены метрики с одинаковым именем, он считает эти метрики одинаковыми. В случаях, когда используется одна метрика с разными значениями веса, балансировщик ресурсов усредняет вес и использует в среде выполнения полученное среднее значение. Таким образом, если вес метрики в одной службе равен нулю (балансировка не требуется), а в другой службе та же метрика имеет большой вес, реальный вес будет где-то посредине.

![Веса метрик][Image3]

В этом примере показано два сценария с разными весами метрик. В каждом случае балансировщик ресурсов по-разному распределяет работу служб, так как метрики с высоким весом получают приоритет над метриками с низким весом. В примере слева лучше сбалансирована служба B, а в примере справа — служба А. Так как в этом примере невозможно сбалансировать обе метрики, балансировщик ресурсов Service Fabric определяет важность метрик по их весу. Следовательно, при балансировке приоритет отдается метрикам с более высоким весом.

Обратите внимание, что нулевой вес метрики используется тогда, когда служба только отслеживает эту метрику, но не требует балансировки по ней. Рассмотрим для примера метрику, в которой задано четкое ограничение на нескольких узлах, но для которой «равномерное распределение по узлам» (то, что делает балансировщик ресурсов) не имеет значения. Для типа метрик, которые не требуют балансировки, но отслеживают соблюдение ограничений на узлах, можно задать нулевой вес балансировки. В среде выполнения балансировщик ресурсов Service Fabric отслеживает емкость, но не пытается балансировать метрику на упреждение, даже если показатели этой метрики очень различаются на разных узлах.

### Метрики нагрузки по умолчанию для первичной или вторичной ролей
Если служба работает в первичной или вторичной роли, при определении служебной метрики следует указать уровень ожидаемого использования службы. Эти сведения не только помогут балансировщику ресурсов изначально разместить службу наиболее эффективным образом, но и позволят вам получить представление об использовании службы в разрезе соответствующей метрики в течение всего времени существования службы. Балансировщик ресурсов Service Fabric автоматически учитывает сведения об использовании службы не только при ее размещении, но и всякий раз, когда возникает необходимость переместить реплики для обеспечения баланса или в связи с другими изменениями в кластере. Если нагрузка службы вполне прогнозируема и стабильна, то во время выполнения эти значения позволят службе не сообщать о своей нагрузке.

В следующем примере кода показана служба, для которой полностью определены две пользовательские метрики: одна для использования памяти, а другая для использования места на диске.

``` cpp
ServiceLoadMetricDescription memoryMetric = new ServiceLoadMetricDescription();
memoryMetric.Name = "MemoryInMb";
memoryMetric.Weight = ServiceLoadMetricWeight.High;
memoryMetric.PrimaryDefaultLoad = 100;
memoryMetric.SecondaryDefaultLoad = 50;

ServiceLoadMetricDescription diskMetric = new ServiceLoadMetricDescription();
diskMetric.Name = "DiskInMb";
diskMetric.Weight = ServiceLoadMetricWeight.Medium;
diskMetric.PrimaryDefaultLoad = 1024;
diskMetric.SecondaryDefaultLoad = 750;

serviceDescription.Metrics.Add(memoryMetric);
serviceDescription.Metrics.Add(diskMetric);

Task t = fabricClient.ServiceManager.CreateServiceAsync(serviceDescription);
```

В этом примере кода показаны определения типов служб (ServiceTypes) в манифесте служб.

``` xml
<ServiceTypes>
  <StatefulServiceType ServiceTypeName="QueueReplica" HasPersistedState="true">
    <LoadMetrics>
      <LoadMetric Name="MemoryInMb" Weight="High" PrimaryDefaultLoad="100" SecondaryDefaultLoad="50"/>
      <LoadMetric Name="DiskInMb" Weight="Medium" PrimaryDefaultLoad="1024" SecondaryDefaultLoad="750"/>
    </LoadMetrics>
  </StatefulServiceType>
</ServiceTypes>
```

В этом примере кода показаны определения шаблонов служб (ServiceTemplates) в манифесте приложения.

``` xml
<ServiceTemplates>
   <StatefulService ServiceTypeName="QueueReplica">
     <SingletonPartition></SingletonPartition>
     <LoadMetrics>
       <LoadMetric Name="MemoryInMb" Weight="High" PrimaryDefaultLoad="100" SecondaryDefaultLoad="50"/>
       <LoadMetric Name="DiskInMb" Weight="Medium" PrimaryDefaultLoad="1024" SecondaryDefaultLoad="750"/>
     </LoadMetrics>
   </StatefulService>
 </ServiceTemplates>
```
В этом примере кода показаны определения служб по умолчанию (DefaultServices) в манифесте приложения.

``` xml
<DefaultServices>
  <Service Name="QueueServiceInstance">
    <StatefulService MinReplicaSetSize="3" ServiceTypeName="QueueService" TargetReplicaSetSize="3">
      <SingletonPartition/>
      <LoadMetrics>
        <LoadMetric Name="MemoryInMb" Weight="High" PrimaryDefaultLoad="100" SecondaryDefaultLoad="50"/>
        <LoadMetric Name="DiskInMb" Weight="Medium" PrimaryDefaultLoad="1024" SecondaryDefaultLoad="750"/>
      </LoadMetrics>
    </StatefulService>
  </Service>
</DefaultServices>
```

Так как значения нагрузки по умолчанию не обновляются, пока служба в среде выполнения специально не сообщит через код о своей нагрузке, с помощью этих значений также можно создать модель балансировки ресурсов «с резервированием мощности». Например, если рабочие нагрузки в целом соответствуют разным контейнерам размеров, а на узле в любое время можно разместить известное количество единиц работы, для «единиц работы» можно создать пользовательскую метрику и определять емкость узла и нагрузку службы по умолчанию, исходя из этих единиц.


<!--Every topic should have next steps and links to the next logical set of content to keep the customer engaged-->
## Дальнейшие действия

Подробнее об этом: [Архитектура балансировщика ресурсов](service-fabric-resource-balancer-architecture.md), [Ограничения на размещение](service-fabric-placement-constraint.md).

[Image1]: media/service-fabric-resource-balancer-service-description/PC.png
[Image2]: media/service-fabric-resource-balancer-service-description/DM.png
[Image3]: media/service-fabric-resource-balancer-service-description/MW.png
 

<!---HONumber=Oct15_HO3-->