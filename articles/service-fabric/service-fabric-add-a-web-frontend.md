<properties
   pageTitle="Создание внешнего веб-интерфейса для приложения | Microsoft Azure"
   description="Предоставление веб-доступа к приложению Service Fabric с помощью проекта веб-API ASP.NET 5 и взаимодействие между службами через ServiceProxy."
   services="service-fabric"
   documentationCenter=".net"
   authors="seanmck"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotNet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="11/21/2015"
   ms.author="seanmck"/>


# Построение внешнего интерфейса веб-службы приложения

По умолчанию службы Azure Service Fabric не предоставляют общедоступный интерфейс для веб-служб. Чтобы сделать свое приложение функциональным для клиентов HTTP, вам нужно создать веб-проект, который будет работать в качестве точки входа и обмениваться данными с отдельными службами.

В этом руководстве мы рассмотрим добавление в приложение внешнего интерфейса веб-API ASP.NET 5, который уже включает надежную службу, основанную на шаблоне проекта службы с отслеживанием состояния. Возможно, перед началом работы с этим руководством вам будет полезно просмотреть статью [Создание первого приложения в Visual Studio](service-fabric-create-your-first-application-in-visual-studio.md).


## Добавление в приложение службы ASP.NET 5

ASP.NET 5 — это легкое кросс-платформенное средство для разработки веб-страниц, позволяющее создавать современные пользовательские веб-интерфейсы и веб-интерфейсы API. Давайте добавим проект веб-API ASP.NET в существующее приложение.

1. В обозревателе решений щелкните **Службы** в проекте приложения правой кнопкой мыши и выберите параметр **Добавить Fabric Service**.

	![Добавление новой службы в существующее приложение][vs-add-new-service]

2. В диалоговом окне **Создание службы** выберите **ASP.NET 5** и укажите имя службы.

	![Выбор веб-службы ASP.NET в диалоговом окне создания службы][vs-new-service-dialog]

3. На следующей странице будет отображен набор шаблонов проектов ASP.NET 5. Обратите внимание, что это те же шаблоны, которые используются при создании проекта ASP.NET 5 вне приложения Service Fabric. В этом учебнике мы будем использовать **веб-API**. Однако те же идеи можно использовать и при построении полноценного веб-приложения.

	![Выбор типа проекта ASP.NET][vs-new-aspnet-project-dialog]

    После создания проекта веб-API в вашем приложении будут две службы. По мере построения приложения вам нужно будет добавлять дополнительные службы (таким же образом). Каждая из этих служб может быть отдельно обновлена, в том числе до определенной версии.

>[AZURE.NOTE]В выпуске общедоступной предварительной версии Service Fabric за ноябрь существуют известные проблемы с длинными путями при работе с проектами ASP.NET. При создании проектов таких типов лучше выбирать короткие имена для типов службы и приложения, а также для имен пакетов кода и пакетов конфигурации, чтобы избежать проблем.

## Выполнение приложения

Чтобы прояснить свои действия, мы развернем новое приложение и посмотрим на поведение по умолчанию, связанное с использованием шаблона веб-API ASP.NET 5.

1. В Visual Studio нажмите клавишу F5, чтобы начать отладку приложения.

2. После завершения развертывания Visual Studio запустит браузер и откроет в нем корневой каталог службы веб-API ASP.NET, например http://localhost:33003. Номер порта назначается случайным образом и может отличаться на вашем компьютере. Так как шаблон веб-API ASP.NET 5 не предоставляет поведение по умолчанию для корневого каталога, в браузере будет показано сообщение об ошибке.

3. В браузере добавьте к адресу путь `/api/values`. При этом будет вызван метод `Get` объекта ValuesController в шаблоне веб-API. Он вернет ответ по умолчанию, предоставленный шаблоном — массив JSON, который содержит две строки:

    ![Значения по умолчанию, возвращаемые шаблоном веб-API ASP.NET 5][browser-aspnet-template-values]

    В конце этого руководства мы заменим эти значения по умолчанию последним значением счетчика службы с отслеживанием состояния.


## Подключение служб

Service Fabric позволяет пользователям самим определять способ взаимодействия со службами Reliable Services. В одном приложении можно иметь службы, доступные по TCP, другие службы, которые доступны через HTTP REST API, и третьи службы, которые доступны через веб-сокеты. Сведения о доступных возможностях и их преимуществах и недостатках см. в статье [Обмен данными со службами](service-fabric-connect-and-communicate-with-services.md). В этом руководстве мы обратимся к одному из простых подходов, используя классы `ServiceProxy`/`ServiceRemotingListener`, предоставляемые в пакете SDK.

При использовании подхода `ServiceProxy` (моделируется с помощью удаленных вызовов процедур или RPC) определяется интерфейс, который будет выступать в качестве общедоступного контракта службы. Затем этот интерфейс используется для создания класса прокси для взаимодействия со службой.


### Создание интерфейса

Мы начнем с создания интерфейса, который будет выполнять роль контракта между службой с отслеживанием состояния и ее клиентами, включая веб-проект ASP.NET 5.

1. В обозревателе решений щелкните решение правой кнопкой мыши и выберите **Добавить** > **Новый проект**.

2. В области навигации слева выберите **Visual C#**, а затем — шаблон **Библиотека классов**. Убедитесь, что версия платформы .NET установлена в **4.5.1**.

    ![Создание проекта интерфейса для службы с отслеживанием состояния][vs-add-class-library-project]

3. Чтобы интерфейс мог использоваться `ServiceProxy`, он должен быть производным от интерфейса IService. Этот интерфейс входит в один из пакетов NuGet Service Fabric. Чтобы добавить пакет, щелкните правой кнопкой мыши проект библиотеки классов и выберите **Управление пакетами NuGet**.

4. Убедитесь, что флажок **Включить предварительный выпуск** установлен, а затем найдите пакет **Microsoft.ServiceFabric.Services** и установите его.

    ![Добавление пакета NuGet для служб][vs-services-nuget-package]

5. В библиотеке классов создайте интерфейс с помощью одиночного метода `GetCountAsync` и выполните расширение интерфейса из IService.

    ```c#
    namespace MyStatefulService.Interfaces
    {
        using Microsoft.ServiceFabric.Services.Remoting;

        public interface ICounter: IService
        {
            Task<long> GetCountAsync();
        }
    }
    ```


### Реализация интерфейса в службе с отслеживанием состояния

Теперь, когда мы определили интерфейс, нам нужно реализовать его в нашей службе с отслеживанием состояния.

1. В службе с отслеживанием состояния добавьте ссылку на проект библиотеки классов, содержащий интерфейс.

    ![Добавление ссылки на проект библиотеки классов в службе с отслеживанием состояния][vs-add-class-library-reference]

2. Найдите класс, который наследуется от `StatefulService`, например `MyStatefulService`, и выполните его расширение для реализации интерфейса `ICounter`.

    ```c#
    using MyStatefulService.Interfaces;

    ...

    public class MyStatefulService : StatefulService, ICounter
    {        
          // ...
    }
    ```

3. Теперь реализуйте одиночный метод `GetCountAsync`, определенный в интерфейсе `ICounter`.

    ```c#
    public async Task<long> GetCountAsync()
    {
      var myDictionary =
        await this.StateManager.GetOrAddAsync<IReliableDictionary<string, long>>("myDictionary");

        using (var tx = this.StateManager.CreateTransaction())
        {          
            var result = await myDictionary.TryGetValueAsync(tx, "Counter-1");
            return result.HasValue ? result.Value : 0;
        }
    }
    ```


### Предоставление службы с отслеживанием состояния с помощью ServiceRemotingListener

После реализации интерфейса `ICounter` последним шагом будет обеспечение возможности вызова службы с отслеживанием состояния из других служб посредством открытия коммуникационного канала. Для служб с отслеживанием состояния Service Fabric предоставляет переопределяемый метод под названием `CreateServiceReplicaListeners`. С помощью этого метода можно указать один или несколько прослушивателей связи, на основе типа связи, который вы хотите включить в службе.

>[AZURE.NOTE]Эквивалентный метод для открытия коммуникационного канала для службы без отслеживания состояния называется `CreateServiceInstanceListeners`.

В нашем случае мы заменим существующий метод `CreateServiceReplicaListeners` и укажем метод `ServiceRemotingListener`, который создает конечную точку RPC, которую клиенты будут вызывать с помощью `ServiceProxy`.

```c#
using Microsoft.ServiceFabric.Services.Remoting.Runtime;

...

protected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()
{
    return new List<ServiceReplicaListener>()
    {
        new ServiceReplicaListener(
            (initParams) =>
                new ServiceRemotingListener<ICounter>(initParams, this))
    };
}
```


### Использование класса ServiceProxy для взаимодействия со службой

Теперь наша служба с отслеживанием состояния готова получать трафик от других служб. Поэтому все, что остается — добавить код для взаимодействия с ней из веб-службы ASP.NET.

1. В проекте ASP.NET добавьте ссылку на проект библиотеки классов, которая содержит интерфейс `ICounter`.

2. Добавьте в проект ASP.NET пакет Microsoft.ServiceFabric.Services (так же, как и для проекта библиотеки классов ранее). Будет добавлен класс `ServiceProxy`.

3. В папке **Controllers** откройте класс `ValuesController`. Обратите внимание, что сейчас метод `Get` просто возвращает жестко запрограммированный массив строк значений value1 и value2, соответствующих тем, которые мы видели ранее в браузере. Замените эту реализацию следующим кодом:

    ```c#
    using MyStatefulService.Interfaces;
    using Microsoft.ServiceFabric.Services.Remoting.Client;

    ...

    public async Task<IEnumerable<string>> Get()
    {
        ICounter counter =
            ServiceProxy.Create<ICounter>(0, new Uri("fabric:/MyApp/MyStatefulService"));

        long count = await counter.GetCountAsync();

        return new string[] { count.ToString() };
    }
    ```

    Первая строка кода — ключевая. Чтобы добавить в службу с отслеживанием состояния прокси-сервер ICounter, необходимо предоставить два блока данных: идентификатор раздела и имя службы.

    Секционирование позволяет масштабировать службы с отслеживанием состояния, разбивая их состояние на разные сегменты на основе определенного ключа, например идентификатора клиента или почтового индекса. Так как в обычном приложении у службы с отслеживанием состояния есть только один раздел, ключ не имеет особого значения. При указании любого ключа будет создан один и тот же раздел. Дополнительные сведения о секционировании служб см. в статье [Секционирование надежных служб Service Fabric](service-fabric-concepts-partitioning).

    Имя службы — это универсальный код ресурса в формате fabric:/&lt;application\_name&gt;/&lt;service\_name&gt;.

    Service Fabric использует эти два блока информации для уникальной идентификации компьютера, на который должны отправляться запросы. `ServiceProxy` также согласованным образом выполняет переключение операций на другой компьютер, когда на компьютере с размещенным разделом службы с отслеживанием состояния происходит сбой. Эта абстракция значительно упрощает процесс написания кода клиента для работы с другими службами.

    После создания прокси-сервера мы просто вызываем метод `GetCountAsync`, который возвращает нужный результат.

4. Нажмите клавишу F5 еще раз, чтобы запустить измененное приложение. Visual Studio автоматически откроет в браузере корень веб-проекта. Добавьте путь api/values, и вы увидите возвращаемое текущее значение счетчика.

    ![Отображаемое в браузере значение счетчика с отслеживанием состояния][browser-aspnet-counter-value]

    Периодически обновляйте браузер, чтобы отслеживать актуальные показания счетчика.


## Обмен данными с субъектами

В этом руководстве описывается добавление веб-интерфейса для обеспечения связи со службой с отслеживанием состояния. Однако сходную модель можно использовать для обмена данными с субъектами. Это даже проще.

При создании проекта субъекта Visual Studio автоматически создает проект интерфейса. Этот интерфейс можно использовать для создания в веб-проекте прокси-сервера субъекта для взаимодействия с субъектом. Коммуникационный канал предоставляется автоматически. Поэтому вам не нужно предпринимать какие-либо действия по настройке `ServiceRemotingListener`, как в случае со службами с отслеживанием состояния.

## Как работают веб-службы на локальном кластере

Развернутое в локальном кластере приложение Service Fabric, как правило, можно развернуть в кластере с несколькими компьютерами. Это приложение будет работать должным образом. Это объясняется тем, что локальный кластер представляет собой конфигурацию из пяти узлов, расположенную на одном компьютере.

Однако с веб-службами связана одна ключевая особенность. Если кластер не включен в подсистему балансировки нагрузки, как это предусмотрено в среде Azure, вам нужно убедиться, что веб-службы развернуты на каждом компьютере. Это необходимо, так как балансировщик нагрузки будет просто выполнять циклический перебор трафика между компьютерами. Это можно сделать, указав для параметра `InstanceCount` службы особое значение: "-1".

Напротив, при выполнении веб-службы локально необходимо убедиться, что запущен только один экземпляр службы. В противном случае возникнут конфликты с несколькими процессами, которые прослушивают тот же путь и тот же порт. Поэтому для локальных развертываний счетчику экземпляров веб-службы нужно присвоить значение 1.

Дополнительные сведения о настройке разных значений для разных сред см. в статье [Управление параметрами приложения для нескольких сред](service-fabric-manage-multiple-environment-app-configuration.md).

## Дальнейшие действия

- [Создание кластера в Azure для развертывания приложения в облако](service-fabric-cluster-creation-via-portal.md)
- [Дополнительные сведения о взаимодействии со службами](service-fabric-connect-and-communicate-with-services.md)
- [Дополнительные сведения о секционировании служб с отслеживанием состояния](service-fabric-concepts-partitioning.md)

<!-- Image References -->

[vs-add-new-service]: ./media/service-fabric-add-a-web-frontend/vs-add-new-service.png
[vs-new-service-dialog]: ./media/service-fabric-add-a-web-frontend/vs-new-service-dialog.png
[vs-new-aspnet-project-dialog]: ./media/service-fabric-add-a-web-frontend/vs-new-aspnet-project-dialog.png
[browser-aspnet-template-values]: ./media/service-fabric-add-a-web-frontend/browser-aspnet-template-values.png
[vs-add-class-library-project]: ./media/service-fabric-add-a-web-frontend/vs-add-class-library-project.png
[vs-add-class-library-reference]: ./media/service-fabric-add-a-web-frontend/vs-add-class-library-reference.png
[vs-services-nuget-package]: ./media/service-fabric-add-a-web-frontend/vs-services-nuget-package.png
[browser-aspnet-counter-value]: ./media/service-fabric-add-a-web-frontend/browser-aspnet-counter-value.png

<!---HONumber=AcomDC_0114_2016-->