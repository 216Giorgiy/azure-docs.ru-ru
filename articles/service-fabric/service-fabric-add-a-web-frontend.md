<properties
   pageTitle="Создание внешнего веб-интерфейса для приложения с помощью ASP.NET Core | Microsoft Azure"
   description="Предоставление веб-доступа к приложению Service Fabric с помощью проекта веб-API ASP.NET Core и взаимодействие между службами через ServiceProxy."
   services="service-fabric"
   documentationCenter=".net"
   authors="seanmck"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotNet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="08/11/2016"
   ms.author="seanmck"/>


# Создание внешнего интерфейса веб-службы для приложения с помощью ASP.NET Core

По умолчанию службы Azure Service Fabric не предоставляют общедоступный интерфейс для веб-служб. Чтобы сделать свое приложение функциональным для клиентов HTTP, вам нужно создать веб-проект, который будет работать в качестве точки входа и обмениваться данными с отдельными службами.

Мы продолжим с того места, на котором остановились в руководстве по [созданию первого приложения в Visual Studio](service-fabric-create-your-first-application-in-visual-studio.md), и добавим веб-службу для службы счетчиков с отслеживанием состояния. Выполните соответствующие указания в этом руководстве, если вы этого еще не сделали.

## Добавление службы ASP.NET Core в приложение

ASP.NET Core — это простое кросс-платформенное средство для разработки веб-страниц, позволяющее создавать современные пользовательские веб-интерфейсы и интерфейсы веб-API. Давайте добавим проект веб-API ASP.NET в существующее приложение.

>[AZURE.NOTE] Для работы с этим учебником необходимо [установить .NET Core 1.0][dotnetcore-install].

1. В обозревателе решений в проекте приложения щелкните правой кнопкой мыши **Службы** и последовательно выберите **Добавить > Новая служба Service Fabric**.

	![Добавление новой службы в существующее приложение][vs-add-new-service]

2. На странице **Создание службы** выберите **ASP.NET Core** и укажите имя для этой службы.

	![Выбор веб-службы ASP.NET в диалоговом окне создания службы][vs-new-service-dialog]

3. На следующей странице представлен набор шаблонов проекта ASP.NET Core. Обратите внимание, что это те же шаблоны, которые используются при создании проекта ASP.NET Core вне приложения Service Fabric. В этом учебнике мы будем использовать **веб-API**. Однако те же идеи можно использовать и при построении полноценного веб-приложения.

	![Выбор типа проекта ASP.NET][vs-new-aspnet-project-dialog]

    После создания проекта веб-API в вашем приложении будут две службы. По мере построения приложения вам нужно будет добавлять дополнительные службы (таким же образом). Каждая из этих служб может быть отдельно обновлена, в том числе до определенной версии.

>[AZURE.TIP] Дополнительные сведения о создании служб ASP.NET Core см. в [документации по ASP.NET Core](https://docs.asp.net).

## Выполнение приложения

Чтобы прояснить свои действия, мы развернем новое приложение и рассмотрим поведение по умолчанию, связанное с использованием шаблона веб-API ASP.NET Core.

1. В Visual Studio нажмите клавишу F5, чтобы начать отладку приложения.

2. После завершения развертывания Visual Studio запустит браузер и откроет в нем корневой каталог службы веб-API ASP.NET, например http://localhost:33003. Номер порта назначается случайным образом и может отличаться на вашем компьютере. Так как шаблон веб-API ASP.NET Core не предоставляет поведение по умолчанию для корневого каталога, в браузере будет показано сообщение об ошибке.

3. В браузере добавьте к адресу путь `/api/values`. При этом будет вызван метод `Get` объекта ValuesController в шаблоне веб-API. Он вернет ответ по умолчанию, предоставленный шаблоном — массив JSON, который содержит две строки:

    ![Значения по умолчанию, возвращаемые шаблоном веб-API ASP.NET Core][browser-aspnet-template-values]

    В конце этого руководства мы заменим эти значения по умолчанию последним значением счетчика службы с отслеживанием состояния.


## Подключение служб

Service Fabric позволяет пользователям самим определять способ взаимодействия со службами Reliable Services. В одном приложении можно иметь службы, доступные по TCP, другие службы, которые доступны через HTTP REST API, и третьи службы, которые доступны через веб-сокеты. Сведения о доступных возможностях и их преимуществах и недостатках см. в статье о [взаимодействии со службами](service-fabric-connect-and-communicate-with-services.md). В этом руководстве мы воспользуемся одним из более простых подходов и используем классы `ServiceProxy`/`ServiceRemotingListener`, предоставляемые в пакете SDK.

При использовании подхода `ServiceProxy` (на основе удаленных вызовов процедур, или RPC) определяется интерфейс, который будет выступать в качестве общедоступного контракта службы. Затем этот интерфейс используется для создания класса прокси для взаимодействия со службой.


### Создание интерфейса

Мы начнем с создания интерфейса, который будет выполнять роль контракта между службой с отслеживанием состояния и ее клиентами, включая веб-проект ASP.NET Core.

1. В обозревателе решений щелкните решение правой кнопкой мыши и выберите **Добавить** > **Новый проект**.

2. В области навигации слева выберите **Visual C#**, а затем — шаблон **Библиотека классов**. Для платформы .NET Framework должна быть установлена версия **4.5.2**.

    ![Создание проекта интерфейса для службы с отслеживанием состояния][vs-add-class-library-project]

3. Чтобы интерфейс мог использоваться `ServiceProxy`, он должен быть производным от интерфейса IService. Этот интерфейс входит в один из пакетов NuGet Service Fabric. Чтобы добавить пакет, щелкните правой кнопкой мыши проект библиотеки классов и выберите **Управление пакетами NuGet**.

4. Найдите пакет **Microsoft.ServiceFabric.Services** и установите его.

    ![Добавление пакета NuGet для служб][vs-services-nuget-package]

5. В библиотеке классов создайте интерфейс с помощью одиночного метода `GetCountAsync` и выполните расширение интерфейса из IService.

    ```c#
    namespace MyStatefulService.Interfaces
    {
        using Microsoft.ServiceFabric.Services.Remoting;

        public interface ICounter: IService
        {
            Task<long> GetCountAsync();
        }
    }
    ```


### Реализация интерфейса в службе с отслеживанием состояния

Теперь, когда мы определили интерфейс, нам нужно реализовать его в нашей службе с отслеживанием состояния.

1. В службе с отслеживанием состояния добавьте ссылку на проект библиотеки классов, содержащий интерфейс.

    ![Добавление ссылки на проект библиотеки классов в службе с отслеживанием состояния][vs-add-class-library-reference]

2. Найдите класс, который наследуется от `StatefulService`, например `MyStatefulService`, и выполните его расширение для реализации интерфейса `ICounter`.

    ```c#
    using MyStatefulService.Interfaces;

    ...

    public class MyStatefulService : StatefulService, ICounter
    {        
          // ...
    }
    ```

3. Теперь реализуйте одиночный метод `GetCountAsync`, определенный в интерфейсе `ICounter`.

    ```c#
    public async Task<long> GetCountAsync()
    {
      var myDictionary =
        await this.StateManager.GetOrAddAsync<IReliableDictionary<string, long>>("myDictionary");

        using (var tx = this.StateManager.CreateTransaction())
        {          
            var result = await myDictionary.TryGetValueAsync(tx, "Counter");
            return result.HasValue ? result.Value : 0;
        }
    }
    ```


### Предоставление службы с отслеживанием состояния с помощью прослушивателя удаленного взаимодействия в службе

После реализации интерфейса `ICounter` последним шагом будет обеспечение возможности вызова службы с отслеживанием состояния из других служб посредством открытия коммуникационного канала. Для служб с отслеживанием состояния Service Fabric предоставляет переопределяемый метод `CreateServiceReplicaListeners`. С помощью этого метода можно указать один или несколько прослушивателей связи, на основе типа связи, который вы хотите включить в службе.

>[AZURE.NOTE] Эквивалентный метод для открытия коммуникационного канала для службы без отслеживания состояния называется `CreateServiceInstanceListeners`.

В нашем случае мы заменим имеющийся метод `CreateServiceReplicaListeners` и укажем экземпляр `ServiceRemotingListener`, который создает конечную точку RPC, вызываемую с клиентов с помощью `ServiceProxy`.

```c#
using Microsoft.ServiceFabric.Services.Remoting.Runtime;

...

protected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()
{
    return new List<ServiceReplicaListener>()
    {
        new ServiceReplicaListener(
            (context) =>
                this.CreateServiceRemotingListener(context))
    };
}
```


### Использование класса ServiceProxy для взаимодействия со службой

Теперь наша служба с отслеживанием состояния готова получать трафик от других служб. Поэтому все, что остается — добавить код для взаимодействия с ней из веб-службы ASP.NET.

1. В проекте ASP.NET добавьте ссылку на библиотеку классов, которая содержит интерфейс `ICounter`.

2. В меню **Сборка** откройте **диспетчер конфигураций**. Вы увидите нечто вроде этого:

    ![Диспетчер конфигураций, отображающий библиотеку класса как AnyCPU ("Любой ЦП")][vs-configuration-manager]

    Обратите внимание, что для проекта библиотеки классов, **MyStatefulService.Interface**, выбран вариант Any CPU ("Любой ЦП"). Чтобы нормально работать с Service Fabric, его нужно вручную настроить для работы с 64-разрядной архитектурой. Щелкните раскрывающееся меню "Платформа", выберите элемент **Создать** и создайте конфигурацию 64-разрядной платформы.

    ![Создание платформы для библиотеки класса][vs-create-platform]

3. Добавьте в проект ASP.NET пакет Microsoft.ServiceFabric.Services (так же, как и для проекта библиотеки классов ранее). Будет добавлен класс `ServiceProxy`.

4. В папке **Контроллеры** откройте класс `ValuesController`. Обратите внимание, что сейчас метод `Get` просто возвращает жестко запрограммированный строковый массив значений value1 и value2, соответствующих тем, которые мы видели ранее в браузере. Замените эту реализацию следующим кодом:

    ```c#
    using MyStatefulService.Interfaces;
    using Microsoft.ServiceFabric.Services.Remoting.Client;

    ...

    public async Task<IEnumerable<string>> Get()
    {
        ICounter counter =
            ServiceProxy.Create<ICounter>(new Uri("fabric:/MyApplication/MyStatefulService"), new ServicePartitionKey(0));

        long count = await counter.GetCountAsync();

        return new string[] { count.ToString() };
    }
    ```

    Первая строка кода — ключевая. Чтобы добавить в службу с отслеживанием состояния прокси-сервер ICounter, необходимо предоставить два блока данных: идентификатор раздела и имя службы.

    Секционирование позволяет масштабировать службы с отслеживанием состояния, разбивая их состояние на разные сегменты на основе определенного ключа, например идентификатора клиента или почтового индекса. Так как в обычном приложении у службы с отслеживанием состояния есть только один раздел, ключ не имеет особого значения. При указании любого ключа будет создан один и тот же раздел. Дополнительные сведения о секционировании служб см. в статье [Секционирование надежных служб Service Fabric](service-fabric-concepts-partitioning.md).

    Имя службы — это универсальный код ресурса в формате fabric:/&lt;application\_name&gt;/&lt;service\_name&gt;.

    Service Fabric использует эти два блока информации для уникальной идентификации компьютера, на который должны отправляться запросы. Класс `ServiceProxy` также согласованно переключает операции на другой компьютер, когда на компьютере с размещенной секцией службы с отслеживанием состояния происходит сбой. Эта абстракция значительно упрощает процесс написания кода клиента для работы с другими службами.

    После создания прокси-сервера мы просто вызываем метод `GetCountAsync`, который возвращает нужный результат.

5. Нажмите клавишу F5 еще раз, чтобы запустить измененное приложение. Visual Studio автоматически откроет в браузере корень веб-проекта. Добавьте путь api/values, и вы увидите возвращаемое текущее значение счетчика.

    ![Отображаемое в браузере значение счетчика с отслеживанием состояния][browser-aspnet-counter-value]

    Периодически обновляйте браузер, чтобы отслеживать актуальные показания счетчика.


>[AZURE.WARNING] Для веб-сервера ASP.NET Core, указанного в шаблоне и известного как Kestrel, [не поддерживается обработка прямого трафика Интернета](https://docs.asp.net/en/latest/fundamentals/servers.html#kestrel). Для рабочих сценариев рассмотрите возможность размещения конечных точек ASP.NET Core за службой [управления API][api-management-landing-page] или другим шлюзом с доступом в Интернет. Обратите внимание, что Service Fabric не поддерживается для развертывания в службах IIS.


## Обмен данными с субъектами

В этом руководстве описывается добавление веб-интерфейса для обеспечения связи со службой с отслеживанием состояния. Однако сходную модель можно использовать для обмена данными с субъектами. Это даже проще.

При создании проекта субъекта Visual Studio автоматически создает проект интерфейса. Этот интерфейс можно использовать для создания в веб-проекте прокси-сервера субъекта для взаимодействия с субъектом. Коммуникационный канал предоставляется автоматически. Поэтому вам не нужно предпринимать какие-либо действия по настройке `ServiceRemotingListener`, как в случае со службами с отслеживанием состояния.

## Как работают веб-службы на локальном кластере

Развернутое в локальном кластере приложение Service Fabric, как правило, можно развернуть в кластере с несколькими компьютерами. Это приложение будет работать должным образом. Это объясняется тем, что локальный кластер представляет собой конфигурацию из пяти узлов, расположенную на одном компьютере.

Однако с веб-службами связана одна ключевая особенность. Если кластер не включен в подсистему балансировки нагрузки, как это предусмотрено в среде Azure, вам нужно убедиться, что веб-службы развернуты на каждом компьютере. Это необходимо, так как балансировщик нагрузки будет просто выполнять циклический перебор трафика между компьютерами. Это можно сделать, указав для параметра `InstanceCount` службы особое значение: "-1".

Напротив, при выполнении веб-службы локально необходимо убедиться, что запущен только один экземпляр службы. В противном случае возникнут конфликты с несколькими процессами, которые прослушивают тот же путь и тот же порт. Поэтому для локальных развертываний счетчику экземпляров веб-службы нужно присвоить значение 1.

Дополнительные сведения о настройке разных значений для разных сред см. в статье [Управление параметрами приложения для нескольких сред](service-fabric-manage-multiple-environment-app-configuration.md).

## Дальнейшие действия

- [Создание кластера в Azure для развертывания приложения в облако](service-fabric-cluster-creation-via-portal.md)
- [Дополнительные сведения о взаимодействии со службами](service-fabric-connect-and-communicate-with-services.md)
- [Дополнительные сведения о секционировании служб с отслеживанием состояния](service-fabric-concepts-partitioning.md)

<!-- Image References -->

[vs-add-new-service]: ./media/service-fabric-add-a-web-frontend/vs-add-new-service.png
[vs-new-service-dialog]: ./media/service-fabric-add-a-web-frontend/vs-new-service-dialog.png
[vs-new-aspnet-project-dialog]: ./media/service-fabric-add-a-web-frontend/vs-new-aspnet-project-dialog.png
[browser-aspnet-template-values]: ./media/service-fabric-add-a-web-frontend/browser-aspnet-template-values.png
[vs-add-class-library-project]: ./media/service-fabric-add-a-web-frontend/vs-add-class-library-project.png
[vs-add-class-library-reference]: ./media/service-fabric-add-a-web-frontend/vs-add-class-library-reference.png
[vs-services-nuget-package]: ./media/service-fabric-add-a-web-frontend/vs-services-nuget-package.png
[browser-aspnet-counter-value]: ./media/service-fabric-add-a-web-frontend/browser-aspnet-counter-value.png
[vs-configuration-manager]: ./media/service-fabric-add-a-web-frontend/vs-configuration-manager.png
[vs-create-platform]: ./media/service-fabric-add-a-web-frontend/vs-create-platform.png


<!-- external links -->
[dotnetcore-install]: https://www.microsoft.com/net/core#windows
[api-management-landing-page]: https://azure.microsoft.com/services/api-management/

<!---HONumber=AcomDC_0817_2016-->
