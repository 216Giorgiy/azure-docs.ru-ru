
<properties
   pageTitle="Шаблон композиции службы с отслеживанием состояния | Microsoft Azure"
   description="Конструктивный шаблон Reliable Actors Service Fabric, в котором используются субъекты с отслеживанием состояния для поддержания состояния между вызовами служб, а также для кэширования предыдущих результатов работы служб."
   services="service-fabric"
   documentationCenter=".net"
   authors="vturecek"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="08/05/2015"
   ms.author="vturecek"/>

# Конструктивный шаблон Reliable Actors: построение служб с отслеживанием состояния

Разработчики последние полтора десятилетия строили N-уровневые службы без отслеживания состояния на предприятиях. Они строили службы поверх баз данных. Они строили службы высокого порядка поверх других служб. Затем они создавали механизмы оркестрации и ПО промежуточного слоя, ориентированное на сообщения, для координации этих служб. По мере эволюции пользовательских рабочих нагрузок, будь то требование к большей интерактивности или масштабу, архитектура, ориентированная на службы без отслеживания состояния (SOA), начала проявлять свои недостатки.

## Старый способ: службы SOA

Хотя службы SOA легко масштабировались горизонтально из-за их характера, не предусматривающего отслеживание состояния, на уровне хранения они создавали проблемы для параллелизма и пропускной способности. Поэтому доступ к хранилищу стал очень дорогим. Большинство разработчиков взяли за правило вводить в свои решения кэширование, чтобы снизить потребности в хранилище. Хотя этот способ тоже имеет свои недостатки. Для него требуется еще один уровень, предназначенный для управления, одновременного доступа к кэшу, семантических ограничений и изменений, а также согласованности. Как было описано ранее [в разделе о шаблоне смарт-кэша](service-fabric-reliable-actors-pattern-smart-cache.md), модель виртуальных субъектов обеспечивает идеальное решение этих проблем. Некоторые разработчики пытаются решить проблемы SOA путем репликации уровня хранилища. Однако этот подход не обеспечивает эффективное масштабирование и быстро достигает границ общего протокола предупреждений.

Вторая проблема эволюционировала с учетом меняющихся требований. И пользователи, и компании считают нормой интерактивные службы, которые могут отвечать на запросы в течение миллисекунд, а не секунд. Для удовлетворения этой потребности разработчики начали строить фасадные службы поверх других служб. В некоторых случаях разработаны десятки фасадных служб, специально предназначенные для создания служб, ориентированных на пользователя. Однако добавление множества нижестоящих служб быстро создает проблемы задержки.

Разработчики также взялись за кэши и хранилища объектов в памяти. В некоторых случаях понадобилось использовать различные реализации для соблюдения требований к производительности. При таком подходе разработчики обычно создают внутренние рабочие процессы для периодического построения кэша. Это минимизирует дорогое заполнение кэша по требованию. Затем они деконструируют свои рабочие нагрузки, чтобы изолировать асинхронные операции от синхронных. Такой подход дает больше пространства для интерактивных операций, которые реагируют на изменения в состоянии. Это особенно трудно реализовать в SOA.

Разработчики также часто вводят дополнительные уровни, такие как очереди и рабочие процессы. Эти уровни могут еще больше усложнить их решения.

По сути разработчики ищут решения для построения "служб с отслеживанием состояния", в которых совмещается "состояние" и "поведение служб" для обеспечения ориентированных на пользователя и интерактивных взаимодействий. Для этого и нужна модель Reliable Actors Azure Service Fabric, представляющая уровень совмещения служб, а не решение для их замены.

Этот сценарий показан на схеме ниже:

![Reliable Actors, построение службы и сохранение состояния][1]

## Реализация лучших решений с помощью субъектов

При составлении служб субъекты могут предусматривать или не предусматривать отслеживание состояния.

* Субъекты без отслеживания состояния можно использовать как прокси-объекты для базовых служб. Такие субъекты могут динамически масштабироваться в кластере Azure Service Fabric и кэшировать определенные сведения, связанные со службой, например сведения о конечной точке службы после ее обнаружения.
* Субъекты с отслеживанием состояния могут поддерживать состояние между вызовами служб, а также кэшировать предыдущие результаты служб. Состояние может быть постоянным или переходным.

Этот шаблон применяется во многих сценариях. В большинстве случаев субъект должен с помощью внешнего вызова вызывать операцию для определенной службы. Рассмотрим эту ситуацию, используя пример из современного приложения электронной коммерции. Такие приложения строятся на основе служб, обеспечивающих работу различных функций, включая управление профилями пользователей, рекомендации, управление корзиной, управление списком желаний и покупку.

Большинство разработчиков приложений для электронной коммерции стараются применять в своей архитектуре ориентированный на пользователей подход. Это напоминает разработку приложений для социальных сетей. Это связано с тем, что работа приложений для электронной коммерции также опирается в основном на пользователей и продукты. Обычно решения разработчика можно реализовать за счет поставки фасада служб, который, скорее всего, будет поддерживаться кэшем в целях производительности.

Сравните это с подходом с использованием субъектов. Субъект пользователя может представлять поведение пользователя (например, просмотр каталога, предпочтение продукта, добавление элемента в корзину или рекомендация продукта другу). Но он также может представлять составное состояние пользователя, в том числе профиль пользователя, элементы в корзине, товары, рекомендованные друзьями, истории покупок пользователя и географическое положение текущего пользователя.

## Заполнение состояния с помощью субъектов с отслеживанием состояния

Сначала рассмотрим пример, в котором субъекту пользователя необходимо заполнять свое состояние из нескольких служб. Для этого примера мы не будем предоставлять образец кода, так как здесь применимо все, что обсуждалось в [разделе о шаблоне смарт-кэша](service-fabric-reliable-actors-pattern-smart-cache.md). Субъект пользователя можно активировать во время входа в систему и заполнить достаточными данными из внутренних служб. Состояния также могут быть предварительно заполнены полностью или частично по требованию и (или) по таймеру и могут кэшироваться в субъекте. Ниже показаны службы **Profile** (Профиль) и **Wish List** (Список желаний) для данного примера:

![Службы Profile и Wish List][2]

Разработчики могут предварительно заполнять состояние регулярных пользователей и подготавливать его, когда они входят в приложение. Разработчики также могут заполнять состояние во время входа пользователя, посещающего службу каждый месяц. Вы можете увидеть эти шаблоны в разделе, посвященном смарт-кэшу.

Во время входа пользователя 23 (как показано на рисунке выше) субъект пользователя (23) активируется, если он еще не был активирован. Затем субъект пользователя извлекает сведения о профиле соответствующего пользователя, а также список желаний из внутренних служб. Скорее всего, субъект пользователя также кэширует эти сведения для последующих вызовов. Если, например, элемент должен быть добавлен в список желаний, это достигается путем отложенной или сквозной записи, как описано выше.

Теперь давайте рассмотрим пример, когда пользователь нажимает кнопку **Нравится**, чтобы отметить продукт как понравившийся. Для этого действия могут потребоваться несколько вызовов различных служб. Эти операции могут включать отправку предпочтения в службу каталога, активацию следующего набора рекомендаций и публикацию обновления в социальную сеть.

Вот как это можно сделать:

![Предпочтение продукта, а также службы Wish List, Profile и Catalog][3]

## Использование субъектов в композиции и асинхронный обмен данными
Все преимущества модели программирования Reliable Actors Azure Service Fabric можно оценить, когда требуется сочетать операции запроса и ответа с асинхронными операциями. Например, нажатие кнопки "Мне нравится продукт" немедленно помещает понравившийся товар в список желаний пользователя, а публикация в социальных сетях и активация следующего набора рекомендаций могут быть асинхронными операциями с использованием буферов и таймеров.

Другое важное преимущество использования субъекта пользователя для служб заключается в том, что субъект предоставляет естественное место для кэшированного состояния. Самое главное, что на изменения своего состояния субъект также реагирует асинхронно. Этот сценарий является особенно проблемным при использовании служб без отслеживания состояния. Например, пользователь может выполнить ряд действий в рамках пути взаимодействия пользователя, и эти события могут записываться в субъект в режиме реального времени. Затем может быть собран поток, который может запрашиваться во время событий или асинхронно по таймеру для изменения поведения субъекта.

На этом этапе приверженцы SOA, без сомнения, заметят, что это не службы в значении субъектов как конечных точек, предоставляемых посредством протокола, независимого от языка. Модель Reliable Actors Service Fabric не является ни компонентом взаимодействия, ни платформой для взаимодействия служб. Но разработчикам ничто не мешает мыслить категориями детализации служб в стиле SOA во время моделирования субъектов или разделения проблем таким же образом. Такие службы называются микрослужбами. Также разработчиками ничто не мешает разместить конечную точку REST или SOAP в качестве уровня взаимодействия перед Reliable Actors Service Fabric.

Затем составление служб с отслеживанием состояния применяется также к рабочим процессам, а не только к транзакционным сценариям вроде электронной коммерции. Платформа Service Fabric разработана как механизм рабочих процессов и оркестрации. Ее можно использовать для моделирования рабочих потоков, которые включают взаимодействие служб и поддержку состояния этих взаимодействий.

Вы можете увидеть недостатки службы без отслеживания состояния во время построения масштабируемых служб, обеспечивающих динамическое взаимодействие. Благодаря объединению состояния и поведения модель программирования Reliable Actors Service Fabric помогает разработчикам строить масштабируемые и интерактивные процессы взаимодействия в дополнение к уже существующим инвестициям.


## Дальнейшие действия

[Конструктивный шаблон Reliable Actors: смарт-кэш](service-fabric-reliable-actors-pattern-smart-cache.md)

[Конструктивный шаблон Reliable Actors: распределенные сети и графы](service-fabric-reliable-actors-pattern-distributed-networks-and-graphs.md)

[Конструктивный шаблон Reliable Actors: управление ресурсами](service-fabric-reliable-actors-pattern-resource-governance.md)

[Шаблон: Интернет вещей](service-fabric-reliable-actors-pattern-internet-of-things.md)

[Конструктивный шаблон Reliable Actors: распределенные вычисления](service-fabric-reliable-actors-pattern-distributed-computation.md)

[Конструктивный шаблон Reliable Actors: некоторые антишаблоны](service-fabric-reliable-actors-anti-patterns.md)

[Общие сведения о надежных субъектах Service Fabric](service-fabric-reliable-actors-introduction.md)


<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-1.png
[2]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-2.png
[3]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-3.png

<!---HONumber=AcomDC_0121_2016-->