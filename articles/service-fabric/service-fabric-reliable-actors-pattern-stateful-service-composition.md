
<properties
   pageTitle="Шаблон разработки субъектов Azure Service Fabric: составление служб с отслеживанием состояний"
   description="Шаблон разработки субъектов Service Fabric, в котором используются субъекты с отслеживанием состояния для поддержания состояния между вызовами служб, а также для кэширования предыдущих результатов работы служб. Состояние может быть постоянным или переходным."
   services="service-fabric"
   documentationCenter=".net"
   authors="jessebenson"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="04/01/2015"
   ms.author="claudioc"/>

# Шаблон проектирования субъектов Service Fabric: построение служб с отслеживанием состояния
Разработчики последние полтора десятилетия строили N-уровневые службы без отслеживания состояния на предприятиях. Они создавали службы поверх баз данных, службы высокого порядка поверх других служб, а также механизмы оркестрации и ориентированный на сообщения промежуточный слой для координации этих служб. По мере эволюции пользовательских рабочих нагрузок, будь то требование к большей интерактивности или масштабу, архитектура, ориентированная на службы без отслеживания состояния, начала показывать свои слабости.

## Старый способ: службы SOA
В то время как службы SOA масштабировались горизонтально без проблем из-за своего характера, не предусматривающего отслеживания состояний, они создавали узкое место на уровне хранения для параллелизма и пропускной способности. Доступ к хранилищу становился все более дорогостоящим. В качестве распространенной практики большинство разработчиков внедрило в свои решения кэширование, чтобы сократить требования к хранению данных. Но это решение не было лишено своих минусов: еще один уровень для управления, одновременный доступ к кэшу, семантические ограничения и изменения и, наконец, согласованность. Как было описано ранее в разделе о шаблоне смарт-кэш, модель виртуальных субъектов обеспечивает для этого идеальное решение.

Некоторые разработчики пытались решить проблему путем репликации уровня хранения. Однако такой подход не масштабировался как следует и быстро достигал пределов CAP. Вторая проблема эволюционировала вокруг меняющихся требований. Как конечным пользователям, так и компаниям требуются интерактивные услуги, для которых нормой является ответ на запрос в течение миллисекунд, а не секунд. Отвечая на этот запрос, разработчики начали строить фасадные службы поверх других служб, в некоторых случаях — в количестве десятков, для создания служб, ориентированных на пользователя. Однако составление множества нижестоящих служб быстро показало проблемы с задержкой.

Еще раз разработчики вернулись к кэшам и хранилищам объектов в памяти, в некоторых случаях с разными реализациями для выполнения требований производительности. Они начали строить внутренние процессы-исполнители для периодического построения кэша, чтобы минимизировать затратное заполнение кэша по требованию. Наконец, они начали деконструкцию рабочих нагрузок, чтобы изолировать асинхронные операции от синхронных и получить больше места для интерактивных операций с реакцией на изменения состояния, что особо трудно осуществить в SOA.

Были внедрены дополнительные уровни, такие как очереди и исполнители, что добавило еще больше сложности в решения. По сути разработчики начали искать решения для построения «служб с отслеживанием состояния», то есть чтобы совместить «состояние» и «поведение служб» для обеспечения ориентированных на пользователя и интерактивных взаимодействий. И вот когда появляются субъекты Azure Service Fabric в качестве уровня составления служб, а не в качестве замены для этих служб.

Этот момент показан на схеме ниже:

![][1]

## Улучшение решения с помощью субъектов
В случае составления служб субъекты могут предусматривать или не предусматривать отслеживание состояния.

* Субъекты без отслеживания состояния можно использовать как прокси-серверы для базовых служб. Такие субъекты могут динамически масштабироваться в кластере Azure Service Fabric и кэшировать определенные сведения, связанные со службой, например сведения о ее конечной точке после обнаружения таковой.
* Субъект с отслеживанием состояния может поддерживать состояние между вызовами служб, а также кэшировать предыдущие результаты служб. Состояние может быть постоянным или переходным.

Этот шаблон также может применяться для многих сценариев. В большинстве случаев субъекты должны осуществлять внешние вызовы, чтобы задействовать операцию конкретной службы. Давайте проиллюстрируем это в примере с использованием современных приложений электронной коммерции. Такие приложения строятся на основе служб, обеспечивающих различную функциональность, например управление профилями пользователей, рекомендации, управление корзиной, управление списком желаний, покупку и многое другое.

Большинство разработчиков придерживается ориентированного на пользователя подхода к архитектуре, что очень похоже на разработку социальных сетей, поскольку процессы электронной коммерции в основном вращаются вокруг пользователей и продуктов. Обычно это достигается за счет поставки фасада служб, вероятнее всего поддерживаемых кэшем в целях производительности.

Теперь давайте обсудим подход на основе субъектов. Субъект пользователя может представлять как поведение пользователя (просмотр каталога, предпочтение продукта, добавление элемента в корзину, рекомендация продукта другу), так и свое составное состояние — профиль, элементы в корзине, список товаров, рекомендованных друзьями, их историю покупок, текущее географическое местоположение и т. д.

## Использование субъектов с отслеживанием состояния
Сначала рассмотрим пример, где субъекту пользователя необходимо заполнять свое состояние из нескольких служб. Для этого примера мы не будем предоставлять образец кода, поскольку здесь применимо все, что обсуждалось в разделе о шаблоне смарт-кэш. Мы можем активировать субъект пользователя во время входа в систему, заполняя его достаточными данными из внутренних служб. Разумеется, как мы уже наблюдали во многих случаях ранее в данном документе, состояние может предварительно заполняться полностью или частично по запросу, по таймеру или с элементами того и другого, и кэшироваться в субъекте. Ниже показаны профиль и список желаний для данного примера:

![][2]

Например, мы можем предварительно заполнить состояние частых пользователей и подготовить его при их входе или заполнять состояние во время входа пользователей, посещающих службу каждый месяц. Мы видели эти шаблоны в разделе «Смарт-кэш».

При входе пользователя 23, если он еще не активирован, субъект пользователя (23) активируется и извлекает сведения о профиле соответствующего пользователя и его список желаний из внутренних служб. Скорее всего, субъект пользователя кэширует эти сведения для последующих вызовов. А если необходимо добавить товар в список желаний, мы можем выполнить запись с задержкой или сквозную запись, как уже было сказано ранее. Во-вторых, давайте рассмотрим пример, когда пользователь нажимает кнопку «Мне нравится» и отмечает продукт как понравившийся. Это действие может потребовать нескольких вызовов различных служб, как показано ниже: отправка «Мне нравится» в службу каталога, запуск следующего набора рекомендаций и, возможно, публикация обновления в социальной сети.

Вот как это можно сделать:

![][3]

## Как могут помочь составление субъектов и асинхронный обмен данными
Фактически субъекты Azure Service Fabric проявляются в полной мере тогда, когда требуется сочетать операции запроса и ответа вместе с асинхронными операциями. Например, в то время как нажатие кнопки «Мне нравится продукт» немедленно помещает понравившийся товар в список желаний пользователя, публикация в социальных сетях и запуск следующего набора рекомендаций могут быть асинхронными операциями с использованием буферов и таймеров.

Еще одно ключевое преимущество использования субъекта пользователя со службами в том, что субъекты предоставляют естественное место для кэширования состояния и, что самое главное, реагируют на изменения своего состояния асинхронно. Этот сценарий является особенно проблемным при использовании служб без отслеживания состояния. Например, пользователь выполняет ряд операций, возможно, в рамках своего «путешествия» по сайту. Эти события могут перехватываться в реальном времени в субъекте, и мы можем собрать поток, который будем опрашивать во время событий или асинхронно по таймеру для изменения поведения субъекта.

На этом этапе пуристы SOA несомненно заметят, что это не службы в значении объектов как конечных точек, предоставляемых посредством протокола, независимого от языка. Субъекты Azure Service Fabric не являются ни компонентом взаимодействия, ни платформой для взаимодействия служб. Тем не менее, нам ничего не мешает размышлять о детализации служб в стиле SOA при моделировании субъектов или при моделировании разделения областей ответственности таким же образом. Такие службы называются «микрослужбами». Точно так же нам ничего не мешает установить конечную точку REST или конечную точку SOAP в качестве уровня взаимодействия перед субъектами Azure Service Fabric.

Составление служб с отслеживанием состояний применяется также к рабочим процессам, а не только к транзакционным сценариям вроде электронной коммерции. Azure Service Fabric спроектирована в виде механизма рабочих процессов и оркестровки, поэтому ее можно использовать для моделирования рабочих процессов, предусматривающих взаимодействие служб, с поддержанием состояния таких взаимодействий.

Мы видим недостатки «службы без отслеживания состояния» при построении масштабируемых служб для обеспечения динамических взаимодействий. Субъекты Service Fabric Actors, в особенности благодаря объединению состояния и поведения, помогают разработчикам строить масштабируемые и интерактивные процессы взаимодействия поверх существующих вложений.


## Дальнейшие действия
[Шаблон: смарт-кэш](service-fabric-reliable-actors-pattern-smart-cache.md)

[Шаблон: распределенные сети и графы](service-fabric-reliable-actors-pattern-distributed-networks-and-graphs.md)

[Шаблон: управление ресурсами](service-fabric-reliable-actors-pattern-resource-governance.md)

[Шаблон: Интернет вещей](service-fabric-reliable-actors-pattern-internet-of-things.md)

[Шаблон: распределенные вычисления](service-fabric-reliable-actors-pattern-distributed-computation.md)

[Некоторые антишаблоны](service-fabric-reliable-actors-anti-patterns.md)

[Общие сведения о субъектах Service Fabric](service-fabric-reliable-actors-introduction.md)


<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-1.png
[2]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-2.png
[3]: ./media/service-fabric-reliable-actors-pattern-stateful-service-composition/stateful-service-composition-3.png
 

<!---HONumber=July15_HO4-->