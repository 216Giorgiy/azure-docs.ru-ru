<properties
   pageTitle="Общие сведения о субъектах Azure Service Fabric"
   description="Общие сведения о модели программирования на основе субъектов Azure Service Fabric."
   services="service-fabric"
   documentationCenter=".net"
   authors="jessebenson"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="03/02/2015"
   ms.author="claudioc"/>

# Общие сведения о субъектах Azure Service Fabric
Субъекты Azure Service Fabric — это модель программирования на основе субъектов, используемая в [Service Fabric](service-fabric-technical-overview.md). Service Fabric — это платформа, позволяющая с легкостью разрабатывать надежные масштабируемые приложения для облачных и локальных сред и управлять ими.

Модель на основе субъектов Service Fabric — это асинхронная однопотоковая модель, в которой субъект представляет собой единицу состояния и вычисления. Субъекты распределяются по всему кластеру для обеспечения высокого уровня масштабируемости. В случае сбоя хост-процесса субъекта система заново создает его в другом процессе. То же самое происходит в случае сбоя узла, на котором выполняется хост-процесс субъекта: система создает субъект в хост-процессе на другом узле. Среда выполнения субъектов использует распределенное хранилище, предоставляемое платформой Service Fabric, для обеспечения высокой доступности и единообразного управления состояниями. Это значительно упрощает разработку и обслуживание распределенных облачных приложений на основе субъектов.

## Субъекты
Субъекты — это изолированные однопотоковые компоненты, инкапсулирующие как состояние, так и поведение. Они похожи на объекты .NET, поэтому модель программирования на их основе будет привычной для разработчиков. Аналогично объектам .NET, которые являются экземплярами типов .NET, каждый субъект является также экземпляром типа субъекта. Предположим, есть тип субъекта, который реализует функции калькулятора, и есть много субъектов этого типа, распределенных по разным узлам кластера. У каждого такого субъекта есть уникальный идентификатор.

Субъекты взаимодействуют с другими компонентами системы, в том числе с другими субъектами, обмениваясь асинхронными сообщениями по схеме «запрос-ответ». Такие взаимодействия определяются в интерфейсе как асинхронные методы. Например, интерфейс для типа субъекта, который реализует функциональность калькулятора, может быть определен так, как указано ниже.

```csharp
public interface ICalculatorActor : IActor
{
    Task<double> AddAsync(double valueOne, double valueTwo);
    Task<double> SubtractAsync(double valueOne, double valueTwo);
}
```

Тип субъекта может реализовать приведенный выше интерфейс так, как указано ниже.

```csharp
public class CalculatorActor : Actor, ICalculatorActor
{
    public Task<double> AddAsync(double valueOne, double valueTwo)
    {
        return Task.FromResult(valueOne + valueTwo);
    }

    public Task<double> SubtractAsync(double valueOne, double valueTwo)
    {
        return Task.FromResult(valueOne - valueTwo);
    }
}
```

Для каждого метода интерфейса аргументы и результаты возвращаемой методом задачи должны относиться к типу [сериализуемых контрактов данных](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).

Реализация этих методов субъектов не ведет к возникновению проблем с блокировками или параллелизмом, так как среда выполнения субъектов поддерживает поочередный параллелизм. Дополнительные сведения см. в разделе [Параллелизм](#concurrency).

> [AZURE.TIP]В среде выполнения субъектов Service Fabric предусмотрены некоторые [события и счетчики производительности, связанные с методами субъектов](service-fabric-reliable-actors-diagnostics.md#actor-method-events-and-performance-counters). Они полезны при диагностике и мониторинге производительности.

Следует упомянуть следующие правила, относящиеся к методам интерфейса субъекта: — методы интерфейса субъекта нельзя перегружать; — методы интерфейса субъекта не должны иметь выходных, ссылочных или необязательных параметров.

## Обмен данными с субъектами
Клиентский API субъектов обеспечивает обмен данными между клиентом и экземпляром субъекта. Для обмена данными с субъектом клиент создает для него прокси-объект, реализующий интерфейс субъекта. Клиент взаимодействует с субъектом, вызывая методы через прокси-объект. Прокси-объект субъекта можно использовать для связи как между клиентом и субъектом, так и между субъектами. Вернемся к нашему примеру с калькулятором. Клиентский код субъекта калькулятора можно записать следующим образом.

```csharp
ActorId actorId = ActorId.NewId();
string applicationName = "fabric:/CalculatorActorApp";
ICalculatorActor calculatorActor = ActorProxy.Create<ICalculatorActor>(actorId, applicationName);
double result = calculatorActor.AddAsync(2, 3).Result;
```

В примере прокси-объект для субъекта создается с помощью двух фрагментов информации: идентификатора субъекта и имени приложения. Идентификатор субъекта однозначно определяет субъект. Имя приложения — это имя [приложения Service Fabric](service-fabric-reliable-actors-platform.md#service-fabric-application-model-concepts-for-actors), в качестве которого развернут субъект.

Субъекты имеют виртуальную природу, что означает, что они существуют всегда и их не нужно явным образом создавать или удалять. Среда выполнения субъектов автоматически активирует субъект при первом получении запроса для него. Если субъект не используется в течение определенного времени, среда выполнения удалит его при сборке мусора и при необходимости активирует его позже. Дополнительные сведения см. в статье [Жизненный цикл субъекта и сборка мусора](service-fabric-reliable-actors-lifecycle.md).

Клиентский API для субъекта поддерживает также обнаружение субъектов и отработку отказа. Класс `ActorProxy` на стороне клиента выполняет необходимое разрешение, находит [секцию](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors) службы, в которой размещается субъект с заданным идентификатором, и открывает канал связи с ним. В случае отработки отказа объект `ActorProxy` будет повторять попытки подключения. Это означает, что в реализации субъектов возможно получение дубликатов сообщений от одного клиента.

## Параллелизм
В среде выполнения субъектов для методов субъектов поддерживается простой поочередный параллелизм. Это означает, что в конкретный момент времени в коде субъекта может быть активен только один поток.

Очередь подразумевает полное выполнение метода субъекта в ответ на запрос от других субъектов или клиентов либо полное выполнение обратного вызова [по таймеру или напоминанию](service-fabric-reliable-actors-timers-reminders.md). Несмотря на то что эти методы и обратные вызовы являются асинхронными, среда выполнения субъектов не позволяет чередовать их. Для передачи очереди предыдущее действие должно быть завершено полностью. Другими словами, метод субъекта или обратный вызов (по таймеру или напоминанию), которые сейчас выполняются, должны быть завершены, чтобы можно было вызвать новый метод или выполнить другой обратный вызов. Метод или обратный вызов считается завершенным, если его выполнение завершено и выполнена задача, возвращаемая методом или обратным вызовом. Следует подчеркнуть, что поочередный параллелизм обеспечивается для разных методов, таймеров и обратных вызовов.

Среда выполнения субъектов принудительно обеспечивает поочередный параллелизм за счет получения блокировки конкретного субъекта в начале очереди и ее освобождения после того, как выполняемое в очереди действие будет завершено. Таким образом, поочередный параллелизм обеспечивается на уровне отдельного субъекта, а не для всех субъектов сразу. Разные субъекты могут одновременно и независимо выполнять методы субъектов и обратные вызовы по таймеру или напоминанию.

Проиллюстрируем эти понятия на примере. Рассмотрим тип субъекта, который реализует два асинхронных метода (назовем их *Method1* и *Method2*), таймер и напоминание. На диаграмме показана временная шкала выполнения этих методов и обратных вызовов от имени субъектов *ActorId1* и *ActorId2*, относящихся к этому типу субъекта.

![][1]

На диаграмме используются следующие обозначения.

- Каждая вертикальная линия обозначает логический поток выполнения метода или функции обратного вызова от имени определенного субъекта.
- Отмеченные на них события происходят в хронологическом порядке, при этом новые события отражены ниже старых.
- Временные шкалы, относящиеся к разным субъектам, нарисованы разными цветами.
- Для обозначения периода блокировки субъекта, получаемой методом или функцией обратного вызова, используется выделение цветом.

Обратите внимание на такие важные моменты:

- Когда выполняется *Method1* от имени субъекта *ActorId2* в ответ на запрос клиента *xyz789*, поступает другой запрос от клиента *abc123*, который тоже требует выполнения метода *Method1* субъектом *ActorId2*. Выполнение второго метода *Method1* не начинается до завершения первого. Аналогичным образом напоминание, зарегистрированное субъектом *ActorId2*, срабатывает во время выполнения метода *Method1* в ответ на запрос клиента *xyz789*. Обратный вызов по напоминанию будет выполнен только после того, как оба метода *Method1* будут выполнены. Такое поведение обусловлено тем, что для субъекта *ActorId2* работает принцип поочередного параллелизма.
- Кроме того, этот принцип применяется для субъекта *ActorId1*. Это видно по последовательному выполнению методов *Method1*, *Method2* и обратного вызова по таймеру от имени субъекта *ActorId1*.
- Выполнение метода *Method1* от имени субъекта *ActorId1* перекрывается с выполнением того же метода от имени субъекта *ActorId2*. Это связано с тем, что поочередный параллелизм применяется только для одного субъекта, а не для всех субъектов сразу.
- Для некоторых методов или обратных вызовов возвращаемая ими задача (`Task`) завершается только после возврата метода. В других случаях к возврату метода или обратного вызова задача (`Task`) уже завершена. В обоих случаях блокировка субъекта снимается только после выполнения обоих этих действий, то есть после возврата метода и функции обратного вызова и завершения задачи (`Task`).

Среда выполнения субъектов по умолчанию поддерживает для субъектов повторный вход. Это означает, что если метод субъекта A вызывает метод для субъекта Б, который вызывает другой метод для субъекта А, то второй метод может быть вызван, так как он является частью логического контекста цепочки вызовов. Все вызовы с таймерами и напоминаниями начинаются с нового логического контекста вызова. Дополнительные сведения см. в статье [Повторный вход](service-fabric-reliable-actors-reentrancy.md).

Среда выполнения субъектов предоставляет гарантии повторного входа в ситуациях, когда она управляет вызовом методов, например методов, которые вызываются в ответ на запрос клиента, или обратных вызовов по таймеру и напоминанию. Тем не менее если код субъекта напрямую вызывает эти методы вне механизмов, предоставляемых средой выполнения субъектов, то среда выполнения не предоставляет никаких гарантий параллелизма. Например, среда выполнения не предоставляет таких гарантий, если метод вызывается в контексте некоторой задачи, которая не связана с задачей, возвращаемой методами субъекта, или если он вызывается из потока, который субъект создает самостоятельно. Таким образом, для выполнения фоновых операций субъектам следует использовать [таймеры или напоминания](service-fabric-reliable-actors-timers-reminders.md), в которых соблюдаются принципы поочередного параллелизма.

> [AZURE.TIP]В среде выполнения субъектов Service Fabric предусмотрены некоторые [события и счетчики производительности, связанные с параллелизмом](service-fabric-reliable-actors-diagnostics.md#concurrency-events-and-performance-counters). Они полезны при диагностике и мониторинге производительности.

## Управление состояниями субъектов
Субъекты Service Fabric позволяют создавать субъекты с отслеживанием и без отслеживания состояния.

### Субъекты без отслеживания состояния
У субъектов без отслеживания состояния, как следует из названия, нет состояния, которым управляет среда выполнения субъектов. Субъекты без отслеживания состояния являются производными от базового класса Actor. У них могут быть переменные-члены, которые сохраняются на протяжении времени существования субъекта так же, как у любых других типов .NET. Однако, если экземпляр субъекта после определенного времени простоя удаляется во время сборки мусора, он теряет состояние, хранимое в его переменных-членах. Аналогичным образом состояние может быть потеряно в результате отработки отказа, например при обновлении, балансировке ресурсов либо при сбое процесса субъекта или хост-узла процесса субъекта.

Ниже приведен пример субъекта без отслеживания состояния.

```csharp
class HelloActor : Actor, IHello
{
    public Task<string> SayHello(string greeting)
    {
        return Task.FromResult("You said: '" + greeting + "', I say: Hello Actors!");
    }
}
```

### Субъекты с отслеживанием состояния
У субъектов с отслеживанием состояния есть состояние, которое сохраняется во время сборки мусора и при отработке отказа. Субъекты с отслеживанием состояния являются производными от базового класса `Actor<TState>`, где `TState` — это тип состояния, которое необходимо сохранить во время сборки мусора или отработки отказа. Доступ к состоянию можно получить с помощью методов субъектов, используя свойство `State` базового класса `Actor<TState>`. Ниже приведен пример получения состояния субъекта с отслеживанием состояния.

```csharp
class VoicemailBoxActor : Actor<VoicemailBox>, IVoicemailBoxActor
{
    public Task<List<Voicemail>> GetMessagesAsync()
    {
        return Task.FromResult(State.MessageList);
    }
    ...
}
```

Состояние субъекта должно относиться к типу [сериализуемых контрактов данных](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).

> [Примечание] Сведения о способах определения интерфейсов и типов состояний субъектов приведены в статье [Заметки о сериализации типов надежных субъектов](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).

#### Поставщики состояний субъектов
Хранение и извлечение состояний обеспечивается поставщиком состояний субъектов. Используя конкретный атрибут, можно настроить поставщик состояний для отдельного субъекта или для всех субъектов в сборке. Существует несколько поставщиков состояний субъектов, которые используются по умолчанию и являются частью среды выполнения субъектов. Устойчивость и надежность состояния определяются гарантиями, предоставляемыми поставщиком состояний. При активации субъекта его состояние загружается в память. Когда завершается выполнение метода субъекта, среда выполнения субъектов автоматически сохраняет измененное состояние, вызывая соответствующий метод для поставщика состояний. Если во время сохранения состояния происходит сбой, среда выполнения удаляет сохраняемый экземпляр субъекта. Новый экземпляр субъекта создается и загружается с последним согласованным состоянием из поставщика состояний.

По умолчанию субъект с отслеживанием состояния использует в качестве поставщика состояний субъекта хранилище ключей и значений. Этот поставщик построен на основе распределенного хранилища ключей и значений, предоставляемого платформой Service Fabric. Дополнительные сведения см. в статье, посвященной [выбору поставщика состояний](service-fabric-reliable-actors-platform.md#actor-state-provider-choices).

> [AZURE.TIP]В среде выполнения субъектов Service Fabric предусмотрены некоторые [события и счетчики производительности, связанные с управлением состояниями](service-fabric-reliable-actors-diagnostics.md#actor-state-management-events-and-performance-counters). Они полезны при диагностике и мониторинге производительности.

#### Методы «только чтение»
По умолчанию среда выполнения субъектов сохраняет состояние субъекта по завершении вызова метода субъекта или обратного вызова по таймеру либо напоминанию. Другие вызовы для этого субъекта не разрешаются до тех пор, пока сохранение состояния не будет завершено. Время сохранения состояния может отличаться и зависит от используемого поставщика состояний.

Некоторые методы субъекта не изменяют его состояния. В этом случае дополнительное время, затрачиваемое на сохранение состояния, может отразиться на общей производительности. Чтобы избежать снижения пропускной способности, можно пометить методы и обратные вызовы по таймеру, которые не изменяют состояние, флагом «только для чтения».

В приведенном примере показано, как пометить метод субъекта флагом «только для чтения» с помощью атрибута `Readonly`.

```csharp
public interface IVoicemailBoxActor : IActor
{
    [Readonly]
    Task<List<Voicemail>> GetMessagesAsync();
}
```

Аналогичным образом можно пометить обратные вызовы по таймеру с помощью атрибута `Readonly`. Чтобы пометить напоминание как «только для чтения», используйте соответствующий флаг в качестве аргумента метода `RegisterReminder`, который вызывается для регистрации напоминаний.

## Дальнейшие действия
### Основные понятия
[Жизненный цикл субъектов и сборка мусора](service-fabric-reliable-actors-lifecycle.md)

[Таймеры и напоминания субъектов](service-fabric-reliable-actors-timers-reminders.md)

[События субъектов](service-fabric-reliable-actors-events.md)

[Повторный вход субъектов](service-fabric-reliable-actors-reentrancy.md)

[Использование платформы Service Fabric субъектами](service-fabric-reliable-actors-platform.md)

[Настройка субъекта KVSActorStateProvider](../Service-Fabric/service-fabric-reliable-actors-KVSActorstateprovider-configuration.md)

[Диагностика и мониторинг производительности субъектов](service-fabric-reliable-actors-diagnostics.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
 

<!---HONumber=July15_HO2-->