<properties
   pageTitle="Общие сведения о субъектах Azure Service Fabric"
   description="Общие сведения о модели программирования на основе субъектов Azure Service Fabric."
   services="service-fabric"
   documentationCenter=".net"
   authors="jessebenson"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="07/10/2015"
   ms.author="claudioc"/>

# Общие сведения о субъектах Azure Service Fabric
API надежных субъектов — это одна из двух высокоуровневых платформ, предоставляемых службой [Service Fabric](service-fabric-technical-overview.md), наряду с [API надежных служб](service-fabric-reliable-services-introduction.md).

В зависимости от шаблона субъектов, API надежных субъектов обеспечивает асинхронную однопотоковую модель программирования, которая упрощает ваш код, при этом пользуясь преимуществами гарантий масштабируемости и надежности, предоставляемых службой Service Fabric.

## Субъекты
Субъекты — это изолированные однопотоковые компоненты, инкапсулирующие как состояние, так и поведение. Они похожи на объекты .NET, поэтому модель программирования на их основе будет привычной. Аналогично объектам .NET, которые являются экземплярами типов .NET, каждый субъект является также экземпляром типа субъекта. Предположим, есть тип субъекта, который реализует функции калькулятора, и есть много субъектов этого типа, распределенных по разным узлам кластера. У каждого такого субъекта есть уникальный идентификатор.

## Определение и реализация интерфейсов субъектов

Субъекты взаимодействуют с другими компонентами системы, в том числе с другими субъектами, обмениваясь асинхронными сообщениями по схеме "запрос-ответ". Такие взаимодействия определяются в интерфейсе как асинхронные методы. Например, интерфейс для типа субъекта, который реализует функциональность калькулятора, может быть определен так, как указано ниже.

```csharp
public interface ICalculatorActor : IActor
{
    Task<double> AddAsync(double valueOne, double valueTwo);
    Task<double> SubtractAsync(double valueOne, double valueTwo);
}
```

Тип субъекта может реализовать приведенный выше интерфейс так, как указано ниже.

```csharp
public class CalculatorActor : Actor, ICalculatorActor
{
    public Task<double> AddAsync(double valueOne, double valueTwo)
    {
        return Task.FromResult(valueOne + valueTwo);
    }

    public Task<double> SubtractAsync(double valueOne, double valueTwo)
    {
        return Task.FromResult(valueOne - valueTwo);
    }
}
```

Так как вызовы методов и получение их ответов обязательно ведут к обработке сетевых запросов в кластере, то аргументы и тип результата задачи, которые она возвращает, должны поддерживать сериализацию с помощью платформы. В частности, они должны быть [сериализуемыми по контракту данных](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).

> [AZURE.TIP]В среде выполнения субъектов Service Fabric предусмотрены некоторые [события и счетчики производительности, связанные с методами субъектов](service-fabric-reliable-actors-diagnostics.md#actor-method-events-and-performance-counters). Они полезны при диагностике и мониторинге производительности.

Следует упомянуть следующие правила, относящиеся к методам интерфейса субъекта: — методы интерфейса субъекта нельзя перегружать; — методы интерфейса субъекта не должны иметь выходных, ссылочных или необязательных параметров.

## Обмен данными с субъектами
### Прокси субъектов
Клиентский API субъектов обеспечивает обмен данными между клиентом и экземпляром субъекта. Для обмена данными с субъектом клиент создает для него прокси-объект, реализующий интерфейс субъекта. Клиент взаимодействует с субъектом, вызывая методы через прокси-объект. Прокси-объект субъекта можно использовать для связи как между клиентом и субъектом, так и между субъектами. Вернемся к нашему примеру с калькулятором. Клиентский код субъекта калькулятора можно записать следующим образом.

```csharp
ActorId actorId = ActorId.NewId();
string applicationName = "fabric:/CalculatorActorApp";
ICalculatorActor calculatorActor = ActorProxy.Create<ICalculatorActor>(actorId, applicationName);
double result = calculatorActor.AddAsync(2, 3).Result;
```

Обратите внимание на два фрагмента информации, используемых для создания объекта прокси субъекта — идентификатор объекта и имя приложения. Идентификатор субъекта — это идентификатор, который однозначно определяет субъект, хотя имя приложения определяет[приложение в Service Fabric](service-fabric-reliable-actors-platform.md#service-fabric-application-model-concepts-for-actors), в котором развернут субъект.

### Срок действия субъекта

Субъекты Service Fabric виртуальные. Это означает, что срок их действия не привязан к их представлению в памяти. В результате их не требуется создавать и удалять в явном виде. Среда выполнения субъектов автоматически активирует субъект при первом получении запроса для него. Если субъект не используется в течение определенного времени, среда выполнения субъектов соберет объект в памяти, сохраняя сведения о существовании субъекта на случай, если его потребуется повторно активировать. Дополнительные сведения см. в статье [Жизненный цикл субъекта и сбор мусора](service-fabric-reliable-actors-lifecycle.md).

### Прозрачность расположения и автоматическая отработка отказа

Для обеспечения высокой масштабируемости и надежности Service Fabric распределяет субъекты по кластеру и автоматически переносит их с неисправных узлов в работоспособные по мере необходимости. Класс `ActorProxy` на стороне клиента выполняет необходимое разрешение, чтобы найти субъект по идентификатору [раздела](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors) и открыть канал связи с ним. `ActorProxy` также повторяет попытку в случае сбоев связи и отработки отказов. Это гарантирует, что сообщения будут доставлены несмотря на присутствие сбоев, но также означает, что реализация субъекта может получать дублированные сообщения от одного клиента.

## Параллелизм
### Пошаговый параллелизм

В среде выполнения субъектов для методов субъектов поддерживается простой поочередный параллелизм. Это означает, что в конкретный момент времени в коде субъекта может быть активен только один поток.

Очередь подразумевает полное выполнение метода субъекта в ответ на запрос от других субъектов или клиентов либо полное выполнение обратного вызова [по таймеру или напоминанию](service-fabric-reliable-actors-timers-reminders.md). Несмотря на то что эти методы и обратные вызовы асинхронные, среда выполнения субъекта не позволяет чередовать их — прежде чем начать новый шаг, необходимо завершить предыдущий. Другими словами, метод субъекта или обратный вызов (по таймеру или напоминанию), которые сейчас выполняются, должны быть завершены, чтобы можно было вызвать новый метод или выполнить другой обратный вызов. Метод или обратный вызов считается завершенным, если его выполнение завершено и выполнена задача, возвращаемая методом или обратным вызовом. Следует подчеркнуть, что поочередный параллелизм обеспечивается для разных методов, таймеров и обратных вызовов.

Среда выполнения субъектов принудительно обеспечивает поочередный параллелизм за счет получения блокировки конкретного субъекта в начале очереди и ее освобождения после того, как выполняемое в очереди действие будет завершено. Таким образом, поочередный параллелизм обеспечивается на уровне отдельного субъекта, а не для всех субъектов сразу. Разные субъекты могут одновременно и независимо выполнять методы субъектов и обратные вызовы по таймеру или напоминанию.

Проиллюстрируем эти понятия на примере. Рассмотрим тип субъекта, который реализует два асинхронных метода (назовем их *Method1* и *Method2*), таймер и напоминание. На диаграмме показана временная шкала выполнения этих методов и обратных вызовов от имени субъектов *ActorId1* и *ActorId2*, относящихся к этому типу субъекта.

![][1]

На диаграмме используются следующие обозначения.

- Каждая вертикальная линия обозначает логический поток выполнения метода или функции обратного вызова от имени определенного субъекта.
- Отмеченные на них события происходят в хронологическом порядке, при этом новые события отражены ниже старых.
- Временные шкалы, относящиеся к разным субъектам, нарисованы разными цветами.
- Для обозначения периода блокировки субъекта, получаемой методом или функцией обратного вызова, используется выделение цветом.

Обратите внимание на такие важные моменты:

- Когда выполняется *Method1* от имени субъекта *ActorId2* в ответ на запрос клиента *xyz789*, поступает другой запрос от клиента *abc123*, который тоже требует выполнения метода *Method1* субъектом *ActorId2*. Выполнение второго метода *Method1* не начинается до завершения первого. Аналогичным образом напоминание, зарегистрированное субъектом *ActorId2*, срабатывает во время выполнения метода *Method1* в ответ на запрос клиента *xyz789*. Обратный вызов по напоминанию будет выполнен только после того, как оба метода *Method1* будут выполнены. Такое поведение обусловлено тем, что для субъекта *ActorId2* работает принцип поочередного параллелизма.
- Кроме того, этот принцип применяется для субъекта *ActorId1*. Это видно по последовательному выполнению методов *Method1*, *Method2* и обратного вызова по таймеру от имени субъекта *ActorId1*.
- Выполнение метода *Method1* от имени субъекта *ActorId1* перекрывается с выполнением того же метода от имени субъекта *ActorId2*. Это связано с тем, что поочередный параллелизм применяется только для одного субъекта, а не для всех субъектов сразу.
- Для некоторых методов или обратных вызовов возвращаемая ими задача (`Task`) завершается только после возврата метода. В других случаях к возврату метода или обратного вызова задача (`Task`) уже завершена. В обоих случаях блокировка субъекта снимается только после выполнения обоих этих действий, то есть после возврата метода и функции обратного вызова и завершения задачи (`Task`).

### Повторный вход

Среда выполнения субъектов по умолчанию поддерживает для субъектов повторный вход. Это означает, что если метод субъекта A вызывает метод для субъекта Б, который вызывает другой метод для субъекта А, то второй метод может быть вызван, так как он является частью логического контекста цепочки вызовов. Все вызовы с таймерами и напоминаниями начинаются с нового логического контекста вызова. Дополнительные сведения см. в статье [Повторный вход](service-fabric-reliable-actors-reentrancy.md).

### Область гарантий параллелизма

Среда выполнения субъектов предоставляет гарантии повторного входа в ситуациях, когда она управляет вызовом методов, например методов, которые вызываются в ответ на запрос клиента, или обратных вызовов по таймеру и напоминанию. Тем не менее если код субъекта напрямую вызывает эти методы вне механизмов, предоставляемых средой выполнения субъектов, то среда выполнения не предоставляет никаких гарантий параллелизма. Например, среда выполнения не предоставляет таких гарантий, если метод вызывается в контексте некоторой задачи, которая не связана с задачей, возвращаемой методами субъекта, или если он вызывается из потока, который субъект создает самостоятельно. Таким образом, для выполнения фоновых операций субъектам следует использовать [таймеры или напоминания](service-fabric-reliable-actors-timers-reminders.md), в которых соблюдаются принципы поочередного параллелизма.

> [AZURE.TIP]В среде выполнения субъектов Service Fabric предусмотрены некоторые [события и счетчики производительности, связанные с параллелизмом](service-fabric-reliable-actors-diagnostics.md#concurrency-events-and-performance-counters). Они полезны при диагностике и мониторинге производительности.

## Управление состояниями субъектов
Субъекты Service Fabric позволяют создавать субъекты с отслеживанием и без отслеживания состояния.

### Субъекты без отслеживания состояния
У субъектов без отслеживания состояния, которые получены из базового класса ``Actor``, нет состояния, которым управляет среда выполнения субъектов. Их переменные-участники сохраняются в течение их жизненного цикла в памяти, как в любом другом типе .NET. Тем не менее, когда они собираются после периода бездействия, их состояние теряется. Аналогичным образом, состояние может быть утеряно в связи с отработкой отказов, которая происходит во время обновления, операций балансировки ресурсов или сбоев в процессе субъекта либо его узле.

Ниже приведен пример субъекта без отслеживания состояния.

```csharp
class HelloActor : Actor, IHello
{
    public Task<string> SayHello(string greeting)
    {
        return Task.FromResult("You said: '" + greeting + "', I say: Hello Actors!");
    }
}
```

### Субъекты с отслеживанием состояния
У субъектов с отслеживанием состояния есть состояние, которое сохраняется во время сборки мусора и при отработке отказа. Они основаны на базовом классе `Actor<TState>`, где `TState` — это тип состояния, которое нужно сохранить. Доступ к состоянию можно получить с помощью методов субъектов, используя свойство `State` базового класса.

Ниже приведен пример получения состояния субъекта с отслеживанием состояния.

```csharp
class VoicemailBoxActor : Actor<VoicemailBox>, IVoicemailBoxActor
{
    public Task<List<Voicemail>> GetMessagesAsync()
    {
        return Task.FromResult(State.MessageList);
    }
    ...
}
```

Состояние субъектов сохраняется при сборке мусора и отработке отказа путем записи на диск и репликации между несколькими узлами кластера. Это означает, что аналогично аргументам и возвращаемым значениям методов тип состояния субъекта должен поддерживать [сериализацию по контракту данных](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).

> [AZURE.NOTE]Сведения о способах определения интерфейсов и типов состояний субъектов приведены в статье [Заметки о сериализации типов надежных субъектов](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).

#### Поставщики состояний субъектов
Хранение и извлечение состояний обеспечивается поставщиком состояний субъектов. Используя конкретный атрибут, можно настроить поставщик состояний для отдельного субъекта или для всех субъектов в сборке. При активации субъекта его состояние загружается в память. Когда завершается выполнение метода субъекта, среда выполнения субъектов автоматически сохраняет измененное состояние, вызывая соответствующий метод для поставщика состояний. Если во время сохранения происходит сбой, среда выполнения субъектов возвращает новый экземпляр субъекта и загружает последнее согласованное состояние у поставщика.

По умолчанию субъекты с отслеживанием состояния используют поставщика состояний субъектов на основе хранилища "ключ-значение", предоставленного платформой Service Fabric. Дополнительные сведения см. в статье, посвященной [выбору поставщика состояний](service-fabric-reliable-actors-platform.md#actor-state-provider-choices).

> [AZURE.TIP]В среде выполнения субъектов предусмотрены некоторые [события и счетчики производительности, связанные с управлением состояниями](service-fabric-reliable-actors-diagnostics.md#actor-state-management-events-and-performance-counters). Они полезны при диагностике и мониторинге производительности.

#### Методы «только чтение»
По умолчанию среда выполнения субъектов сохраняет состояние субъекта после завершения вызова метода субъекта или обратного вызова по таймеру либо напоминанию. Другие вызовы для этого субъекта не разрешаются до тех пор, пока сохранение состояния не будет завершено.

Некоторые методы субъекта не изменяют его состояния. В этом случае дополнительное время, затрачиваемое на сохранение состояния, может отразиться на общей производительности. Чтобы избежать снижения пропускной способности, можно пометить методы и обратные вызовы по таймеру, которые не изменяют состояние, флагом «только для чтения».

В приведенном примере показано, как пометить метод субъекта флагом «только для чтения» с помощью атрибута `Readonly`.

```csharp
public interface IVoicemailBoxActor : IActor
{
    [Readonly]
    Task<List<Voicemail>> GetMessagesAsync();
}
```

Аналогичным образом можно пометить обратные вызовы по таймеру с помощью атрибута `Readonly`. Чтобы пометить напоминание как «только для чтения», используйте соответствующий флаг в качестве аргумента метода `RegisterReminder`, который вызывается для регистрации напоминаний.

## Дальнейшие действия
### Основные понятия
[Жизненный цикл субъектов и сборка мусора](service-fabric-reliable-actors-lifecycle.md)

[Таймеры и напоминания субъектов](service-fabric-reliable-actors-timers-reminders.md)

[События субъектов](service-fabric-reliable-actors-events.md)

[Повторный вход субъектов](service-fabric-reliable-actors-reentrancy.md)

[Использование платформы Service Fabric субъектами](service-fabric-reliable-actors-platform.md)

[Настройка субъекта KVSActorStateProvider](../Service-Fabric/service-fabric-reliable-actors-KVSActorstateprovider-configuration.md)

[Диагностика и мониторинг производительности субъектов](service-fabric-reliable-actors-diagnostics.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png

<!---HONumber=July15_HO4-->