<properties
   pageTitle="Обзор Reliable Actors в Service Fabric | Microsoft Azure"
   description="Общие сведения о модели программирования на основе надежных субъектов Service Fabric."
   services="service-fabric"
   documentationCenter=".net"
   authors="vturecek"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="08/05/2015"
   ms.author="vturecek"/>

# Общие сведения о надежных субъектах Service Fabric
API субъектов Reliable Actors — это одна из двух высокоуровневых платформ, предоставляемых платформой [Azure Service Fabric](service-fabric-technical-overview.md) наряду с [API служб Reliable Services](service-fabric-reliable-services-introduction.md).

В зависимости от шаблона субъектов API Reliable Actors обеспечивает асинхронную однопотоковую модель программирования. Эта модель упрощает ваш код, позволяя при этом пользоваться возможностями масштабируемости и надежности, предоставляемыми платформой Service Fabric.

## Субъекты
Субъекты — это изолированные однопотоковые компоненты, инкапсулирующие как состояние, так и поведение. Так как они похожи на объекты .NET, использующая их модель программирования является традиционной. Аналогично объектам .NET, которые являются экземплярами типов .NET, каждый субъект является также экземпляром типа субъекта. Предположим, есть тип субъекта, который реализует функции калькулятора, и есть много субъектов этого типа, распределенных между разными узлами кластера. У каждого такого субъекта есть уникальный идентификатор.

## Определение и реализация интерфейсов субъектов

Субъекты взаимодействуют с другими компонентами системы, в том числе с другими субъектами, обмениваясь асинхронными сообщениями по схеме "запрос-ответ". Такие взаимодействия определяются в интерфейсе как асинхронные методы. Например, интерфейс для типа субъекта, который реализует функциональность калькулятора, может быть определен так, как указано ниже.

```csharp
public interface ICalculatorActor : IActor
{
    Task<double> AddAsync(double valueOne, double valueTwo);
    Task<double> SubtractAsync(double valueOne, double valueTwo);
}
```

Тип субъекта может реализовать этот интерфейс:

```csharp
public class CalculatorActor : StatelessActor, ICalculatorActor
{
    public Task<double> AddAsync(double valueOne, double valueTwo)
    {
        return Task.FromResult(valueOne + valueTwo);
    }

    public Task<double> SubtractAsync(double valueOne, double valueTwo)
    {
        return Task.FromResult(valueOne - valueTwo);
    }
}
```

Вызовы методов и получение их ответов обязательно ведут к обработке сетевых запросов в кластере. Поэтому возвращаемые типы результата задач и аргументы должны поддерживать сериализацию с помощью платформы. В частности, они должны быть [сериализуемыми по контракту данных](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).

> [AZURE.TIP]В среде выполнения субъектов Service Fabric предусмотрены некоторые [события и счетчики производительности, связанные с методами субъектов](service-fabric-reliable-actors-diagnostics.md#actor-method-events-and-performance-counters). Они полезны при диагностике и мониторинге производительности.

Следует упомянуть следующие правила, относящиеся к методам интерфейса субъекта: 1) методы интерфейса субъекта нельзя перегружать; 2) методы интерфейса субъекта не должны иметь выходные, ссылочные или необязательные параметры.

## Обмен данными с субъектами
### Прокси-объект субъекта
Клиентский API субъектов Reliable Actors обеспечивает обмен данными между клиентом и экземпляром субъекта. Для обмена данными с субъектом клиент создает для него прокси-объект, реализующий интерфейс субъекта. Клиент взаимодействует с субъектом, вызывая методы через прокси-объект. Прокси-объект субъекта можно использовать для обмена данными как между клиентом и субъектом, так и между субъектами. Вернемся к нашему примеру с калькулятором. Клиентский код субъекта калькулятора можно записать следующим образом:

```csharp
ActorId actorId = ActorId.NewId();
string applicationName = "fabric:/CalculatorActorApp";
ICalculatorActor calculatorActor = ActorProxy.Create<ICalculatorActor>(actorId, applicationName);
double result = calculatorActor.AddAsync(2, 3).Result;
```

Обратите внимание на два фрагмента данных, используемых для создания прокси-объекта субъекта. Это идентификатор субъекта и имя приложения. Идентификатор субъекта однозначно определяет субъект, а имя приложения определяет [приложение Service Fabric](service-fabric-reliable-actors-platform.md#service-fabric-application-model-concepts-for-actors), в котором развернут субъект.

### Срок действия субъекта

Субъекты Service Fabric виртуальные. Это означает, что срок их действия не привязан к их представлению в памяти. В результате их не требуется создавать и удалять в явном виде. Среда выполнения субъектов автоматически активирует субъект при первом получении запроса для него. Если субъект не используется в течение определенного времени, среда выполнения выполнит сбор мусора — выполняющихся в памяти объектов. Существование субъекта также будет учитываться на случай необходимости в его повторной активации в будущем. Дополнительные сведения см. в статье [Жизненный цикл субъектов и сбор мусора](service-fabric-reliable-actors-lifecycle.md).

### Прозрачность расположения и автоматическая отработка отказа

Для обеспечения высокой масштабируемости и надежности Service Fabric распределяет субъекты по кластеру и автоматически переносит их с неисправных узлов в работоспособные по мере необходимости. Класс `ActorProxy` на стороне клиента выполняет необходимое разрешение, чтобы найти субъект по идентификатору [раздела](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors) и открыть канал связи с ним. Класс `ActorProxy` также повторяет попытку поиска субъекта при сбоях связи и отработках отказов. Это гарантирует, что сообщения будут доставлены, несмотря на наличие ошибок. Но это также означает, что при реализации субъектов от одного клиента могут приходить повторяющиеся сообщения.

## Параллелизм
### Поочередный доступ

В среде выполнения субъектов для доступа к методам субъектов используется простая модель поочередности. Это означает, что в конкретный момент времени в коде субъекта может быть активен только один поток.

Очередь подразумевает не только полное выполнение метода субъекта в ответ на запрос от других субъектов или клиентов, но и полное выполнение обратного вызова [по таймеру или напоминанию](service-fabric-reliable-actors-timers-reminders.md). Несмотря на то что эти методы и обратные вызовы являются асинхронными, среда выполнения субъектов не позволяет чередовать их. Для смены очереди предыдущее действие должно быть завершено полностью. Другими словами, чтобы можно было вызвать новый метод или выполнить другой обратный вызов, выполняемые сейчас метод субъекта или обратный вызов (по таймеру или напоминанию) должны быть завершены. Метод или обратный вызов считается завершенным, если его выполнение завершено, а задача, возвращаемая методом или обратным вызовом, выполнена. Следует подчеркнуть, что пошаговый параллелизм касается разных методов, таймеров и обратных вызовов.

Среда выполнения субъектов принудительно обеспечивает поочередный параллелизм за счет получения блокировки конкретного субъекта в начале очереди и ее освобождения после того, как выполняемое в очереди действие будет завершено. Таким образом, поочередный параллелизм обеспечивается на уровне отдельного субъекта, а не для всех субъектов сразу. Разные субъекты могут одновременно и независимо выполнять методы субъектов и обратные вызовы по таймеру или напоминанию.

Проиллюстрируем эти понятия на примере. Рассмотрим тип субъекта, который реализует два асинхронных метода (назовем их *Method1* и *Method2*), таймер и напоминание. На схеме ниже показана временная шкала выполнения этих методов и обратных вызовов от имени субъектов *ActorId1* и *ActorId2*, относящихся к этому типу субъекта.

![Доступ и пошаговый параллелизм в среде выполнения Reliable Actors][1]

На приведенной выше схеме используются следующие обозначения.

- Каждая вертикальная линия обозначает логический поток выполнения метода или функции обратного вызова от имени определенного субъекта.
- Отмеченные на них события происходят в хронологическом порядке, при этом новые события размещены под старыми.
- Временные шкалы, относящиеся к разным субъектам, нарисованы разными цветами.
- Для обозначения периода блокировки субъекта, получаемой методом или функцией обратного вызова, используется выделение цветом.

Обратите внимание на такие важные моменты:

- Когда выполняется *Method1* от имени субъекта *ActorId2* в ответ на запрос клиента *xyz789*, поступает другой запрос от клиента *abc123*, который тоже требует выполнения метода *Method1* субъектом *ActorId2*. Выполнение второго метода *Method1* не начинается до завершения первого. Аналогичным образом напоминание, зарегистрированное субъектом *ActorId2*, срабатывает во время выполнения метода *Method1* в ответ на запрос клиента *xyz789*. Обратный вызов по напоминанию будет выполнен только после того, как оба метода *Method1* будут выполнены. Такое поведение обусловлено тем, что для субъекта *ActorId2* работает принцип поочередного параллелизма.
- Кроме того, этот принцип применяется для субъекта *ActorId1*. Это видно по последовательному выполнению методов *Method1* и *Method2*, а также обратного вызова по таймеру от имени субъекта *ActorId1*.
- Выполнение метода *Method1* от имени субъекта *ActorId1* перекрывается с выполнением того же метода от имени субъекта *ActorId2*. Это связано с тем, что пошаговый параллелизм применяется только для одного субъекта, а не для всех субъектов сразу.
- В некоторых случаях возвращаемая выполняющимися методами или обратными вызовами задача `Task` завершается только после возврата метода. В других случаях задача `Task` завершается к моменту возврата метода или обратного вызова. В любом случае разблокировка субъектов происходит только после возврата метода или обратного вызова, а также по завершении `Task`.

### Повторный вход

Среда выполнения субъектов по умолчанию поддерживает для субъектов повторный вход. Это означает, что, если метод *ActorA* вызывает метод для *ActorB*, который вызывает другой метод для *ActorA*, второй метод может быть вызван, так как он является частью логического контекста цепочки вызовов. Все вызовы с таймерами и напоминаниями начинаются с нового логического контекста вызова. Дополнительные сведения см. в статье [Повторный вход Reliable Actors](service-fabric-reliable-actors-reentrancy.md).

### Область гарантий параллелизма

Среда выполнения субъектов предоставляет гарантии повторного входа в ситуациях, когда она управляет вызовом методов, например методов, которые вызываются в ответ на запрос клиента, а также обратных вызовов по таймеру и напоминанию. Тем не менее если код субъекта напрямую вызывает эти методы вне механизмов, предоставляемых средой выполнения субъектов, то среда выполнения не предоставляет никаких гарантий параллелизма. Например, среда выполнения не предоставляет таких гарантий, если метод вызывается в контексте некоторой задачи, которая не связана с задачей, возвращаемой методами субъекта. Если метод вызывается из потока, который субъект создает самостоятельно, среда выполнения также не предоставляет таких гарантий. Таким образом, для выполнения фоновых операций субъектам следует использовать [таймеры или напоминания](service-fabric-reliable-actors-timers-reminders.md), в которых соблюдаются принципы пошагового параллелизма.

> [AZURE.TIP]В среде выполнения субъектов Service Fabric предусмотрены некоторые [события и счетчики производительности, связанные с параллелизмом](service-fabric-reliable-actors-diagnostics.md#concurrency-events-and-performance-counters). Они полезны при диагностике и мониторинге производительности.

## Управление состоянием субъекта
Платформа Service Fabric позволяет создавать субъекты с отслеживанием состояния и без отслеживания состояния.

### Субъекты без отслеживания состояния
У субъектов без отслеживания состояния, которые основаны на базовом классе `StatelessActor`, нет состояния, которым управляет среда выполнения субъектов. Их переменные-члены сохраняются в течение жизненного цикла в памяти, как для любого другого типа .NET. Но при сборе мусора после периода бездействия их состояние теряется. Также состояние может быть утеряно в связи с отработкой отказов, которая происходит во время обновления, операций балансировки ресурсов, а также при сбоях в работе субъекта или размещающего его узла.

Ниже приведен пример субъекта без отслеживания состояния.

```csharp
class HelloActor : StatelessActor, IHello
{
    public Task<string> SayHello(string greeting)
    {
        return Task.FromResult("You said: '" + greeting + "', I say: Hello Actors!");
    }
}
```

### Субъекты с отслеживанием состояния
У субъектов с отслеживанием состояния есть состояние, которое сохраняется во время сборки мусора и при отработке отказа. Они основаны на `StatefulActor<TState>`, где `TState` — это тип состояния, которое нужно сохранить. Доступ к состоянию можно получить с помощью методов субъектов, используя свойство `State` базового класса.

Ниже приведен пример получения состояния субъекта с отслеживанием состояния.

```csharp
class VoicemailBoxActor : StatefulActor<VoicemailBox>, IVoicemailBoxActor
{
    public Task<List<Voicemail>> GetMessagesAsync()
    {
        return Task.FromResult(State.MessageList);
    }
    ...
}
```

Состояние субъектов сохраняется при сборе мусора и отработке отказа благодаря записи на диск и репликации на несколько узлов кластера. Это означает, что, как и для аргументов и возвращаемых значений методов, тип состояния субъекта должен поддерживать [сериализацию контрактов данных](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).

> [AZURE.NOTE]Сведения о способах определения интерфейсов и типов состояний субъектов см. в статье [Примечания о сериализации типов Reliable Actors в Service Fabric](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).

#### Поставщики состояний субъектов
Хранение и извлечение состояний обеспечивает поставщик состояний субъектов. Используя конкретный атрибут, можно настроить поставщик состояний для отдельного субъекта или для всех субъектов в сборке. При активации субъекта его состояние загружается в память. Когда выполнение метода субъекта завершается, среда выполнения субъектов автоматически сохраняет измененное состояние, вызывая соответствующий метод для поставщика состояний. Если во время операции **Сохранить** происходит сбой, среда выполнения субъектов возвращает новый экземпляр субъекта и загружает последнее согласованное состояние из поставщика состояний.

По умолчанию субъекты с отслеживанием состояния используют поставщика состояний субъектов на основе хранилища "ключ-значение", предоставленного платформой Service Fabric. Дополнительные сведения см. в разделе [Выбор поставщиков состояний субъекта](service-fabric-reliable-actors-platform.md#actor-state-provider-choices).

> [AZURE.TIP]В среде выполнения субъектов предусмотрены некоторые [события и счетчики производительности, связанные с управлением состояниями](service-fabric-reliable-actors-diagnostics.md#actor-state-management-events-and-performance-counters). Они полезны при диагностике и мониторинге производительности.

#### Методы с доступом на чтение
По умолчанию среда выполнения субъектов сохраняет состояние субъекта после завершения вызова метода субъекта, а также обратного вызова по таймеру или напоминанию. Другие вызовы для этого субъекта не разрешаются до тех пор, пока сохранение состояния не будет завершено.

Но некоторые методы субъекта не изменяют состояние. В этом случае выделение дополнительного времени, необходимого для сохранения состояния, может негативно отразиться на общей производительности. Чтобы избежать этого, можно отметить методы и обратные вызовы по таймеру, которые не изменяют состояние, как доступные только для чтения.

В приведенном примере показано, как с помощью атрибута `Readonly` сделать метод субъекта доступным только для чтения.

```csharp
public interface IVoicemailBoxActor : IActor
{
    [Readonly]
    Task<List<Voicemail>> GetMessagesAsync();
}
```

Аналогичным образом можно пометить обратные вызовы по таймеру с помощью атрибута `Readonly`. Чтобы пометить напоминание как «только для чтения», используйте соответствующий флаг в качестве аргумента метода `RegisterReminder`, который вызывается для регистрации напоминаний.

## Дальнейшие действия
[Жизненный цикл субъектов и сбор мусора](service-fabric-reliable-actors-lifecycle.md)

[Таймеры и напоминания субъекта](service-fabric-reliable-actors-timers-reminders.md)

[События субъекта](service-fabric-reliable-actors-events.md)

[Повторный вход субъекта](service-fabric-reliable-actors-reentrancy.md)

[Использование платформы Service Fabric надежными субъектами](service-fabric-reliable-actors-platform.md)

[Конфигурация Reliable Actors — KVSActorStateProvider](service-fabric-reliable-actors-kvsactorstateprovider-configuration.md)

[Диагностика и мониторинг производительности в Reliable Actors](service-fabric-reliable-actors-diagnostics.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png

<!---HONumber=AcomDC_0121_2016-->