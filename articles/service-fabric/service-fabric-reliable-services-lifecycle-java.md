---
title: "Общие сведения о жизненном цикле Reliable Services в Azure Service Fabric | Документация Майкрософт"
description: "Сведения о различных событиях жизненного цикла служб Reliable Services в Service Fabric"
services: Service-Fabric
documentationcenter: java
author: PavanKunapareddyMSFT
manager: timlt
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: java
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/30/2017
ms.author: pakunapa;
ms.openlocfilehash: 93fd003ff5ba7673e5a719fb1ced0cbb97034610
ms.sourcegitcommit: b5c6197f997aa6858f420302d375896360dd7ceb
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/21/2017
---
# <a name="reliable-services-lifecycle-overview"></a>Жизненный цикл Reliable Services
> [!div class="op_single_selector"]
> * [C# в Windows](service-fabric-reliable-services-lifecycle.md)
> * [Java в Linux](service-fabric-reliable-services-lifecycle-java.md)
>
>

Если речь идет о жизненных циклах служб Reliable Services, наиболее важны основные аспекты, а именно:

* во время запуска:
  * создаются службы;
  * они могут создавать и возвращать ни одного или несколько прослушивателей;
  * все возвращаемые прослушиватели открываются, что разрешает взаимодействие со службой;
  * вызывается метод RunAsync службы, позволяя службе выполнять длительную или фоновую работу;
* во время завершения работы:
  * токен отмены, переданный в RunAsync, отменяется, и прослушиватели закрываются;
  * после этого уничтожается сам объект службы.

Следует отметить некоторые моменты, связанные с точным порядком этих событий. В частности, порядок событий может немного изменяться в зависимости от того, предусматривают ли Reliable Services отслеживание состояния. В случае со службами с отслеживанием состояния приходится иметь дело со сценарием переключения первичной реплики. Во время этой процедуры первичная роль передается другой реплике (или возвращается) без завершения работы службы. И, наконец, следует учитывать условия ошибок и сбоев.

## <a name="stateless-service-startup"></a>Запуск службы без отслеживания состояния
Жизненный цикл службы без отслеживания состояния достаточно прост. Ниже приведен порядок событий.

1. Создается служба.
2. Затем одновременно происходят две вещи:
    - вызывается метод `StatelessService.createServiceInstanceListeners()` и открываются все возвращаемые прослушиватели (для каждого прослушивателя вызывается `CommunicationListener.openAsync()`);
    - вызывается метод RunAsync службы (`StatelessService.runAsync()`).
3. При наличии вызывается собственный метод службы OnOpenAsync (в частности, вызывается `StatelessService.onOpenAsync()`). Это редко используемое переопределение, но оно доступно.

Важно отметить, что между вызовами методов для создания и открытия прослушивателей и RunAsync нет упорядоченности. Прослушиватели могут быть открыты перед запуском RunAsync. Аналогичным образом метод RunAsync может быть вызван перед открытием или созданием прослушивателей связи. Если синхронизация не требуется, она остается в качестве упражнения для разработчика. Ниже приведены распространенные решения.

* Иногда прослушиватели не будут работать, пока не будут сформированы другие сведения или выполнены некоторые задачи. Для служб без отслеживания состояния такие задачи обычно могут выполняться в конструкторе службы во время вызова `createServiceInstanceListeners()` или в рамках создания самого прослушивателя.
* Иногда код в RunAsync не запускается, пока прослушиватели открыты. В этом случае необходима дополнительная координация. Распространенным решением является использование в прослушивателях флагов, указывающих, что прослушиватели завершили работу. Их необходимо установить в RunAsync, прежде чем приступать к фактической работе.

## <a name="stateless-service-shutdown"></a>Завершение работы службы без отслеживания состояния
При завершении работы службы без отслеживания состояния те же операции выполняются в обратном порядке.

1. В параллельном режиме:
    - все открытые прослушиватели закрываются (для каждого прослушивателя вызывается `CommunicationListener.closeAsync()`);
    - маркер отмены, переданный в `runAsync()`, отменяется (в результате проверки свойства `isCancelled` маркера отмены возвращается значение true, а при вызове метода `throwIfCancellationRequested` маркера возвращается `CancellationException`).
2. После выполнения метода `closeAsync()` для каждого прослушивателя и завершения выполнения `runAsync()` при наличии вызывается метод `StatelessService.onCloseAsync()` службы (это редкое переопределение).
3. После выполнения метода `StatelessService.onCloseAsync()` объект службы уничтожается.

## <a name="stateful-service-startup"></a>Запуск службы с отслеживанием состояния
Запуск службы с отслеживанием состояния имеет лишь несколько отличий по сравнению со службой без отслеживания состояния. Для запуска службы с отслеживанием состояния порядок событий выглядит следующим образом:

1. Создается служба.
2. Вызывается метод `StatefulServiceBase.onOpenAsync()`. Этот вызов редко переопределяется в службе.
3. Ниже приведены действия, которые выполняются параллельно.
    - Вызывается метод `StatefulServiceBase.createServiceReplicaListeners()`. 
      - Если служба является первичной, открываются все возвращенные прослушиватели. Для каждого прослушивателя вызывается метод `CommunicationListener.openAsync()`.
      - Если служба является вторичной, то открываются только прослушиватели, помеченные как `listenOnSecondary = true`. Открытые прослушиватели для вторичных служб используются реже.
    - Если сейчас служба является первичной, то вызывается метод `StatefulServiceBase.runAsync()`.
4. После завершения всех вызовов `openAsync()` прослушивателя реплик и вызова `runAsync()` вызывается `StatefulServiceBase.onChangeRoleAsync()`. Этот вызов редко переопределяется в службе.

Как и для службы без сохранения состояния, нет не координацию между порядок создания и открытия прослушивателей и когда **runAsync** вызывается. Если требуется координация, то решение будет во многом схожим. Есть лишь одно дополнение для службы с отслеживанием состояния. Предположим, что для вызовов, поступающих в прослушиватели связи, требуется наличие сведений в некоторых [надежных коллекциях](service-fabric-reliable-services-reliable-collections.md). Поскольку средства прослушивания связи может открыть перед надежного коллекции для чтения или для чтения и перед **runAsync** удалось запустить некоторые дополнительные координации не требуется. Простейшее и самое распространенное решение для прослушивателей связи — вернуть код ошибки, который клиент использует для повторного запроса.

## <a name="stateful-service-shutdown"></a>Завершение работы службы с отслеживанием состояния
Как и в случае со службами без отслеживания состояния, события жизненного цикла во время завершения работы совпадают с событиями во время запуска, но происходят в обратном порядке. При завершении работы службы с отслеживанием состояния происходят следующие события.

1. В параллельном режиме:
    - Закрываются все открытые прослушиватели. Для каждого прослушивателя вызывается метод `CommunicationListener.closeAsync()`.
    - Токен отмены, передаваемый `runAsync()` отменяется. Маркер отмены вызова `isCancelled()` метод возвращает значение true и при вызове токена `throwIfCancellationRequested()` вызывает исключение `OperationCanceledException`.
2. Как только `closeAsync()` завершается для каждого прослушивателя, также завершается `runAsync()` и вызывается `StatefulServiceBase.onChangeRoleAsync()` службы. Этот вызов редко переопределяется в службе.

   > [!NOTE]  
   > Необходимо ждать **runAsync** завершения необходимо только, если эта реплика является первичной реплики.

3. После завершения метода `StatefulServiceBase.onChangeRoleAsync()` вызывается метод `StatefulServiceBase.onCloseAsync()`. Этот вызов представляет собой редко используемое переопределение, но оно доступно.
3. После выполнения метода `StatefulServiceBase.onCloseAsync()` объект службы уничтожается.

## <a name="stateful-service-primary-swaps"></a>Переключения первичной реплики службы с отслеживанием состояния
Во время выполнения службы с отслеживанием состояния, только первичные реплики, с отслеживанием состояния службы имеют их открытии прослушивания связи и их **runAsync** вызываемый метод. Вторичные реплики создаются, но не видят последующие вызовы. Пока выполняется служба с отслеживанием состояния, первичная реплика может измениться. Что это означает с точки зрения событий жизненного цикла, которые может видеть реплика? Поведение, которое видит реплика с отслеживанием состояния, зависит от того, что происходит во время переключения: понижение или повышение реплики.

### <a name="for-the-primary-thats-demoted"></a>При пониженной первичной реплике
Для пониженной первичной реплики Service Fabric требуется, чтобы эта реплика остановила обработку сообщений и выполнение любой фоновой работы. Это выглядит аналогично завершению работы службы. Отличие в том, что служба не уничтожается и не закрывается, так как остается вторичной. Вызываются следующие API.

1. В параллельном режиме:
    - Закрываются все открытые прослушиватели. Для каждого прослушивателя вызывается метод `CommunicationListener.closeAsync()`.
    - Токен отмены, переданный в `runAsync()`, отменяется. Проверка токена отмены `isCancelled()` метод возвращает значение true и при вызове токена `throwIfCancellationRequested()` вызывает исключение `OperationCanceledException`.
2. Как только `closeAsync()` завершается для каждого прослушивателя, также завершается `runAsync()` и вызывается `StatefulServiceBase.onChangeRoleAsync()` службы. Этот вызов редко переопределяется в службе.

### <a name="for-the-secondary-thats-promoted"></a>При повышении уровня вторичной реплики
Аналогичным образом Service Fabric необходимо, чтобы вторичная реплика с повышенным уровнем начала ожидать передачи сообщений и запустила все фоновые задачи, которые необходимо выполнить. Эта процедура соответствует процессу создания службы за исключением того, что сама реплика уже существует. Вызываются следующие API.

1. В параллельном режиме:
    - Вызывается метод `StatefulServiceBase.createServiceReplicaListeners()` и открываются все возвращаемые прослушиватели. Для каждого прослушивателя вызывается метод `CommunicationListener.openAsync()`.
    - Вызывается метод службы `StatefulServiceBase.runAsync()`.
2. После завершения всех вызовов `openAsync()` прослушивателя реплик и вызова `runAsync()` вызывается `StatefulServiceBase.onChangeRoleAsync()`. Этот вызов редко переопределяется в службе.


### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a>Распространенные проблемы во время завершения работы службы с отслеживанием состояния и понижения уровня первичной реплики
Service Fabric изменяет первичную реплику службы с отслеживанием состояния по ряду причин. Наиболее распространенными являются [балансировка кластера](service-fabric-cluster-resource-manager-balancing.md) и [обновление приложения](service-fabric-application-upgrade.md). Во время этих операций (а также во время штатного завершения работы службы, т. е. как при ее удалении) очень важно, чтобы служба учитывала `cancellationToken`. 

Службы, которые не обрабатывают отмену аккуратно, могут вызывать несколько проблем. Эти операции выполняются медленно, так как Service Fabric ожидает корректную остановку служб. В конечном счете это может привести к сбоям обновлений из-за истечения времени ожидания и откату. Если не использовать токен отмены, это может также нарушить балансировку кластеров. Кластеры становятся несбалансированными, потому что узлы нагружаются, но реорганизация служб невозможна, так как их перемещение занимает слишком много времени. 

Так как это службы с отслеживанием состояния, то, скорее всего, они используют [надежные коллекции](service-fabric-reliable-services-reliable-collections.md). Когда в Service Fabric понижается уровень первичной реплики, то в первую очередь отменяется доступ на запись к базовому состоянию. Это приводит ко второму ряду проблем, которые могут повлиять на жизненный цикл службы. Коллекции возвращают исключения на основании времени и операции с репликой (перемещение или завершение работы). Эти исключения должны обрабатываться правильно. Исключения, порождаемые Service Fabric, делятся на постоянные [(`FabricException`)](https://docs.microsoft.com/en-us/java/api/system.fabric.exception) и временные [(`FabricTransientException`)](https://docs.microsoft.com/en-us/java/api/system.fabric.exception._fabric_transient_exception). Постоянные исключения должны быть зарегистрированы в журнале и порождены, тогда как для временных исключений возможен повтор породившей их операции в соответствии с логикой повтора.

Обработка исключений, которые поступают от `ReliableCollections`, в сочетании с событиями жизненного цикла службы является важной частью тестирования и проверки надежной службы. Перед развертыванием в рабочей среде рекомендуется запустить службу под нагрузкой во время выполнения обновлений и [хаотического тестирования](service-fabric-controlled-chaos.md). Эти простые действия помогут обеспечить правильную реализацию службы и обработку событий жизненного цикла.

## <a name="notes-on-service-lifecycle"></a>Примечания о жизненном цикле службы
* Метод `runAsync()` и вызовы `createServiceInstanceListeners/createServiceReplicaListeners` являются необязательны. В службе может использоваться один из их, оба или ни одного. Например, если служба выполняет всю работу в ответ на вызовы пользователя, реализовывать метод `runAsync()` не нужно. Необходимы только прослушиватели связи и соответствующий код. Создание и возвращение прослушивателей связи является необязательным, так как у службы может быть только фоновая работа, поэтому достаточно реализовать `runAsync()`.
* Служба может успешно завершить `runAsync()` и вернуться из него. Это не считается сбоем и представляет фоновую работу завершения службы. Для надежных служб с отслеживанием состояния `runAsync()` будет вызываться снова, если служба была понижена с первичной, а затем обратно повышена.
* Если служба выходит при выполнении `runAsync()`, выдавая непредвиденные исключения, — это сбой. Объект службы завершает работу, и возникает ошибка работоспособности.
* Несмотря на то, что возвращение этих методов не ограничивается по времени, вы не сможете выполнять запись, а значит, и выполнить какую-либо действительную задачу. После получения запроса на отмену рекомендуется возвращать методы как можно быстрее. Если служба не отвечает на такие вызовы API в течение приемлемого промежутка времени, Service Fabric может принудительно завершить работу службы. Обычно это происходит только во время обновления приложения или при удалении службы. По умолчанию время ожидания составляет 15 минут.
* Сбои в пути `onCloseAsync()` приводят к вызову `onAbort()`, что является последней наилучшей возможностью для службы очистить и освободить все запрошенные ресурсы.

## <a name="next-steps"></a>Дальнейшие действия
* [Обзор надежных служб](service-fabric-reliable-services-introduction.md)
* [Краткое руководство по надежным службам Reliable Services](service-fabric-reliable-services-quick-start-java.md)
* [Продвинутое использование надежных служб](service-fabric-reliable-services-advanced-usage.md)
