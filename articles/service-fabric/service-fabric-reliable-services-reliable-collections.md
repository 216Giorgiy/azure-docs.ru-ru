---
title: "Reliable Collections | Документация Майкрософт"
description: "Службы с отслеживанием состояния Service Fabric предоставляют надежные коллекции, которые позволяют создавать высокодоступные и масштабируемые облачные приложения с низкой задержкой."
services: service-fabric
documentationcenter: .net
author: mcoskun
manager: timlt
editor: masnider,vturecek
ms.assetid: 62857523-604b-434e-bd1c-2141ea4b00d1
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: na
ms.workload: required
ms.date: 10/18/2016
ms.author: mcoskun
translationtype: Human Translation
ms.sourcegitcommit: 219dcbfdca145bedb570eb9ef747ee00cc0342eb
ms.openlocfilehash: 9d8be5bed137ae00dec4f66fc821a6415f269ea1


---
# <a name="introduction-to-reliable-collections-in-azure-service-fabric-stateful-services"></a>Введение в надежные коллекции в службах с отслеживанием состояния Azure Service Fabric
Надежные коллекции позволяют создавать высокодоступные и масштабируемые облачные приложения с низкой задержкой точно так же, как приложения для одного компьютера. Классы в пространстве имен **Microsoft.ServiceFabric.Data.Collections** предоставляют набор готовых коллекций, автоматически обеспечивающих высокодоступное состояние. Разработчикам нужно только создать интерфейсы API для надежных коллекций и разрешить надежным коллекциям управлять реплицированным и локальным состояниями.

Основное различие между надежными коллекциями и другими технологиями обеспечения высокой доступности (например, Redis, службы таблиц и очередей Azure) заключается в том, что состояние хранится локально в экземпляре службы и одновременно делается высокодоступным. Это означает следующее:

* Все операции чтения выполняются локально, что позволяет достичь низкой задержки и высокой пропускной способности при чтении.
* Все операции записи создают минимальное количество сетевых операций ввода-вывода, что позволяет достичь низкой задержки и высокой пропускной способности при записи.

![Изображение развития коллекций.](media/service-fabric-reliable-services-reliable-collections/ReliableCollectionsEvolution.png)

Надежные коллекции можно рассматривать как развитие классов **System.Collections**. Это новый набор удобных коллекций для разработчиков, предназначенных для облачных приложений и приложений для нескольких компьютеров. Таким образом, надежные коллекции являются:

* реплицируемыми (изменения состояния реплицируются для обеспечения высокой доступности);
* сохраняемыми (данные сохраняются на диск для защиты от крупномасштабных перебоев, например отключения питания в центре обработки данных);
* асинхронными (интерфейсы API работают асинхронно, что позволяет избежать блокировки потоков при операциях ввода-вывода);
* транзакционными (интерфейсы API используют абстракцию транзакций, что позволяет легко управлять несколькими надежными коллекциями в службе).

Надежные коллекции изначально гарантируют высокую целостность данных, благодаря чему вам будет легче анализировать состояние приложений.
Высокая целостность достигается за счет того, что фиксация транзакции завершается только после регистрации всей транзакции в большинстве кворума реплик (включая первичные реплики).
Для достижения более низкой целостности приложения могут отправить подтверждение клиенту (или инициатору запроса) до того, как вернется асинхронная фиксация.

API надежных коллекций являются развитием API параллельных коллекций (находятся в пространстве имен **System.Collections.Concurrent** ):

* работают асинхронно (возвращают задачи, потому что, в отличие от параллельных коллекций, операции реплицируются и сохраняются);
* нет выходных параметров, вместо них используется `ConditionalValue<T>` для возвращения логического типа и значения; `ConditionalValue<T>` имеет сходство с `Nullable<T>`, но не требует, чтобы значение T было структурой.
* являются транзакционными (используется объект транзакции, благодаря чему пользователь может группировать действия с несколькими надежными коллекциями в одну транзакцию).

В настоящее время пространство имен **Microsoft.ServiceFabric.Data.Collections** содержит две коллекции:

* [надежный словарь](https://msdn.microsoft.com/library/azure/dn971511.aspx) (реплицируемая, транзакционная и асинхронная коллекция пар "ключ-значение"; как и в **ConcurrentDictionary**, ключ и значение могут быть любого типа);
* [надежная очередь](https://msdn.microsoft.com/library/azure/dn971527.aspx) (реплицируемая, транзакционная и асинхронная очередь, функционирующая строго по методу FIFO; как и в **ConcurrentQueue**, значение может быть любого типа).

## <a name="isolation-levels"></a>Уровни изоляции
Уровень изоляции определяет степень, до которой транзакция должна быть изолирована от изменений, вносимых другими транзакциями.
Надежные коллекции поддерживают два уровня изоляции:

* **Повторяющееся чтение**. Указывает, какие операторы не могут считывать данные, которые были изменены, но еще не зафиксированы другими транзакциями, и что другие транзакции не могут изменять данные, считанные текущей транзакцией, до ее завершения. Дополнительные сведения см. в статье [https://msdn.microsoft.com/library/ms173763.aspx](https://msdn.microsoft.com/library/ms173763.aspx).
* **Моментальный снимок**. Указывает, что данные, считанные любым оператором в транзакции, будут согласованы с версией данных, которые существовали в начале транзакции.
  Транзакция может распознать только те изменения данных, которые были зафиксированы до ее начала.
  Изменения данных, произведенные другими транзакциями после запуска текущей транзакции, будут невидны для инструкций, выполняемых в текущей транзакции.
  Это похоже на то, как если бы инструкции в транзакции получили снимок данных, зафиксированных на момент начала транзакции.
  Моментальные снимки согласованы между надежными коллекциями.
  Дополнительные сведения см. в статье [https://msdn.microsoft.com/library/ms173763.aspx](https://msdn.microsoft.com/library/ms173763.aspx).

Для операций чтения надежные коллекции автоматически выбирают уровень изоляции в зависимости от самой операции и роли реплики в момент создания транзакции.
Ниже приведена таблица уровней изоляции по умолчанию для операций надежного словаря и очереди.

| Операция \ Роль | Первичная | Вторичная |
| --- |:--- |:--- |
| Операция чтения одной сущности |Повторяющаяся операция чтения |Снимок |
| Перечисление или подсчет |Снимок |Снимок |

> [!NOTE]
> Распространенные примеры операций с одной сущностью: `IReliableDictionary.TryGetValueAsync`, `IReliableQueue.TryPeekAsync`.
> 
> 

Надежный словарь и надежная очередь поддерживают мгновенную целостность данных (Read Your Writes, RYW).
Другими словами, каждая операция записи в рамках одной транзакции будет видна для последующей операции чтения, которая выполняется в рамках той же транзакции.

## <a name="locking"></a>Блокировка
В надежных коллекциях все транзакции являются двухэтапными: транзакция не снимает свои установленные блокировки, пока она не завершится прерыванием или фиксацией.

Надежный словарь использует блокировку уровня строки для всех операций с одной сущностью.
Надежная очередь поступается параллелизмом ради строгого соблюдения транзакционного свойства FIFO.
Надежная очередь использует блокировки уровня операции, позволяя одновременно выполнять одну транзакцию с `TryPeekAsync` и (или) `TryDequeueAsync` и одну транзакцию с `EnqueueAsync`.
Обратите внимание, что если `TryPeekAsync` или `TryDequeueAsync` когда-либо обнаружит, что надежная очередь пуста, то для сохранения логики FIFO также заблокирует `EnqueueAsync`.

Операции записи всегда используют монопольные блокировки.
Для операций чтения блокировка зависит от нескольких факторов.
В операциях чтения, выполняемых с уровнем изоляции "Снимок", блокировки не используются.
В повторяющихся операциях чтения используются совмещаемые блокировки (по умолчанию).
Тем не менее, для любой операции чтения, поддерживающей повторяющееся чтение, вместо совмещаемой блокировки пользователь может запросить блокировку изменений.
Блокировка изменений является асимметричной блокировкой, которая используется для предотвращения распространенной формы взаимоблокировки. Взаимоблокировка возникает, когда несколько транзакций блокируют ресурсы для возможного обновления в будущем.

Ниже приведена таблица совместимости блокировок.

| Запрос \ Предоставлено | Без блокировки | Совмещаемая блокировка | Блокировка изменений | Монопольная блокировка |
| --- |:--- |:--- |:--- |:--- |
| Совмещаемая блокировка |Нет конфликтов |Нет конфликтов |Конфликт |Конфликт |
| Блокировка изменений |Нет конфликтов |Нет конфликтов |Конфликт |Конфликт |
| Монопольная блокировка |Нет конфликтов |Конфликт |Конфликт |Конфликт |

Обратите внимание, что в API надежных коллекций для обнаружения взаимоблокировок используется аргумент времени ожидания.
Например, две транзакции (Т1 и Т2) пытаются считать и изменить К1.
Существует вероятность возникновения взаимоблокировки, поскольку в обеих транзакциях используется совмещаемая блокировка.
В этом случае время ожидания для одной или обеих операций будет превышено.

Описанная выше ситуация с взаимоблокировкой является хорошим примером того, как блокировка изменений может предотвратить возникновение взаимоблокировки.

## <a name="persistence-model"></a>Модель сохраняемости
Диспетчер надежных состояний и надежные коллекции используют модель сохраняемости под названием "Журнал и контрольная точка".
В этой модели каждое изменение состояния записывается в журнал на диске и применяется только в памяти.
Полное состояние сохраняется только время от времени (создается контрольная точка).
Преимущество этого состоит в том, что изменения преобразуются в операции записи на диск, которые добавляют только недостающие данные, что позволяет повысить производительность.

Чтобы лучше понять модель журнала и контрольной точки, давайте сначала рассмотрим гипотетическую ситуацию с диском неограниченного объема.
Диспетчер надежных состояний заносит в журнал каждую операцию, прежде чем она реплицируется.
Это позволяет надежной коллекции применять операцию только в памяти.
Поскольку журналы сохраняются, даже если произошел сбой реплики и ее необходимо перезапустить, диспетчер надежных состояний имеет достаточно сведений в журналах, чтобы воспроизвести все операции, которые потеряла реплика.
Так как место на диске бесконечно, записи журналов никогда не удаляются, а надежная коллекция управляет только состоянием в памяти.

Теперь рассмотрим ситуацию, когда место на диске ограничено.
Ввиду накопления записей журнала у диспетчера надежных состояний может закончиться доступное дисковое пространство.
Но пока это не произошло, диспетчеру нужно удалить из журнала часть записей, чтобы освободить место для новых записей.
Он попросит надежные коллекции создать контрольную точку для их состояния в памяти на диске.
До этого момента за сохранение состояния надежной коллекции отвечает сама надежная коллекция.
Когда надежная коллекция создаст контрольную точку, диспетчер надежных состояний сможет удалить из журнала часть записей и освободить место на диске.
Таким образом, когда возникнет необходимость перезапустить реплику, надежные коллекции смогут восстановить свое состояние из контрольной точки, а диспетчер надежных состояний сможет восстановить и воспроизвести все изменения состояния, которые произошли после создания контрольной точки.

> [!NOTE]
> Еще одно преимущество создания контрольных точек состоит в том, что в общем случае они повышают производительность восстановления.
> Это обусловлено тем, что контрольные точки содержат только последние версии.
> 
> 

## <a name="recommendations"></a>Рекомендации
* Не изменяйте объекты пользовательского типа, возвращаемые операциями чтения (например, `TryPeekAsync` или `TryGetValueAsync`). Надежные коллекции, как и параллельные коллекции, возвращают ссылку на объект, а не его копию.
* Обязательно создайте глубокую копию возвращенного объекта пользовательского типа, прежде чем изменять этот объект. Так как структуры и встроенные типы передают параметры по значению, создавать их глубокую копию не нужно.
* Не используйте `TimeSpan.MaxValue` для времени ожидания. Время ожидания следует использовать для выявления взаимоблокировок.
* Не используйте транзакцию после того, как она была зафиксирована, прервана или удалена.
* Не используйте перечисление за пределами области транзакции, в которой оно было создано.
* Не создавайте транзакцию в операторе `using` другой транзакции, так как это может привести к возникновению взаимоблокировки.
* Убедитесь, что реализация `IComparable<TKey>` правильна. Система использует соответствующую зависимость для слияния контрольных точек.
* Используете блокировку изменения при чтении элемента с целью обновить его, чтобы предотвратить взаимоблокировки определенного класса.
* Возможно, вас заинтересует применение функций архивации и восстановления для аварийного восстановления.
* Избегайте совместного использования операций с одной сущностью и операций с несколькими сущностями (например, `GetCountAsync`, `CreateEnumerableAsync`) в одной и той же транзакции ввиду различных уровней изоляции.

При этом нужно помнить о следующем:

* Время ожидания по умолчанию составляет 4 секунды для всех API надежных коллекций. Большинству пользователей не следует переопределять это значение.
* Во всех API надежных коллекций токеном отмены по умолчанию является `CancellationToken.None` .
* Параметр типа ключа (*TKey*) для надежного словаря должен правильно реализовывать `GetHashCode()` и `Equals()`. Ключи должны быть неизменяемыми.
* Чтобы обеспечить высокую доступность надежных коллекций, в каждой службе необходимый и минимальный размер набора реплик должен быть равен как минимум 3.
* Операции чтения в базе данных-получателе могут считывать версии без кворума.
  Это означает, что версия данных, считываемая из отдельной базы данных-получателя, может быть ложно увеличена.
  Разумеется, чтение из базы данных-источника всегда стабильно и не может вызывать ложное увеличение номера версии.

## <a name="next-steps"></a>Дальнейшие действия
* [Краткое руководство по надежным службам Reliable Services](service-fabric-reliable-services-quick-start.md)
* [Работа с Reliable Collections](service-fabric-work-with-reliable-collections.md)
* [Уведомления Reliable Services](service-fabric-reliable-services-notifications.md)
* [Архивация и восстановление (аварийное восстановление) надежных служб](service-fabric-reliable-services-backup-restore.md)
* [Конфигурация диспетчера надежных состояний](service-fabric-reliable-services-configuration.md)
* [Приступая к работе со службами веб-API Service Fabric](service-fabric-reliable-services-communication-webapi.md)
* [Дополнительные возможности использования модели программирования надежных служб](service-fabric-reliable-services-advanced-usage.md)
* [Справочник разработчика по надежным коллекциям](https://msdn.microsoft.com/library/azure/microsoft.servicefabric.data.collections.aspx)




<!--HONumber=Nov16_HO3-->


