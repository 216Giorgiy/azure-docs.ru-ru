<properties
   pageTitle="Надежные коллекции | Microsoft Azure"
   description="Службы с отслеживанием состояния Service Fabric предоставляют надежные коллекции, которые позволяют создавать высокодоступные и масштабируемые облачные приложения с низкой задержкой."
   services="service-fabric"
   documentationCenter=".net"
   authors="mcoskun"
   manager="timlt"
   editor="masnider,vturecek"/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="required"
   ms.date="03/25/2016"
   ms.author="mcoskun"/>

# Введение в надежные коллекции в службах с отслеживанием состояния Azure Service Fabric

Надежные коллекции позволяют создавать высокодоступные и масштабируемые облачные приложения с низкой задержкой точно так же, как приложения для одного компьютера. Классы в пространстве имен **Microsoft.ServiceFabric.Data.Collections** предоставляют набор готовых коллекций, автоматически обеспечивающих высокодоступное состояние. Разработчикам нужно только создать интерфейсы API для надежных коллекций и разрешить надежным коллекциям управлять реплицированным и локальным состояниями.

Основное различие между надежными коллекциями и другими технологиями обеспечения высокой доступности (например, Redis, службы таблиц и очередей Azure) заключается в том, что состояние хранится локально в экземпляре службы и одновременно делается высокодоступным. Это означает следующее:

- Все операции чтения выполняются локально, что позволяет достичь низкой задержки и высокой пропускной способности при чтении.
- Все операции записи создают минимальное количество сетевых операций ввода-вывода, что позволяет достичь низкой задержки и высокой пропускной способности при записи.

![Изображение развития коллекций.](media/service-fabric-reliable-services-reliable-collections/ReliableCollectionsEvolution.png)

Надежные коллекции можно рассматривать как развитие классов **System.Collections**. Это новый набор удобных коллекций для разработчиков, предназначенных для облачных приложений и приложений для нескольких компьютеров. Таким образом, надежные коллекции являются:

- реплицируемыми (изменения состояния реплицируются для обеспечения высокой доступности);
- сохраняемыми (данные сохраняются на диск для защиты от крупномасштабных перебоев, например отключения питания в центре обработки данных);
- асинхронными (интерфейсы API работают асинхронно, что позволяет избежать блокировки потоков при операциях ввода-вывода);
- транзакционными (интерфейсы API используют абстракцию транзакций, что позволяет легко управлять несколькими надежными коллекциями в службе).

Надежные коллекции изначально гарантируют высокую целостность данных, благодаря чему вам будет легче анализировать состояние приложений. Высокая целостность достигается за счет того, что фиксация транзакции завершается только после регистрации всей транзакции в большинстве кворума реплик (включая первичные реплики). Для достижения более низкой целостности приложения могут отправить подтверждение клиенту (или инициатору запроса) до того, как вернется асинхронная фиксация.

API надежных коллекций являются развитием API параллельных коллекций (находятся в пространстве имен **System.Collections.Concurrent**):

- работают асинхронно (возвращают задачи, потому что, в отличие от параллельных коллекций, операции реплицируются и сохраняются);
- нет выходных параметров (вместо параметров используется `ConditionalValue<T>` для возврата логического типа и значения; `ConditionalValue<T>` напоминает `Nullable<T>`, но может быть структурой без T);
- являются транзакционными (используется объект транзакции, благодаря чему пользователь может группировать действия с несколькими надежными коллекциями в одну транзакцию).

В настоящее время пространство имен **Microsoft.ServiceFabric.Data.Collections** содержит две коллекции:

- [надежный словарь](https://msdn.microsoft.com/library/azure/dn971511.aspx) (реплицируемая, транзакционная и асинхронная коллекция пар «ключ — значение»; как и в **ConcurrentDictionary**, ключ и значение могут быть любого типа);
- [надежная очередь](https://msdn.microsoft.com/library/azure/dn971527.aspx) (реплицируемая, транзакционная и асинхронная очередь, функционирующая строго по методу FIFO; как и в **ConcurrentQueue**, значение может быть любого типа).

## Уровни изоляции
Уровень изоляции — это степень полученной изоляции. Изоляция означает, что транзакция выполняется так, как если бы она выполнялась в системе, которая разрешает выполнение только одной транзакции в любой данный момент времени.

Для операций чтения надежные коллекции автоматически выбирают уровень изоляции в зависимости от самой операции и роли реплики.

Надежные коллекции поддерживают два уровня изоляции:

- **Повторяющееся чтение**. Указывает, какие операторы не могут считывать данные, которые были изменены, но еще не зафиксированы другими транзакциями, и что другие транзакции не могут изменять данные, считанные текущей транзакцией, до завершения текущей транзакции. Дополнительные сведения см. в статье по адресу: [https://msdn.microsoft.com/library/ms173763.aspx](https://msdn.microsoft.com/library/ms173763.aspx).
- **Моментальный снимок**. Указывает, что данные, считанные любым оператором в транзакции, будут согласованы с версией данных, которые существовали в начале транзакции. Транзакция может распознать только те изменения данных, которые были зафиксированы до ее начала. Изменения данных, произведенные другими транзакциями после запуска текущей транзакции, будут невидны для инструкций, выполняемых в текущей транзакции. Это похоже на то, как если бы инструкции в транзакции получили снимок данных, зафиксированных на момент начала транзакции. Моментальные снимки согласованы между надежными коллекциями. Дополнительные сведения см. в статье по адресу: [https://msdn.microsoft.com/library/ms173763.aspx](https://msdn.microsoft.com/library/ms173763.aspx).

Надежный словарь и надежная очередь поддерживают мгновенную целостность данных (Read Your Writes, RYW). Другими словами, каждая операция записи в рамках одной транзакции будет видна для последующей операции чтения, которая выполняется в рамках той же транзакции.

### Надежный словарь
| Операция \\ Роль | Первичная | Второстепенный |
| --------------------- | :--------------- | :--------------- |
| Операция чтения одной сущности | Повторяющаяся операция чтения | Снимок |
| Перечисление или подсчет | Снимок | Снимок |

### Надежная очередь
| Операция \\ Роль | Первичная | Второстепенный |
| --------------------- | :--------------- | :--------------- |
| Операция чтения одной сущности | Снимок | Снимок |
| Перечисление или подсчет | Снимок | Снимок |

## Модель сохраняемости
Диспетчер надежных состояний и надежные коллекции используют модель сохраняемости под названием "Журнал и контрольная точка". В этой модели каждое изменение состояния записывается в журнал на диске и применяется только в памяти. Полное состояние сохраняется только время от времени (создается контрольная точка). Преимущество этой модели заключается в следующем.

- Изменения преобразуются в последовательные операции дозаписи на диск, что позволяет повысить производительность.

Чтобы лучше понять модель журнала и контрольной точки, давайте сначала рассмотрим гипотетическую ситуацию с диском неограниченного объема. Диспетчер надежных состояний заносит в журнал каждую операцию, прежде чем она реплицируется. Это позволяет надежной коллекции применять операцию только в памяти. Поскольку журналы сохраняются, даже если произошел сбой реплики и ее необходимо перезапустить, диспетчер надежных состояний имеет достаточно сведений в журналах, чтобы воспроизвести все операции, которые потеряла реплика. Так как место на диске бесконечно, записи журналов никогда не удаляются, а надежная коллекция управляет только состоянием в памяти.

Теперь рассмотрим ситуацию, когда место на диске ограничено. В какой-то момент у диспетчера надежных состояний закончится место на диске. Но пока это не произошло, диспетчеру нужно удалить из журнала часть записей, чтобы освободить место для новых записей. Он попросит надежные коллекции создать контрольную точку для их состояния в памяти на диске. До этого момента за сохранение состояния надежной коллекции отвечает сама надежная коллекция. Когда надежная коллекция создаст контрольную точку, диспетчер надежных состояний сможет удалить из журнала часть записей и освободить место на диске. Таким образом, когда возникнет необходимость перезапустить реплику, надежные коллекции смогут восстановить свое состояние из контрольной точки, а диспетчер надежных состояний сможет восстановить и воспроизвести все изменения состояния, которые произошли после создания контрольной точки.

## Блокировка
В надежных коллекциях все транзакции являются двухэтапными: транзакция не снимает свои установленные блокировки, пока она не завершится прерыванием или фиксацией.

Надежные коллекции всегда используют монопольные блокировки. Для операций чтения блокировка зависит от нескольких факторов. В операциях чтения, выполняемых с уровнем изоляции "Снимок", блокировки не используются. В повторяющихся операциях чтения используются совмещаемые блокировки (по умолчанию). Тем не менее, для любой операции чтения, поддерживающей повторяющееся чтение, вместо совмещаемой блокировки пользователь может запросить блокировку изменений. Блокировка изменений является асимметричной блокировкой, которая используется для предотвращения распространенной формы взаимоблокировки. Взаимоблокировка возникает, когда несколько транзакций блокируют ресурсы для возможного обновления в будущем.

Ниже приведена таблица совместимости блокировок.

| Запрос \\ Предоставлено | Без блокировки | Совмещаемая блокировка | Блокировка изменений | Монопольная блокировка |
| ----------------- | :----------- | :----------- | :---------- | :----------- |
| Совмещаемая блокировка | Нет конфликтов | Нет конфликтов | Конфликт | Конфликт |
| Блокировка изменений | Нет конфликтов | Нет конфликтов | Конфликт | Конфликт |
| Монопольная блокировка | Нет конфликтов | Конфликт | Конфликт | Конфликт |

Обратите внимание, что в API надежных коллекций для обнаружения взаимоблокировок используется аргумент времени ожидания. Например, две транзакции (Т1 и Т2) пытаются считать и изменить К1. Существует вероятность возникновения взаимоблокировки, поскольку в обеих транзакциях используется совмещаемая блокировка. В этом случае время ожидания для одной или обеих операций будет превышено.

Описанная выше ситуация с взаимоблокировкой является хорошим примером того, как блокировка изменений может предотвратить возникновение взаимоблокировки.

## Рекомендации

- Не изменяйте объекты пользовательского типа, возвращаемые операциями чтения (например, `TryPeekAsync` или `TryGetValueAsync`). Надежные коллекции, как и параллельные коллекции, возвращают ссылку на объект, а не его копию.
- Обязательно создайте глубокую копию возвращенного объекта пользовательского типа, прежде чем изменять этот объект. Так как структуры и встроенные типы передают параметры по значению, создавать их глубокую копию не нужно.
- Не используйте `TimeSpan.MaxValue` для времени ожидания. Время ожидания следует использовать для выявления взаимоблокировок.
- Не создавайте транзакцию в инструкции `using` другой транзакции, так как это может привести к возникновению взаимоблокировки.
- Убедитесь, что реализация `IComparable<TKey>` верна. Система использует соответствующую зависимость для слияния контрольных точек.
- Возможно, вас заинтересует применение функций архивации и восстановления для аварийного восстановления.

При этом нужно помнить о следующем:

- Время ожидания по умолчанию составляет 4 секунды для всех API надежных коллекций. Большинству пользователей не следует переопределять это значение.
- Во всех API надежных коллекций токеном отмены по умолчанию является `CancellationToken.None`.
- Параметр типа ключа (*TKey*) для надежного словаря должен правильно реализовывать `GetHashCode()` и `Equals()`. Ключи должны быть неизменяемыми.
- Чтобы обеспечить высокую доступность надежных коллекций, в каждой службе необходимый и минимальный размер набора реплик должен быть равен как минимум 3.
- Операции чтения в базе данных-получателе могут считывать версии без кворума. Это означает, что версия данных, считываемая из отдельной базы данных-получателя, может быть ложно увеличена. Разумеется, чтение из базы данных-источника всегда стабильно и не может вызывать ложное увеличение номера версии.

## Дальнейшие действия

- [Краткое руководство по надежным службам Reliable Services](service-fabric-reliable-services-quick-start.md)
- [Архивация и восстановление (аварийное восстановление) надежных служб](service-fabric-reliable-services-backup-restore.md)
- [Конфигурация диспетчера надежных состояний](service-fabric-reliable-services-configuration.md)
- [Приступая к работе со службами веб-API Service Fabric](service-fabric-reliable-services-communication-webapi.md)
- [Дополнительные возможности использования модели программирования надежных служб](service-fabric-reliable-services-advanced-usage.md)
- [Справочник разработчика по надежным коллекциям](https://msdn.microsoft.com/library/azure/microsoft.servicefabric.data.collections.aspx)

<!---HONumber=AcomDC_0518_2016-->