<properties
   pageTitle="Начало работы с надежными службами Service Fabric Microsoft Azure"
   description="Service Fabric поддерживает службы с отслеживанием и без отслеживания состояния. В этой статье описано поэтапное создание приложений Service Fabric со службами без отслеживания состояния и с отслеживанием состояния."
   services="service-fabric"
   documentationCenter=".net"
   authors="vturecek"
   manager="timlt"
   editor="jessebenson"/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="06/09/2015"
   ms.author="vturecek"/>

# Начало работы с надежными службами Service Fabric Microsoft Azure

Приложение Service Fabric содержит одну или несколько служб, которые выполняют код. В этом руководстве описано поэтапное создание приложений Service Fabric «Hello World» без отслеживания состояния и с отслеживанием состояния с помощью [модели программирования *надежных служб*](../Service-Fabric/service-fabric-reliable-services-introduction.md).

Сейчас в облачных службах преимущественно используется служба без отслеживания состояния Служба без отслеживания состояния сама по себе не содержит данных, требующих надежного хранения или высокой доступности. Проще говоря, если экземпляр службы без отслеживания состояния завершает работу, все его внутреннее состояние теряется. Для обеспечения высокой доступности и надежности в службах этого типа состояния должны сохраняться во внешнее хранилище, например таблицы Azure или базы данных SQL.

Service Fabric представляет новый тип службы с отслеживанием состояния — это служба, которая может надежно поддерживать свое состояние, вместе с кодом, который ее использует. Service Fabric делает ваше состояние высокодоступным без необходимости сохранения состояния во внешнее хранилище.

В этом руководстве мы реализуем службу без отслеживания состояния и службу с отслеживанием состояния с внутренним счетчиком. После перезапуска или перемещения службы без отслеживания состояния значение счетчика теряется. В службе с отслеживанием состояния надежность счетчика обеспечивается Service Fabric, и в случае прерывания выполнения службы по какой-либо причине подсчет продолжится с места остановки.

## Создание службы без отслеживания состояния

Давайте начнем со службы без отслеживания состояния.

Запустите Visual Studio RC 2015 от имени **администратора** и создайте новый проект **службы без отслеживания состояния Service Fabric** с именем *HelloWorld*:

![Создание службы без отслеживания состояния Service Fabric с помощью диалогового окна «Создание проекта»](media/service-fabric-reliable-services-quick-start/hello-stateless-NewProject.png)

В созданном решении будет 2 проекта.

 + **HelloWorldApplication** — это проект *приложения*, содержащий ваши *службы*. В нем также содержится манифест приложения, описывающий приложение, и ряд скриптов PowerShell для развертывания приложения.
 + **HelloWorld** — это проект службы, который содержит реализацию службы без сохранения состояния.


## Реализация службы

Откройте файл **HelloWorld.cs** в проекте службы. В Service Fabric служба может выполнять любую бизнес-логику. API службы предоставляет две точки входа для кода.

 - Вызывается метод *RunAsync* с открытой точкой входа, в котором можно начать выполнение любой рабочей нагрузки, например длительных вычислений.

```C#

protected override async Task RunAsync(CancellationToken cancellationToken)
{
    ...
}

```

 - Точка входа связи, в которой можно подключить стек связи по выбору, например веб-API, в котором вы можете получать запросы от пользователей или других служб.

```C#

protected override ICommunicationListener CreateCommunicationListener()
{
    ...
}

```

В этом руководстве рассматривается метод точки входа `RunAsync()`, в котором можно немедленно начать выполнение кода. Шаблон проекта включает пример реализации `RunAsync()`, который инкрементирует счетчик.

> [AZURE.NOTE]Дополнительные сведения о работе со стеком связи см. в статье [Начало работы со службами веб API Microsoft Azure Service Fabric с собственным хостом OWIN](service-fabric-reliable-services-communication-webapi.md)


### Метод RunAsync

```C#

protected override async Task RunAsync(CancellationToken cancellationToken)
{
    // TODO: Replace the following with your own logic.

    int iterations = 0;
    while (!cancellationToken.IsCancellationRequested)
    {
        ServiceEventSource.Current.ServiceMessage(this, "Working-{0}", iterations++);
        await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);
    }
}

```

Платформа вызывает этот метод, когда экземпляр вашей службы размещен и готов к выполнению. Для службы без отслеживания состояния это означает, что экземпляр службы открыт. Токен отмены предоставляется для координации закрытия экземпляра вашей службы. В Service Fabric этот цикл открытия — закрытия экземпляра службы может повторяться множество раз в течение времени существования службы. Это происходит, потому что система может перемещать экземпляры вашей службы для балансировки ресурсов в случае отказов во время обновления приложения или системы либо когда аппаратное обеспечение выходит из строя. Эта оркестрация управляется системой с целью сохранения высокой доступности и надлежащей сбалансированности службы.

`RunAsync()` выполняется в собственном Task. Обратите внимание, что во фрагменте кода мы переходим вправо в цикл while, поэтому нет необходимости планировать отдельную задачу для рабочей нагрузки. Отмена рабочей нагрузки является совместным действием, координированным предоставленным токеном отмены. Система будет ожидать окончания вашей задачи (успешного завершения, отмены или сбоя) перед продолжением работы, поэтому когда операция отмены будет затребована системой, *важно* не потерять токен отмены, завершить все работы и выйти из `RunAsync()`.

В этом примере службы без отслеживания состояния счетчик хранится в локальной переменной. Но, поскольку это служба без отслеживания состояния, хранимое значение существует только в текущем жизненном цикле экземпляра службы, в котором оно находится. Если службу переместить или перезапустить, значение будет утеряно.

## Создание службы с отслеживанием состояния

Чтобы значение нашего счетчика было высокодоступным и постоянным даже в случае перемещения или перезапуска службы, нужно использовать службу с отслеживанием состояния.

В том же приложении **HelloWorld** добавьте новую службу, щелкнув правой кнопкой мыши проект приложения и выбрав пункт «Новая Fabric Service».

![Добавление службы в приложение Service Fabric](media/service-fabric-reliable-services-quick-start/hello-stateful-NewService.png)

Выберите **Служба с отслеживанием состояния Service Fabric** и назовите его «HelloWorldStateful». Щелкните **Добавить**.

![Создание службы с отслеживанием состояния Service Fabric с помощью диалогового окна «Создание проекта»](media/service-fabric-reliable-services-quick-start/hello-stateful-NewProject.png)

Теперь в вашем приложении должно быть две службы: служба *HelloWorld* без отслеживания состояния и служба *HelloWorldStateful*с отслеживанием состояния. Откройте **HelloWorldStateful.cs** в *HelloWorldStateful*:

```C#

protected override async Task RunAsync(CancellationToken cancellationToken)
{
    // TODO: Replace the following with your own logic.
    IReliableDictionary<string, long>  myDictionary = await this.StateManager.GetOrAddAsync<IReliableDictionary<string, long>>("myDictionary");

    while (!cancellationToken.IsCancellationRequested)
    {
        using (ITransaction tx = this.StateManager.CreateTransaction())
        {
            var result = await myDictionary.TryGetValueAsync(tx, "Counter-1");
            ServiceEventSource.Current.ServiceMessage(
                this,
                "Current Counter Value: {0}",
                result.HasValue ? result.Value.ToString() : "Value does not exist.");

            await myDictionary.AddOrUpdateAsync(tx, "Counter-1", 0, (k, v) => ++v);

            await tx.CommitAsync();
        }

        await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);
    }
}

```

### Метод RunAsync

Служба с отслеживанием состояния имеет такие же точки входа, как и служба без отслеживания состояния. Их основное различие заключается в доступности *Надежных коллекций* и *Диспетчера состояний*. В обеих службах метод `RunAsync()` работает одинаково, только в службе без отслеживания состояния перед выполнением `RunAsync()` платформа проделывает некоторую работу от вашего имени, например проверяет готовность к использованию *Диспетчера состояний* и *Надежных коллекций*.

### Надежные коллекции и диспетчер состояний

```C#

IReliableDictionary<string, long> myDictionary = await this.StateManager.GetOrAddAsync<IReliableDictionary<string, long>>("myDictionary");

```

**IReliableDictionary** — это словарь, в котором можно локально хранить состояние в надежной части встроенных [Надежных коллекций](service-fabric-reliable-services-reliable-collections.md) Service Fabric. Service Fabric делает вашу службу и состояние, которое хранится в надежной коллекции, высокодоступными. Теперь в Service Fabric и надежных коллекциях можно надежно хранить данные непосредственно в службе без использования внешнего постоянного хранилища. В Service Fabric это достигается созданием нескольких *реплик* службы и управлением ими с помощью API, который упрощает управление этими репликами и переходы между их состояниями.

В надежных коллекциях можно хранить любые типы объектов .NET, включая ваши пользовательские типы, с некоторыми предостережениями.

 1. Service Fabric делает ваше состояние высокодоступным, *реплицируя* его между узлами и сохраняя на локальном диске. Это означает, что все, что хранится в надежной коллекции, должно *сериализоваться*. По умолчанию надежные коллекции используют [DataContract](https://msdn.microsoft.com/library/system.runtime.serialization.datacontractattribute%28v=vs.110%29.aspx) для сериализации, поэтому при использовании сериализатора по умолчанию убедитесь, что ваши типы [поддерживаются сериализатором контракта данных](https://msdn.microsoft.com/library/ms731923%28v=vs.110%29.aspx).

 2. После фиксации транзакции в надежной коллекции объекты реплицируются и получают высокий уровень доступности. Объекты, сохраненные в надежной коллекции, хранятся в локальной памяти вашей службы, а это означает, что у вас есть локальная ссылка на объект. Очень важно не изменять локальные экземпляры этих объектов без выполнения операции обновления в надежной коллекции в транзакции, так как эти изменения не реплицируются автоматически.

*StateManager* управляет надежными коллекциями. Запросите у StateManager имя надежной коллекции в любое время в любом месте службы, чтобы получить ссылку. Мы не рекомендуем сохранять ссылки на экземпляры надежной коллекции в переменных или свойствах членов класса, так как необходимо очень внимательно следить, чтобы ссылка была направлены на экземпляр на протяжении всего жизненного цикла службы. StateManager выполняет за вас эту работу, так как он оптимизирован для повторных визитов.

### Транзакционные и асинхронные операции

```C#

using (ITransaction tx = this.StateManager.CreateTransaction())
{
    var result = await myDictionary.TryGetValueAsync(tx, "Counter-1");

    await myDictionary.AddOrUpdateAsync(tx, "Counter-1", 0, (k, v) => ++v);

    await tx.CommitAsync();
}

```

Надежные коллекции имеют множество таких же операций, как аналогичные им System.Collections.Generic и System.Collections.Concurrent, в том числе LINQ. Тем не менее, операции надежных коллекций являются асинхронными, поскольку операции записи в надежных коллекциях *реплицируются*, то есть операции отправляются другим репликам службы на разных узлах для обеспечения высокого уровня доступности.

Они также поддерживают *транзакционные* операции, которые позволяют поддерживать нескольких надежных коллекций в одинаковом состоянии. Например, вы можете исключить рабочий элемент из надежной очереди, выполнить над ним какую-либо операцию и сохранить результат в надежном словаре, и это все в пределах одной транзакции. Такая операция называется атомарной, она предусматривает, что вся операция завершится успешно, либо совсем не завершится. Если ошибка возникнет после удаления элемента из очереди, но до сохранения результата, вся транзакция будет откатана, и элемент останется в очереди для обработки.

## Запуск приложения

Теперь вы можете построить и развернуть свои службы. Нажмите клавишу **F5**, и приложение будет построено и развернуто в вашем локальном кластере. После запуска службы можно увидеть созданные события трассировки событий Windows в окне **События диагностики**. Обратите внимание, что в приложении отображаются события из службы без отслеживания состояния и с отслеживанием состояния. Поток можно приостановить нажатием кнопки *Приостановить* и просмотреть сведения о сообщении, развернув его.

> [AZURE.NOTE]Перед запуском приложения убедитесь, что кластер локальной разработки запущен. Чтобы получить настройки локальной среды, см. [Руководство по началу работы](service-fabric-get-started.md).

![Просмотр событий диагностики в Visual Studio](media/service-fabric-reliable-services-quick-start/hello-stateful-Output.png)


## Дальнейшие действия

[Отладка приложения Service Fabric в Visual Studio](service-fabric-debugging-your-application.md)

[Начало работы со службами веб API Microsoft Azure Service Fabric с собственным хостом OWIN](service-fabric-reliable-services-communication-webapi.md)

[Дополнительные сведения о надежных коллекциях](service-fabric-reliable-services-reliable-collections.md)

[Управление службой Service Fabric](service-fabric-manage-your-service-index.md)

[Справочник разработчика по надежным службам](https://msdn.microsoft.com/library/azure/dn706529.aspx)
 

<!---HONumber=58_postMigration-->