---
title: "Общие сведения о жизненном цикле Reliable Services в Azure Service Fabric | Документация Майкрософт"
description: "Сведения о различных событиях жизненного цикла служб Reliable Services в Service Fabric"
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek;
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 01/05/2017
ms.author: masnider;
translationtype: Human Translation
ms.sourcegitcommit: eeb56316b337c90cc83455be11917674eba898a3
ms.openlocfilehash: 1237f467cf993170eaf1345134fb732d4f0b1171
ms.lasthandoff: 04/03/2017

---

# <a name="reliable-services-lifecycle-overview"></a>Жизненный цикл Reliable Services
> [!div class="op_single_selector"]
> * [C# в Windows](service-fabric-reliable-services-lifecycle.md)
> * [Java в Linux](service-fabric-reliable-services-lifecycle-java.md)
>
>

Если речь идет о жизненных циклах служб Reliable Services, наиболее важны основные аспекты, а именно:

* во время запуска:
  * создаются службы;
  * они могут создавать и возвращать ни одного или несколько прослушивателей;
  * все возвращаемые прослушиватели открываются, что разрешает взаимодействие со службой;
  * вызывается метод RunAsync службы, позволяя службе выполнять длительную или фоновую работу;
* во время завершения работы:
  * маркер отмены, переданный в RunAsync, отменяется, и прослушиватели закрываются;
  * после этого уничтожается сам объект службы.

Следует отметить некоторые моменты, связанные с точным порядком этих событий. В частности, порядок событий может немного изменяться в зависимости от того, предусматривают ли Reliable Services отслеживание состояния. В случае со службами с отслеживанием состояния приходится иметь дело со сценарием переключения первичной реплики. Во время этой процедуры первичная роль передается другой реплике (или возвращается) без завершения работы службы. И, наконец, следует учитывать условия ошибок и сбоев.

## <a name="stateless-service-startup"></a>Запуск службы без отслеживания состояния
Жизненный цикл службы без отслеживания состояния достаточно прост. Ниже приведен порядок событий.

1. Создается служба.
2. Затем одновременно происходят две вещи:
    - вызывается метод `StatelessService.CreateServiceInstanceListeners()` и открываются все возвращаемые прослушиватели (для каждого прослушивателя вызывается `ICommunicationListener.OpenAsync()`);
    - вызывается метод RunAsync службы (`StatelessService.RunAsync()`).
3. При наличии вызывается собственный метод службы OnOpenAsync (в частности, вызывается `StatelessService.OnOpenAsync()`). Это редко используемое переопределение, но оно доступно.

Важно отметить, что между вызовами методов для создания и открытия прослушивателей и RunAsync нет упорядоченности. Прослушиватели могут быть открыты перед запуском RunAsync. Аналогичным образом метод RunAsync может быть вызван перед открытием или созданием прослушивателей связи. Если синхронизация не требуется, она остается в качестве упражнения для разработчика. Ниже приведены распространенные решения.

* Иногда прослушиватели не будут работать, пока не будут сформированы другие сведения или выполнены некоторые задачи. Для служб без отслеживания состояния такие задачи обычно могут выполняться в конструкторе службы во время вызова `CreateServiceInstanceListeners()` или в рамках создания самого прослушивателя.
* Иногда код в RunAsync не запускается, пока прослушиватели открыты. В этом случае необходима дополнительная координация. Распространенным решением является использовать в прослушивателях флаги, указывающие что, прослушиватели завершили работу. Их необходимо установить в RunAsync, прежде чем приступать к фактической работе.

## <a name="stateless-service-shutdown"></a>Завершение работы службы без отслеживания состояния
При завершении работы службы без отслеживания состояния те же операции выполняются в обратном порядке.

1. В параллельном режиме:
    - все открытые прослушиватели закрываются (для каждого прослушивателя вызывается `ICommunicationListener.CloseAsync()`);
    - маркер отмены, переданный `RunAsync()`, отменяется (в результате проверки свойства `IsCancellationRequested` маркера отмены возвращается значение true, а при вызове метода `ThrowIfCancellationRequested` маркера возвращается `OperationCanceledException`).
2. После выполнения метода `CloseAsync()` для каждого прослушивателя и завершения выполнения `RunAsync()` при наличии вызывается метод `StatelessService.OnCloseAsync()` службы (это редкое переопределение).
3. После выполнения метода `StatelessService.OnCloseAsync()` объект службы уничтожается.

## <a name="stateful-service-startup"></a>Запуск службы с отслеживанием состояния
Запуск службы с отслеживанием состояния имеет лишь несколько отличий по сравнению со службой без отслеживания состояния. При запуске службы с отслеживанием состояния порядок событий выглядит следующим образом.

1. Создается служба.
2. Вызывается метод `StatefulServiceBase.OnOpenAsync()`. (Это редко переопределяется в службе.)
3. Если рассматриваемая реплика службы является первичной, затем одновременно выполняются следующие действия (в противном случае служба перейдет к шагу 4):
    - вызывается метод `StatefulServiceBase.CreateServiceReplicaListeners()` и открываются все возвращаемые прослушиватели (для каждого прослушивателя вызывается `ICommunicationListener.OpenAsync()`);
    - вызывается метод RunAsync службы (`StatefulServiceBase.RunAsync()`).
4. Когда завершены все вызовы `OpenAsync()` прослушивателя реплики и запущен метод `RunAsync()` (или эти шаги были пропущены, так как реплика является вторичной), вызывается `StatefulServiceBase.OnChangeRoleAsync()`. (Это редко переопределяется в службе.)

Как и в случае со службами без отслеживания состояния, между порядком, в котором прослушиватели создаются и открываются, а также вызовом RunAsync отсутствует координация. Решения схожи. Есть лишь одно дополнение. Скажем так: для работы вызовов, поступающих в прослушиватели связи, требуется наличие сведений в некоторых [надежных коллекциях](service-fabric-reliable-services-reliable-collections.md). Так как прослушиватели связи могут быть открыты до того, как надежные коллекции станут доступны для чтения или записи, а также до запуска RunAsync, потребуется дополнительная координация. Простейшее и самое распространенное решение для прослушивателей связи — вернуть код ошибки, который клиент использует для повторного запроса.

## <a name="stateful-service-shutdown"></a>Завершение работы службы с отслеживанием состояния
Как и в случае со службами без отслеживания состояния, события жизненного цикла во время завершения работы совпадают с событиями во время запуска, но происходят в обратном порядке. При завершении работы службы с отслеживанием состояния происходят следующие события.

1. В параллельном режиме:
    - все открытые прослушиватели закрываются (для каждого прослушивателя вызывается `ICommunicationListener.CloseAsync()`);
    - маркер отмены, переданный `RunAsync()`, отменяется (в результате проверки свойства `IsCancellationRequested` маркера отмены возвращается значение true, а при вызове метода `ThrowIfCancellationRequested` маркера возвращается `OperationCanceledException`).
2. После выполнения метода `CloseAsync()` для каждого прослушивателя и завершения выполнения `RunAsync()` (необходимо, только если реплика этой службы является первичной), вызывается `StatefulServiceBase.OnChangeRoleAsync()` службы. (Это редко переопределяется в службе.)
3. После завершения метода `StatefulServiceBase.OnChangeRoleAsync()` вызывается метод `StatefulServiceBase.OnCloseAsync()` (это редкое, но доступное переопределение).
3. После завершения `StatefulServiceBase.OnCloseAsync()` объект службы уничтожается.

## <a name="stateful-service-primary-swaps"></a>Переключения первичной реплики службы с отслеживанием состояния
Во время выполнения службы с отслеживанием состояния только первичные реплики этих служб открывают прослушиватели связи и вызывают метод RunAsync. Вторичные реплики создаются, но не видят последующие вызовы. Пока выполняется служба с отслеживанием состояния, первичная реплика может измениться. Что это означает с точки зрения событий жизненного цикла, которые может видеть реплика? Поведение, которое видит реплика с отслеживанием состояния, зависит от того, что происходит во время переключения: понижение или повышение реплики.

### <a name="for-the-primary-being-demoted"></a>При понижении первичной реплики
Service Fabric требуется, чтобы эта реплика остановила обработку сообщений и выполнение любой фоновой работы. Это выглядит аналогично завершению работы службы. Отличие в том, что служба не уничтожается или закрывается, так как остается вторичной. Вызываются следующие API.

1. В параллельном режиме:
    - все открытые прослушиватели закрываются (для каждого прослушивателя вызывается `ICommunicationListener.CloseAsync()`);
    - маркер отмены, переданный `RunAsync()`, отменяется (в результате проверки свойства `IsCancellationRequested` маркера отмены возвращается значение true, а при вызове метода `ThrowIfCancellationRequested` маркера возвращается `OperationCanceledException`).
2. Как только `CloseAsync()` завершается для каждого прослушивателя, а также завершается `RunAsync()`, вызывается `StatefulServiceBase.OnChangeRoleAsync()` службы. (Это редко переопределяется в службе.)

### <a name="for-the-secondary-being-promoted"></a>При повышении вторичной реплики
Аналогичным образом для Service Fabric необходимо, чтобы эта реплика запустила прослушивание передаваемых сообщений (если она это делает) и все необходимые фоновые задачи. Эта процедура соответствует процессу создании службы за исключением того, что сама реплика уже существует. Вызываются следующие API.

1. В параллельном режиме:
    - вызывается метод `StatefulServiceBase.CreateServiceReplicaListeners()` и открываются все возвращаемые прослушиватели (для каждого прослушивателя вызывается `ICommunicationListener.OpenAsync()`);
    - вызывается метод RunAsync службы (`StatefulServiceBase.RunAsync()`).
4. Когда завершены все вызовы `OpenAsync()` прослушивателя реплики и запущен `RunAsync()` (или эти шаги были пропущены, так как реплика является вторичной), вызывается `StatefulServiceBase.OnChangeRoleAsync()`. (Это редко переопределяется в службе.)

## <a name="notes-on-service-lifecycle"></a>Примечания о жизненном цикле службы
* Метод `RunAsync()` и вызовы `CreateServiceReplicaListeners/CreateServiceInstanceListeners` являются необязательны. В службе может использоваться один из их, оба или ни одного. Например, если служба выполняет всю работу в ответ на вызовы пользователя, реализовывать метод `RunAsync()` не нужно. Необходимы только прослушиватели связи и соответствующий код. Создание и возвращение прослушивателей связи является необязательным, так как у службы может быть только фоновая работа, поэтому достаточно реализовать `RunAsync()`.
* Служба может успешно завершить `RunAsync()` и вернуться из него. Это не считается сбоем и представляет фоновую работу завершения службы. Для надежных служб с отслеживанием состояния `RunAsync()` будет вызываться снова, если служба была понижена с первичной, а затем обратно повышена.
* Если служба выходит при выполнении `RunAsync()`, выдавая непредвиденные исключения, — это сбой. Объект службы завершает работу, и возникает ошибка работоспособности.
* Несмотря на то, что возвращение этих методов не ограничивается по времени, вы не сможете записать никакие надежные коллекции, а значит, и выполнить какую-либо действительную задачу. После получения запроса на отмену рекомендуется возвращать методы как можно быстрее. Если служба не отвечает на такие вызовы API в течение приемлемого промежутка времени, Service Fabric может принудительно завершить работу службы. Обычно это происходит только во время обновления приложения или при удалении службы. По умолчанию время ожидания составляет 15 минут.
* Для служб с отслеживанием состояния существует дополнительный параметр для ServiceReplicaListeners, позволяющий запускать их на вторичных репликах. Этот сценарий применяется редко, но единственное изменение в жизненном цикле заключается в том, что `CreateServiceReplicaListeners()` вызывается (и открываются получаемые в результате прослушиватели), даже если реплика является вторичной. Если в дальнейшем реплика преобразуется в первичную реплику, прослушиватели закрываются, уничтожаются, и процессе преобразования создаются и открываются новые прослушиватели.
* Сбои в пути `OnCloseAsync()` приводят к вызову `OnAbort()`, что является последней наилучшей возможностью для службы очистить и освободить все запрошенные ресурсы.

## <a name="next-steps"></a>Дальнейшие действия
* [Обзор надежных служб](service-fabric-reliable-services-introduction.md)
* [Краткое руководство по надежным службам Reliable Services](service-fabric-reliable-services-quick-start.md)
* [Продвинутое использование надежных служб](service-fabric-reliable-services-advanced-usage.md)

