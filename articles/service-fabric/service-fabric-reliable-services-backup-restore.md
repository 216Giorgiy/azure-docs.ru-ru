<properties
   pageTitle="Резервное копирование и восстановление Reliable Services | Microsoft Azure"
   description="Основная документация по надежному резервному копированию и восстановлению Reliable Services платформы Service Fabric"
   services="service-fabric"
   documentationCenter=".net"
   authors="mcoskun"
   manager="timlt"
   editor="subramar,jessebenson"/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="12/01/2015"
   ms.author="mcoskun"/>

# Резервное копирование и восстановление Reliable Services

Service Fabric — это платформа высокой доступности, которая реплицирует состояние между несколькими узлами для обеспечения высокой доступности. Таким образом, даже в случае сбоя одного узла в кластере службы будут оставаться доступными. Хотя в некоторых случаях может быть достаточно предоставленной платформой встроенной избыточности, желательно выполнять резервное копирование данных службы (во внешнее хранилище).

Например, службе может потребоваться резервное копирование данных в следующих случаях.

* В случае полной утери всего кластера Service Fabric или всех узлов, запущенных в указанном разделе (т. е. всех узлов в кластере). Это может произойти, если георепликация не выполнена и весь центр обработки данных, в котором находится кластер, вышел из строя.

* Если из-за административных ошибок произошло случайное удаление или повреждение состояния. Это может произойти, если администратор с достаточными привилегиями ошибочно удалил службу.

* Если из-за ошибок в службе происходит повреждение данных. Например, это может произойти при обновлении кода службы, которое начинает запись поврежденных данных в надежную коллекцию. В этом случае может потребоваться вернуть код и данные в предыдущее состояние.

* При автономной обработке данных. Автономная обработка данных для бизнес-аналитики, которая происходит отдельно от службы, создающей данные, может быть очень удобной.

Благодаря функции резервного копирования и восстановления службы, созданные на основе интерфейса API Reliable Services, могут создавать и восстанавливать резервные копии. API резервного копирования, предоставляемые платформой, позволяют выполнять резервное копирование состояния раздела без блокировки операций чтения или записи. Благодаря им можно восстановить состояние раздела из выбранной резервной копии.


## Как выполнять резервное копирование

Создатель службы полностью контролирует время выполнения резервного копирования и место хранения резервных копий.

Чтобы начать резервное копирование, служба должна вызвать метод **IReliableStateManager.BackupAsync**. Резервное копирование можно выполнить только из первичных реплик, которым необходимо присвоить состояние записи.

В примере ниже показано, как простейший перегруженный метод **BackupAsync** принимает функцию << BackupInfo  bool >> под названием **backupCallback**.

```C#
await this.StateManager.BackupAsync(this.BackupCallbackAsync);
```

В **BackupInfo** содержатся сведения о резервном копировании, включая расположение папки в среде выполнения, где сохранена резервная копия (BackupInfo.Directory). Чтобы выполнить функцию обратного вызова, необходимо переместить BackupInfo.Directory во внешнее хранилище или другое расположение. Эта функция также возвращает логическое значение bool, указывающее, успешно ли перемещена папка резервного копирования в целевое расположение.

В следующем примере кода показано, как с помощью функции backupCallback можно передать резервную копию в службу хранилища Azure:

```C#
private async Task<bool> BackupCallbackAsync(BackupInfo backupInfo)
{
    var backupId = Guid.NewGuid();

    await externalBackupStore.UploadBackupFolderAsync(backupInfo.Directory, backupId, CancellationToken.None);

    return true;
}
```

В примере выше **ExternalBackupStore** — это пример класса, используемый для взаимодействия с хранилищем BLOB-объектов Azure, а **UploadBackupFolderAsync** — это метод, используемый для сжатия и перемещения папки в хранилище больших двоичных объектов Azure.

Обратите внимание на следующее:

- В любой момент времени в обрабатываемой реплике можно выполнить только один вызов метода **BackupAsync**. Выполнение нескольких вызовов метода **BackupAsync** одновременно приведет к вызову исключения **FabricBackupInProgressException**, которое ограничит создание резервных копий до одной за раз.

- В случае сбоя реплики при резервном копировании операция не будет завершена. Таким образом, после завершения обработки отказа служба должна перезапустить резервное копирование, при необходимости вызвав метод **BackupAsync**.

## Как восстанавливать данные

Как правило, ситуации, в которых может потребоваться выполнить операцию восстановления, относятся к одной из следующих категорий:


1. Потеря данных в разделе службы. К примеру, диск для двух из трех реплик для раздела (включая первичную реплику) поврежден или очищен. Новой первичной реплике может потребоваться восстановить данные из резервной копии.

2. Утеря всей службы. Например, администратор удаляет всю службу, и поэтому необходимо восстановить службу и данные.

3. Репликация поврежденных данных приложения (например, из-за ошибки приложения) в службе. В этом случае необходимо обновить службу или вернуть ее в прежнее состояние, чтобы устранить причину повреждения и восстановить неповрежденные данные.

Несмотря на то, что это можно сделать многими способами, мы приведем некоторые примеры использования RestoreAsync для восстановления в указанных выше сценариях.

## Потеря данных раздела

В этом случае среда выполнения автоматически обнаруживает потерю данных и вызывает интерфейс API **OnDataLossAsync**.

Чтобы восстановить данные, создателю службы необходимо выполнить следующие действия. Переопределить **IReliableStateManager**, чтобы вернуть новый ReliableStateManager и предоставить функцию обратного вызова на случай потери данных. Найти последнюю резервную копию во внешнем расположении, в котором содержатся резервные копии службы. Вернуть значение "false", если состояние последней резервной копии отстает от новой первичной реплики. Это гарантирует, что новая первичная реплика не перезаписывается старыми данными. Скачать последнюю резервную копию (и, если она была сжата, распаковать ее в папку резервной копии). Вызвать **IReliableStateManager.RestoreAsync** с путем к папке резервной копии. Вернуть значение "true", если восстановление выполнено успешно.

Ниже приведен пример реализации метода **OnDataLossAsync** с переопределением **IReliableStateManager**.

```C#
protected override IReliableStateManager CreateReliableStateManager()
{
    return new ReliableStateManager(new ReliableStateManagerConfiguration(
            onDataLossEvent: this.OnDataLossAsync));
}

protected override async Task<bool> OnDataLossAsync(CancellationToken cancellationToken)
{
    var backupFolder = await this.externalBackupStore.DownloadLastBackupAsync(cancellationToken);

    await this.StateManager.RestoreAsync(backupFolder);

    return true;
}
```

>[AZURE.NOTE]Для параметра RestorePolicy по умолчанию установлено значение Safe. Это означает, что в случае обнаружения в папке резервного копирования состояния, которое позже состояния, содержащегося в этой реплике, или соответствует ему, произойдет сбой интерфейса API RestoreAsync с исключением ArgumentException. Чтобы пропустить эту проверку безопасности, можно использовать метод RestorePolicy.Force.

## Удаленная или утерянная служба

Если служба удалена, прежде чем восстанавливать данные, необходимо заново создать службу. Важно создать службу с такой же конфигурацией, например с такой же схемой секционирования, чтобы можно было легко восстановить данные. После запуска службы для восстановления данных службы необходимо вызвать интерфейс API (**OnDataLossAsync** выше) в каждом разделе этой службы. Для этого необходимо использовать метод **FabricClient.ServiceManager.InvokeDataLossAsync** в каждом разделе.

С этого момента реализация осуществляется по описанному выше сценарию. Необходимо восстановить последнюю соответствующую резервную копию из внешнего хранилища для каждого раздела. Следует учитывать один недостаток: идентификатор раздела, возможно, изменен, так как среда выполнения создает идентификаторы разделов динамически. Таким образом, служба должна хранить сведения о соответствующем разделе и имени службы, чтобы правильно определить последнюю резервную копию, которую необходимо восстановить для каждого раздела.


## Репликация поврежденных данных приложения

Наличие ошибки в новом развернутом приложении после обновления может привести к повреждению данных, например: обновленное приложение может запустить обновление всех записей телефонных номеров в надежном словаре с использованием недопустимого кода области. В этом случае недопустимые телефонные номера будут реплицированы, так как Service Fabric не учитывает характер хранимых данных.

Первое, что необходимо сделать после обнаружения такой серьезной ошибки, которая приводит к повреждению данных, — заморозить службу на уровне приложения и по возможности обновить приложение до версии без ошибки в коде. Даже после исправления кода службы данные по-прежнему могут быть повреждены. Поэтому может потребоваться их восстановление. В таких случаях восстановления последней резервной копии может оказаться недостаточно, так как последние резервные копии также могут быть повреждены. Поэтому необходимо найти последнюю резервную копию, выполненную до повреждения данных.

Если вы не знаете, какие резервные копии повреждены, нужно развернуть новый кластер Service Fabric и восстановить резервные копии поврежденных разделов, как описано выше в сценарии с удаленной службой. Для каждой секции начните восстановление резервных копий от самой последней до самой ранней. Обнаружив резервную копию без повреждений, переместите или удалите все резервные копии этой секции, которые новее этой резервной копии. Повторите эту процедуру для каждой секции. Теперь при вызове метода **OnDataLossAsync** для раздела в рабочем кластере будет обнаружена необходимая последняя резервная копия во внешнем хранилище.

Чтобы восстановить резервную копию службы до состояния, в котором она находилась до повреждения из-за ошибки в коде, можно использовать действия сценария с удаленной службой.

Обратите внимание на следующее.

- При восстановлении есть вероятность того, что состояние восстанавливаемой резервной копии является старше состояния раздела до потери данных. Из-за этого восстановление можно использовать только в качестве последнего средства для восстановления максимального объема данных.

- Строка, представляющая собой путь к папке резервного копирования и пути к файлам в этой папке, может содержать больше 255 символов в зависимости от пути FabricDataRoot и длины имени типа приложения. Из-за этого такие методы .NET, как **Directory.Move**, могут выдать исключение **PathTooLongException**. Один из возможных обходных путей заключается в том, чтобы напрямую вызывать API kernel32, такие как **CopyFile**.


## Дополнительные сведения о резервном копировании и восстановлении

### Архивация
Диспетчер надежных состояний позволяет создавать согласованные резервные копии без блокировки операций чтения и записи. Для этого используется механизм сохранения контрольных точек и журналов. Диспетчер надежных состояний создает нечеткие (упрощенные) контрольные точки в определенных точках, чтобы уменьшить нагрузку на журнал транзакций и сократить время восстановления. При вызове метода IReliableStateManager.**BackupAsync** диспетчер надежных состояний дает всем надежным объектам команду копировать их последние файлы контрольных точек в локальную папку резервного копирования. Затем он копирует в папку резервного копирования все записи журнала — от «отправной точки» до последней записи в журнале. Так как все записи журнала копируются и диспетчер надежных состояний сохраняет упреждающие записи журнала, все зафиксированные транзакции (которые успешно вернул CommitAsync) будут сохранены при резервном копировании.

Любая транзакция, зафиксированная после вызова метода **BackupAsync**, может не быть включена в резервную копию. После заполнения локальной папки резервного копирования с помощью платформы (т. е. среда выполнения завершает локальное резервное копирование) осуществляется обратный вызов службы резервного копирования. Этот обратный вызов отвечает за перемещение папки резервного копирования во внешнее расположение, например службу хранилища Azure.

### Восстановление

Диспетчер надежных состояний позволяет выполнять восстановление из резервной копии с помощью интерфейса API IReliableStateManager.RestoreAsync. Метод RestoreAsync можно вызвать только внутри метода ** OnDataLossAsync**. Возвращенное методом ** OnDataLossAsync** логическое значение указывает, удалось ли восстановить состояние службы из внешнего источника. Если метод **OnDataLossAsync** возвращает значение "true", Service Fabric перестраивает все реплики из этого источника. Service Fabric гарантирует, что реплики, которые должны будут получать вызов **OnDataLossAsync**, сначала получат роль первичных, но им не будет присвоено состояние чтения или записи. Это означает, что для исполнителей StatefulService метод RunAsync будет вызван только после успешного завершения метода **OnDataLossAsync**. Затем **OnDataLossAsync** будет вызван на новой первичной реплике. Интерфейс API будет постоянно вызываться, пока служба успешно не завершит его (возвратив значение "true" или "false").


Метод RestoreAsync сначала удаляет все существующие состояния в первичной реплике, для которой он был вызван. После этого диспетчер надежных состояний создает все надежные объекты, существующие в папке резервного копирования. Затем все надежные объекты получают команду выполнить восстановление из контрольных точек в папке резервного копирования. Наконец, диспетчер надежных состояний восстанавливает собственное состояние из записей журнала в папке резервного копирования и выполняет восстановление. Как часть процесса восстановления операции, начиная с «отправной точки», записи журнала которых сохранены в папке резервного копирования, воспроизводятся в надежных объектах. Этот шаг обеспечивает согласованность восстановленного состояния.

<!---HONumber=AcomDC_1203_2015-->