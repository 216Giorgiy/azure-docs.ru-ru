<properties
   pageTitle="Обзор модели программирования надежных служб Service Fabric"
	description="Сведения о модели программирования надежных служб Service Fabric, позволяющие приступить к написанию собственных служб."
	services="Service-Fabric"
	documentationCenter=".net"
	authors="masnider"
	manager="timlt"
	editor="jessebenson; mani-ramaswamy"/>

<tags
   ms.service="Service-Fabric"
	ms.devlang="dotnet"
	ms.topic="article"
	ms.tgt_pltfrm="NA"
	ms.workload="NA"
	ms.date="08/26/2015"
	ms.author="masnider;jesseb"/>

# Обзор надежных служб
Платформа Service Fabric упрощает написание надежных служб с отслеживанием или без отслеживания состояния и управление ими. В этом документе:

1. Модель программирования надежных служб для служб с отслеживанием состояния и без него.
2. Различные варианты выбора при написании надежной службы.
3. Некоторые сценарии и примеры использования надежных служб, а также способ их написания.

Надежные службы являются одной из моделей программирования, доступных в Service Fabric. Дополнительные сведения о модели программирования надежных субъектов см. во [введении](service-fabric-reliable-actors-introduction.md).

В Service Fabric служба состоит из конфигурации, кода приложения и (при необходимости) состояния.

Service Fabric управляет временем существования служб от подготовки и развертывания до обновления и удаления посредством [управления приложениями Service Fabric](service-fabric-deploy-remove-applications.md).

## Что такое надежные службы
Надежные службы предоставляют простую, мощную модель программирования верхнего уровня, помогающую сформулировать, что важно для вашего приложения. С помощью модели программирования надежных служб вы получаете такие возможности:

1. Для служб с отслеживанием состояния модель программирования надежных служб позволяет согласованно и надежно хранить состояние прямо в службе с помощью надежных коллекций, то есть простого набора классов коллекций с высокой доступностью, которые будут знакомы всем, кто использовал коллекции C#. Обычно для надежного управления состоянием службам требовались внешние системы. С использованием надежных коллекций состояние можно хранить рядом с вычислениями с такой же высокой доступностью и надежностью, которых можно ожидать от высокодоступных внешних хранилищ, что также снижает задержку.

2. Простая модель для выполнения собственного кода, которая похожа на привычные модели программирования: у создаваемого кода четко определенная точка входа и простой в управлении жизненный цикл.

3. Подключаемая модель связи позволяет использовать транспорт по своему усмотрению, например HTTP с [веб-API](service-fabric-reliable-services-communication-webapi.md), протоколы WebSocket, пользовательские протоколы TCP и т. п. Надежные службы дают возможность использовать ряд отличных готовых вариантов или задействовать собственный.

## Чем отличаются надежные службы
Надежные службы в Service Fabric отличаются от служб, которые вы могли создавать ранее. Service Fabric обеспечивает надежность, доступность, согласованность и масштабируемость.

+ <u>Надежность</u> — ваша служба будет работать даже в ненадежных средах, где компьютеры могут давать сбои или сталкиваться с проблемами сети.

+ <u>Доступность</u> — ваша служба будет доступна и будет реагировать (это не означает, что у вас не может быть служб, которые невидимы или недоступны извне).

+ <u>Масштабируемость</u> — службы отвязываются от конкретного оборудования и могут увеличиваться или уменьшаться в масштабе (настолько, насколько это нужно) путем добавления или удаления оборудования или виртуальных ресурсов. Службы легко секционируются (особенно в случае с отслеживанием состояния). Это дает возможность масштабировать независимые компоненты службы и обеспечивать их независимую реакцию на сбои. Наконец, Service Fabric позволит подготавливать тысячи служб в рамках одного процесса, если они используют немного памяти. Другими словами, не будет необходимости выделять целые экземпляры ОС для одного экземпляра конкретной рабочей нагрузки.

+ <u>Согласованность</u> — это означает, что для любой информации, хранящейся в данной службе, можно гарантировать согласованность (это относится только к службам с отслеживанием состояния, подробнее об этом позже).

## Жизненный цикл службы
Независимо от того, какую службу вы используете (с отслеживанием или без отслеживания состояния), надежные службы обеспечивают простой жизненный цикл, позволяющий быстро подключить код и приступить к работе. Для запуска службы необходимо реализовать всего лишь один или два метода.

+ CreateCommunicationListener — здесь служба определяет стек связи, который планируется использовать. Стек связи, например [веб-API](service-fabric-reliable-services-communication-webapi.md), определяет одну или несколько конечных точек прослушивания для службы (способ доступа к ней клиентов). Он определяет также дальнейшее взаимодействие поступающих сообщений с остальным кодом службы.

+ RunAsync — здесь служба выполняет свою бизнес-логику. Предоставляемый токен отмены сигнализирует о моменте, когда работу следует остановить. Например, если вы используете службу, которая постоянно извлекает сообщения из очереди ReliableQueue и обрабатывает их, это и будет местом выполнения соответствующей работы.

Основные события жизненного цикла надежной службы перечислены далее.

1. Создается объект Service (являющийся производным от StatelessService или StatefulService).

2. Вызывается метод CreateCommunicationListener, давая службе возможность вернуть прослушиватель связи по своему выбору.
  + Обратите внимание, что это необязательно, хотя большинство служб предоставляют конечную точку непосредственно.

3. После создания прослушиватель связи открывается
  + Прослушиватели связи содержат метод Open(), который вызывается на этом этапе и возвращает адрес прослушивания для службы. Если в вашей надежной службе используется один из встроенных интерфейсов ICommunicationListener, эта обработка выполняется автоматически.

4. Когда прослушиватель выполняет команду Open(), вызывается метод RunAsync() в основной службе.
  + Обратите внимание, что метод RunAsync является необязательным. Если служба выполняет всю работу только непосредственно в ответ на вызовы пользователя, то нет необходимости реализовать RunAsync().

Во время завершения работы службы (либо в ходе удаления, либо просто из-за перемещения из определенного расположения) сначала в прослушивателе связи вызывается метод Close(), а затем отменяется токен отмены, который был передан в RunAsync().

## Примеры служб
Зная эту модель программирования, давайте кратко рассмотрим две разные службы, чтобы увидеть, как взаимодействуют все описанные элементы.

### Надежные службы без отслеживания состояния
Служба без отслеживания состояния — это служба, в которой в буквальном смысле не поддерживается состояние или имеющееся состояние полностью утилизируется и не требует синхронизации, репликации, постоянного сохранения или высокой доступности.

Например, рассмотрим калькулятор — службу, которая не пользуется памятью и которая принимает все условия и операции для одновременного выполнения.

В этом случае метод RunAsync() службы может быть пустым, так как у службы нет необходимости в фоновой обработке задач. Когда эта служба будет создана, она вернет объект CommunicationListener (например, [веб-API](service-fabric-reliable-services-communication-webapi.md)), который открывает конечную точку прослушивания на некотором порту. Эта конечная точка подключится к различным методам (например, Add(n1, n2)), которые определяют открытый API калькулятора.

При клиентском вызове вызывается соответствующий метод, а калькулятор выполняет операции над предоставленными данными и возвращает результат. Никакое состояние она не хранит.

Это очень простой пример, так как в службе «Калькулятор» внутреннее состояние не сохраняется. Однако большинство служб без отслеживания состояния не являются таковыми в полной мере, так как они записывают свои состояния в какое-либо внешнее хранилище (например, веб-приложение, хранящее состояние сеанса в резервном хранилище или кэше, не является в полной мере службой без отслеживания состояния).

Распространенным примером использования служб без отслеживания состояния в Service Fabric является внешний интерфейс, который позволяет пользоваться общедоступным интерфейсом API для веб-приложения. Затем внешняя служба обменивается данными со службами с отслеживанием состояния для выполнения запроса пользователя. В этом случае вызовы от клиентов направляются на известный порт, например с номером 80, который прослушивает служба без отслеживания состояния. Такая служба получает вызов и определяет, поступил ли он из надежного источника, а также узнает службу, которой он предназначен. Затем служба без отслеживания состояния перенаправляет вызов на нужную секцию службы с отслеживанием состояния и ожидает ответа. При получении ответа служба отвечает исходному клиенту.

### Надежные службы с отслеживанием состояния
Служба с отслеживанием состояния — это служба, которой для надлежащего функционирования необходимо часть состояния поддерживать в согласованном виде. Рассмотрим службу, которая постоянно вычисляет скользящее среднее некоторых значений на основе получаемых обновлений. Для этого службе необходимо располагать текущим набором входящих запросов, которые требуется обработать, а также текущим средним значением. Любая служба, которая получает, обрабатывает и сохраняет информацию во внешнем хранилище (как это сегодня делается в Azure Blob или табличном хранилище), является службой с отслеживанием состояния — она просто хранит свое состояние во внешнем хранилище состояний.

Большинство служб сегодня хранят свое состояние во внешних хранилищах, что обеспечивает надежность, доступность, масштабируемость и согласованность состояния. В Service Fabric службам с отслеживанием состояния не обязательно хранить состояние во внешнем хранилище, поскольку Service Fabric берет на себя выполнение этих требований как для кода службы, так и для ее состояния.

Предположим, что нужно создать службу, принимающую запросы для ряда преобразований, которые необходимо выполнить над изображением, и изображение, которое требуется преобразовать. Для этой службы будет возвращен объект CommunicationListener (например, веб-API), который открывает порт связи и позволяет отправлять данные через интерфейс API, например `ConvertImage(Image i, IList<Conversion> conversions)`. В этом интерфейсе API служба может принимать данные и сохранять запрос в ReliableQueue, а затем возвращать клиенту токен для отслеживания запроса (поскольку запросы могут занимать некоторое время).

В этой службе метод RunAsync может быть более сложным: служба внутри RunAsync будет запускать цикл, извлекающий запросы из ReliableQueue, выполняющий перечисленные преобразования и сохраняющий результаты в ReliableDictionary, чтобы при возвращении клиента он мог получить преобразованные изображения. Чтобы убедиться, что даже в случае какого-либо отказа изображение не будет потеряно, такая надежная служба будет извлекать очередь (Queue), выполнять преобразования и сохранять результат в транзакции (Transaction), так что сообщение фактически удаляется из очереди и результаты сохраняются в словаре результатов только после завершения преобразований. Если где-либо между этими действиями произойдет отказ (например, на компьютере, где выполняется данный экземпляр кода), запрос останется в очереди ожидать повторной обработки.

Следует еще отметить, что данная служба выглядит почти как обычная служба .NET. Единственная разница в том, что используемые структуры данных (ReliableQueue и ReliableDictionary) предоставляются платформой Service Fabric и поэтому для них обеспечивается высокая надежность, доступность и согласованность.

## Когда следует использовать интерфейсы API надежных служб
Если службе приложения требуется любая из приведенных ниже характеристик, следует рассмотреть возможность использования интерфейсов API надежных служб.

- Необходимо обеспечить поведение приложения между несколькими единицами состояния (например, заказами и позициями заказов).

- Состояние приложения можно естественным образом моделировать в виде надежных словарей и очередей.

- Состояние должно быть высокодоступным (с низкой задержкой доступа).

- Приложению требуется контролировать параллелизм или степень детализации транзакционных операций по одной или нескольким надежным коллекциям.

- Необходимо управлять обменом данными или контролировать схему секционирования службы.

- Коду требуется среда выполнения, работающая в режиме свободного потока.

- Приложению требуется динамически создавать или уничтожать надежные словари или очереди во время выполнения.

- Вам нужно программным способом управлять функциями резервного копирования и восстановления, которые предоставляет платформа Service Fabric и которые относятся к вашей службе.*

- Приложению необходимо поддерживать историю изменений своих единиц состояния.*

- Вам нужно разработать свои настраиваемые поставщики состояний или использовать сторонние.*

> [AZURE.NOTE]* Функции доступны при условии общей доступности пакета SDK.


## Дальнейшие действия
+ [Быстрое начало работы с надежными службами](service-fabric-reliable-services-quick-start.md)
+ [Ознакомьтесь с дополнительными возможностями использования надежных служб](service-fabric-reliable-services-advanced-usage.md)
+ [Прочитайте о модели программирования надежных субъектов](service-fabric-reliable-actors-introduction.md)
 

<!---HONumber=August15_HO9-->