<properties
   pageTitle="Развертывание существующего приложения в Azure Service Fabric"
   description="Пошаговое руководство по упаковыванию существующего приложения для развертывания в кластере Azure Service Fabric"
   services="service-fabric"
   documentationCenter=".net"
   authors="clca"
   manager="timlt"
   editor=""/>

<tags
   ms.service="service-fabric"
   ms.devlang="dotnet"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="NA"
   ms.date="07/06/2015"
   ms.author="claudioc"/>

# Развертывание существующего приложения в Azure Service Fabric

Azure Service Fabric можно использовать для развертывания существующих приложений. Приложения, которые выполняются, к примеру, на сайте Azure или в рабочей роли, можно "упаковать", чтобы их можно было развернуть в кластере Service Fabric. Существующим приложениям, выполняющимся в кластере Service Fabric, могут быть полезны такие функции, как отслеживание работоспособности и ALM (управление жизненным циклом приложения), поэтому этот сценарий важен и полностью поддерживается. В этом руководство описываются процесс и основные понятия, связанные с упаковкой существующего приложения. За этой статьей, которая является обзором процесса, последуют конкретные примеры упаковки существующих приложений (например, node.js или Java) для размещения в кластере Service Fabric.

## Краткий обзор файлов манифестов приложений и служб

Прежде чем приступить к изучению упаковки существующего приложения, начнем с краткого введения в модель развертывания Service Fabric. Модель развертывания Service Fabric основана, по большей части, на двух файлах:


* Манифест приложения. Манифест приложения содержит описание приложения и список образующих его служб, а также другие параметры, например количество экземпляров, которые определяют, как будут развертываться службы. Приложение в Service Fabric — расширяемая единица. Приложение можно расширить как единицу, где потенциальные сбои (и потенциальные откаты) управляются платформой, гарантируя, что процесс обновления либо будет полностью успешным, либо, в случае сбоя, не оставит приложение в неизвестном или нестабильном состоянии.

    Ниже приводится пример манифеста приложения.
    
    ```xml
    <?xml version="1.0" encoding="utf-8"?>
    <ApplicationManifest ApplicationTypeName="actor2Application" 
                         ApplicationTypeVersion="1.0.0.0" 
                         xmlns="http://schemas.microsoft.com/2011/01/fabric" 
                         xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
                         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    
      <ServiceManifestImport>
        <ServiceManifestRef ServiceManifestName="actor2Pkg" ServiceManifestVersion="1.0.0.0" />
        <ConfigOverrides />
      </ServiceManifestImport>
      
      <DefaultServices>
        <Service Name="actor2">
          <StatelessService ServiceTypeName="actor2Type">
            <SingletonPartition />
          </StatelessService>
        </Service>
      </DefaultServices>
    
    </ApplicationManifest>
    ```

* Манифест службы. Манифест службы описывает ее компоненты. Он включает такие данные, как имя и тип службы (сведения, которые Service Fabric использует для управления службой), ее код, конфигурацию и компоненты данных, а также некоторые дополнительные параметры, которые позволяют настраивать службу после ее развертывания. Мы не будем углубляться в подробности различных параметров, доступных в манифесте службы, но рассмотрим их подмножество, необходимое для запуска существующего приложения в Service Fabric.

    Ниже приводится пример манифеста службы.
    
    ```xml
    <?xml version="1.0" encoding="utf-8"?>
    <ServiceManifest Name="actor2Pkg"
                     Version="1.0.0.0"
                     xmlns="http://schemas.microsoft.com/2011/01/fabric"
                     xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
      <ServiceTypes>
        <StatelessServiceType ServiceTypeName="actor2Type" />
      </ServiceTypes>
    
      <CodePackage Name="Code" Version="1.0.0.0">
        <EntryPoint>
          <ExeHost>
            <Program>actor2.exe</Program>
          </ExeHost>
        </EntryPoint>
      </CodePackage>
    
      <ConfigPackage Name="Config" Version="1.0.0.0" />
    
      <Resources>
        <Endpoints>
          <Endpoint Name="ServiceEndpoint" />
        </Endpoints>
      </Resources>
    </ServiceManifest>
    ```

## Структура файла пакета приложения
Для развертывания приложения с помощью, к примеру, командлетов PowerShell приложение должно следовать предопределенной структуре каталогов.

```
\applicationmanifest.xml
\MyServicePkg
    \servicemanifest.xml
    \code
    \config
    \data
```

Корневой каталог содержит файл applicationmanifest.xml, определяющий приложение. Дочерний каталог для каждой службы, включенной в приложение, используется для хранения всех артефактов, необходимых службе: файла servicemanifest.xml и, как правило, 3 каталогов:

- *code*: содержит код службы;
- *config*: содержит файл settings.xml (и другие файлы, если это необходимо), который служба может использовать во время работы для получения определенных параметров конфигурации;
- *data*: дополнительный каталог для хранения дополнительных локальных данных, необходимых службе. Примечание: каталог Data следует использовать только для хранения временных данных. Service Fabric не копирует и не реплицирует изменения каталога данных, если службу требуется переместить, например во время отработки отказа. 

Примечание: вы можете использовать любые имена для каталогов Code, Config и Data. Убедитесь, что в файле ApplicationManifest используются такие же значения.

## Процесс упаковки существующего приложения
Процесс упаковки существующего приложения включает следующие этапы:

- Создание структуры каталогов пакета
- Добавление файлов кода и конфигурации приложения
- Обновление файла манифеста службы
- Обновление манифеста приложения


### Создание структуры каталогов пакета
Для начала можно создать структуру каталогов, как описано выше. Я создаю каталог и копирую манифесты приложения и службы из существующего проекта, созданного ранее с помощью Visual Studio.

![][1] ![][2]


### Добавление файлов кода и конфигурации приложения
После создания структуры каталогов вы можете добавить файлы кода и конфигурации приложения в каталоги Code и Config. Вы также можете создавать дополнительные каталоги или дочерние папки в каталогах Code и Config. Service Fabric выполняет операцию xcopy для содержимого корневого каталога, поэтому, за исключением каталогов верхнего уровня Code и Settings, не существует предопределенной структуры (вы можете выбрать другие имена каталогов, подробнее см. в следующем разделе).

!Примечание по Azure: убедитесь, что включены все файлы и зависимости, необходимые приложению. Service Fabric скопирует содержимое пакета приложения на все узлы кластера, где будут развертываться службы приложения. Пакет должен содержать весь код, необходимый для работы приложения. Не рекомендуется рассчитывать на то, что зависимости уже установлены.

### Редактирование файла манифеста службы
Следующий этап — редактирование файла манифеста службы с добавлением следующих сведений: — имени типа службы. Это идентификатор, который Service Fabric использует, чтобы определять службу; — команды, используемой для запуска приложения (ExeHost); — любого сценария, который необходимо выполнить для установки или настройки приложения (SetupEntrypoint

Ниже приводится пример файла `servicemanifest.xnml`, который "упаковывает" приложение node.js:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ServiceManifest Name="VisualObjectsNodejsWebServicePkg"
                 Version="1.0.0.0"
                 xmlns="http://schemas.microsoft.com/2011/01/fabric"
                 xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <ServiceTypes>
    <StatelessServiceType ServiceTypeName="VisualObjectsNodejsWebServiceType" UseImplicitHost="true" />
  </ServiceTypes>
  
  <CodePackage Name="Code" Version="1.0.0.0">
    <EntryPoint>
      <ExeHost>
        <Program>node.exe</Program>
        <Arguments>server.js</Arguments>
        <WorkingFolder>CodeBase</WorkingFolder>
      </ExeHost>
    </EntryPoint>
  </CodePackage>
  
  <ConfigPackage Name="Config" Version="1.0.0.0"/>
  
  <Resources>
    <Endpoints>
      <Endpoint Name="ServiceEndpoint" />
    </Endpoints>
  </Resources>
  
</ServiceManifest>
```

Рассмотрим другую часть файла, которую необходимо изменить:

### ServiceTypes

```xml
<ServiceTypes>
  <StatelessServiceType ServiceTypeName="VisualObjectsNodejsWebServiceType" UseImplicitHost="true" />
</ServiceTypes>
```

- Вы можете выбрать для `ServiceTypeName` любое имя, значение используется в `applicationmanifest.xml` для идентификации службы.
- Необходимо указать `UserImplicitHost = "true"`. Этот атрибут сообщает Service Fabric, что служба основана на автономном приложении, поэтому достаточно запустить ее как процесс и отслеживать ее работоспособность.


### CodePackage 
Атрибут CodePackage задает расположение (и версию) кода службы.

```xml
<CodePackage Name="Code" Version="1.0.0.0">
```

Элемент `Name` используется для указания имени каталога в пакете приложения, который содержит код службы. `CodePackage` также имеет атрибут `version`, который позволяет указать версию кода и может быть использован для обновления кода службы за счет инфраструктуры управления жизненным циклом приложений в Service Fabric.


### Entrypoint

```xml
<EntryPoint>
  <ExeHost>
    <Program>node.exe</Program>
    <Arguments>server.js</Arguments>
    <WorkingFolder>CodeBase</WorkingFolder>
  </ExeHost>
</EntryPoint>
```


Элемент `Entrypoint` в файле манифеста службы позволяет указать, как запускать службу. Элемент `ExeHost` задает исполняемый файл (и аргументы), которые следует использовать для запуска службы.

- `Program` задает имя исполняемого файла, который следует выполнить для запуска службы. 
- `Arguments` задает аргументы, которые следует передавать исполняемому файлу. Это может быть список параметров с аргументами.
- `WorkingFolder` задает рабочий каталог процесса, который будет запущен. Вы можете задать два значения:
	- `CodeBase`: рабочим каталогом будет каталог Code в пакете приложения (каталог `Code` в показанной ниже структуре).
	- `CodePackage`: рабочим каталогом будет корневой каталог пакета приложения (`MyServicePkg`).
- Элемент `WorkingDirectory` позволяет задать правильный рабочий каталог, чтобы приложение или сценарии инициализации могли использовать относительные пути. Для элемента `WorkingFolder` (`Work`) можно задать еще одно значение, но оно не очень полезно при упаковывании существующего приложения.


```
\applicationmanifest.xml
\MyServicePkg
    \servicemanifest.xml
    \code
        \bin
        \...
    \config
    \data
    \...
```


#### Точка входа для установки

```xml
<SetupEntryPoint>
  <ExeHost>
    <Program>scripts\myAppsetup.cmd</Program>
  </ExeHost>
</SetupEntryPoint>
```

Элемент `SetupEntrypoint` позволяет задать исполняемый или пакетный файл, который следует выполнить перед запуском кода службы. Это необязательный элемент, поэтому его не требуется включать, если отсутствует необходимость в инициализации и установке. Точка входа выполняется при каждом перезапуске службы. Существует только одна точка входа для установки, поэтому сценарии установки и настройки необходимо объединить в один пакетный файл, если для установки или настройки приложения требуется несколько сценариев. Как и элемент `Entrypoint`, `SetupEntrypoint` может выполнять файлы любого типа: исполняемые и пакетные файлы, а также командлеты PowerShell. В приведенном выше примере `SetupEntrypoint` основывается на пакетном файле myAppsetup.cmd, расположенном в дочерней папке каталога Code (при условии, что элемент `WorkingDirectory` имеет значение `Code`).

## Файл манифеста приложения

После настройки файла `servicemanifest.xml` потребуется внести в файл `applicationmanifest.xml` некоторые изменения, чтобы использовались правильные тип и имя службы.

```xml
<ServiceManifestImport>
  <ServiceManifestRef ServiceManifestName="MyServicePkg" ServiceManifestVersion="1.0.0.0" />
</ServiceManifestImport>
<DefaultServices>
  <Service Name="actor2">
    <StatelessService ServiceTypeName="MyServiceType" InstanceCount = "1">
    </StatelessService>
  </Service>
</DefaultServices>
```

### ServiceManifestImport

В `ServiceManifestImport` можно указать одну или несколько служб, которые требуется включить в приложение. Ссылки на службы указываются в элементе `ServiceManifestName`, который задает имя каталога, где находится файл `servicemanifest.xml`.

```xml
<ServiceManifestImport>
  <ServiceManifestRef ServiceManifestName="MyServicePkg" ServiceManifestVersion="1.0.0.0" />
</ServiceManifestImport>
```

### DefaultServices

Элемент `DefaultServices` в файле манифеста приложения используется для настройки некоторых свойств службы.

```xml
<DefaultServices>
  <Service Name="actor2">
    <StatelessService ServiceTypeName="MyServiceType" InstanceCount="1">
    </StatelessService>
  </Service>
</DefaultServices>
```

* Элемент `ServiceTypeName` используется как идентификатор службы в контексте переноса существующего приложения. `ServiceTypeName` должен содержать уникальные удостоверения службы.
* `StatelessService`: Service Fabric поддерживает два типа службы: с отслеживанием состояния и без него. В случае переноса существующего приложения используется служба без отслеживания состояния, поэтому элемент `StatelessService` следует использовать всегда.

Службу Service Fabric можно развернуть в нескольких конфигурациях, например как один или несколько экземпляров либо так, чтобы в каждом узле кластера Service Fabric находилось по одному экземпляру службы. В файле `applicationmanifest.xml` можно указать, как будет развертываться приложение.

* `InstanceCount`: позволяет указать, сколько экземпляров службы следует запускать в кластере Service Fabric. Вы можете задать значение `InstanceCount` в зависимости от типа развертываемого приложения. Ниже приводятся два самых распространенных сценария.

	* `InstanCount = "1"`: в этом случае в кластере развертывается только один экземпляр службы. Служба планирования Service Fabric определяет, в каком узле будет развертываться служба. Один экземпляр также уместен для приложений, требующих другой конфигурации при запуске в нескольких экземплярах. В этом случае удобнее задать несколько служб в одном файле манифеста приложения и использовать `InstanceCount = "1"`. Таким образом, конечным результатом будут несколько экземпляров одной службы, каждая из которых имеет свою конфигурацию. Значение `InstanceCount` больше 1 уместно, только если требуются несколько экземпляров с одинаковой конфигурацией.
    
	* `InstanceCount ="-1"`: в этом случае в каждом узле кластера Service Fabric будет развернуто по одному экземпляру службы. В результате в каждом узле кластера будет по одному (и только одному) экземпляру службы. Эта конфигурация удобна для интерфейсных приложений (например, конечной точки REST), поскольку клиентским приложениям достаточно подключиться к любому узлу кластера, чтобы использовать конечную точку. Эту конфигурацию также можно использовать, если, к примеру, все узлы кластера Service Fabric подключены к подсистеме балансировки нагрузки, чтобы трафик клиента можно было распределять между экземплярами службы во всех узлах кластера.


### Тестирование
Для существующих приложений очень удобна возможность просматривать журналы консоли, чтобы убедиться, что сценарии приложения и настройки не возвращают ошибок. Перенаправление консоли можно настроить в файле `servicemanifest.xml` с помощью элемента `ConsoleRedirection`.

```xml
<EntryPoint>
  <ExeHost>
    <Program>node.exe</Program>
    <Arguments>server.js</Arguments>
    <WorkingFolder></WorkingFolder>
    <ConsoleRedirection FileRetentionCount="5" FileMaxSizeInKb="2048"/>
  </ExeHost>
</EntryPoint>
```

* Элемент `ConsoleRedirection` позволяет перенаправлять выходные данные консоли (stdout и stderr) в рабочий каталог для проверки на ошибки во время установки или выполнения приложения в кластере Service Fabric.

	* Элемент `FileRetentionCount` определяет, сколько файлов сохраняется в рабочем каталоге. Например, значение 5 означает, что в рабочем каталоге сохраняются файлы журналов для предыдущих 5 запусков.
	* `FileMaxSizeInKb` задает максимальный размер файлов журналов. 

Файлы журналов сохраняются в одном из рабочих каталогов службы. Чтобы определить расположение файлов, необходимо использовать обозреватель Service Fabric для поиска узла, где запущена служба, и используемого в данный момент рабочего каталога.

В обозревателе Service Fabric определите узел, где запущена служба

![][3]

Узнав, в каком узле выполняется служба, вы можете узнать, какой рабочий каталог используется

![][4]

Выбрав имя службы, в правой области вы можете увидеть, где хранятся код и параметры службы

![][5]

Нажав ссылку в поле "Расположение диска", вы можете открыть каталог, в котором выполняются службы.

![][6]

Каталог журналов содержит все файлы журналов.

Примечание: в этом примере в кластере запущен один экземпляр службы. Если существует несколько экземпляров, вам может потребоваться проверить файл журнала на всех узлах, где запущена служба.

 
## Что дальше?
Мы работаем над инструментами, позволяющими упаковать существующее приложение, наведя его на корневой каталог в структуре каталогов приложения. Инструмент создает файлы манифестов и настраивает основные параметры, необходимые для преобразования приложения в службу Service Fabric.

Чтобы получить дополнительную информацию о разработке обычных приложений Service Fabric, ознакомьтесь с [этим](service-fabric-develop-your-service-index.md) разделом.

[1]: ./media/service-fabric-deploy-existing-app/directory-structure-1.png
[2]: ./media/service-fabric-deploy-existing-app/directory-structure-2.png
[3]: ./media/service-fabric-deploy-existing-app/service-node-1.png
[4]: ./media/service-fabric-deploy-existing-app/service-node-2.png
[5]: ./media/service-fabric-deploy-existing-app/service-node-3.png
[6]: ./media/service-fabric-deploy-existing-app/service-node-4.png

<!---HONumber=Oct15_HO1-->