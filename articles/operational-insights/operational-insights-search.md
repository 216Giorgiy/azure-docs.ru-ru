<properties
   pageTitle="Поиск данных в компоненте оперативной аналитики"
   description="Функцию поиска журналов в компоненте оперативной аналитики Microsoft Azure можно использовать для поиска необходимых данных."
   services="operational-insights"
   documentationCenter=""
   authors="bandersmsft"
   manager="jwhit"
   editor="" />
<tags
   ms.service="operational-insights"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="tbd"
   ms.date="09/10/2015"
   ms.author="banders" />

# Поиск данных в компоненте оперативной аналитики

[AZURE.INCLUDE [operational-insights-note-moms](../../includes/operational-insights-note-moms.md)]

Основой оперативной аналитики Microsoft Azure является функция поиска журналов, позволяющая объединять и сопоставлять данные компьютеров из нескольких источников в существующей среде. Функция поиска журналов также дополняет решения, позволяя получать сводные показатели по определенной проблемной области.

На странице Поиск можно создать запрос, а затем во время поиска отфильтровать результаты с помощью элементов управления аспектами. Можно создать сложные запросы для преобразования и фильтрации результатов, а также для формирования соответствующих отчетов.

Общие запросы поиска журналов отображаются на большинстве страниц решений. В консоли оперативной аналитики можно щелкать плитки или детализировать другие элементы, чтобы просмотреть сведения о них с помощью функции поиска журналов.

В этом учебнике мы рассмотрим примеры, охватывающие все основные аспекты использования поиска журналов.

Мы начнем с простых практических примеров, а затем разовьем их, чтобы получить представление о реальных вариантах использования синтаксиса для извлечения нужных ценных сведений из данных.

При проведении поиска журналов в компоненте оперативной аналитики вы будете использовать следующие методы:

- использование базовых фильтров;
- использование дополнительных фильтров;
- работа с результатами поиска;
- использование команды measure;
- использование функций max и min с командой measure;
- использование функции avg с командой measure;
- использование команды where.

После ознакомления с методиками поиска можно изучить разделы [Справочник по синтаксису поиска](#search-syntax-reference) и [Справочник по полю и аспекту поиска](#search-field-and-facet-reference).

## использование базовых фильтров;

Прежде всего необходимо знать, что первой частью поискового запроса, расположенной перед любым символом вертикальной черты "|", всегда является *фильтр*. Его можно рассматривать как предложение WHERE в TSQL, он определяет, *какое* подмножество данных следует извлекать из хранилища данных оперативной аналитики. Поиск в хранилище данных главным образом заключается в указании характеристик данных, которые нужно извлечь, поэтому логично, что запрос будет начинаться с предложения WHERE.

Самыми простыми из доступных фильтров являются *ключевые слова*, такие как "ошибка", "время ожидания" или имя компьютера. Эти типы простых запросов обычно возвращают различные формы данных в рамках одного результирующего набора. Это происходит потому, что оперативная аналитика имеет другие *типы* данных в системе.


### Выполнение простого поиска
1. На портале оперативной аналитики щелкните **Search Data Explorer** (Обозреватель поиска данных). ![плитка поиска](./media/operational-insights-search/overview-search.png)
2. В поле запроса введите `error` и нажмите кнопку **Поиск**. ![ошибка поиска](./media/operational-insights-search/search-error.png) Например, запрос для `error` на следующем рисунке возвратил 100 000 записей **Event** (собранных функцией управления журналами), 18 записей **ConfigurationAlert** (созданных в ходе оценки конфигурации) и 12 записей **ConfigurationChange** (полученных функцией отслеживания изменений). ![результаты поиска](./media/operational-insights-search/results01.png)

Эти фильтры на самом деле не являются классами и типами объектов. *Type* — это просто тег, свойство или строка/имя/категория, присоединяемые к фрагменту данных. Некоторые документы в системе помечены как **Type:ConfigurationAlert**, другие — как **Type:PerfHourly** или **Type:Event** и т. д. Каждый результат поиска, документ или запись отображает все общие свойства и их значения для каждого из этих фрагментов данных, и вы можете использовать эти имена полей в фильтре, когда необходимо получить только те записи, где поле имеет заданное значение.

*Type* — это просто поле, которое имеет все записи, оно ничем не отличается от любого другого поля. Это было установлено на основе значения поля "Тип". Эта запись будет иметь другую форму. В частности, **Type=PerfHourly** или **Type=Event** также относится к синтаксису, который необходимо изучить для запроса событий или агрегатных функций данных производительности за каждый час.

Двоеточие (:) или знак равенства (=) можно использовать после имени поля и перед значением. **Type:Event** и **Type=Event** имеют одинаковое значение, поэтому можно выбрать тот стиль, который вы предпочитаете.

Поэтому, если записи Type=PerfHourly имеют поле с именем CounterName, вы можете написать запрос наподобие `Type=PerfHourly CounterName="% Processor Time"`.

Это позволит получить только те данные о производительности, где счетчик производительности имеет имя "% Processor Time" (% загруженности процессора).

### Поиск данных о производительности по загруженности процессора
- В поле поискового запроса введите `Type=PerfHourly CounterName="% Processor Time"`

Можно указать значение более точно и использовать в запросе **InstanceName=\_'Total'**, который представляет собой счетчик производительности Windows. Можно также выбрать другой аспект и другую пару **поле:значение**. Фильтр автоматически добавляется в фильтр в строке запроса. Вы увидите это на следующем рисунке. Там показано, как добавить **InstanceName:’\_Total’** в запрос, не вводя никакого текста.

![аспект поиска](./media/operational-insights-search/search-facet.png)

Ваш запрос превращается в `Type=PerfHourly CounterName=”% Processor Time” InstanceName=”_Total”`

В этом примере нет необходимости указывать **Type=PerfHourly** для получения этого результата. Поскольку поля CounterName и InstanceName существуют только для записей Type=PerfHourly, запрос является достаточно точным, чтобы возвращать те же результаты, что и предыдущий более длинный запрос: ```
CounterName=”% Processor Time” InstanceName=”_Total”
```

Это происходит потому, что все фильтры в запросе вычисляются так, как если бы они были связаны оператором *И (AND)*. Фактически, чем больше поле вы добавляете в условия, тем менее точные и детальные результаты вы получаете.

Например, запрос `Type=Event EventLog="Windows PowerShell"` идентичен запросу `Type=Event AND EventLog="Windows PowerShell"`. Он возвращает все события, которые были зарегистрированы и собраны из журнала событий Windows PowerShell. Если вы добавляете фильтр несколько раз, выбирая один и тот же аспект, проблема является совершенно формальной — он может загромождать панель поиска, но по-прежнему возвращает те же результаты, так как неявный оператор И всегда присутствует.

Вы можете легко обратить неявный оператор И с помощью явного оператора НЕ (NOT). Например:

`Type:Event NOT(EventLog:"Windows PowerShell")` или его эквивалент `Type=Event EventLog!="Windows PowerShell"` возвращают все события из всех журналов, которые НЕ являются журналом Windows PowerShell.

Либо можно использовать другой логический оператор, такой как ИЛИ (OR). Следующий запрос возвращает записи, для которых EventLog имеет значение Application ИЛИ System.

```
EventLog=Application OR EventLog=System
```

Используя приведенный выше запрос, вы получаете записи для обоих журналов в одном результирующем наборе.

Однако если удалить оператор ИЛИ, оставив неявный оператор И на месте, то следующий запрос не даст никаких результатов, так как запись журнала событий, относящаяся к обоим журналам, не существует. Каждая запись журнала была записана только в один из двух журналов.

```
EventLog=Application EventLog=System
```


## использование дополнительных фильтров;

Следующий запрос возвращает записи для 2 журналов событий для всех компьютеров, которые отправляли данные.

```
EventLog=Application OR EventLog=System
```

![результаты поиска](./media/operational-insights-search/search-results03.png)

Выбрав одно из полей и один из фильтров, можно будут сузить запрос до конкретного компьютера, исключив при этом все остальные. Результирующий запрос будет выглядеть следующим образом.

```
EventLog=Application OR EventLog=System Computer=SERVER1.contoso.com
```

Это эквивалентно следующему запросу из-за неявного оператора И.

```
EventLog=Application OR EventLog=System AND Computer=SERVER1.contoso.com
```

Каждый запрос вычисляется в следующем явном порядке. Обратите внимание на скобки.

```
(EventLog=Application OR EventLog=System) AND Computer=SERVER1.contoso.com
```

Как и в случае с полем журнала событий, вы можете извлечь данные только для набора определенных компьютеров путем добавления оператора ИЛИ. Например:

```
(EventLog=Application OR EventLog=System) AND (Computer=SERVER1.contoso.com OR Computer=SERVER2.contoso.com OR Computer=SERVER3.contoso.com)
```

Аналогичным образом, этот следующий запрос возвращает значение **% времени ЦП** только для двух выбранных компьютеров.

```
CounterName=”% Processor Time”  AND InstanceName=”_Total” AND (Computer=SERVER1.contoso.com OR Computer=SERVER2.contoso.com)
```


### Логические операторы
С помощью полей даты/времени и числовых полей можно выполнить поиск значений с помощью операторов *больше*, *меньше* и *меньше или равно*. На панели поисковых запросов можно использовать простые операторы, такие как >, < , >=, <= , !=.


Можно запросить журнал событий за конкретный период времени. Например, последние 24 часа обозначает следующее мнемоническое выражение.

```
EventLog=System TimeGenerated>NOW-24HOURS
```


#### Поиск с помощью логического оператора
- В поле поискового запроса введите `EventLog=System TimeGenerated>NOW-24HOURS"` ![поиск с логическими операторами](./media/operational-insights-search/search-boolean.png).

Хотя интервалом времени можно управлять графически и в большинстве случаев так и следует поступать, включение фильтра времени непосредственно в запрос дает определенные преимущества. Например, это прекрасно работает с панелями мониторинга, где можно переопределить время для каждой плитки независимо от *глобального* селектора времени на странице панели мониторинга. Дополнительные сведения см. в разделе [Аспекты использования времени на панели мониторинга](http://cloudadministrator.wordpress.com/2014/10/19/system-center-advisor-restarted-time-matters-in-dashboard-part-6/).

При фильтрации по времени помните о том, что можно получить результаты для *пересечения* двух периодов: заданного на портале оперативной аналитики (S1) и в запросе (S2).

![пересечение](./media/operational-insights-search/intersection.png)

Это означает, что если периоды не пересекаются, например на портале оперативной аналитики, где выбрано значение **На этой неделе**, и в запросе, где определена **прошлая неделя**, то вы не получите никаких результатов.

Операторы сравнения, используемые для поля TimeGenerated, также могут пригодиться и в других ситуациях. Например, для числовых полей.

Предположим, что оповещения оценки конфигурации имеют следующие уровни серьезности:

- 0 = информационный
- 1 = предупреждение
- 2 = критический

С помощью следующего запроса можно запросить предупреждения и критические оповещения, а также исключить информационные оповещения:

```
Type=ConfigurationAlert  Severity>=1
```


Можно также использовать запросы в диапазоне. Это означает, что вы можете задать начало и конец диапазона значений в последовательности. Например, если требуются события из журнала событий Operations Manager, где EventID больше или равен 2100, но не больше 2199, следующий запрос позволит получить их.

```
Type=Event EventLog="Operations Manager" EventID:[2100..2199]
```


>[AZURE.NOTE]Необходимо использовать синтаксис диапазона, подразумевающий использование в качестве разделителя пары поле:значение двоеточия (:), а *не* знака равенства (=). Заключите нижнюю и верхнюю границу диапазона в квадратные скобки, разделив их двумя точками (..).

## работа с результатами поиска;

При поиске данных может потребоваться уточнение поискового запроса и наличие высокого уровня контроля над результатами. При извлечении результатов можно применять команды для их преобразования.

Команды в поиске оперативной аналитики *должны* следовать после символа вертикальной черты (|). Фильтр должен всегда быть первой частью строки запроса. Он определяет набор данных, с которым вы работаете, а затем направляет эти результаты в команду. После этого можно использовать символ черты, чтобы добавить дополнительные команды. Это приблизительно соответствует конвейеру Windows PowerShell.

В общем случае язык поиска оперативной аналитики пытается следовать стилю и правилам PowerShell, чтобы казаться привычным для ИТ-специалистов и упростить обучение.

Команды имеют форму глаголов, чтобы можно было легко понять, что именно они делают.

### Сортировать

Команда sort позволяет задать порядок сортировки по одному или нескольким полям. Даже если вы не используете ее, по умолчанию применяется сортировка по времени в порядке убывания. Недавние результаты всегда находятся в верхней части результатов поиска. Это означает, что при выполнении поиска с учетом `Type=Event EventID=1234` реально выполняется следующее:

```
Type=Event EventID=1234 **| Sort TimeGenerated desc**
```

Это происходит так, поскольку данная процедура знакома вам по работе с журналами. Например, в средстве просмотра событий Windows.

С помощью команды sort можно изменить способ возврата результатов. Ниже приведены примеры того, как именно это работает.

```
Type=Event EventID=1234 | Sort TimeGenerated asc
```

```
Type=Event EventID=1234 | Sort Computer asc
```

```
Type=Event EventID=1234 | Sort Computer asc,TimeGenerated desc
```


Простые примеры выше показывают работу команды: они изменяют форму результатов, возвращаемых фильтром.

### Limit и top
Другой менее известной командой является LIMIT. Эта команда похожа на команды PowerShell. По функциональности Limit аналогична команде TOP. Следующие запросы возвращают одинаковые результаты.

```
Type=Event EventID=2110 | Limit 1
```

```
Type=Event EventID=2110 | Top 1
```


#### Поиск с использованием команды top
- В поле поискового запроса введите `Type=Event EventID=2110 | Top 1` ![поиск лучших результатов](./media/operational-insights-search/search-top.png).

На приведенном выше рисунке показано 988 записей с EventID=2110. Поля, аспекты и фильтры в левой части всегда показывать сведения о результатах, возвращаемых *частью фильтра* в запросе, которая стоит до знака вертикальной черты. Область **Результаты** панели возвращает только 1 последний результат, так как команда в примере изменила форму результатов и преобразовала их.

### Выберите пункт

Команда SELECT похожа на команду Select-Object в PowerShell. Она возвращает отфильтрованные результаты, имеющие не все свои первоначальные свойства. Вместо этого она выбирает только заданные вами свойства.

#### Выполнение поиска с помощью команды select

1. В поле поиска введите `Type=Event` и нажмите кнопку **Поиск**.
2. Щелкните **+ Дополнительно** в одном из результатов, чтобы просмотреть все свойства, которые имеют результаты.
3. Выберите некоторые из них явным образом, и запрос изменяется на `Type=Event | Select Computer,EventID,RenderedDescription`. ![поиск с помощью select](./media/operational-insights-search/search-select.png)

Это команда особенно полезна, когда требуется управлять выходными данными поиска и отбирать только те фрагменты данных, которые важны для проводимого исследования, а не полный спектр записей. Это также полезно, когда записи различных типов имеют *несколько* общих свойств, но не *все* их свойства являются общими. Вы можете формировать выходные данные, которые имеют более привычный вид таблицы или более удобны для экспорта в CSV-файл и последующей обработки в Excel.

[AZURE.INCLUDE [operational-insights-export](../../includes/operational-insights-export.md)]

## использование команды measure;

MEASURE является одной из наиболее универсальных команд в поиске оперативной аналитики. Она позволяет применять статистические *функции* к данным и статистически обрабатывать данные, сгруппированные по заданному полю. Существует несколько статистических функций, поддерживаемых командой Measure.

### Measure count()

Первой и наиболее простой в использовании статистической функцией является функция *count()*.

В левой части результатов любого поискового запроса, например `Type=Event`, отображаются фильтры, которые также называются аспектами. Эти фильтры показывают распределение значений по заданному полю для результатов выполненного поиска.

![поиск с помощью measure count](./media/operational-insights-search/search-measure-count01.png)

Например, на приведенном выше рисунке видно поле **Computer** (Компьютер), показывающее, что в рамках почти 3 миллионов событий в результатах присутствует 20 уникальных и не совпадающих значений для поля **Computer**. На плитке отображаются только 5 лучших значений, которые наиболее часто записываются в поля **Computer**), с сортировкой по количеству документов, содержащих это конкретное значение в данном поле. На рисунке видно, что среди почти 3 миллионов событий 880 тысяч поступают с компьютера DM, 602 тысячи — с компьютера DE и т. д.


Что делать, если вы хотите просмотреть все значения, а не только 5 лучших значений на плитке?

Для этого вместе с командой measure можно применить функцию count(). Эта функция не использует никаких параметров. Просто укажите поле, по которому требуется выполнить группировку, в данном случае это поле **Computer**:

`Type=Event | Measure count() by Computer`

![поиск с помощью measure count](./media/operational-insights-search/search-measure-count-computer.png)

Однако **Computer** — это просто поле, используемое *в* каждом фрагменте данных, нет никаких реляционных баз данных и никакого отдельного объекта **Computer**. Только значения *в* данных могут описывать, какая сущность создала их, а также ряд других характеристик и аспектов данных, отсюда мы и получаем термин *аспект*. Однако вы точно так же можете выполнять группировку по другим полям. Поскольку исходные результаты почти 3 миллионов событий, которые переданы в команду measure, также имеют поле с именем **EventID**, можно применить ту же методику для группировки по этому полю и получить количество событий по EventID:

```
Type=Event | Measure count() by EventID
```

Если вас не интересует реальное число записей, содержащих определенное значение, а требуется только список самих значений, можно добавить в конец команду *Select* и просто выбрать первый столбец:

```
Type=Event | Measure count() by EventID | Select EventID
```

После этого можно усложнить запрос и предварительно отсортировать результаты в нем или просто щелкнуть столбцы в сетке.

```
Type=Event | Measure count() by EventID | Select EventID | Sort EventID asc
```

#### Поиск с использованием measure count

- В поле поискового запроса введите `Type=Event | Measure count() by EventID`
- Добавьте `| Select EventID` в конец запроса.
- Затем добавьте `| Sort EventID asc` в конец запроса.


Существует несколько важных моментов, на которые следует обратите внимание.

Во-первых, отображаемые результаты больше не являются исходными необработанными результатами. Вместо этого они являются агрегированными результатами, то есть группами результатов. Это не представляет проблемы, однако следует понимать, что взаимодействие осуществляется совершенно с иной формой данных, которая отличается от исходной необработанной формы, создаваемой в режиме реального времени в результате статистической обработки или применения статистической функции.

Во-вторых, в настоящее время **Measure count** возвращает только 100 лучших несовпадающих результатов. Это ограничение не применяется к другим статистическим функциям. Поэтому обычно перед применением measure count() сначала требуется использовать более точный фильтр для поиска определенных элементов.

## использование функций max и min с командой measure;

Существуют различные сценарии, где использование **Measure Max()** и **Measure Min()** имеет смысл. Однако поскольку каждая функция является противоположностью другой, мы опишем Max(), а с Min() вы сможете поэкспериментировать самостоятельно.

Когда вы выполняете запрос оповещений оценки конфигурации, они имеют свойство **Severity**, которое может иметь значение 0, 1 или 2, представляя информационное оповещение, предупреждение и критическое оповещение соответственно. Например:

```
Type=ConfigurationAlert
```

![начало поиска с помощью measure count](./media/operational-insights-search/search-measure-max01.png)

Если вы хотите просмотреть наибольшее значение для всех оповещений, которым назначено общее поле Computer, с группировкой по полю, можно использовать следующее:

```
Type=ConfigurationAlert | Measure Max(Severity) by Computer
```

![поиск с помощью measure max по computer](./media/operational-insights-search/search-measure-max02.png)

Он покажет, что большинство компьютеров с записями **Alert** имеет по крайней мере одно критическое оповещение, а наибольшим уровнем серьезности для компьютера Bacc является предупреждение.

```
Type=ConfigurationAlert | Measure Max(Severity) by Computer
```

![поиск с помощью measure max для времени создания по computer](./media/operational-insights-search/search-measure-max03.png)

Эта функция хорошо работает с числами, однако она также работает с полями типа DateTime. Это полезно, когда требуется проверить самую последнюю или недавнюю метку времени для любого фрагмента данных, индексируемых для каждого компьютера. Например, когда произошло самое последнее изменение конфигурации, о котором сообщило решение отслеживания изменений, для каждого компьютера?

```
Type=ConfigurationChange | Measure Max(TimeGenerated) by Computer
```

## использование функции avg с командой measure;

Статистическая функция Avg(), используемая с командой measure, позволяет вычислить среднее значение для некоторого поля, группируя результаты по тому же или другому полю. Это оказывается полезным в самых различных случаях, например в случае с данными о производительности.

Мы начнем с данных о производительности. Однако обратите внимание, что в настоящее время компонент оперативной аналитики собирает только определенные связанные со структурой счетчики производительности для узлов диспетчера виртуальных машин и Hyper-V в рамках решения управления емкостью.

Самый простой запрос для поиска *всех* данных о производительности имеет следующий вид:

```
Type=PerfHourly
```

![начало поиска с помощью avg](./media/operational-insights-search/search-avg01.png)

Прежде всего вы заметите компонент оперативной аналитики диаграммы для счетчиков производительности. В нижней части результатов отображаются фактические записи, на которых основаны диаграммы.

![начало поиска с помощью avg](./media/operational-insights-search/search-avg02.png)

На рисунке выше помечено два набора полей, которые обозначают следующее.

- Первый набор определяет имя счетчика производительности Windows, имя объекта и имя экземпляра в фильтре запроса. Это поля, которые вы, вероятно, будете использовать в качестве аспектов и фильтров чаще всего.
- **SampleValue** — это фактическое значение счетчика.
- В запросе **Type=PerfHourly** представляет собой почасовую агрегатную функцию.
- **TimeGenerated** имеет значение 21:00 в 24-часовом формате. Оно представляет агрегат этого почасового периода с 20:00 до 21:00.
- **SampleCount** представляет собой агрегат, вычисленный на основе 12 выборок (один раз в 5 минут)
- **min**, **max** и **Percentile95** для почасового периода в данном примере использовались для объема памяти виртуальной машины, равного 6144 (Мбайт)
- **SampleValue** является почасовой статистической функцией, заполняется *средним значением* за почасовой период и используется для построения диаграмм производительности.

После ознакомления с формой записи PerfHourly и другими методиками поиска можно использовать measure Avg() для статистической обработки числовых данных этого типа.

Ниже приведен простой пример.

```
Type=PerfHourly  ObjectName:Processor  InstanceName:_Total  CounterName:"% Processor Time" | Measure Avg(SampleValue) by Computer
```

![поиска с помощью avg по samplevalue](./media/operational-insights-search/search-avg03.png)

В этом примере вы выбираете счетчик производительности CPU Total Time (Общее время ЦП) и получаете среднее значение по полю Computer. Поскольку **SampleValue** уже является средней величиной, фактически вы запрашиваете усреднение среднего значения. В данном случае с Type=PerfHourly это имеет смысл. Следует всегда использовать фильтр для TimeGenerated, чтобы ограничить выполнение операции небольшим или последним набором данных, например за последние 4 часа, а не за 7 дней.

Таким образом, приведенный выше запрос приобретает следующий вид:

```
Type=PerfHourly  ObjectName:Processor  InstanceName:_Total  CounterName:"% Processor Time" TimeGenerated>NOW-4HOURS | Measure Avg(SampleValue) by Computer
```

### Поиска с использованием функции avg с командой measure
1. В поле поиска введите `Type=PerfHourly  ObjectName:Processor  InstanceName:_Total  CounterName:"% Processor Time" TimeGenerated>NOW-4HOURS | Measure Avg(SampleValue) by Computer`.
2. Обратите внимание, что последнее среднее значение обычно будет больше.
3. Вычислите среднюю величину для максимальных почасовых значений, изменив запрос поиска следующим образом: `Type=PerfHourly  ObjectName:Processor  InstanceName:_Total  CounterName:"% Processor Time" TimeGenerated>NOW-4HOURS | Measure Avg(Max) by Computer`

Можно объединять и сопоставлять данные *по* разным компьютерам. Например, предположим, что имеется набор узлов в некоторой ферме, где каждый узел совпадает с любым другим узлом и они выполняют одинаковую работу, а также требуется грубая балансировка нагрузки. Вы можете собрать все счетчики за один проход с помощью следующего запроса и получить средние значения для всей фермы. Для начала можно выбрать компьютеры, используя следующий пример:

```
Type=PerfHourly AND (Computer=”SERVER1.contoso.com” OR Computer=”SERVER2.contoso.com” OR Computer=”SERVER3.contoso.com”)
```

Теперь, когда вы получили компьютеры, вам требуется выбрать всего два ключевых показателя эффективности (KPI): "% CPU Usage" (% загрузки ЦП) и "% Free Disk Space" (% свободного места на диске). Таким образом, запрос принимает следующий вид:

```
Type=PerfHourly  InstanceName:_Total  ((ObjectName:Processor AND CounterName:"% Processor Time") OR (ObjectName="LogicalDisk" AND CounterName="% Free Space")) AND TimeGenerated>NOW-4HOURS
```

Теперь можно добавить компьютеры и счетчики, как показано в следующем примере:

```
Type=PerfHourly  InstanceName:_Total  ((ObjectName:Processor AND CounterName:"% Processor Time") OR (ObjectName="LogicalDisk" AND CounterName="% Free Space")) AND TimeGenerated>NOW-4HOURS AND (Computer=”SERVER1.contoso.com” OR Computer=”SERVER2.contoso.com” OR Computer=”SERVER3.contoso.com”)
```

Благодаря выбору конкретных элементов команда **measure Avg()** позволяет возвратить среднее значение не для компьютера, а для всей фермы путем группирования по CounterName. Например:

```
Type=PerfHourly  InstanceName:_Total  ((ObjectName:Processor AND CounterName:"% Processor Time") OR (ObjectName="LogicalDisk" AND CounterName="% Free Space")) AND TimeGenerated>NOW-4HOURS AND (Computer=”SERVER1.contoso.com” OR Computer=”SERVER2.contoso.com” OR Computer=”SERVER3.contoso.com”) | Measure Avg(SampleValue) by CounterName
```

Это позволяет получить удобное компактное представление с парой ключевых показателей эффективности вашей среды.

![группировка поиска с помощью avg](./media/operational-insights-search/search-avg04.png)


Это можно легко использовать в панели мониторинга. Дополнительные сведения об использовании панелей мониторинга см. в разделе [Панели мониторинга оперативной аналитики](operational-insights-use-dashboards).

![панель мониторинга поиска с помощью avg](./media/operational-insights-search/search-avg05.png)

### Использование функции sum с командой measure

Функция sum аналогична другим функциям команды measure. Пример использования функции sum см. в разделе [Поиск журналов IIS W3C в компоненте оперативной аналитики Microsoft Azure](http://blogs.msdn.com/b/dmuscett/archive/2014/09/20/w3c-iis-logs-search-in-system-center-advisor-limited-preview.aspx).

Функции Max() и Min() можно использовать с числами, датой и временем, а также с текстовыми строками. Текстовые строки сортируются в алфавитном порядке, и вы получаете первую и последнюю сроку.

Однако функцию Sum() можно использовать только с числовыми полями. Это также касается и функции Avg().

## использование команды where.

Команда where работает как фильтр, но ее можно применить в конвейере для дальнейшей фильтрации сводных результатов, полученных с помощью команды Measure, в отличие от необработанных результатов, которые фильтруются в начале запроса.

Например:

```
Type=PerfHourly  CounterName="% Processor Time"  InstanceName="_Total" | Measure Avg(SampleValue) as AVGCPU by Computer
```

Можно добавить другой символ вертикальной черты "|" и команду Where, чтобы получить только те компьютеры, на которых средняя загрузка ЦП превышает 80 %, как показано в следующем примере:

```
Type=PerfHourly  CounterName="% Processor Time"  InstanceName="_Total" | Measure Avg(SampleValue) as AVGCPU by Computer | Where AVGCPU>80
```

Если вы знакомы с Microsoft System Center Operations Manager, команду where можно определить в терминах пакета управления. Если бы данный пример являлся правилом, первая часть запроса была бы источником данных, а команда where была бы определением условия.

Этот запрос можно использовать в качестве плитки в окне **Моя панель мониторинга**, позволяющей отслеживать чрезмерную загрузку ЦП компьютера. Дополнительные сведения о панелях мониторинга см. в разделе [Панели мониторинга оперативной аналитики](operational-insights-use-dashboards). Вы также можете создавать и использовать панели мониторинга с помощью мобильного приложения. Дополнительные сведения см. в разделе [Мобильное приложение оперативной аналитики Azure](http://www.windowsphone.com/ru-RU/store/app/operational-insights/4823b935-83ce-466c-82bb-bd0a3f58d865). На двух нижних плитках на следующем изображении представлен монитор, отображающий список и число. В большинстве случаев желательно, чтобы это число было равным нулю, а список был пуст. Иное состояние указывает на наличие условия предупреждения. При необходимости его можно использовать для просмотра компьютеров с высокой загрузкой.

![панель мониторинга на мобильном устройстве](./media/operational-insights-search/search-mobile.png)

## Справочник по синтаксису поиска

В следующем справочном разделе о языке поиска описываются общие варианты синтаксиса запросов, которые можно использовать при поиске данных и фильтрации выражений для сужения области поиска. В нем также описываются команды, которые можно использовать для выполнения действий с полученными данными.

Сведения о полях, возвращаемых при поиске, и аспектах, которые помогают детализировать подобные категории данных, см. в разделе [Справочник по полю и аспекту поиска](#Search-field-and-facet-reference).

### Общий синтаксис запросов

Синтаксис:

выражение\_фильтра | команда1 | команда2 …

Выражение фильтра (**filterExpression**) определяет условие where для запроса. Команды применяются к результатам, возвращаемым запросом. Несколько команд следует разделить символом вертикальной черты (|).

#### Примеры общего синтаксиса

Примеры:

	system

Этот запрос возвращает результаты, содержащие слово "system" в любом поле, которое было проиндексировано для полнотекстового поиска или поиска терминов.

>[AZURE.NOTE]Подобным образом индексируются не все поля, однако наиболее распространенные текстовые поля (например, описания и имена) в общем случае проиндексированы именно так.

	system error

Этот запрос возвращает результаты, содержащие слова system и error.

	system error | sort ManagementGroupName, TimeGenerated desc | top 10

Этот запрос возвращает результаты, содержащие слова system и error. Затем он выполняет сортировку результатов по полю **ManagementGroupName** (в порядке возрастания), а затем по полю **TimeGenerated** (в порядке убывания). Он принимает только первые 10 результатов.

>[AZURE.IMPORTANT]Все имена полей и значения для строковых и текстовых полей указываются с учетом регистра.

### Выражения фильтра

Следующие подразделы содержат пояснения по выражениям фильтра.

#### Строковые литералы

Строковый литерал — это любая строка, которая не распознается средством синтаксического анализа как ключевое слово или предопределенный тип данных (например, число или дата).

Примеры:

	These all are string literals


Этот запрос выполняет поиск результатов, содержащих вхождения всех пяти слов. Для выполнения поиска сложных строк заключите строковый литерал в кавычки, например:

	" Windows Server"

Этот запрос возвращает только результаты с точным совпадением для Windows Server.

#### Числа

Средство синтаксического анализа поддерживает для числовых полей синтаксис на базе десятичных целых чисел и чисел с плавающей запятой.

Примеры:

	Type:PerfHourly 0.5


	HTTP 500

#### Дата и время

Каждый фрагмент данных в системе имеет свойство **TimeGenerated**, которое представляет исходные значения даты и времени записи. Некоторые типы данных могут также иметь дополнительные поля даты и времени (например, **LastModified**).

Селектор диаграммы/времени временной шкалы в компоненте оперативной аналитики показывает распределение результатов во времени (в соответствии с выполняемым в данный момент запросом) на основе поля **TimeGenerated**. Поля даты и времени имеют определенный строковый формат, который можно использовать в запросах для ограничения запроса определенным периодом времени. Синтаксис также можно использовать, чтобы сослаться на относительные интервалы времени (например, "между 3 днями назад и 2 часами назад").

Синтаксис:

	yyyy-mm-ddThh:mm:ss.dddZ


	yyyy-mm-ddThh:mm:ss.ddd


	yyyy-mm-ddThh:mm:ss


	yyyy-mm-ddThh:mm:ss


	yyyy-mm-ddThh:mm


	yyyy-mm-dd



Пример:

	TimeGenerated:2013-10-01T12:20

Предыдущая команда возвращает только записи, у которых значение **TimeGenerated** в точности соответствует 12:20 1 октября 2013 г. Маловероятно, что она даст какой-либо результат, однако это позволяет понять саму идею.

Средство синтаксического анализа также поддерживает мнемоническое значение даты и времени — NOW (Сейчас).

Пример:


Опять же маловероятно, что это даст какой-либо результат, так как данные не проходят через систему с такой скоростью.

Эти примеры являются шаблонами для относительных и абсолютных дат. В трех следующих подразделах объясняется, как использовать их в более сложных фильтрах, с примерами, где применяются относительные временные диапазоны.

#### Математические операторы даты и времени

Используйте математические операторы даты и времени для смещения или округления значения даты и времени с помощью простых вычислений даты и времени.

Синтаксис:

	datetime/unit


	datetime[+|-]count unit




<table border="1" cellspacing="4" cellpadding="4">
	<tr>
		<th>Оператор</th>
		<th>Описание</th>
	</tr>
	<tr>
		<td>
		<p>/</p>
		</td>
		<td>
		<p>Округляет значение даты и времени до заданной единицы измерения. </p>
		<p>Пример: NOW/DAY округляет текущее значение даты и времени до полуночи текущего дня. </p>
		</td>
	</tr>
	<tr>
		<td>
		<p>+ или -</p>
		</td>
		<td>
		<p>Смещает дату и время на указанное число единиц измерения.</p>
		<p>Примеры:&#160; </p>
		<ul>
			<li class="unordered">NOW+1HOUR смещает текущее значение даты и времени на час вперед.<br><br></li>
			<li class="unordered">2013-10-01T12:00-10DAYS смещает значение даты на 10 дней назад.</li>
		</ul>
		</td>
	</tr>
</table>





Математические операторы даты и времени можно объединить в цепочку, например:

	NOW+1HOUR-10MONTHS/MINUTE

В следующей таблице перечислены поддерживаемые единицы измерения даты и времени.

Единица измерения даты и времени|Описание
---|---
YEAR, YEARS|Округляет значение до текущего года или смещает значение на указанное число лет.
MONTH, MONTHS|Округляет значение до текущего месяца или смещает значение на указанное число месяцев.
DAY, DAYS, DATE|Округляет значение до текущего дня месяца или смещает значение на указанное число дней.
HOUR, HOURS|Округляет значение до текущего часа или смещает значение на указанное число часов.
MINUTE, MINUTES|Округляет значение до текущей минуты или смещает значение на указанное число минут.
SECOND, SECONDS|Округляет значение до текущей секунды или смещает значение на указанное число секунд.
MILLISECOND, MILLISECONDS, MILLI, MILLIS|Округляет значение до текущей миллисекунды или смещает значение на указанное число миллисекунд.


#### Аспекты поля

С помощью аспектов поля можно указать условие поиска для конкретных полей и их точные значения, а не составлять запросы в развернутой форме для различных терминов по всему индексу. Мы уже использовали этот синтаксис в нескольких примерах выше. Здесь мы предлагаем более сложные примеры.

**Синтаксис**

*поле:значение*

*поле=значение*

**Описание**

Выполняет поиск конкретного значения в поле. Значение может быть строковым литералом, числом либо датой и временем.

Пример:


	TimeGenerated:NOW


	ObjectDisplayName:"server01.contoso.com"


	SampleValue:0.3

**Синтаксис**

*поле>значение*

*поле<значение*

*поле>=значение*

*поле<=значение*

*поле!=значение*

**Описание**

Предоставляет сравнения.

Пример:

	TimeGenerated>NOW+2HOURS


**Синтаксис**

*поле:[от..до]*

**Описание**

Предоставляет аспекты диапазона.

Пример:

	TimeGenerated:[NOW..NOW+1DAY]


	SampleValue:[0..2]
#### Логические операторы

Языки запросов поддерживают логические операторы (И, ИЛИ и НЕ) и их псевдонимы в стиле C (&&, || и !) соответственно. Для группировки этих операторов можно использовать круглые скобки.

Примеры:

	system OR error


	Type:Alert AND NOT(Severity:1 OR ObjectId:"8066bbc0-9ec8-ca83-1edc-6f30d4779bcb8066bbc0-9ec8-ca83-1edc-6f30d4779bcb")
Для аргументов фильтра верхнего уровня логический оператор можно опустить. В этом случае подразумевается использование оператора И.


Выражения фильтра|Эквивалент
---|---
system error|system AND error
system "Windows Server" OR Severity:1|system AND ("Windows Server" OR Severity:1)



### Команды

Эти команды применяются к результатам, возвращаемым запросом. Используйте знак вертикальной черты (|), чтобы применить команду к полученным результатам. Несколько команд следует разделить символом вертикальной черты.

>[AZURE.NOTE]Имена команд, в отличие от имен полей и данных, можно вводить в верхнем или нижнем регистре.

#### Сортировать

Синтаксис:

	sort field1 asc|desc, field2 asc|desc, …

Сортирует результаты по определенным полям. Префикс asc/desc является необязательным. Если префикс не указан, подразумевается, что используется asc. Если в запросе не используется команда **Sort**, по умолчанию сортировка выполняется по времени создания (**TimeGenerated**), а первыми всегда возвращаются самые новые результаты.

#### Top/Limit

Синтаксис:

	top number


	limit number
Ограничивает ответ N лучшими результатами.

Пример:

	Type:Alert errors detected | top 10

Возвращает 10 лучших соответствующих результатов.

#### Skip

Синтаксис:

	skip number

Пропускает указанное число результатов.

Пример:

	Type:Alert errors detected | top 10 | skip 200

Возвращает 10 лучших соответствующих результатов, начиная с результата под номером 200.

#### Выберите пункт

Синтаксис:

	select field1, field2, ...

Ограничивает результаты выбранными полями.

Пример:

	Type:Alert errors detected | select Name, Severity

Ограничивает возвращаемые результаты полями **Name** и **Severity**.

#### Measure

Команда **measure** используется для применения статистических функций к необработанным результатам поиска. Иногда данные нужно представить в *сгруппированном* виде. При использовании команды **measure** в компоненте оперативной аналитики отображается таблица с агрегированными результатами.

Синтаксис:

	measure aggregateFunction([aggregatedField]) [as fieldAlias] by groupField [interval interval]


	measure aggregateFunction([aggregatedField])  interval interval

Осуществляет статистическую обработку результатов по **groupField** и вычисляет агрегированные значения с помощью **aggregatedField**.


<table border="1" cellspacing="4" cellpadding="4"><table> <tr> <th>Статистическая функция measure </th> <th>Описание </th> </tr> <tr> <td> <p><em>aggregateFunction</em> </p> <p></p> </td> <td> <p>Имя агрегатной функции (без учета регистра). Поддерживаются следующие агрегатные функции:</p> <ul> <li class="unordered">COUNT<br><br></li> <li class="unordered">MAX<br><br></li> <li class="unordered">MIN<br><br></li> <li class="unordered">SUM<br><br></li> <li class="unordered">AVG<br><br></li> <li class="unordered">STDDEV<br><br></li> </ul> </td> </tr> <tr> <td> <p><em>aggregatedField</em> </p> </td> <td> <p>Поле, в котором проходит статистическая обработка. Это поле является необязательным для агрегатной функции COUNT, но должно присутствовать в качестве числового поля для SUM, MAX, MIN, AVG или STDDEV.</p> </td> </tr> <tr> <td> <p><em>fieldAlias</em> </p> </td> <td> <p>Псевдоним (необязательный) для вычисляемого агрегатного значения. Если он не указан, имя поля будет иметь значение <em>AggregatedValue.</em></p> </td> </tr> <tr> <td> <p><em>groupField</em> </p> </td> <td> <p>Имя поля, по которому группируется результирующий набор. </p> </td> </tr> <tr> <td> <p><em>Interval</em> </p> </td> <td> <p>Интервал времени в следующем формате: </p> <p><em>nnnNAME</em>, </p> <p></p> <p>где: </p> <p>nnn является целым положительным числом</p>; <p><em>NAME</em> является именем интервала</p>. <p>К поддерживаемым именам интервала относятся следующие (с учетом регистра): </p> <ul> <li class="unordered">MILLISECOND[S]<br><br></li>, <li class="unordered">SECOND[S]<br><br></li>, <li class="unordered">MINUTE[S]<br><br></li>, <li class="unordered">HOUR[S]<br><br></li>, <li class="unordered">DAY[S]<br><br></li>, <li class="unordered">MONTH[S]<br><br></li>, <li class="unordered">YEAR[S]<br></li>. </ul> </td> </tr> </table>



Параметр интервала можно использовать только в полях групп даты и времени (например, **TimeGenerated** и **TimeCreated**). В настоящее время служба не применяет данное правило принудительно, однако передача поля без даты и времени в серверную часть приведет к ошибке времени выполнения. При реализации проверки схемы API службы отклоняет запросы, использующие поля без даты и времени для статистической обработки по интервалу. Текущая реализация команды **Measure** поддерживает группировку по интервалу только для агрегатной функции **Count**.

Если предложение BY опущено, однако интервал задан (в качестве второго синтаксиса), по умолчанию подразумевается, что используется поле **TimeGenerated**.

Примеры:

**Пример 1**

	Type:Alert | measure count() as Count by ObjectId

*Пояснение*

Группирует оповещения по параметру **ObjectID** и вычисляет количество оповещений для каждой группы. Агрегированное значение возвращается в виде поля **Count** (псевдоним).

**Пример 2**

	Type:Alert | measure count() interval 1HOUR

*Пояснение*

Группирует оповещения с интервалами в 1 час, используя поле **TimeGenerated**, и возвращает количество оповещений в каждом интервале.

**Пример 3**

	Type:Alert | measure count() as AlertsPerHour interval 1HOUR

*Пояснение*

Аналогичен предыдущему примеру, только с псевдонимом агрегированного поля (**AlertsPerHour**).

**Пример 4**

	* | measure count() by TimeCreated interval 5DAYS

*Пояснение*

Группирует результаты с интервалами в 5 дней, используя поле **TimeCreated**, и возвращает количество результатов в каждом интервале.

**Пример 5**

	Type:Alert | measure max(Severity) by WorkflowName

*Пояснение*

Группирует оповещения по имени рабочей нагрузки и возвращает значение максимального уровня серьезности оповещений для каждого рабочего процесса.

**Пример 6**

	Type:Alert | measure min(Severity) by WorkflowName

*Пояснение*

Аналогичен предыдущему примеру, только с агрегированной функцией **Min**.

**Пример 7**

	Type:PerfHourly | measure avg(SampleValue) by ObjectId

*Пояснение*

Группирует PerfHourly по ObjectId и вычисляет среднее значение (avg).

**Пример 8**

	Type:PerfHourly | measure sum(SampleValue) by ObjectId

*Пояснение*

Аналогичен предыдущему примеру, только использует **Sum**.

**Пример 9**

	Type:PerfHourly | measure stddev(SampleValue) by ObjectId

*Пояснение*

Аналогичен предыдущему примеру, только использует **STDDEV**.

**Пример 10**

	Type:Alert | measure count() as Count by WorkflowName | sort Count desc | top 5

*Пояснение*

Получает пять первых рабочих процессов с максимальным числом оповещений.

#### Where

Синтаксис:

**где** AggregatedValue>20

Можно использовать только после команды **Measure** для дальнейшей фильтрации объединенных результатов, созданных агрегированной функцией **Measure**.

Примеры:

	Type:PerfHourly CounterName:"% Total Run Time" | Measure max(Max) as MAXCPU by

	Type:PerfHourly CounterName:"% Total Run Time" | Measure max(Max) by RootObjectName | where (AggregatedValue>50 and AggregatedValue<90)




## Справочник по полю и аспекту поиска

При использовании команды Search для поиска данных в результатах отображаются различные поля и аспекты. Тем не менее некоторые из отображаемых сведений могут показаться непонятными. Вы можете воспользоваться приведенной ниже информацией, чтобы интерпретировать результаты.

<table border="1" cellspacing="4" cellpadding="4">
	<tr>
		<th><b>Поле</b></th>
		<th><b>Тип поиска<b></th>
		<th><b>Описание</b></th>
	</tr>
	<tr>
		<td>
		<p>TenantId</p>
		</td>
		<td>
		<p>Все</p>
		</td>
		<td>
		<p>Используется для секционирования данных.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>TimeGenerated</p>
		</td>
		<td>
		<p>Все</p>
		</td>
		<td>
		<p>Используется для управления временной шкалой и селекторами времени (в поиске и на других экранах). Оно представляет, когда фрагмент данных был создан (обычно в агенте). Время обозначается по стандарту ISO и всегда является временем в формате UTC. В случае с "типами", основанными на существующем инструментировании (т. е. событиях в журнале), обычно это реальное время регистрации строки/записи журнала; для некоторых других типов, которые создаются через пакеты управления или в облаке, например рекомендации/оповещения/агенты обновления и т. п., это время, когда был собран этот новый фрагмент данных вместе с каким-либо моментальным снимком конфигурации или на основе его была создана рекомендация/оповещение.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>EventID</p>
		</td>
		<td>
		<p>Событие</p>
		</td>
		<td>
		<p>Код события в журнале событий Windows.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>EventLog</p>
		</td>
		<td>
		<p>Событие</p>
		</td>
		<td>
		<p>Журнал событий, в котором событие было зарегистрировано операционной системой Windows.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>EventLevelName</p>
		</td>
		<td>
		<p>Событие</p>
		</td>
		<td>
		<p>Уровни критический/ предупреждение/информационный/успешное выполнение</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>EventLevel</p>
		</td>
		<td>
		<p>Событие</p>
		</td>
		<td>
		<p>Числовое значение для уровня критический/ предупреждение/информационный/успешное выполнение (используйте вместо него EventLevelName, чтобы получить более простые и удобные для чтения запросы)</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SourceSystem</p>
		</td>
		<td>
		<p>Все</p>
		</td>
		<td>
		<p>Источник поступления данных с точки зрения режима подключения к службе, например Operations Manager компонент оперативной аналитики (данные создаются в облаке), служба хранилища Azure (данные поступают из системы диагностики Microsoft Azure) и т. д.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>ObjectName</p>
		</td>
		<td>
		<p>PerfHourly</p>
		</td>
		<td>
		<p>Имя объекта производительности Windows.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>InstanceName</p>
		</td>
		<td>
		<p>PerfHourly</p>
		</td>
		<td>
		<p>Имя экземпляра счетчика производительности Windows.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>CounteName</p>
		</td>
		<td>
		<p>PerfHourly</p>
		</td>
		<td>
		<p>Имя счетчика производительности Windows.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>ObjectDisplayName</p>
		</td>
		<td>
		<p>PerfHourly, ConfigurationAlert, ConfigurationObject, ConfigurationObjectProperty</p>
		</td>
		<td>
		<p>Отображаемое имя объекта, который является мишенью для правила сбора данных о производительности в Operations Manager, объекта, обнаруженного компонентом оперативной аналитики, либо объекта, для которого было выдано оповещение.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>RootObjectName</p>
		</td>
		<td>
		<p>PerfHourly, ConfigurationAlert, ConfigurationObject, ConfigurationObjectProperty</p>
		</td>
		<td>
		<p>Отображаемое имя родительского элемента родительского элемента (в отношении двойного размещения, например SqlDatabase, размещаемый SqlInstance, который размещается на компьютере Windows) объекта, который является мишенью для правила сбора данных о производительности в Operations Manager, объекта, обнаруженного компонентом оперативной аналитики, либо объекта, для которого было выдано оповещение.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Компьютер</p>
		</td>
		<td>
		<p>Большинство типов </p>
		</td>
		<td>
		<p>Имя компьютера, к которому относятся данные.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>DeviceName</p>
		</td>
		<td>
		<p>ProtectionStatus</p>
		</td>
		<td>
		<p>Имя компьютера, к которому относятся данные (то же, что и Computer)</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>DetectionId</p>
		</td>
		<td>
		<p>ProtectionStatus</p>
		</td>
		<td>
		<p></p>
		</td>
	</tr>
	<tr>
		<td>
		<p>ThreatStatusRank</p>
		</td>
		<td>
		<p>ProtectionStatus</p>
		</td>
		<td>
		<p>Ранг состояния угрозы является числовым представлением состояния угрозы, и, как и в случае с кодами HTTP-ответов, мы оставили промежутки между числами (поэтому число угроз составляет 150, а не 100 или 0), чтобы получить возможность добавлять новые состояния. При выполнении свертки для состояния угрозы и состояния защиты мы хотим показать наихудшее состояние, в котором компьютер находился за выбранный период времени. Мы используем номера для ранжирования различных состояний, чтобы можно было просмотреть запись с наибольшим номером.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>ThreatStatus</p>
		</td>
		<td>
		<p>ProtectionStatus</p>
		</td>
		<td>
		<p>Описание для ThreatStatus полностью соответствует описанию для ThreatStatusRank</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>TypeofProtection</p>
		</td>
		<td>
		<p>ProtectionStatus</p>
		</td>
		<td>
		<p>Продукт защиты от вредоносных программ, обнаруженный на компьютере: отсутствует, средство удаления вредоносных программ (Майкрософт), Forefront и т. д.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>ScanDate</p>
		</td>
		<td>
		<p>ProtectionStatus</p>
		</td>
		<td>
		<p></p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SourceHealthServiceId</p>
		</td>
		<td>
		<p>ProtectionStatus, RequiredUpdate</p>
		</td>
		<td>
		<p>Идентификатор службы работоспособности для агента этого компьютера.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>HealthServiceId</p>
		</td>
		<td>
		<p>Большинство типов </p>
		</td>
		<td>
		<p>Идентификатор службы работоспособности для агента этого компьютера.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>ManagementGroupName</p>
		</td>
		<td>
		<p>Большинство типов </p>
		</td>
		<td>
		<p>Имя группы управления для подключенных к Operations Manager агентов; в противном случае имеет пустое значение или значение NULL.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>ObjectType</p>
		</td>
		<td>
		<p>ConfigurationObject</p>
		</td>
		<td>
		<p>Тип (как в типе/классе пакета управления Operations Manager) для этого объекта, обнаруженный функцией оценки конфигурации компонента оперативной аналитики.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>UpdateTitle</p>
		</td>
		<td>
		<p>RequiredUpdate</p>
		</td>
		<td>
		<p>Имя обновления, которое было определено как неустановленное.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>PublishDate</p>
		</td>
		<td>
		<p>RequiredUpdate</p>
		</td>
		<td>
		<p>Когда обновление было опубликовано в Центре обновления Майкрософт?</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>сервер;</p>
		</td>
		<td>
		<p>RequiredUpdate</p>
		</td>
		<td>
		<p>Имя компьютера, к которому относятся данные (то же, что и Computer)</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Продукт</p>
		</td>
		<td>
		<p>RequiredUpdate</p>
		</td>
		<td>
		<p>Продукт, к которому применяется обновление.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>UpdateClassification</p>
		</td>
		<td>
		<p>RequiredUpdate</p>
		</td>
		<td>
		<p>Тип обновления (накопительный пакет обновления, пакет обновления и т. д.).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>KBID</p>
		</td>
		<td>
		<p>RequiredUpdate</p>
		</td>
		<td>
		<p>Идентификатор статьи в базе знаний с описанием этой рекомендации или этого обновления.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>WorkflowName</p>
		</td>
		<td>
		<p>ConfigurationAlert</p>
		</td>
		<td>
		<p>Имя правила или монитора, которые вызвали оповещение.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Уровень серьезности</p>
		</td>
		<td>
		<p>ConfigurationAlert</p>
		</td>
		<td>
		<p>Серьезность оповещения.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Приоритет</p>
		</td>
		<td>
		<p>ConfigurationAlert</p>
		</td>
		<td>
		<p>Приоритет оповещения.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>IsMonitorAlert</p>
		</td>
		<td>
		<p>ConfigurationAlert</p>
		</td>
		<td>
		<p>Это предупреждение создается монитором (true) или правилом (false)?</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>AlertParameters</p>
		</td>
		<td>
		<p>ConfigurationAlert</p>
		</td>
		<td>
		<p>XML-код с параметрами оповещения оперативной аналитики.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Context</p>
		</td>
		<td>
		<p>ConfigurationAlert</p>
		</td>
		<td>
		<p>XML-код с контекстом оповещения оперативной аналитики.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Рабочая нагрузка</p>
		</td>
		<td>
		<p>ConfigurationAlert</p>
		</td>
		<td>
		<p>Технология или рабочая нагрузка, к которой относится оповещение. </p>
		</td>
	</tr>
	<tr>
		<td>
		<p>AdvisorWorkload</p>
		</td>
		<td>
		<p>Рекомендации</p>
		</td>
		<td>
		<p>Технология или рабочая нагрузка, к которой относится рекомендация.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Описание</p>
		</td>
		<td>
		<p>ConfigurationAlert</p>
		</td>
		<td>
		<p>Описание оповещения (краткое).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>DaysSinceLastUpdate</p>
		</td>
		<td>
		<p>UpdateAgent</p>
		</td>
		<td>
		<p>Сколько дней назад (относительно значения TimeGenerated этой записи) этот агент устанавливал любое обновление из служб WSUS или Центра обновления Майкрософт?</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>DaysSinceLastUpdateBucket</p>
		</td>
		<td>
		<p>UpdateAgent</p>
		</td>
		<td>
		<p>Основанная на значении DaysSinceLastUpdate классификация того, как давно на компьютере в последний раз было установлено обновление из служб WSUS или Центра обновления Майкрософт, по заданным периодам.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>AutomaticUpdateEnabled</p>
		</td>
		<td>
		<p>UpdateAgent</p>
		</td>
		<td>
		<p>Включена ли в данном агенте автоматическая проверка обновления?</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>AutomaticUpdateValue</p>
		</td>
		<td>
		<p>UpdateAgent</p>
		</td>
		<td>
		<p>Настроена ли автоматическая проверка обновления на автоматическое скачивание и установку, только на скачивание или только на проверку?</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>WindowsUpdateAgentVersion</p>
		</td>
		<td>
		<p>UpdateAgent</p>
		</td>
		<td>
		<p>Номер версии агента Центра обновления Майкрософт.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>WSUSServer</p>
		</td>
		<td>
		<p>UpdateAgent</p>
		</td>
		<td>
		<p>На какой сервер WSUS нацелен этот агент обновления?</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>OSVersion</p>
		</td>
		<td>
		<p>UpdateAgent</p>
		</td>
		<td>
		<p>Версия операционной системы, в которой выполняется этот агент обновления.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Имя</p>
		</td>
		<td>
		<p>Recommendation, ConfigurationObjectProperty</p>
		</td>
		<td>
		<p>Имя/заголовок рекомендации или имя свойства из функции оценки конфигурации компонента оперативной аналитики.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Значение</p>
		</td>
		<td>
		<p>ConfigurationObjectProperty</p>
		</td>
		<td>
		<p>Значение свойства из функции оценки конфигурации компонента оперативной аналитики.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>KBLink</p>
		</td>
		<td>
		<p>Рекомендации</p>
		</td>
		<td>
		<p>URL-адрес статьи в базе знаний с описанием этой рекомендации или этого обновления.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>RecommendationStatus</p>
		</td>
		<td>
		<p>Рекомендации</p>
		</td>
		<td>
		<p>Рекомендации относятся к тем немногим типам, записи которых обновляются, а не просто добавляются в индекс поиска. Это состояние определяет, является ли рекомендация активной/открытой или компонент оперативной аналитики обнаружил, что она была разрешена.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>RenderedDescription</p>
		</td>
		<td>
		<p>Событие</p>
		</td>
		<td>
		<p>Готовое для просмотра описание события Windows (повторно используемый текст с заполненными параметрами).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>ParameterXml</p>
		</td>
		<td>
		<p>Событие</p>
		</td>
		<td>
		<p>XML-код с параметрами из раздела данных события Windows (как показано в средстве просмотра событий).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>EventData</p>
		</td>
		<td>
		<p>Событие</p>
		</td>
		<td>
		<p>XML-код со всем разделом данных события Windows (как показано в средстве просмотра событий).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Источник</p>
		</td>
		<td>
		<p>Событие</p>
		</td>
		<td>
		<p>Источник журнала событий, который создал событие.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>EventCategory</p>
		</td>
		<td>
		<p>Событие</p>
		</td>
		<td>
		<p>Категория события, полученная непосредственно из журнала событий Windows.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>UserName</p>
		</td>
		<td>
		<p>Событие</p>
		</td>
		<td>
		<p>Имя пользователя события Windows (обычно это NT AUTHORITY\LOCALSYSTEM)</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SampleValue</p>
		</td>
		<td>
		<p>PerfHourly</p>
		</td>
		<td>
		<p>Среднее значение для почасовой статистической обработки счетчика производительности. </p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Min</p>
		</td>
		<td>
		<p>PerfHourly</p>
		</td>
		<td>
		<p>Минимальное значение в почасовом интервале для почасовой статистической обработки счетчика производительности.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Max</p>
		</td>
		<td>
		<p>PerfHourly</p>
		</td>
		<td>
		<p>Максимальное значение в почасовом интервале для почасовой статистической обработки счетчика производительности.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Percentile95</p>
		</td>
		<td>
		<p>PerfHourly</p>
		</td>
		<td>
		<p>Значение 95-го процентиля для почасового интервала почасовой статистической обработки счетчика производительности.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SampleCount</p>
		</td>
		<td>
		<p>PerfHourly</p>
		</td>
		<td>
		<p>Количество необработанных выборок счетчиков производительности, использовавшихся для создания этой записи почасовой статистической обработки.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Threat</p>
		</td>
		<td>
		<p>ProtectionStatus</p>
		</td>
		<td>
		<p>Имя обнаруженной вредоносной программы.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>StorageAccount</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Учетная записи хранения Azure, из которой был считан журнал.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>AzureDeploymentID</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Идентификатор развертывания Azure для облачной службы, к которой относится журнал.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Роль</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Роль облачной службы Azure, к которой относится журнал.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>RoleInstance</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Значение RoleInstance роли Azure, к которой относится журнал.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>sSiteName</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Веб-сайт IIS, к которому относится журнал (нотация метабазы); поле s-sitename в исходном журнале.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>sComputerName</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Поле s-computername в исходном журнале.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>sIP</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>IP-адрес сервера, на который был направлен HTTP-запрос. Поле s-ip в исходном журнале.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>csMethod</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Метод HTTP (GET/POST и т. д.), используемый клиентом в HTTP-запросе. Поле cs-method в исходном журнале.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>cIP</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>IP-адрес клиента, откуда был выдан HTTP-запрос. Поле c-ip в исходном журнале.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>csUserAgent</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Агент пользователя HTTP, объявленный клиентом (в браузере или иным способом). Поле cs-user-agent в исходном журнале.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>scStatus</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Код состояния HTTP (200/403/500 и т. д.), который сервер возвращает клиенту. Поле cs-status в исходном журнале.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>TimeTaken</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Время (в миллисекундах), потребовавшееся для выполнения запроса. Поле timetaken в исходном журнале.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>csUriStem</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Относительный URI (без адреса узла, например "/search"), который был запрошен. Поле cs-uristem в исходном журнале.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>csUriQuery</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Запрос URI. Запросы URI необходимы только для динамических страниц, например ASP-страниц, поэтому для статических страниц это поле обычно содержит дефис.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>sPort</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Порт сервера, на который был отправлен HTTP-запрос (и который после принятия запроса прослушивают службы IIS).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>csUserName</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Имя пользователя, прошедшего проверку, если запрос подлежит проверке подлинности и не является анонимным.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>csVersion</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Версия протокола HTTP, используемого в запросе (например, "HTTP/1.1").</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>csCookie</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Сведения о файле cookie.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>csReferer</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Сайт, который пользователь посетил последним. Этот сайт предоставил ссылку на текущий сайт. </p>
		</td>
	</tr>
	<tr>
		<td>
		<p>csHost</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Заголовок узла (например, "www.mysite.com"), который был запрошен.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>scSubStatus</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Код подсостояния ошибки.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>scWin32Status</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Код состояния Windows.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>csBytes</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Количество байт, отправленных из клиента на сервер в рамках запроса.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>scBytes</p>
		</td>
		<td>
		<p>W3CIISLog</p>
		</td>
		<td>
		<p>Количество байт, возвращенных клиенту с сервера в рамках ответа.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>ConfigChangeType </p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Тип изменения (службы Windows, программное обеспечение и т. п.).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>ChangeCategory </p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Категория изменения (изменено, добавлено, удалено).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SoftwareType </p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Тип программного обеспечения (обновление, приложение).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SoftwareName </p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Название программного обеспечения (применимо только к изменениям программного обеспечения).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Издатель </p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Поставщик, опубликовавший программное обеспечение (применимо только к изменениям программного обеспечения).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SvcChangeType </p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Тип изменения, примененного к службе Windows (состояние, тип запуска, путь, учетная запись службы) — распространяется только на изменения служб Windows.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SvcDisplayName </p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Отображаемое имя измененной службы.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SvcName </p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Имя измененной службы.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SvcState </p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Новое (текущее) состояние службы.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SvcPreviousState</p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Предыдущее известное состояние службы (применимо только в случае изменения состояния службы).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SvcStartupType </p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Тип запуска службы.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SvcPreviousStartupType</p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Предыдущий тип запуска службы (применимо только в случае изменения типа запуска службы).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SvcAccount </p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Учетная запись службы.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SvcPreviousAccount</p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Предыдущая учетная запись службы (применимо только в случае изменения учетной записи службы).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SvcPath</p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Путь к исполняемому файлу службы Windows.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SvcPreviousPath</p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Предыдущий путь к исполняемому файлу службы Windows (применимо только в случае изменения этого пути).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>SvcDescription</p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Описание службы.</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Предыдущий </p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Предыдущее состояние данного программного обеспечения (установлено, не установлено, предыдущая версия).</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Текущее значение</p>
		</td>
		<td>
		<p>ConfigurationChange</p>
		</td>
		<td>
		<p>Последнее состояние данного программного обеспечения (установлено, не установлено, текущая версия).</p>
		</td>
	</tr>
</table>

## Записи в блогах — сценарии использования функции поиска
- [Поиск в журналах W3C IIS в Microsoft Azure Operational Insights](http://blogs.msdn.com/b/dmuscett/archive/2014/09/20/w3c-iis-logs-search-in-system-center-advisor-limited-preview.aspx)
- [Мониторинг сбоев архивации SQL с помощью функции поиска и панелей мониторинга в Azure Operational Insights](http://blogs.msdn.com/b/dmuscett/archive/2015/02/21/monitoring-sql-backup-failures-with-azure-operational-insights-search-and-dashboards.aspx)
- [Эквиваленты правил поиска OpInsights пакета управления IIS](http://blogs.msdn.com/b/dmuscett/archive/2014/11/05/iis-mp-event-alerting-rules-s-opinsights-searches-equivalents.aspx)
- [Коллекция полезных запросов поиска Operational Insights](http://blogs.msdn.com/b/dmuscett/archive/2014/10/19/advisor-searches-collection.aspx)

## Другие ресурсы
Стефан Рос (Stefan Roth) написал удобную памятку по поиску. Ознакомьтесь с его [блогом](http://stefanroth.net/2014/11/05/microsoft-azure-operational-insights-search-data-explorer-cheat-sheet/), чтобы получить дополнительные сведения и скачать эту памятку.

<!---HONumber=Sept15_HO3-->