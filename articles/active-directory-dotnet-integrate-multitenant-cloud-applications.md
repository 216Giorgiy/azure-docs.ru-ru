<properties linkid="" urlDisplayName="" pageTitle="" metaKeywords="" description="" metaCanonical="" services="" documentationCenter="" title="Интеграция многопользовательских облачных приложений с помощью Azure Active Directory" authors="" solutions="" manager="" editor="" />

# Интеграция многопользовательских облачных приложений с помощью Azure Active Directory

##<a name="introduction"></a>Введение

Azure Active Directory (Azure AD) — это современная служба на основе интерфейса REST, которая предоставляет возможности для управления идентификацией и доступом в облачных приложениях. Azure AD легко интегрируется с облачными службами, а также с Azure, Microsoft Office 365, Dynamics CRM Online и Windows Intune. Существующие локальные развертывания Active Directory также позволяют использовать все возможности Azure AD. Дополнительные сведения см. на [странице учетных данных][] на сайте [windowsazure.com][].

Данное пошаговое руководство предназначено для разработчиков .NET, которые желают интегрировать мультитенантное приложение с Azure AD. Вы научитесь:

* Разрешение клиентам регистрироваться на ваше приложение с помощью Azure AD
* Включение единого входа (SSO) с помощью Azure AD
* Запрос данных каталога клиента с помощью интерфейса API Azure AD Graph

Сопровождающий пример для этого пошагового руководства можно [загрузить здесь][]. Пример можно выполнять без изменений, однако может понадобиться изменить [назначение порта в Visual Studio][] для использования https. Выполните инструкции по ссылке, но укажите протокол привязки как https в разделе привязок файла ApplicationHost.config. Все фрагменты кода, приведенные на следующих шагах, были взяты из примера.

> [WACOM.NOTE]
> Пример мультитенантного приложения каталогов предоставлен исключительно в целях иллюстрации.  Этот пример (включая классы вспомогательной библиотеки) не должен использоваться в производственной среде.


###Предварительные требования
Для данного пошагового руководства необходимы следующие компоненты разработчика:

* [Visual Studio 2012][]
* [Службы данных WCF Data Services для OData][]

###Оглавление
* [Введение][]
* [Часть 1. Получение кода клиента для доступа к Azure AD][]
* [Часть 2. Разрешение клиентам регистрироваться с помощью Azure AD][]
* [Часть 3. Включение единого входа][]
* [Часть 4. Доступ к Azure AD Graph][]
* [Часть 5. Публикация вашего приложения][]
* [Сводка][]


##<a name="getclientid"></a>Часть 1. Получение кода клиента для доступа к Azure AD
В этом разделе описывается, как получить код клиента и секрет клиента после создания учетной записи панели мониторинга продавца Майкрософт. Код клиента — уникальный идентификатор для вашего приложения, а секрет клиента — соответствующий ключ, который необходим при создании запросов с использованием кода клиента. Оба эти элемента необходимы для интеграции вашего приложения с Azure AD.

###Шаг 1. Создание учетной записи с панелью мониторинга продавца Майкрософт
Для разработки и публикации приложений, которые интегрируются с Azure AD, необходимо зарегистрировать учетную запись [панели мониторинга продавца Майкрософт][]. Затем вам будет предложено [создать профиль учетной записи][] в качестве юридического или физического лица. Этот профиль используется для публикации приложений в Магазине Azure или других магазинах, а также для создания кода и секрета клиента.  

Новые учетные записи переводятся в состояние "Учетная запись ожидает утверждения". Это состояние не препятствует началу разработки - вы по-прежнему можете создавать коды клиентов,а также предварительные списки приложений. Однако список приложений можно предоставлять на утверждения только после утверждения самой учетной записи. Отправленный список приложений будет доступен клиентам в Магазине Azure только после утверждения.

###Шаг 2. Получение кода клиента для вашего приложения
Необходим код и секрет клиента для интеграции приложения с Azure AD. Код клиента — уникальный идентификатор для приложения, который используется в основном для идентификации приложения в целях единого входа, а также для проверки подлинности вызовов Azure AD Graph. Дополнительные сведения о получении кода и секрета клиента см. в разделе [Создание кодов и секретов клиента на панели мониторинга продавца Майкрософт][]. 

> [WACOM.NOTE]
> Ваш код и секрет клиента могут понадобиться на более поздних этапах этого пошагового руководства, поэтому их следует записать.

Чтобы создать код и секрет клиента, необходимо указать следующие свойства в панели мониторинга продавца Майкрософт:

**Домен приложения** – имя узла вашего приложения, например contoso.com. Это свойство не должно содержать какой-либо номер порта. Во время разработки этому свойству должно быть присвоено значение localhost.

**URL-адрес перенаправления для приложения** – URL-адрес перенаправления, на который Azure AD будет отправлять ответ после входа пользователя и авторизации вашего приложения организацией, например: https://contoso.com/. Во время разработки этому свойству должно быть присвоено значение https://localhost:&#60;номер порта&#62;

###Шаг 3. Настройка приложения для использования кода клиента и секрета клиента
На этом этапе требуются код и секрет клиента, которые были созданы во время регистрации на панели мониторинга. Код клиента используется для единого входа, а код клиента вместе с секретом клиента будут использоваться позже для получения маркера доступа для вызова интерфейса API Azure AD Graph.  

Пример приложения предварительно настроен для использования Azure AD и загружает код и секрет клиента из конфигурации. В файле **Web.config** примера приложения внесите следующие изменения: 

1. В узле **appSettings** замените значения clientId и SymmetricKey на ваш код клиента, секрет клиента и домен приложения: 

		<appSettings>
    		<add key="clientId" value="(Your Client ID value)"/>
	    	<add key="SymmetricKey" value="(Your Client Secret value)"/>
			<add key="AppHostname" value="(Your App Domain)"/>
		</appSettings>

2. В узле **audienceUris** раздела **system.identityModel** вставьте свой код клиента после записи spn:

		<system.identityModel>
    		<audienceUris>
            	<add value="spn:(Your Client ID value)" />
    		</audienceUris>


##<a name="enablesignup"></a>Часть 2. Разрешение клиентам регистрироваться с помощью Azure AD

В этом разделе описывается, как разрешить клиентам регистрироваться на ваше приложение с помощью Azure AD. Прежде чем клиент может использовать приложение, интегрированное с Azure AD, администратор клиента должен авторизовать это приложение. Процесс авторизации начинается с запроса согласия пользователя из приложения в Azure, что приведет к созданию ответа, который должен быть обработан приложением. В следующих действиях описано, как создать запрос согласия пользователя и как обработать соответствующий ответ.

В действиях, описанных в этом разделе, используются вспомогательные классы из примера приложения. Эти классы содержатся в библиотеке *Microsoft.IdentityModel.WAAD.Preview* примера, они позволяют уделить внимание коду приложения, а не особенностям удостоверений и протоколов.

###Шаг 1. Запрос согласия для вашего приложения
В следующем примере взаимодействия показан процесс запроса согласия пользователя для вашего приложения:

1. Клиент щелкает ссылку "подписаться с помощью Azure AD" на веб-странице вашего приложения.
2.	Выполняется перенаправление клиента на страницу авторизации Azure AD с вложенными в запрос сведениями из вашего приложения.
3.	Клиент предоставляет или запрещает согласие для приложения.
4.	Azure AD перенаправляет клиента на указанный URL-адрес перенаправления в вашем приложении. Этот URL-адрес указан при создании кода и секрета клиента на панели мониторинга продавца Майкрософт.  Запрос перенаправления указывает результат запроса согласия, включая сведения о клиенте, если согласие было дано.

Чтобы создать запрос перенаправления на приведенном выше шаге 2, необходимо добавить параметры строки запроса к следующему URL-адресу страницы авторизации Azure AD: *http://activedirectory.windowsazure.com/Consent/AuthorizeApplication.aspx*

Параметры строки запроса описаны ниже.

**ApplicationID** (является обязательным): значение **ClientID**, полученное на панели мониторинга продавца.

**RequestedPermissions** (не является обязательным): разрешения, которые должны быть предоставлены приложению клиентом.
Во время разработки эти разрешения используются для тестирования неопубликованных приложений. Для опубликованных приложений этот параметр будет игнорироваться. Вместо него будут использоваться запрошенные разрешения из вашего списка приложений. Дополнительные сведения об этом списке см. в части 5.
Существуют три возможных значения для этого параметра:

**DirectoryReader**: предоставляет разрешение на чтение данных каталога, таких как учетные записи пользователей, группы и сведения об организации. Включает единый вход.

**UserAccountAdministrator**: предоставляет разрешение на чтение и запись данных каталога, таких как пользователи, группы и сведения об организации. Включает единый вход.

**Нет**: включает единый вход, но отключает доступ к данным каталога.

Значением по умолчанию является None, если параметр не указан или указан неверно.

Ниже приведен пример допустимого URL-адреса запроса согласия.
*https://activedirectory.windowsazure.com/Consent/AuthorizeApplication.aspx?ApplicationId=33E48BD5-1C3E-4862-BA79-1C0D2B51FB26&RequestedPermissions=DirectoryReader*

В примере приложения ссылка "Зарегистрироваться" содержит URL-адрес запроса согласия, как показано ниже.

![login][login]


> [WACOM.NOTE]
> При тестировании неопубликованного приложения необходимо дать согласие так же, как это будут делать ваши клиенты. Тем не менее, страница авторизации для неопубликованного приложения отличается от страницы авторизации для опубликованного приложения. Опубликованное приложение отображает имя приложения, эмблему и сведения об издателе, а неопубликованное приложение эти сведения не предоставляет.

###Шаг 2. Обработка ответа согласия
После предоставления клиентом согласия или отказа для вашего приложения Azure AD отправляет запрос на URL-адрес перенаправления в вашем приложении. Этот ответ содержит следующие параметры строки запроса:

**TenantId**: уникальный идентификатор GUID для клиента Azure AD, который авторизовал ваше приложение. Этот параметр будет указан, только если клиент авторизовал ваше приложение.

**Consent**: значение будет указано как Granted, если приложение авторизовано, или Denied, если запрос был отклонен.

Ниже приведен пример допустимого ответа на запрос согласия, в котором указано, что приложение было авторизовано:
*https://app.litware.com/redirect.aspx&TenantId=7F3CE253-66DB-4AEF-980A-D8312D76FDC2&Consent=Granted*

Ваше приложение должно обслуживать контекст, чтобы запрос, отправленный на страницу авторизации Azure AD, был привязан к ответу (и должно отклонять любые ответы, не имеющие соответствующего запроса).

<div class="dev-callout"><strong>Примечание.</strong><p>После предоставления согласия может пройти некоторое время, прежде чем Azure AD начнет предоставлять возможность единого входа и доступ к Graph. Первый пользователь организации, который будет подписываться на ваше приложение, может видеть ошибки входа, пока не будет завершена подготовка.</p></div>

После того как клиент предоставил свое согласие для вашего приложения, важно сопоставить и сохранить только что созданного клиента в вашем приложении с параметром TenantId, возвращенным в ответе согласия. Пример приложения содержит *HttpModule* в пространстве имен *Microsoft.IdentityModel.WAAD.Preview.Consent*, который автоматически записывает TenantId в "хранилище данных" клиент/TenantId для всех успешных ответов согласия.  Соответствующий код приведен ниже, а запись TenantId в "хранилище данных" клиент/TenantId выполняется методом *TrustedIssuers.Add*:

	private void Application_BeginRequest(Object source,
             EventArgs e)
    {
    	HttpApplication application = (HttpApplication)source;
        HttpRequest req = application.Context.Request;             

        if((!string.IsNullOrEmpty(req.QueryString["TenantId"]) && (!string.IsNullOrEmpty(req.QueryString["Consent"]))))
        { 
        	if(req.QueryString["Consent"].Equals("Granted",StringComparison.InvariantCultureIgnoreCase))
            {
            	// For this sample we store the consenting tenants in
                // an XML file. We strongly recommend that you change
                // this to use your DataStore
                TrustedIssuers.Add(req.QueryString["TenantId"];	
            }
        }            
    }

Перед тестированием кода запроса/ответа согласия в вашем приложении необходимо получить клиента каталога Azure AD.

<h3>Шаг 3. Получение клиента Azure AD для тестирования приложения</h3>
Чтобы протестировать возможность интеграции вашего приложения с Azure AD, потребуется клиент Azure AD. Можно использовать уже имеющегося клиента, который ранее использовался для тестирования другого приложения. Рекомендуется использовать по крайней мере двух клиентов, чтобы проверить возможность тестирования и использования вашего приложения несколькими клиентами. Не рекомендуется использовать в этих целях клиента из производственной среды. [Получите клиента Azure AD][].

После получения клиента Azure AD можно собрать и запустить приложение, нажав клавишу **F5**. Кроме того, можно попытаться подписаться на приложение с помощью нового клиента. 

<div class="dev-callout"><strong>Примечание.</strong><p>При подписке клиентов на новый клиент Azure AD полное предоставление этого нового клиента может занять некоторое время. Пользователи могут видеть ошибки на странице согласия, пока подготовка не будет полностью завершена.</p></div>

<h2><a name="enablesso"></a>Часть 3. Включение единого входа</h2>

В этом разделе показано, как включить единый вход. Процесс начинается с создания запроса на вход в Azure AD, который проверяет подлинность пользователя для вашего приложения, затем проверяет в ответе входа, что пользователь принадлежит клиенту, который был авторизован приложением. Запрос на вход требует код клиента с панели мониторинга продавца и код клиента у организации пользователя.

Запрос входа относится к клиенту каталога и должен включать TenantID.  TenantID можно определить по имени домена клиента каталога Azure AD. Существует два базовых способа получения этого имени домена от выполняющего вход пользователя:

* Если URL-адрес приложения *https://contoso.myapp.com* или *https://myapp.com/contoso.com*, *contoso* и *contoso.com* представляют имя домена Azure AD, а *myapp.com* представляет URL-адрес приложения. 
* Приложение может запросить у пользователя его адрес электронной почты или имя домена Azure AD. Этот подход используется в примере приложения, где пользователь должен ввести имя домена Azure AD, как показано ниже:

![login][login]

<h3>Шаг 1. Поиск идентификатора клиента</h3>
Используя имя домена Azure AD, предоставленного клиентом, можно найти код клиента, выполнив анализ метаданных федерации Azure AD. В примере приложения этот процесс обрабатывается методом *Domain2TenantId* класса *Microsoft.IdentityModel.WAAD.Preview.TenantUtils.Globals*.

Для демонстрации этого процесса на следующих этапах используется имя домена contoso.com.

1.	Получите файл **FederationMetadata.xml** для клиента Azure AD. Например:  
*https://accounts.accesscontrol.windows.net/contoso.com/FederationMetadata/2007-06/FederationMetadata.xml*
2.	В файле **FederationMetadata.xml** найдите запись **Entity Descriptor**. Идентификатор клиента входит в состав свойства **entityID**, которое следует за адресом https://sts.windows.net, как показано ниже.

		 <EntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" entityID="https://sts.windows.net/a7456b11-6fe2-4e5b-bc83-67508c201e4b/" ID="_cba45203-f8f4-4fc3-a3bb-0b136a2bafa5"> 
В этом случае значение TenantID равно **a7456b11-6fe2-4e5b-bc83-67508c201e4b**.
3.	В "хранилище данных" клиент/TenantId вашего приложения следует сохранить домен и соответствующий TenantID.  Эти два значения могут использоваться совместно для будущих запросов на вход и устраняют необходимость получать каждый раз файл **FederationMetadata.xml**. Пример приложения не содержит этой оптимизации.

<h3>Шаг 2. Создание запроса на вход</h3>
При входе клиента в ваше приложение, например путем нажатия кнопки "Вход", должен быть создан запрос на вход путем использования кода клиента данного пользователя и кода клиента приложения. В примере приложения этот запрос создается методом *GenerateSignInMessage* класса *Microsoft.IdentityModel.WAAD.Preview.WebSSO.URLUtils*. Этот метод проверяет, представляет ли TenantID пользователя организацию, которая авторизовала ваше приложение, а также создает целевой URL-адрес для кнопки входа, как показано ниже.

![login][login]

Нажатие этой кнопки приведет к переходу браузера пользователя на страницу входа в Azure AD. После выполнения входа Azure AD вернет приложению ответ на вход.

###Шаг 3. Проверка издателя входящего токена в ответе на вход

Когда заказчик выполнит вход в ваше приложение, вам необходимо проверить, что его клиент авторизовал ваше приложение. Ответ на вход содержит маркер, а маркер содержит свойства и заявки, которые могут быть проверены вашим приложением.

Для выполнения этой проверки необходимо получить TenantID из свойства Issuer в маркере и обеспечить, что он существует в "хранилище данных" клиент/TenantId. В примере приложения эта проверка достигается путем создания настраиваемого класса обработчика маркеров, который расширяет *Saml2SecurityTokenHandler* Windows Identity Foundation. Настраиваемый обработчик маркера проверяет входящий маркер безопасности и предоставляет приложению доступ к заявкам и свойствам, чтобы можно было проверить TenantID. Ниже приведен фрагмент кода для этого класса.

В примере приложения, исходный код можно найти в пространстве имен *Microsoft.IdentityModel.WAAD.Preview.WebSSO*. Обработчик маркеров также использует метод Contains класса *Microsoft.IdentityModel.WAAD.Preview.WebSSO.TrustedIssuers*, который проверяет, что TenantID сохранен в "хранилище данных" клиент/TenantId.

	/// <summary>
    /// Extends the out of the box SAML2 token handler by ensuring
    /// that incoming tokens have been issued by registered tenants 
    /// </summary>
    public class ConfigurationBasedSaml2SecurityTokenHandler : Saml2SecurityTokenHandler
    {
        public override ReadOnlyCollection<System.Security.Claims.ClaimsIdentity> ValidateToken(SecurityToken token)
        {
            ReadOnlyCollection<System.Security.Claims.ClaimsIdentity> aa = base.ValidateToken(token);
            Saml2SecurityToken ss = token as Saml2SecurityToken;
            string tenant = ss.Assertion.Issuer.Value.Split('/')[3];
            if (!TrustedIssuers.Contains(tenant))
            {
                throw new SecurityTokenValidationException(string.Format("The tenant {0} is not registered with the application", tenant));
            }
            return aa;
        }
    }

После проверки маркера пользователь выполняет вход в приложение. Запустите приложение и попытайтесь выполнить вход с помощью учетной записи Azure AD в согласованном клиенте, который был создан ранее.

<h2><a name="accessgraph"></a>Часть 4. Доступ к Azure AD Graph</h2>

В этом разделе описывается, как получить маркер доступа и вызывать интерфейс API Azure AD Graph для доступа к данным каталога клиента. Например, маркер, полученный во время входа, содержит такие данные пользователя, как имя и адрес электронной почты, а вашему приложению могут понадобиться такие сведения, как членство в группе или имя руководителя пользователя. Эти сведения могут быть получены из каталога клиента с помощью интерфейса Graph API. Дополнительные сведения об интерфейсе Graph API см. в [этом разделе][].

Прежде чем приложение может вызвать Azure AD Graph, оно должно самостоятельно проверить свою подлинность и получить маркер доступа. Маркеры доступа получаются путем проверки подлинности вашего приложения с использованием соответствующего кода и секрета клиента. В следующих действиях освещаются следующие темы:

1.	Использование созданного класса прокси для вызова Azure AD Graph
2.	Получение маркера доступа с использованием библиотеки проверки подлинности Azure (AAL) 
3.	Вызов Azure AD Graph для получения списка пользователей клиента

<div class="dev-callout"><strong>Примечание.</strong><p>Вспомогательная библиотека примера приложения Microsoft.IdentityModel.WAAD.Preview уже содержит автоматически созданный класс прокси (созданный путем добавления ссылки на службу в https://graph.windows.net/имя-вашего-домена под именем GraphService). Приложение будет использовать этот класс прокси для вызова службы Azure AD Graph.</p></div>

<h3>Шаг 1. Использование класса прокси для вызова Azure AD Graph</h3>
На этом этапе мы будем использовать пример приложения для демонстрация следующих аспектов:

1.	Создание конечной точки AD Azure Graph, имеющей отношение к клиенту
2.	Использование конечной точки для создания экземпляра с целью вызова Graph
3.	Добавление в запрос заголовка авторизации и получение маркера  

В примере приложения эти вызовы интерфейса API обрабатываются методом GraphInterface класса *Microsoft.IdentityModel.WAAD.Preview.Graph.GraphInterface*, как показано в следующем коде.

	public GraphInterface()
    {
    	// 1a: When the customer was signed in, we get a security token 
        // that contains a tenant id. Extract that here
        TenantDomainName = ClaimsPrincipal.Current.FindFirst("http://schemas.microsoft.com/ws/2012/10/identity/claims/tenantid").Value;

        // 1b: We generate a URL (https://graph.windows.net/<CustomerDomainName>)
        // to access the Azure AD Graph API endpoint for the tenant 
        connectionUri = new Uri(string.Format(@"https://{0}/{1}", TenantUtils.Globals.endpoint, TenantDomainName));

        // 2: create an instance of the AzureAD Service proxy with the connection URL
        dataService = new DirectoryDataService(connectionUri);

        // This flags ignores the resource not found exception
        // If AzureAD Service throws this exception, it returns null
        dataService.IgnoreResourceNotFoundException = true;
        dataService.MergeOption = MergeOption.OverwriteChanges;
        dataService.AddAndUpdateResponsePreference = DataServiceResponsePreference.IncludeContent;

        // 3: This adds the default required headers to each request
        AddHeaders(GetAuthorizationHeader());
    }

<h3>Шаг 2. Получение маркера доступа с использованием библиотеки проверки подлинности Azure</h3>
Пример приложения использует библиотеку проверки подлинности Azure (AAL) для получения маркеров с целью получения доступа к интерфейсу Graph API.  Процесс получения маркера управляется методом *GetAuthorizationHeader* класса *Microsoft.IdentityModel.WAAD.Preview.Graph.GraphInterface*, как показано ниже.  

<div class="dev-callout"><strong>Примечание.</strong><p>Библиотека AAL доступна в качестве пакета NuGet и может быть установлена в Visual Studio.</p></div>

	/// <summary>
    /// Method to get the Oauth2 Authorization header from ACS
    /// </summary>
    /// <returns>AOauth2 Authorization header</returns>
    private string GetAuthorizationHeader()
    {
        // AAL values
        string fullTenantName = TenantUtils.Globals.StsUrl + TenantDomainName;
        string serviceRealm = string.Format("{0}/{1}@{2}", TenantUtils.Globals.GraphServicePrincipalId, TenantUtils.Globals.GraphServiceHost, TenantDomainName);
        string issuingResource = string.Format("{0}@{1}", Globals.ClientId, TenantDomainName);
        string clientResource = string.Format("{0}/{1}@{2}", Globals.ClientId, Globals.AppHostname, TenantDomainName);

        string authzHeader = null;
        AuthenticationContext _authContext = new AuthenticationContext(fullTenantName);

        try
        {
            ClientCredential credential = new ClientCredential(issuingResource, clientResource, Globals.ServicePrincipalKey);
            AssertionCredential _assertionCredential = _authContext.AcquireToken(serviceRealm, credential);
            authzHeader = _assertionCredential.CreateAuthorizationHeader();
        }
        catch (Exception ex)
        {
            AALException aex = ex as AALException;
            string a = aex.InnerException.Message;
        }

        return authzHeader;
    }

Следующие сведения используются для получения маркера доступа, как было показано в приведенном выше коде.

1.	Сведения о приложении (ClientID, ServicePrincipalKey и AppHostname)
2.	Целевые сведения, которые относятся к Graph, и ссылаются на ServiceRealm выше
3.	Имя TenantDomainName, которое было получено ранее

<h3>Шаг 3. Вызов Azure AD Graph для получения списка пользователей</h3>
Следующий метод класса *Microsoft.IdentityModel.WAAD.Preview.Graph.GraphInterface* получает список всех пользователей вашего клиента с использованием ранее созданного прокси *DataService*.

	public List<User> GetUsers()
    {
        // Add the page size using top
        var users = dataService.Users.AddQueryOption("$top", 20);

        // Execute the Query
        var userQuery = users.Execute();

        // Get the return users list
        return userQuery.ToList();
    }

Этот метод вызывается из файла **HomeController.cs** для отображения списка пользователей на вкладке "Пользователи" веб-приложения.

<h2><a name="publish"></a>Часть 5. Публикация вашего приложения</h2>

После тщательного тестирования приложения можно создать список приложения и опубликовать этот список приложения в Магазине Azure. Эти действия выполняются на панели мониторинга продавца Майкрософт.  

<div class="dev-callout"><strong>Примечание.</strong><p>Приложение отвечает за управление выставлением счетов и отношением с клиентами. В Магазине Azure только приводятся ссылки на веб-сайт приложения и соответствующие сведения о нем.</p></div>

<h3>Шаг 1. Создание манифеста приложения и списка приложений</h3>

Перед созданием приложения необходимо создать новый код и секрет клиента для рабочей версии вашего приложения. В первой части данного пошагового руководства вы создали код и секрет клиента, предназначенные для тестовой версии приложения. Повторите эти шаги и настройте свое приложение для использования новых значений, что обеспечит определение рабочего домена приложения и URL-адрес перенаправления.

Далее необходимо создать манифест приложения, в котором указаны разрешения, согласие на предоставление которых будет запрашивать у клиента ваше приложение. Этот манифест написан в XML-формате в XSD-файле. Манифест должен быть передан как часть создаваемого списка приложений. 

Существуют три различных уровня, как описано в части 1 этого пошагового руководства:

**DirectoryReader**: предоставляет разрешение на чтение данных каталога, таких как учетные записи пользователей, группы и сведения об организации. Включает единый вход.

**UserAccountAdministrator**: предоставляет разрешение на чтение и запись данных каталога, таких как пользователи, группы и сведения об организации. Включает единый вход.

**Нет**: включает единый вход, но отключает доступ к данным каталога.

Ниже приведены два примера манифеста приложения. В первом демонстрируются разрешения на приложение, поддерживающее только единый вход, во втором демонстрируются разрешения на приложение, доступное только для чтение.

	<?xml version="1.0" encoding="utf-16"?>
	<AppRequiredPermissions>
  	  <AppPermissionRequests Policy="AppOnly">
        <AppPermissionRequest Right="None" Scope="http://directory" />
      </AppPermissionRequests>
    </AppRequiredPermissions>


	<?xml version="1.0" encoding="utf-16"?>
	<AppRequiredPermissions>
      <AppPermissionRequests Policy="AppOnly">
        <AppPermissionRequest Right="Directory Reader" Scope="http://directory">
          <Reason culture="en-us" value="Needs to read the app"/>
        </AppPermissionRequest>
      </AppPermissionRequests>
    </AppRequiredPermissions>

Атрибут *Policy* в приведенных выше примерах описывает тип запрашиваемых разрешений приложения. В настоящее время поддерживается только атрибут AppOnly. Этот тип разрешения указывает, что приложение только получает доступ к каталогу. 

Дополнительный элемент *Reason* позволяет указывать (на нескольких языках) объяснение запрашиваемого уровня разрешений. Этот текст отображается на странице согласия для оказания помощи пользователям, утверждающим или отклоняющим ваше приложение.

Используя новый идентификатор клиента и манифест приложения, можно создать список приложений, следуя инструкциям, приведенным в разделе ["Добавить приложения" на панели мониторинга продавца Майкрософт][]. При создании списка приложений не забудьте выбрать тип приложения Azure AD. После завершения создания списка приложений нажмите кнопку "Отправить" для публикации вашего приложения в Магазине Azure. Необходимо подождать, пока ваше приложение будет утверждено до завершения публикации.

<div class="dev-callout"><strong>Примечание.</strong><p>Если появляется запрос о добавлении сведений о налогах и выплатах, можно пропустить этот шаг, так как вы продаете свое приложение непосредственно клиенту, а не через корпорацию Майкрософт.</p></div>

<h3>Шаг 2. Заключительный этап тестирования и предоставление общего доступа к приложению</h3>
После утверждения списка приложений необходимо снова проверить свое приложение от начала до конца. Например, убедитесь, что приложение было обновлено с использованием рабочего кода и секрета клиента.  Пройдитесь в последний раз по контрольному списку тестирования, убедившись, что на странице согласия теперь отображаются сведения, включенные в список приложений.

<h2><a name="summary"></a>Сводка</h2>
В этом пошаговом руководстве вы узнали, как интегрировать мультитенатное приложение с Azure AD. Процесс состоял из трех этапов:

* Разрешение клиентам регистрироваться на ваше приложение с помощью Azure AD
* Включение единого входа (SSO) с помощью Azure AD
* Запрос данных каталога клиента с помощью интерфейса API Azure AD Graph

Интеграция с Azure AD позволяет пользователям зарегистрироваться и войти в приложение, используя уже имеющуюся систему управления удостоверениями, что снижает или устраняет потребность в выполнении отдельных задач по управлению удостоверениями в вашем приложении. Эти функциональные возможности предоставляют вашим клиентам большее удобство при работе с приложением и дает больше времени на выполнение задач управления.


[Введение]: #introduction
[Часть 1. Получение кода клиента для доступа к Azure AD]: #getclientid
[Часть 2. Разрешение клиентам регистрироваться с помощью Azure AD]: #enablesignup
[Часть 3. Включение единого входа]: #enablesso
[Часть 4. Доступ к Azure AD Graph]: #accessgraph
[Часть 5. Публикация вашего приложения]: #publish
[Сводка]: #summary
[Visual Studio 2012]: http://www.microsoft.com/visualstudio/eng/downloads
[Пакет AAL x86 NuGet]: http://g.microsoftonline.com/1AX00en/124
[Пакет AAL x64 NuGet]: http://g.microsoftonline.com/1AX00en/125
[Средство доступа и удостоверений Visual Studio]: http://g.microsoftonline.com/1AX00en/126
[Windows Identity Foundation 3.5]: http://g.microsoftonline.com/1AX00en/127
[Службы данных WCF Data Services для OData]: http://www.microsoft.com/download/en/details.aspx?id=29306
[странице учетных данных]: http://www.windowsazure.com/ru-ru/home/features/identity/

[загрузить здесь]: http://go.microsoft.com/fwlink/?LinkId=271213
[назначение порта в Visual Studio]: http://msdn.microsoft.com/ru-ru/library/ms178109(v=vs.100).aspx
[панели мониторинга продавца Майкрософт]: https://sellerdashboard.microsoft.com/
[создать профиль учетной записи]: http://msdn.microsoft.com/ru-ru/library/jj552460.aspx
[Создание кодов и секретов клиента на панели мониторинга продавца Майкрософт]: http://msdn.microsoft.com/ru-ru/library/jj552461.aspx
[Получите клиента Azure AD]: http://g.microsoftonline.com/0AX00en/5
[этом разделе]: http://msdn.microsoft.com/ru-ru/library/windowsazure/hh974476.aspx
["Добавить приложения" на панели мониторинга продавца Майкрософт]: http://msdn.microsoft.com/ru-ru/library/jj552465.aspx
[login]: ./media/active-directory-dotnet-integrate-multitent-cloud-applications/login.png

