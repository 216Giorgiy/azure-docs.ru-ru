<properties linkid="develop-python-service-bus-queues" urlDisplayName="Очереди Service Bus" pageTitle="Использование очередей Service Bus (Python) — Azure" metaKeywords="очереди Service Bus Azure, очереди Azure, обмен сообщениями Azure, очереди Azure Python" description="Сведения об использовании очередей Service Bus в Azure. Примеры кода написаны на Python." metaCanonical="" services="service-bus" documentationCenter="Python" title="Использование очередей Service Bus" authors="" solutions="" manager="" editor="" />




# Использование очередей Service Bus
В этом руководстве показано, как использовать очереди Service Bus. Примеры
написаны на Python и используют модуль Python для Azure. Здесь описаны
такие сценарии, как **создание очередей, отправка и получение сообщений**, а также
**удаление очередей**. Дополнительные сведения об очередях см. в разделе [Дальнейшие действия][].

## Оглавление

-   [Что такое очереди Service Bus?][]
-   [Создание пространства имен службы][]
-   [Получение учетных данных управления по умолчанию для пространства имен][]
-   [Практическое руководство. Создание очереди][]
-   [Практическое руководство. Отправка сообщений в очередь][]
-   [Практическое руководство. Получение сообщений из очереди][]
-   [Практическое руководство. Обработка сбоев приложения и нечитаемых сообщений][]
-   [Следующие шаги][]

[WACOM.INCLUDE [howto-service-bus-queues](../includes/howto-service-bus-queues.md)]

**Примечание**. Если нужно установить клиентские библиотеки или Python, см. [руководство по установке Python](../python-how-to-install/).


## <a name="create-queue"> </a>Создание очереди

Объект **ServiceBusService** позволяет работать с очередями. Добавьте следующий код в начало любого файла Python, из которого планируется получать доступ к Service Bus Azure программным способом:

	from azure.servicebus import *

Следующий код создает объект **ServiceBusService**. Замените атрибуты mynamespace, mykey и myissuer на фактические значения пространства имен, ключа и издателя.

	bus_service = ServiceBusService(service_namespace='mynamespace', account_key='mykey', issuer='myissuer')
	
	bus_service.create_queue('taskqueue')

**create_queue** также поддерживает дополнительные параметры, позволяющие
переопределить настройки очереди по умолчанию, такие как срок жизни сообщения или
максимальный размер очереди. В следующем примере показано, как установить максимальный размер очереди 5 ГБ и срок жизни 1 минуту.

	queue_options = Queue()
	queue_options.max_size_in_megabytes = '5120'
	queue_options.default_message_time_to_live = 'PT1M'

	bus_service.create_queue('taskqueue', queue_options)

## <a name="send-messages"> </a>Отправка сообщений в очередь

Чтобы отправить сообщение в очередь Service Bus, приложение вызывает
**send\_queue\_message** объекта **ServiceBusService**.

В следующем примере показано, как отправить тестовое сообщение в очередь с именем
*taskqueue using* **send\_queue\_message**:

	msg = Message('Test Message')
	bus_service.send_queue_message('taskqueue', msg)

Очереди Service Bus поддерживают максимальный размер сообщения 256 КБ (максимальный размер заголовка, который содержит стандартные и настраиваемые свойства приложения, составляет 64 КБ). Ограничения на количество сообщений в очереди нет, но есть максимальный общий размер сообщений, содержащихся в очереди. Этот размер очереди, определяемый в момент ее создания, не должен превышать 5 ГБ.

## <a name="receive-messages"> </a>Получение сообщений из очереди

Сообщения извлекаются из очереди с помощью метода **receive\_queue\_message**
объекта **ServiceBusService**:

	msg = bus_service.receive_queue_message('taskqueue')
	print(msg.body)

Прочитанные
сообщения удаляются из очереди. Но можно прочитать (извлечь)
сообщение и заблокировать его удаление из очереди, задав для необязательного параметра
**peek\_lock** значение **True**.

Поведение по умолчанию — чтение и удаление сообщения как часть операции получения — является простейшей моделью, оптимальной для сценариев, в которых приложение может не обрабатывать сообщение в случае сбоя. Чтобы разобраться, рассмотрим сценарий, в котором приложение-получатель выдает запрос на получение, после чего происходит сбой этого приложения еще до обработки сообщения. Поскольку Service Bus помечает сообщение как использованное, то когда после своего перезапуска приложение снова начнет обрабатывать сообщения, оно пропустит сообщение, использованное до сбоя.


Если параметр **peek\_lock** имеет значение **True**, получение становится
операцией из двух этапов, что позволяет поддерживать приложения,
не устойчивые к пропуску сообщений. Получив запрос, Service Bus находит следующее сообщение, блокирует его, чтобы предотвратить его получение другими получателями, и возвращает его приложению.
Когда приложение завершает обработку сообщения (или сохраняет его для будущей
обработки), шина Service Bus завершает второй этап процесса получения,
вызывая метод **delete** объекта **Message**. Метод **delete** помечает сообщение как
использованное и удаляет его из очереди.

	msg = bus_service.receive_queue_message('taskqueue', peek_lock=True)
	print(msg.body)

	msg.delete()

## <a name="handle-crashes"> </a>Обработка сбоев приложения и нечитаемых сообщений

Service Bus предоставляет функции, помогающие корректно выполнить восстановление после ошибок в приложении или трудностей, возникших при обработке сообщения. Если
приложение-получатель по каким-либо причинам не может обработать сообщение,
то оно может вызвать метод **unlock**
объекта **Message**. После этого Service Bus разблокирует сообщение в очереди и сделает его доступным для приема тем же или другим приложением-пользователем.

Кроме того, с сообщением, заблокированным в очереди, связано время ожидания. Если приложение не сможет обработать сообщение в течение времени ожидания (например, при сбое приложения), Service Bus разблокирует сообщение автоматически и сделает его доступным для приема.

Если сбой приложения происходит после обработки сообщения, но перед вызовом
метода **delete**, это сообщение будет повторно доставлено в приложение
после его перезапуска. Часто этот подход называют
**обработать хотя бы один раз**, т. е. каждое сообщение будет обрабатываться по крайней мере один раз, но в некоторых случаях это же сообщение может быть доставлено повторно. Если повторная обработка недопустима, разработчики приложения должны предусмотреть дополнительную логику для обработки повторной доставки сообщений. Часто это достигается с помощью
свойства **MessageId** сообщения, которое остается постоянным для различных попыток доставки.

## <a name="next-steps"> </a>Дальнейшие действия

Вы узнали основные сведения об очередях Service Bus.
Для получения дополнительных сведений используйте следующие далее ссылки.

-   См. справочник MSDN: [Очереди, разделы и подписки][].

  [Следующие шаги]: #next-steps
  [Что такое очереди Service Bus?]: #what-are-service-bus-queues
  [Создание пространства имен службы]: #create-a-service-namespace
  [Получение учетных данных управления по умолчанию для пространства имен]: #obtain-default-credentials
  [Практическое руководство. Создание очереди]: #create-queue
  [Практическое руководство. Отправка сообщений в очередь]: #send-messages
  [Практическое руководство. Получение сообщений из очереди]: #receive-messages
  [Практическое руководство. Обработка сбоев приложения и нечитаемых сообщений]: #handle-crashes
  [Основные понятия очереди]: ../../../DevCenter/dotNet/Media/sb-queues-08.png
  [Портал управления Azure]: http://manage.windowsazure.com
  
  
  
  
  
  [Очереди, разделы и подписки.]: http://msdn.microsoft.com/ru-ru/library/windowsazure/hh367516.aspx

