<properties
   pageTitle="Руководство по секционированию данных | Microsoft Azure"
   description="Руководство по способам разделения секций для реализации отдельного управления и доступа."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="masimms"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="03/26/2016"
   ms.author="masashin"/>

# Руководство по секционированию данных

![](media/best-practices-data-partitioning/pnp-logo.png)

## Обзор

Во многих крупномасштабных решениях данные разделяются на особые секции, которыми можно управлять и пользоваться отдельно. Следует тщательно выбирать стратегию секционирования, чтобы максимально увеличить преимущества от ее использования и свести к минимуму отрицательные эффекты. Секционирование поможет улучшить масштабируемость, уменьшить количество конфликтов и оптимизировать производительность. Дополнительное преимущество секционирования состоит в том, что оно также может предоставить механизм для разделения данных по шаблону использования. Например, можно архивировать старые менее активные (холодные) данные, чтобы снизить стоимость хранилища данных.

## Зачем секционировать данные?

Большинство облачных приложений и служб хранят и извлекают данные в рамках своих операций. Структура хранилищ данных, которыми пользуется приложение, может значительно влиять на производительность, пропускную способность и масштабируемость системы. Одним из способов, которые обычно применяются в крупномасштабных системах, является разделение данных на отдельные секции.

> Термин _секционирование_, используемый в этом руководстве, относится к процессу физического разделения данных на отдельные хранилища. Это не то же самое, что секционирование таблицы сервера SQL, которое представляет собой совсем другую концепцию.

Секционирование данных обеспечивает множество преимуществ. Например, его можно применять в следующих целях.

- **Повышение масштабируемости**. Вертикальное масштабирование отдельной базы данных рано или поздно столкнется с физическими ограничениями оборудования. При разделении данных на несколько секций, каждая из которых размещается на отдельном сервере, можно практически неограниченно масштабировать систему.
- **Повышение производительности**. В каждой секции осуществляется доступ к данным меньшего объема. При условии, что данные секционированы подходящим образом, секционирование может повысить эффективность системы. Операции, которые задействуют несколько секций, могут выполняться параллельно. Каждая секция может находиться рядом с приложением, которое ее использует, для минимизации задержки в сети.
- **Повышение доступности**. Распределение данных по нескольким серверам позволяет избежать наличия единственной точки отказа. В случае сбоя или запланированного обслуживания сервера недоступны только данные в этой секции. Операции в других секциях можно продолжать. Увеличение числа секций уменьшает относительное влияние сбоя на одном сервере за счет снижения доли данных, которые будут недоступны. Репликация каждой секции может дополнительно уменьшить вероятность влияния сбоя одной секции на операции. Такой подход также позволяет отделить критически важные данные, для которых необходима постоянная и высокая доступность, от данных низкой значимости (например файлов журнала), требования к доступности которых приведены ниже.
- **Усиление безопасности**. В зависимости от характера данных и метода их секционирования может существовать возможность размещения конфиденциальных и неконфиденциальных данных в разных секциях и, следовательно, на разных серверах или в разных хранилищах. При этом для конфиденциальных данных можно специально оптимизировать безопасность.
- **Обеспечение операционной гибкости**. Секционирование предлагает множество возможностей для операций тонкой настройки, максимально повышая эффективность администрирования и сводя затраты к минимуму. Некоторые примеры определяют разные стратегии управления, мониторинга, резервного копирования и восстановления, а также других административных задач в зависимости от степени важности данных в каждой секции.
- **Сопоставление хранилища данных с шаблоном использования**. Секционирование позволяет развернуть любую секцию в хранилище данных любого типа в зависимости от стоимости и встроенных функций, которые предоставляет хранилище данных. Например, двоичные данные больших объемов могут храниться в хранилище больших двоичных объектов, а более структурированные данные можно хранить в базе данных документов. Дополнительные сведения см. в разделе [Построение решения Polyglot] руководства по шаблонам и практическим рекомендациям [Доступ к данным для масштабируемых решений: с помощью SQL, NoSQL и Polyglot Persistence] на веб-сайте Майкрософт.

В некоторых системах не реализованы секции, так как считается, что они связаны с затратами, а не дополнительными преимуществами. Вот наиболее распространенные причины такого мнения.

- Многие системы хранения данных не поддерживают соединения по секциям, поэтому поддержка целостности данных в секционированных системах может быть затруднена. Часто возникает необходимость реализовать соединения и проверки целостности в коде приложения (на уровне секционирования), что может привести к увеличению числа вводов-выводов и сложности приложения.
- Обслуживание секций не всегда является простой задачей. В системе, где данные энергозависимы, может потребоваться периодически балансировать секции, чтобы снизить число конфликтов и горячих зон.
- Некоторые стандартные средства не работают автоматически с секционированными данными.

## Проектирование секций

Данные могут быть секционированы по-разному: вертикально, горизонтально или функционально. Выбор стратегии зависит от причины секционирования данных, а также требований приложений и служб, которые будут использовать эти данные.

> [AZURE.NOTE] Схемы секционирования, о которых идет речь в этом руководстве, описаны способом, который не зависит от используемой технологии хранения данных. Они применимы для различных типов хранилищ данных, включая реляционные и базы данных NoSQL.

### Стратегии секционирования

Ниже представлены три типичные стратегии для секционирования данных.

- **Горизонтальное секционирование** (часто называемое _сегментированием_). В этой стратегии каждая секция представляет собой хранилище данных сама по себе, но все секции имеют одинаковые схемы. Каждая секция называется _сегментом_ и содержит конкретное подмножество данных, например все заказы для определенной группы клиентов в приложении электронной коммерции.
- **Вертикальное секционирование**. В этой стратегии каждая секция содержит подмножество полей для элементов в хранилище данных. Поля разделяются по шаблону их использования. Например, часто используемые поля размещаются в одной вертикальной секции, а более редко используемые поля — в другой.
- **Функциональное секционирование**. В этой стратегии данные группируются в соответствии с их использованием в каждом связанном контексте в системе. Например, система электронной коммерции, которая реализует отдельные бизнес-функции для выставления счетов и управления описью продуктов, может хранить данные счетов в одной секции, а данные инвентаризации продуктов — в другой.

Обратите внимание, что три стратегии, описанные здесь, можно сочетать. Они не являются взаимоисключающими, и все три стратегии рекомендуется учитывать при разработке схемы секционирования. Например, можно разделить данные на сегменты и затем использовать вертикальное секционирование для дальнейшего разделения данных в каждом сегменте. Аналогичным образом данные в функциональной секции могут быть разделены на сегменты (которые могут быть также вертикально секционированы).

Однако разные требования каждой стратегии могут увеличить число конфликтов. Их все необходимо оценить и сбалансировать при разработке схемы секционирования, обеспечивающей целевую производительность обработки данных для вашей системы. Следующие разделы посвящены более подробному описанию каждой стратегии.

### Горизонтальное секционирование (сегментирование)

На рисунке 1 представлен обзор горизонтального секционирования, или сегментирования. В этом примере данные инвентаризации продуктов разделены на сегменты на основании ключа продукта. Каждый сегмент содержит данные для непрерывного диапазона ключей сегментов (A-G и H-Z) в алфавитном порядке.

![Горизонтальное секционирование данных (сегментирование) на основании ключа секции](media/best-practices-data-partitioning/DataPartitioning01.png)

_Рис. 1. Горизонтальное секционирование данных (сегментирование) на основании ключа секции_

Сегментирование позволяет распределить нагрузку между несколькими компьютерами, уменьшая вероятность конфликтов и повышая производительность. Можно масштабировать систему, добавляя дополнительные сегменты, работающие на дополнительных серверах.

Наиболее важным фактором при реализации этой стратегии секционирования является выбор ключа сегментирования. Может быть трудно изменить ключ после начала работы системы. Ключ должен гарантировать, что данные секционированы таким образом, чтобы рабочая нагрузка была распределена по сегментам максимально равномерно.

Обратите внимание, что разные сегменты необязательно должны содержать сходные объемы данных. Гораздо важнее сбалансировать количество запросов. Некоторые сегменты, возможно, будут очень большими, но элементы в них могут редко использоваться. Другие сегменты будут меньше, но данные в них могут использоваться чаще. Также важно убедиться, что один сегмент не превышает предел масштабирования (с точки зрения емкости и ресурсов обработки) хранилища данных, используемого для размещения этого сегмента.

При использовании схемы сегментирования следует избегать возникновения горячих точек (или горячих секций), которые могут повлиять на производительность и доступность. Например, если использовать хэш идентификатора клиента вместо первой буквы имени клиента, можно предотвратить несбалансированное распределение, которое возникнет из-за неоднородной частоты использования начальных букв. Это типичный способ, позволяющий более равномерно распределить данные по секциям.

Выберите ключ сегментирования, который сводит к минимуму любые будущие требования разбить большие сегменты на более мелкие части, объединить небольшие сегменты в секции большего размера или изменить схему, которая описывает данные, хранящиеся в наборе секций. Эти операции могут занять очень много времени и потребовать отключения одного или нескольких сегментов во время их выполнения.

Если сегменты реплицируются, можно оставить некоторые реплики в рабочем режиме во время разделения, слияния или перенастройки других реплик. Но система может ограничить операции, выполняемые с данными в этих сегментах во время перенастройки. Например, данные в репликах могут быть помечены как данные только для чтения, чтобы ограничить объем несоответствий, которые возникают во время реструктуризации сегментов.

> Более подробные сведения и рекомендации по этим вопросам, как и по рекомендуемым методам проектирования хранилищ данных, которые реализуют горизонтальное секционирование, см. в разделе [Шаблон сегментирования]

### Вертикальное секционирование

Вертикальное секционирование наиболее часто используется для сокращения операций ввода-вывода и расходов на производительность, связанных с выборкой наиболее часто используемых элементов. На рисунке 2 показан пример вертикального секционирования. В этом примере разные свойства для каждого элемента данных хранятся в разных секциях. В одной секции хранятся данные, используемые чаще всего, например имя, описание и сведения о ценах на продукты. В другой содержатся данные о количестве на складе и дате последнего заказа.

![Вертикальное секционирование данных по шаблону использования](media/best-practices-data-partitioning/DataPartitioning02.png)

_Рис. 2. Вертикальное секционирование данных по шаблону использования_

В этом примере приложение регулярно запрашивает имя, описание и цену продукта при отображении подробных сведений о продукте для клиента. Такие данные, как количество продукта на складе и дата последнего заказа у производителя, хранятся в отдельной секции, так как эти два элемента часто используются совместно.

Эта схема секционирования имеет то дополнительное преимущество, что относительно медленно изменяющиеся данные (название, описание и цена продукта) отделены от более динамически меняющихся данных (количество продукта на складе и дата последнего заказа). Приложение может выиграть, когда изменяющиеся данные медленно кэшируются в памяти, если они часто используются.

Другой типичный сценарий для этой стратегии секционирования — максимальное повышение безопасности конфиденциальных данных. Этого можно добиться, например, храня номера кредитных карт и соответствующие номера проверки безопасности карты в отдельной секции.

Вертикальное секционирование может также снизить объем требуемого параллельного доступа к данным.

> Вертикальное секционирование работает на уровне сущности в хранилище данных, частично нормализуя сущность и преобразуя ее из _широкого_ элемента в набор _узких_ элементов. Это идеально подходит для хранилищ данных со столбцами, таких как HBase и Cassandra. Если данные в коллекции столбцов меняются редко, также можно использовать хранилища со столбцами в SQL Server.

### Функциональное секционирование

Для систем, где можно идентифицировать связанный контекст для каждой области бизнеса или службы в приложении, функциональное секционирование предоставляет способ повышения изоляции и скорости доступа к данным. Кроме этого, функциональное секционирование обычно используется для разделения данных для чтения и записи от данных только для чтения, используемых для составления отчетов. На рисунке 3 представлен обзор функционального секционирования, где инвентаризации отделены от данных клиентов.

![Функциональное секционирование данных по связанному контексту или дочернему домену](media/best-practices-data-partitioning/DataPartitioning03.png)

_Рис. 3. Функциональное секционирование данных по связанному контексту или дочернему домену_

Эта стратегия секционирования может помочь уменьшить количество конфликтов доступа к данным в различных частях системы.

## Проектирование секций для масштабируемости

Важно учитывать размер и рабочую нагрузку каждой секции и равномерно распределять данные для достижения максимальной масштабируемости. Тем не менее необходимо все же секционировать данные так, чтобы не превысить ограничения масштабирования одной секции хранилища.

При создании секций для масштабируемости выполните приведенные далее действия.

1. Проанализируйте приложение, чтобы понять шаблоны доступа к данным, такие как размер результирующего набора, возвращаемого каждым запросом, частота доступа, встречающиеся задержки и требования к вычислительной обработке на стороне сервера. Во многих случаях несколько основных сущностей потребуют большую часть вычислительных ресурсов.
2. На основе анализа определите текущие и будущие целевые показатели масштабируемости, такие как размер данных и рабочая нагрузка. Затем распределите данные по секциям в соответствии с целевыми показателями масштабируемости. В горизонтальной стратегии секционирования выбор соответствующего ключа сегмента важен для обеспечения равномерного распределения. Дополнительные сведения см. в разделе [Шаблон сегментирования].
3. Убедитесь в том, что каждой секции предоставлено достаточно ресурсов для достижения требований масштабируемости с точки зрения размера данных и пропускной способности. Например, узел, где размещается секция, может накладывать жесткое ограничение на объем для хранения, объем обработки или пропускную способность сети, которые он предоставляет. Если требования к хранению и обработке данных, скорее всего, превысят эти пределы, возможно, вам придется пересмотреть стратегию секционирования или дополнительно разделить данные. Например, можно использовать такой подход к масштабированию: отделить данные журналов от основных функций приложения. Для этого следует использовать отдельные хранилища, чтобы общие требования хранилища данных не превышали предел масштабирования узла. Если общее число хранилищ данных превышает ограничение узла, может потребоваться использование отдельных узлов хранилища.
4. Понаблюдайте за используемой системой, чтобы убедиться, что данные распределяются ожидаемым образом и секции справляются со своей нагрузкой. Есть вероятность, что фактические результаты использования не будут совпадать с данными анализа. В этом случае можно повторно сбалансировать секции. Если это не дало результата, может потребоваться изменить некоторые компоненты системы, чтобы получить необходимый баланс.

Обратите внимание, что некоторые облачные среды распределяют ресурсы по границам инфраструктуры. Следует убедиться, что ограничения выбранной границы предоставляют достаточно места для любого ожидаемого роста объема данных с точки зрения хранилища данных, вычислительной мощности и пропускной способности.

Например, при использовании хранилища таблиц Azure занятый сегмент может потребовать больше ресурсов, чем доступно отдельным секциям для обработки запросов. (Существует ограничение на объем запросов, который может быть обработан одной секцией в течение указанного периода времени. Подробнее см. на странице [Целевые показатели производительности и масштабируемости хранилища Azure] на веб-сайте корпорации Майкрософт.)

 В этом случае можно повторно секционировать сегмент, чтобы распределить нагрузку. Если общий размер или пропускная способность этих таблиц превышают емкость учетной записи хранения, возможно, потребуется создать дополнительные учетные записи хранения и распределить таблицы по этим учетным записям. Если число учетных записей хранения превышает количество доступных для подписки, возможно, потребуется использовать несколько подписок.

## Проектирование секций для повышения производительности запросов

Производительность запросов часто можно увеличить путем использования небольших наборов данных и параллельного выполнения запросов. Каждая секция должна содержать небольшую часть всего набора данных. Такое уменьшение объема может повысить производительность запросов. Тем не менее секционирование не является альтернативой правильной разработке и настройке базы данных. Например, необходимо убедиться в том, что присутствуют все необходимые индексы, если вы используете реляционную базу данных.

При создании секций для производительности запросов выполните приведенные далее действия.

1. Изучите требования и производительность приложения.
	- Используйте бизнес-требования, чтобы определить важные запросы, которые всегда должны выполняться быстро.
	- Отслеживайте состояния системы, чтобы выявить любые медленно выполняемые запросы.
	- Установите, какие запросы выполняются наиболее часто. Один экземпляр каждого запроса может иметь минимальный вес, но совокупное потребление ресурсов может быть значительным. Возможно, полезно будет выделить данные, полученные этими запросами, в отдельную секцию или даже в кэш.
2. Разделите данные, которые вызывают снижение производительности.
	- Ограничьте размер каждой секции, чтобы время отклика запроса оставалось в пределах целевого значения.
	- Создайте ключ сегментирования таким образом, чтобы приложение могло легко находить секцию, если вы реализуете горизонтальное секционирование. Так запросу не потребуется проверять каждую секцию.
	- Учитывайте влияние расположения секции. Если это возможно, старайтесь хранить данные в секциях, географически близких к использующим их приложениям и пользователям.
3. Если у сущности есть требования к пропускной способности и запросам, используйте функциональное секционирование на основе этой сущности. Если по-прежнему не удается удовлетворить требования, примените также горизонтальное секционирование. В большинстве случаев будет достаточно одной стратегии секционирования, но в некоторых случаях более эффективно будет объединить обе стратегии.
4. Для повышения производительности рекомендуется использовать асинхронные запросы, которые выполняются параллельно по секциям.

## Проектирование секций для увеличения доступности

Секционирование данных может повысить доступность приложений за счет того, что весь набор данных не составляет единственную точку отказа и что отдельными подмножествами набора данных можно управлять независимо друг от друга. Доступность можно также повысить за счет репликации секций, содержащих важные данные.

При разработке и реализации секций учитывайте следующие факторы, влияющие на доступность.

- **Степень важности данных для бизнес-операций**. Некоторые данные могут представлять собой важные для бизнеса сведения, например сведения о счетах или о банковских переводах. Другие данные могут быть менее важными рабочими данными, такими как файлы журнала, трассировка производительности и т. д. После определения каждого типа данных подумайте о следующем.
	- Можно хранить критически важные данные в секциях высокой доступности с соответствующим планом архивации.
	- Можно установить отдельные механизмы или процедуры управления и мониторинга для различных степеней важности каждого набора данных. Можно разместить данные с одинаковым уровнем важности в одной секции, чтобы их можно было архивировать с соответствующей частотой. Например, для секций, содержащих данные о банковских переводах, архивация может требоваться чаще, чем для секций, содержащих данные журналов или трассировки.
- **Как можно управлять отдельными секциями**. Проектирование секций с поддержкой независимых управления и обслуживания обеспечивает ряд преимуществ. Например:
	- Если в секции происходит сбой, ее можно восстановить независимо, не затрагивая экземпляры приложений, работающих с данными в других секциях.
	- Секционирование данных по географическому региону позволит запускать запланированные задачи по обслуживанию в непиковые часы для каждого расположения. Убедитесь, что секции не слишком велики и их размер не помешает завершить запланированное обслуживание в течение этого периода.
- **Подумайте, следует ли реплицировать критически важные данные по секциям**. Эта стратегия может повысить доступность и производительность, хотя она также может вызвать проблемы согласованности. Для синхронизации изменения данных в секции с каждой репликой требуется время. В течение этого времени различные секции будут содержать разные значения данных.

## Сведения о влиянии секционирования на проектирование и разработку

Использование секционирования усложняет проектирование и разработку системы. Секционирование следует рассматривать как основную часть разработки системы, даже если система изначально содержит только одну секцию. Обращение к секционированию как к методу решения проблем с производительностью и масштабируемостью системы, возникших после ее запуска, приведет к повышению сложности, так как у вас уже есть действующая система, которую нужно поддерживать.

Обновление системы для включения секционирования в этой среде требует не только изменения логики доступа к данным. Оно также может привести к миграции большого количества существующих данных, которые необходимо распределить по секциям. При этом пользователи хотят иметь возможность по-прежнему использовать систему.

В некоторых случаях секционирование не считается важным, так как исходный набор данных небольшой и легко обрабатывается на одном сервере. Это может быть справедливо, если в системе не планируется масштабирование свыше начального размера, но многим коммерческим системам требуется возможность расширения по мере увеличения числа пользователей. Это расширение обычно сопровождается увеличением объема данных.

Следует также понимать, что секционирование не всегда связано с хранилищами больших объемов данных. Например, небольшое хранилище данных могут использовать сотни параллельных клиентов. Секционирование данных в этой ситуации может помочь уменьшить количество конфликтов и повысить пропускную способность.

При разработке схемы секционирования данных учитывайте следующие моменты.

- **По возможности храните данные для наиболее распространенных операций базы данных вместе в каждой секции, чтобы свести к минимуму операции доступа к данным из разных секций**. Запросы к разным секциям могут занимать больше времени, чем отправка запросов в рамках одной секции, но оптимизация секций для одного набора запросов может неблагоприятно повлиять на другие наборы запросов. Чтобы свести к минимуму время запроса к разным секциям там, где этого не избежать, реализуйте параллельные запросы к секциям и статистическую обработку результатов в приложении. Однако такой подход может оказаться невозможным в некоторых случаях, например, когда это необходимо, чтобы получить результат из одного запроса и использовать его в следующем запросе.
- **Если запросы используют относительно статические справочные данные, например таблицы почтовых индексов или списки продуктов, подумайте о репликации этих данных во всех секциях, чтобы снизить потребность в отдельных операциях уточняющих запросов в другие секции**. Этот подход также может уменьшить вероятность того, что справочные данные станут "горячим" набором данных, который подвергается значительному трафику из всех точек системы. Однако существуют дополнительные затраты, связанные с синхронизацией любых изменений этих справочных данных.
- **По возможности сведите к минимуму требования для обеспечения целостности данных для вертикальных и функциональных секций**. В этих схемах само приложение отвечает за обеспечение целостности данных в секциях, когда данные обновляются и потребляются. Запросы, которые должны объединить данные из нескольких секций, выполняются медленнее, чем запросы, которые объединяют данные только из одной секции, поскольку приложению обычно требуется выполнить последовательные запросы на основе ключа, а затем на основе внешнего ключа. Вместо этого рассмотрите возможность репликации или денормализации соответствующих данных. Чтобы свести к минимуму время запроса там, где необходимы соединения между секциями, реализуйте параллельные запросы из разных секций и объединение данных внутри приложения.
- **Учитывайте влияние схемы секционирования на согласованность данных в секциях.** Следует оценить, является ли строгое согласование обязательным. Обычно стандартный подход в облаке заключается в реализации окончательной согласованности. Данные в каждой секции обновляются отдельно, а логика приложения может нести ответственность за обеспечение успешного завершения обновлений. Она также обрабатывает несоответствия, которые могут возникнуть после запроса данных во время выполнения операции согласования. Дополнительные сведения о реализации окончательной согласованности см. в [руководстве по согласованности].
- **Подумайте, как запросы будут находить правильную секцию**. Если запрос должен сканировать все секции, чтобы найти требуемые данные, это сильно повлияет на производительность даже при использовании нескольких параллельных запросов. Запросы, используемые с вертикальной и функциональной стратегиями секционирования, могут естественным образом указывать секции. Однако при использовании горизонтального секционирования (сегментирования) поиск элемента может быть затруднен, так как каждый сегмент имеет ту же схему. Стандартное решение для сегментирования — поддерживать карту, которую можно использовать для поиска определенных элементов данных в сегменте. Эту карту можно реализовать в логике сегментирования приложения или поддерживать в хранилище данных, если оно поддерживает прозрачное сегментирование.
- **При использовании стратегии горизонтального секционирования рекомендуется периодически балансировать нагрузку сегментов**. Это позволит равномерно распределять данные по размеру и рабочей нагрузке и свести к минимуму горячие точки, повысить производительность выполнения запросов и обойти ограничения физического хранилища. Однако это сложная задача, которая часто требует использования пользовательских средств или процессов.
- **Репликация каждой из секций обеспечивает дополнительную защиту от сбоев**. В случае сбоя одной реплики запросы могут направляться на рабочую копию.
- **При достижении физических ограничений стратегии секционирования может потребоваться расширить масштабируемость до другого уровня**. Например, если секционирование находится на уровне базы данных, это может означать необходимость размещения или репликации секций в нескольких базах данных. Если секционирование уже находится на уровне базы данных и физические ограничения стали проблемой, это может означать необходимость размещения или репликации секций в нескольких учетных записях.
- **Избегайте транзакций, осуществляющих доступ к данным в нескольких секциях**. Некоторые хранилища данных реализуют согласованность и целостность транзакций для операций, которые изменяют данные, но только в том случае, когда они находятся в одной секции. Если требуется поддержка транзакций с использованием нескольких секций, возможно, потребуется реализовать это как часть логики приложения, поскольку большая часть систем секционирования не обеспечивает встроенную поддержку.

Все хранилища данных требуют некоторого оперативного управления и наблюдения за активностью. Задачи могут варьироваться от загрузки данных, резервного копирования и восстановления данных до реорганизации данных и обеспечения правильной и эффективной работы системы.

Учитывайте следующие факторы, влияющие на оперативное управление.

- **Как при секционировании данных реализовать соответствующее управление и рабочие задачи**. В число этих задач могут входить архивация и восстановление, архивация данных, мониторинг системы и других задач администрирования. Например, сохранение логического соответствия во время операций резервного копирования и восстановления может оказаться непростой задачей.
- **Как можно загружать данные в несколько секций и как добавлять новые данные, поступающие из других источников**. Некоторые средства и служебные программы могут не поддерживать операции с сегментированными данными, например загрузку в нужную секцию. Поэтому такие операции могут потребовать создания или приобретения новых средств и служебных программ.
- **Как будут архивироваться и удаляться данные на регулярной основе**. Для предотвращения чрезмерного увеличения размера секций необходимо регулярно архивировать и обновлять данные (возможно, раз в месяц). Очевидно, потребуется преобразовать данные, чтобы обеспечить соответствие другой схеме архивирования.
- **Как обнаруживать проблемы целостности данных**. Рассмотрите возможность выполнения периодического процесса для обнаружения любых проблем целостности данных, например, когда данные в одной секции ссылаются на данные в другой, но эти данные отсутствуют. Процесс может либо попытаться устранить эти проблемы автоматически, либо создать оповещение оператора для устранения неполадок вручную. Например, в приложении электронной коммерции сведения о заказах могут храниться в одной секции, а элементы строк, которые составляют каждый заказ, — в другой. В процессе размещения заказа необходимо добавить данные к обеим секциям. Если этот процесс завершается ошибкой, могут быть сохранены элементы строк, для которых отсутствует соответствующий заказ.

Разные технологии хранения данных обычно предоставляют свои собственные функции для поддержки секционирования. В следующих разделах рассматриваются возможности, реализуемые хранилищами данных и часто используемые приложениями Azure. В них также содержатся рекомендации по разработке приложений с использованием преимуществ этих функций.

## Стратегии секционирования для базы данных SQL Azure

База данных SQL Azure является реляционной базой данных, которая предоставляется как служба, работающая в облаке. Она основана на Microsoft SQL Server. Реляционная база данных делит данные на таблицы, и каждая таблица содержит сведения о сущностях в виде набора строк. Каждая строка содержит столбцы, которые предоставляют данные для отдельных полей сущности. Подробную документацию по созданию и использованию базы данных SQL см. на странице [Что такое база данных SQL Azure] на веб-сайте Майкрософт.

## Горизонтальное секционирование с использованием эластичной базы данных

Одна база данных SQL имеет ограничение на объем содержащихся в ней данных. Пропускная способность ограничена архитектурными факторами и числом поддерживаемых одновременных подключений. База данных SQL Azure предоставляет эластичную базу данных для поддержки горизонтального масштабирования базы данных SQL. С помощью эластичной базы данных вы можете секционировать данные в сегменты, которые распределены между несколькими базами данных SQL. Можно также добавлять или удалять сегменты по мере роста или уменьшения объема обрабатываемых данных. Кроме того, использование эластичной базы данных помогает уменьшить количество конфликтов за счет распределения нагрузки между базами данных.

> [AZURE.NOTE] В данный момент эластичная база данных предлагается в режиме предварительного просмотра по состоянию на декабрь 2015 г. Она является заменой федераций базы данных SQL Azure, которые будут отменены. Установленную федерацию базы данных SQL можно перенести в эластичную базу данных с помощью [программы миграции федераций]. Кроме того, вы можете реализовать собственный механизм сегментирования, если ваш сценарий не использует естественным образом функции, предоставляемые эластичной базой данных.

Каждый сегмент реализуется как база данных SQL. Сегмент может содержать более одного набора данных (называемого _шардлетом_). Каждая база данных хранит метаданные, которые описывают содержащиеся в ней шардлеты. Шардлет может быть отдельным элементом данных или группой элементов, которые совместно используют один и тот же ключ шардлета. Например, если вы сегментируете данные в приложении с несколькими клиентами, ключом шардлета может быть идентификатор клиента и все данные для данного клиента будут храниться в рамках одного шардлета. Данные для других клиентов будут храниться в других шардлетах.

Программист должен связать набор данных с ключом шардлета. Отдельная база данных SQL служит глобальным диспетчером сопоставления сегментов, который содержит список баз данных (сегментов), составляющих всю систему вместе со сведениями о шардлетах в каждой базе данных. Клиентское приложение, которое обращается к данным, сначала подключается к базе данных глобального диспетчера сопоставления сегментов для получения копии карты сегментов (списка сегментов и шардлетов), которую оно кэширует локально.

Затем приложение использует эти сведения для направления запросов данных к соответствующему сегменту. Эта функциональность скрыта за рядом API-интерфейсов, содержащихся в клиентской библиотеке эластичной базы данных базы данных SQL Azure, доступной в виде пакета NuGet. Дополнительные сведения об эластичной базе данных см. на странице [Общие сведения о возможностях эластичных баз данных] на веб-сайте Майкрософт.

> [AZURE.NOTE] Можно реплицировать базу данных глобального диспетчера сопоставления сегментов для сокращения задержки и повышения доступности. При реализации базы данных с помощью одной из ценовых категорий "Премиум" можно настроить активную георепликацию для непрерывного копирования данных в базы данных в разных регионах. Создайте копию базы данных в каждом регионе, где есть пользователи. Затем настройте приложение на подключение к этой копии для получения карты сегментов.

> В качестве альтернативы можно использовать синхронизацию данных SQL Azure или конвейер фабрики данных Azure для репликации базы данных диспетчера сопоставления сегментов по регионам. Эта форма репликации запускается периодически и лучше подходит, если карта сегментов изменяется редко. Кроме того, базу данных диспетчера сопоставления сегментов не обязательно создавать с помощью ценовой категории "Премиум".

Эластичная база данных предоставляет две схемы для сопоставления данных и шардлетов и их хранения в сегментах.

- **Карта сегментов в виде списка** описывает связь между одним ключом и шардлетом. Например, в мультитенантной системе данные для каждого клиента могут быть связаны с уникальным ключом и храниться в собственном шардлете. Для обеспечения конфиденциальности и изоляции (чтобы предотвратить истощение одним клиентом ресурсов хранилища данных, доступных другим пользователям) каждый шардлет может храниться в собственном сегменте.

![Использование карты сегментов в виде списка для хранения данных клиента в отдельных сегментах](media/best-practices-data-partitioning/PointShardlet.png)

_Рис. 4. Использование карты сегментов в виде списка для хранения данных клиента в отдельных сегментах_

- **Карта сегментов в виде диапазона** описывает связь между набором непрерывных значений ключа и шардлетом. В описанном ранее примере многопользовательской системы в качестве альтернативы реализации выделенных шардлетов можно группировать данные для набора клиентов (каждый из которых имеет собственный ключ) в пределах одного шардлета. Эта схема дешевле первой (клиенты совместно используют ресурсы хранилища данных), но есть риск снижения конфиденциальности и изоляции данных.

![Использование карты сегментов в виде диапазона для хранения данных диапазона клиентов в сегменте](media/best-practices-data-partitioning/RangeShardlet.png)

_Рис. 5. Использование карты сегментов в виде диапазона для хранения данных диапазона клиентов в сегменте_

Обратите внимание, что один сегмент может содержать данные для нескольких шардлетов. Например, можно использовать шардлеты в виде списка для хранения данных разных несмежных клиентов в одном сегменте. Можно также смешивать шардлеты в виде диапазона и шардлеты в виде списка в одном сегменте несмотря на то, что они будут использоваться через разные карты в базе данных глобального диспетчера карт сегментов. (База данных глобального диспетчера карт сегментов может содержать несколько карт сегментов.) Рис. 6 демонстрирует этот подход.

![Реализация нескольких карт сегментов](media/best-practices-data-partitioning/MultipleShardMaps.png)

_Рис. 6. Реализация нескольких карт сегментов_

Реализованная вами схема секционирования может значительно повлиять на производительность системы. Она также влияет на скорость добавления или удаления сегментов и повторного секционирования данных по сегментам. При использовании эластичной базы данных для секционирования данных учитывайте приведенные далее моменты.

- Группируйте данные, используемые вместе, в одном сегменте и избегайте операций, которым требуется доступ к данным, хранящимся в нескольких сегментах. Имейте в виду, что при использовании эластичной базы данных сегмент сам по себе является базой данных SQL, а база данных SQL Azure не поддерживает межбазовые соединения. Эти операции должны выполняться на стороне клиента. Также следует помнить, что в базе данных SQL Azure ограничения целостности данных, триггеры и хранимые процедуры в одной базе данных не могут ссылаться на объекты в другой. Поэтому не разрабатывайте систему, в которой есть зависимости между сегментами. Однако база данных SQL может включать таблицы, содержащие копии справочных данных, часто используемых в запросах и других операциях. Эти таблицы не всегда принадлежат какому-либо конкретному шардлету. Репликация данных по сегментам поможет устранить необходимость объединения данных, охватывающих базы данных. В идеальном случае такие данные должны быть статическими или медленно изменяющимися, чтобы максимально упростить репликацию и снизить вероятность устаревания изменений.

	> [AZURE.NOTE] Несмотря на то, что база данных SQL Azure не поддерживает межбазовые соединения, API эластичной базы данных позволяет выполнять запросы к нескольким сегментам. Эти запросы обеспечивают прозрачную итерацию данных, содержащихся во всех шардлетах, на которые ссылается карта сегментов. API эластичной базы данных разбивает запросы к нескольким сегментам на ряд отдельных запросов (по одному для каждой базы данных) и объединяет результаты. Дополнительные сведения см. на странице [Запросы к нескольким сегментам] на веб-сайте Майкрософт.

- Данные, хранящиеся в шардлетах, принадлежащих к одной карте сегментов, должны иметь одинаковую схему. Например, не стоит создавать карту сегментов в виде списка, которая указывает на некоторые шардлеты, содержащие данные клиента, и на другие шардлеты, содержащие сведения о продукте. Эластичная база данных не навязывает это правило, но управление данными и запросами становится очень сложным, если у всех шардлетов разные схемы. В приведенном выше примере необходимо создать две карты сегментов в виде списка: одна будет ссылаться на данные клиента, а другая — на сведения о продукте. Помните, что данные, принадлежащие к разным шардлетам, можно хранить в одном сегменте.

	> [AZURE.NOTE] Функциональность межсегментных запросов в API эластичной базы данных зависит от каждого шардлета в схеме сегментирования, содержащей одну и ту же схему.

- Транзакционные операции поддерживаются только для данных, хранящихся в пределах одного сегмента, но не между сегментами. Транзакции могут охватывать шардлеты при условии, что они являются частью одного сегмента. Таким образом, если вашей бизнес-логике требуется выполнять транзакции, соответствующие данные либо должны храниться в одном сегменте, либо нужно реализовать окончательную согласованность. Дополнительную информацию см. в статье [Руководство по согласованности данных].
- Размещайте сегменты рядом с пользователями, которые обращаются к данным в этих сегментах (другими словами, выполняйте географическое распределение сегментов). Эта стратегия помогает сократить задержку.
- Избегайте смешения высокоактивных (горячих) и относительно неактивных сегментов. Попробуйте равномерно распределить нагрузку по сегментам. Это может потребовать хэширования ключей шардлетов.
- При географическом распределении сегментов убедитесь, что хэшированные ключи соответствуют шардлетам, хранящимся в сегментах, которые находятся рядом с использующими эти данные пользователями.
- В настоящее время в качестве ключей шардлетов поддерживается только ограниченный набор типов данных SQL: _int, bigint, varbinary,_ и _uniqueidentifier_. Типы SQL _int_ и _bigint_ соответствуют типам данных _int_ и _long_ в C# и имеют такие же диапазоны. Тип SQL _varbinary_ может обрабатываться с помощью массива _Byte_ в C#, а тип SQL _uniqueidentier_ соответствует классу _Guid_ в .NET Framework.

Как предполагает имя, эластичная база данных позволяет добавлять и удалять сегменты в системе по мере увеличения или уменьшения объема данных. API в клиентской библиотеке эластичной базы данных базы данных SQL Azure позволяют приложению создавать и удалять сегменты динамически (и прозрачно обновлять диспетчер карты сегментов). Однако удаление сегмента является необратимой операцией, в ходе которой также необходимо удалить все данные этого сегмента.

Если приложению требуется разбить сегмент на два отдельных сегмента или объединить их, эластичная база данных предоставляет отдельную службу разделения и объединения. Эта служба работает в облачной службе (разработчик должен ее создать) и обеспечивает безопасный перенос данных между сегментами. Дополнительные сведения см. в разделе [Масштабирование с применением средства разбиения и объединения эластичной базы данных] на веб-сайте Майкрософт.

## Стратегии секционирования для хранилища Azure

Хранилище Azure предоставляет три абстракции для управления данными.

- Хранилище таблиц, которое реализует хранилище с масштабируемой структурой. Таблица содержит коллекцию сущностей, каждая из которых может включать в себя набор свойств и значений.
- Хранилище BLOB-объектов, которое предоставляет хранилище для больших объектов и файлов.
- Очереди хранилища, которые поддерживают надежную асинхронную систему обмена сообщениями между приложениями.

Хранилище таблиц и хранилище BLOB-объектов фактически представляют собой хранилища на базе значения и ключа, оптимизированные для хранения структурированных и неструктурированных данных соответственно. Очереди хранилища предоставляют механизм для создания слабосвязанных масштабируемых приложений. Хранилище таблиц, хранилище BLOB-объектов и очереди хранилища создаются в контексте учетной записи хранения Azure. Учетные записи хранения Azure поддерживают три вида избыточности.

- **Локально избыточное хранилище** поддерживает три копии данных в одном центре обработки данных. Эта форма избыточности обеспечивает защиту от сбоев оборудования, но не от аварии, которая охватывает весь центр обработки данных.
- **Хранилище, избыточное в пределах зоны**, поддерживает три копии данных, которые хранятся в различных центрах обработки данных в одном регионе (или двух географически близких регионах). Эта форма избыточности обеспечивает защиту от сбоев, возникающих в рамках одного центра обработки данных, но не может защитить от крупномасштабных сетевых отключений, которые влияют на весь регион. Обратите внимание, что хранилище, избыточное в пределах зоны, в данный момент доступно только для блочных BLOB-объектов.
- **Геоизбыточное хранилище** поддерживает шесть копий данных. Три копии хранятся в одном регионе (в вашем локальном регионе), а еще три копии — в удаленном регионе. Эта форма избыточности обеспечивает самый высокий уровень защиты от аварии.

Корпорация Майкрософт опубликовала целевые показатели масштабируемости для хранилища Azure. Дополнительные сведения см. на странице [Целевые показатели масштабируемости и производительности хранилища Azure] на веб-сайте Майкрософт. В настоящее время общая емкость учетной записи хранения не может превышать 500 ТБ. (Сюда входит размер данных, хранящихся в хранилище таблиц, хранилище BLOB-объектов и в ожидающих сообщениях в очереди хранилища.)

Максимальная частота запросов (из расчета размера сущности, BLOB-объекта или сообщения в 1 КБ) составляет 20 КБ в секунду. Если для вашей системы вероятно превышение этих ограничений, попробуйте разбить нагрузку на несколько учетных записей хранения. Каждая подписка Azure может включать до 100 учетных записей хранения. Однако обратите внимание, что эти ограничения могут изменяться со временем.

## Секционирование хранилища таблиц Microsoft Azure

Хранилище таблиц Azure является хранилищем ключей и значений, которое разработано на основе секционирования. Все сущности хранятся в секции, а секции управляются внутренне хранилищем таблиц Azure. Каждая сущность, хранящаяся в таблице, должна предоставить двухкомпонентный ключ, включающий ключ секции и ключ строки.

- **Ключ секции**. Это строковые значения, которые определяют, в какой секции хранилища таблицы Azure нужно разместить сущность. Все сущности с одинаковым ключом секции будут храниться в одной секции.
- **Ключ строки**. Это другое строковое значение, определяющее сущность в секции. Все сущности в секции сортируются лексически в порядке возрастания с помощью этого ключа. Сочетание ключа секции и ключа строки должно быть уникальным для каждой сущности, а его длина не может превышать 1 КБ.

Остальная часть данных для сущности состоит из полей, определяемых приложением. Конкретные схемы не применяются, и каждая строка может содержать свой набор полей, определяемых приложением. Единственное ограничение: максимальный размер сущности (включая ключи секций и строк) в настоящее время составляет 1 МБ. Максимальный размер таблицы составляет 200 ТБ, хотя эти данные могут измениться в будущем. (Актуальные сведения об этих ограничениях см. на странице [Целевые показатели масштабируемости и производительности хранилища Azure] на веб-сайте Майкрософт.)

Если вам необходимо хранить сущности, размер которых превышает это ограничение, попробуйте разбить их на несколько таблиц. Используйте вертикальное секционирование и разделите поля на группы, которые, скорее всего, используются вместе.

Рис. 7 демонстрирует логическую структуру примера учетной записи хранения (Contoso Data) для вымышленного приложения электронной коммерции. Учетные записи хранения содержат три таблицы: сведения о клиенте, сведения о продукции и сведения о заказах. Каждая таблица содержит несколько секций.

В таблице сведений о клиенте данные секционируются по городам, в которых находятся клиенты, а ключ строки содержит идентификатор клиента. В таблице сведений о продукте продукты секционированы по категориям, а ключ строки содержит номер продукта. В таблице сведений о заказах заказы секционируются по дате размещения, а ключ строки указывает время получения заказа. Обратите внимание, что все данные в каждой секции упорядочены с помощью ключа строки.

![Таблицы и секции в примере учетной записи хранения](media/best-practices-data-partitioning/TableStorage.png)

_Рис. 7. Таблицы и секции в примере учетной записи хранения_

> [AZURE.NOTE] Хранилище таблиц Azure также добавляет поле метки времени для каждой сущности. Поле метки времени обслуживается хранилищем таблиц. Оно обновляется при каждом изменении сущности и записывается обратно в секцию. Служба хранилища таблиц использует поле для реализации оптимистичного параллелизма. (Каждый раз, когда приложение записывает сущность обратно в хранилище таблиц, служба хранилища таблиц сравнивает значение метки времени записываемой сущности со значением, содержащимся в хранилище таблиц. Если значения отличаются, возможно, другое приложение изменило сущность после получения, в результате чего происходит сбой операции записи.) Не изменяйте это поле в собственном коде, а также не задавайте значение для этого поля при создании новой сущности.

Хранилище таблиц Azure использует ключ секции для определения способа хранения данных. При добавлении сущности в таблицу с ранее неиспользуемым ключом секции хранилище таблиц Azure создаст новую секцию для этой сущности. Другие сущности с одинаковым ключом секции будут храниться в одной секции.

Этот механизм эффективно реализует стратегию автоматического масштабирования. Каждая секция хранится на одном сервере в центре обработки данных Azure, чтобы обеспечить быстрое выполнение запросов, получающих данные из одной секции. Но разные секции могут располагаться на нескольких серверах. Кроме того, один сервер может поддерживать несколько секций, если размер этих секций ограничен.

При проектировании сущностей для хранилища таблиц Azure учитывайте следующие моменты.

- Выбор значений ключа секции и ключа строки должен быть основан на способе получения доступа к данным. Необходимо выбрать сочетание ключа секции и ключа строки, которое поддерживает большинство запросов. Наиболее эффективные запросы будут получать данные, указав ключ секции и ключ строки. Запросы, которые определяют ключ секции и диапазон ключей строк, могут быть выполнены путем сканирования одной секции. Это относительно быстро, поскольку данные хранятся в порядке значений ключей строк. В случае запросов, которые не указывают, какую секцию следует сканировать, ключ секции может потребовать от хранилища таблиц Azure проверить каждую секцию данных.

	> [AZURE.TIP] Если у сущности есть один естественный ключ, используйте его в качестве ключа секции и укажите пустую строку в качестве ключа строки. Если сущность имеет составной ключ, включающий два свойства, выберите наиболее медленно изменяющееся свойство в качестве ключа секции, а второе — в качестве ключа строки. Если сущность имеет более двух свойств ключа, используйте объединение свойств, чтобы указать ключи секций и строк.

- Если вы регулярно выполняете запросы, которые ищут данные с использованием других полей, кроме ключей секций и строк, рассмотрите возможность реализации [шаблона таблицы индексов].
- Если вы создаете ключи секций с помощью монотонной увеличивающейся или уменьшающейся последовательности (например 0001, 0002, 0003 и т. д.) и каждая секция содержит только ограниченный объем данных, хранилище таблиц Azure может физически сгруппировать эти секции вместе на одном сервере. Этот механизм предполагает, что приложение, скорее всего, будет выполнять запросы к смежным секциям (запросы к диапазону), и оптимизирован для этого случая. Однако такой подход может привести к образованию горячих точек на одном сервере, так как все операции добавления новых сущностей, вероятно, будут сконцентрированы на одном или другом конце непрерывного диапазона. Он также может снизить масштабируемость. Чтобы более равномерно распределить нагрузку между серверами, рассмотрите возможность хэширования ключа секции, чтобы сделать последовательность более случайной.
- Хранилище таблиц Azure поддерживает транзакционные операции для сущностей, которые относятся к одной секции. Это означает, что приложение может выполнять несколько операций вставки, обновления, удаления или объединения как одну неделимую единицу (транзакции не должны включать более 100 сущностей, а размер полезных данных запроса не должен превышать 4 МБ). Операции, охватывающие несколько секций, не являются транзакционными и могут потребовать реализации окончательной согласованности в соответствии с [руководством по согласованности данных]. Дополнительные сведения о хранилище таблиц и транзакциях см. на странице [Выполнение групповых транзакций сущности] на веб-сайте Майкрософт.
- Уделите особое внимание гранулярности ключа секции. Это необходимо сделать по указанным далее причинам:
	- Использование одного и того же ключа секции для каждой сущности приведет к тому, что служба хранилища таблиц создаст одну большую секцию, хранящуюся на одном сервере. В результате масштабирование будет затруднено, а нагрузка сконцентрируется на одном сервере. В результате этот подход применим только для систем, которые управляют небольшим количеством сущностей. Тем не менее этот подход не гарантирует, что все сущности смогут участвовать в транзакциях группы сущностей.
	- Использование уникального ключа секции для каждой сущности приведет к тому, что служба хранилища таблиц создаст отдельную секцию для каждой сущности, в результате чего может появиться большое количество небольших секций (в зависимости от размера сущностей). Этот подход лучше поддается масштабированию, чем подход с использованием одного ключа секции, но транзакции группы сущностей невозможны. Кроме того запросы, получающие более одной сущности, могут включать чтение с нескольких серверов. Тем не менее, если приложение выполняет запросы к диапазону, использование монотонной последовательности для создания ключей секций может помочь оптимизировать такие запросы.
	- Совместное использование ключа секции в подмножестве сущностей позволяет группировать связанные сущности в одну секцию. Операции, включающие связанные сущности, можно выполнить с помощью транзакции группы сущностей, и запросы, получающие набор связанных сущностей, могут удовлетворяться путем доступа к одному серверу.

Дополнительные сведения о секционировании данных в хранилище таблиц Azure см. в статье [Руководство по разработке хранилищ таблиц Azure] на веб-сайте Майкрософт.

## Секционирование хранилища BLOB-объектов Azure

Хранилище BLOB-объектов Azure позволяет хранить большие двоичные объекты, размер которых в настоящее время может достигать 200 ГБ для блочных BLOB-объектов или 1 ТБ для страничных BLOB-объектов. (Самые последние сведения см. на странице [Целевые показатели масштабируемости и производительности хранилища Azure] на веб-сайте Майкрософт.) Используйте блочные BLOB-объекты в таких сценариях, как потоковая передача, где требуется быстро отправлять или загружать большие объемы данных. Используйте страничные BLOB-объекты для приложений, требующих случайного, а не последовательного доступа к частям данных.

Каждый BLOB-объект (блочный или страничный) удерживается в контейнере в учетной записи хранения Azure. Контейнеры можно использовать для группировки связанных BLOB-объектов, имеющих одинаковые требования безопасности, хотя это группирование скорее логическое, чем физическое. Внутри контейнера каждый BLOB-объект имеет уникальное имя.

Хранилище BLOB-объектов автоматически секционируется на основе имени BLOB-объекта. Каждый BLOB-объект хранится в отдельной секции. BLOB-объекты в одном контейнере используют разные секции. Эта архитектура позволяет хранилищу BLOB-объектов Azure прозрачно балансировать нагрузку между серверами, так как разные BLOB-объекты в одном контейнере могут быть распределены по разным серверам.

Действия записи одного блока (блочного BLOB-объекта) или страницы (страничного BLOB-объекта) являются неделимыми, но операции, охватывающие блоки, страницы или BLOB-объекты, таковыми не являются. Если требуется обеспечить согласованность при выполнении операций записи всех блоков, страниц и BLOB-объектов, необходимо убрать блокировку записи с помощью аренды BLOB-объекта.

Хранилище BLOB-объектов Azure поддерживает скорость передачи данных до 60 МБ в секунду или 500 запросов в секунду для каждого BLOB-объекта. Если предполагается превышение этих ограничений и данные BLOB-объекта относительно статичны, рассмотрите возможность репликации BLOB-объектов с помощью сети доставки содержимого Azure. Дополнительные сведения см. на странице [Использование сети доставки содержимого для Azure] на веб-сайте Майкрософт. Дополнительные руководства и рекомендации см. в статье [Использование сети доставки содержимого для Azure].

## Секционирование очередей хранилища Azure

Очереди хранилища Azure позволяют реализовать асинхронный обмен сообщениями между процессами. Учетная запись хранения Azure может содержать любое количество очередей, и каждая очередь может содержать любое количество сообщений. Единственным ограничением является место, доступное в учетной записи хранения. Максимальный размер отдельного сообщения составляет 64 КБ. Если требуются сообщения большего размера, попробуйте использовать очереди служебной шины Azure.

Каждая очередь хранилища имеет уникальное имя в пределах учетной записи хранения, где она содержится. Очереди секций Azure основаны на имени. Все сообщения одной очереди хранятся в одной секции, управляемой одним сервером. Различными очередями могут управлять разные серверы, чтобы сбалансировать нагрузку. Выделение очередей для серверов является прозрачным для приложений и пользователей.

 В приложении большого объема не используйте одну и ту же очередь хранилища для всех экземпляров приложения: этот подход может привести к тому, что на сервере образуется очередь, являющаяся горячей точкой. Используйте различные очереди для различных функциональных областей приложения. Очереди хранилища Azure не поддерживают транзакции, поэтому направление сообщений в различные очереди должно мало влиять на согласованность обмена сообщениями.

Очередь хранилища Azure может обрабатывать до 2000 сообщений в секунду. Если необходимо обрабатывать сообщения с большей скоростью, рассмотрите возможность создания нескольких очередей. Например, в глобальном приложении создайте отдельные очереди хранилища в отдельных учетных записях хранения для обработки экземпляров приложений, работающих в каждом регионе.

## Стратегии секционирования для служебной шины Azure

Служебная шина Azure использует брокер сообщений для обработки сообщений, отправленных в очередь или раздел служебной шины. По умолчанию все сообщения, отправленные в очередь или раздел, обрабатываются одним процессом брокера сообщений. Эта архитектура может ограничить общую пропускную способность очереди сообщений. Однако можно секционировать очереди или разделы при их создании. Это можно сделать, задав свойству _EnablePartitioning_ описания очереди или раздела значение _true_.

Секционированная очередь или раздел делится на несколько фрагментов, для каждого из которых выполняется резервное копирование в отдельном хранилище сообщений и брокере сообщений. Служебная шина отвечает за создание этих фрагментов и управление ими. Когда приложение отправляет сообщение в секционированную очередь или раздел, служебная шина назначает сообщение фрагменту для этой очереди или раздела. Когда приложение получает сообщение из очереди или подписки, служебная шина проверяет каждый фрагмент на наличие следующего доступного сообщения и передает его приложению для обработки.

Эта структура позволяет распределять нагрузку между брокерами сообщений и хранилищами сообщений, повышая масштабируемость и доступность. Если брокер или хранилище сообщений для одного фрагмента временно недоступны, служебная шина может получить сообщения от одного из оставшихся доступных фрагментов.

Служебная шина присваивает сообщение фрагменту следующим образом.

- Если сообщение относится к сеансу, все сообщения с тем же значением свойства \_ SessionId\_ отправляются в тот же фрагмент.
- Если сообщение не принадлежит к сеансу, но отправитель указал значение для свойства _PartitionKey_, все сообщения с тем же значением _PartitionKey_ отправляются в тот же фрагмент.

	> [AZURE.NOTE] Если задать значения свойствам _SessionId_ и _PartitionKey_ одновременно, то эти значения должны быть одинаковыми, в противном случае сообщение будет отклонено.
- Если свойства _SessionId_ и _PartitionKey_ для сообщения не заданы, но включен поиск повторяющихся данных, будет использоваться свойство _MessageId_. Все сообщения с тем же значением _MessageId_ будут направляться в тот же фрагмент.
- Если сообщения не содержат свойства _SessionId, PartitionKey_ или _MessageId_, служебная шина назначает сообщения фрагментам по очереди. Если фрагмент недоступен, служебная шина перейдет к следующему. Таким образом, временная ошибка в инфраструктуре обмена сообщениями не вызовет сбой операции отправки сообщения.

При принятии решения о том, стоит ли и как именно секционировать очередь сообщений или раздел служебной шины, рекомендуется учитывать следующее.

- Очереди и разделы служебной шины создаются в области пространства имен служебной шины. В настоящее время служебная шина обеспечивает до 100 секционированных очередей или разделов на пространство имен.
- Каждое пространство имен служебной шины налагает квоты на доступные ресурсы, такие как количество подписок на раздел, количество параллельных запросов на отправку и получение в секунду, а также максимальное число одновременных подключений, которые можно установить. Эти квоты описаны на странице [Квоты на служебную шину] на веб-сайте Майкрософт. Если предполагается, что эти значения будут превышены, создайте дополнительные пространства имен с собственными очередями и разделами и распределите работу по этим пространствам имен. Например, в глобальном приложении создайте отдельные пространства имен в каждом регионе и настройте экземпляры приложения на использование очередей и разделов в ближайшем пространстве имен.
- Сообщения, отправленные в рамках транзакции, должны указать ключ секции. Это может быть свойство _SessionId, PartitionKey_ или _MessageId_. Все сообщения, отправленные в рамках одной транзакции, должны указать один и тот же ключ секции, так как их должен обрабатывать один брокер сообщений. Невозможно отправить сообщения в различные очереди или разделы в рамках одной транзакции.
- Невозможно настроить автоматическое удаление секционированной очереди или раздела, когда они становятся неактивными.
- При построении межплатформенных или гибридных решений в настоящее время нельзя использовать секционированные очереди и расширенный протокол управления очередью сообщений (AMQP).

## Стратегии секционирования для Azure DocumentDB

Azure DocumentDB — это база данных NoSQL, созданная для хранения документов. Документ в DocumentDB является представлением сериализации JSON объекта или другой части данных. Фиксированные схемы не применяются, за исключением того, что каждый документ должен содержать уникальный идентификатор.

Документы организованы в коллекции. Коллекция позволяет группировать связанные документы. Например, в системе, которая хранит сообщения блогов, можно хранить содержимое каждой записи блога в виде документа в коллекции. Можно также создавать коллекции для каждого типа субъекта. Кроме того, в мультитенантном приложении, таком как система, позволяющая разным авторам управлять собственными блогами и записями, можно секционировать блоги по авторам и создавать отдельную коллекцию для каждого автора. Выделенное для коллекций дисковое пространство гибкое и может уменьшаться или увеличиваться по мере необходимости.

Коллекция документов предоставляет естественный механизм для секционирования данных в пределах отдельной базы данных. База данных DocumentDB может внутренне охватывать несколько серверов и пытаться балансировать нагрузку путем распределения коллекций между серверами. Самый простой способ реализации сегментирования — создание коллекции для каждого сегмента.

> [AZURE.NOTE] Каждая база данных DocumentDB имеет _уровень производительности_, который определяет объем получаемых им ресурсов. Каждый уровень производительности связан с ограничением частоты в виде _единицы запроса_ (RU). Ограничение частоты RU определяет объем ресурсов, которые зарезервированы для этой коллекции и доступны для эксклюзивного использования этой коллекцией. Стоимость коллекции зависит от выбранного для нее уровня производительности. Чем выше уровень производительность (и ограничение частоты RU), тем выше стоимость. Уровень производительности коллекции можно настроить с помощью портала Azure. Дополнительные сведения см. на странице [Уровни производительности в DocumentDB] на веб-сайте Майкрософт.

Все базы данных создаются в контексте учетной записи DocumentDB. Одна учетная запись DocumentDB может содержать несколько баз данных и указывает, в каком регионе создаются базы данных. Каждая учетная запись DocumentDB также обеспечивает собственный контроль доступа. Можно использовать учетные записи DocumentDB для обнаружения сегментов (коллекций в базах данных), географически близких к пользователям, которым необходим к ним доступ, и наложить ограничения, чтобы к ним могли подключаться только такие пользователи.

Каждая учетная запись DocumentDB имеет квоту, ограничивающую количество баз данных и коллекций, которые она может содержать, а также доступный объем хранилища документов. Эти ограничения могут измениться. Текущие ограничения описаны на странице [Ограничения и квоты DocumentDB] на веб-сайте Майкрософт. При реализации системы, где все сегменты принадлежат одной базе данных, теоретически возможно достичь предельной емкости хранилища в учетной записи.

В этом случае может потребоваться создать дополнительные учетные записи и базы данных DocumentDB и распределить сегменты между этими базами данных. Даже если вы не ожидаете превышения емкости хранилища базы данных, целесообразно использовать несколько баз данных. Это связано с тем, что каждая база данных имеет собственный набор пользователей и разрешений. Этот механизм позволяет изолировать доступ к коллекциям отдельно для каждой базы данных.

На рисунке 8 показана структура высокого уровня архитектуры DocumentDB.

![Структура DocumentDB](media/best-practices-data-partitioning/DocumentDBStructure.png)

_Рис. 8. Структура DocumentDB_

Клиентское приложение должно отвечать за направление запросов в соответствующий сегмент, обычно путем реализации собственного механизма сопоставления на основе некоторых атрибутов данных, которые определяют ключ сегмента. Рис. 9 демонстрирует две базы данных DocumentDB, каждая из которых содержит две коллекции, действующие как сегменты. Данные сегментируются по идентификатору клиента и содержат данные конкретного клиента. Базы данных создаются в отдельных учетных записях DocumentDB. Эти учетные записи находятся в том же регионе, что и клиенты, данные которых они содержат. Логика маршрутизации в клиентском приложении использует идентификатор клиента как ключ сегментирования.

![Реализация сегментирования с помощью Azure DocumentDB](media/best-practices-data-partitioning/DocumentDBPartitions.png)

_Рис. 9. Реализации сегментирования с помощью Azure DocumentDB_

Принимая решение о том, как секционировать данные с помощью DocumentDB, учитывайте следующие моменты.

- **Ресурсы, доступные базе данных DocumentDB, могут быть ограничены квотами учетной записи DocumentDB**. Каждая база данных может содержать несколько коллекций (здесь тоже есть ограничение), каждая из которых связана с уровнем производительности, который управляет ограничением частоты RU (зарезервированной пропускной способностью) для этой коллекции. Дополнительные сведения см. на странице [Ограничения и квоты DocumentDB] на веб-сайте Майкрософт.
- **Каждый документ должен иметь атрибут, который используется для идентификации этого документа в пределах содержащей его коллекции**. Этот атрибут отличается от ключа сегмента, который определяет, в какой коллекции содержится документ. Коллекция может содержать большое количество документов. Теоретически она ограничена только максимальной длиной идентификатора документа. Идентификатор документа может включать до 255 символов.
- **Все операции с документом выполняются в контексте транзакции. Транзакции в DocumentDB относятся к коллекции, в которой содержится документ.** Если произошел сбой операции, происходит откат выполняемой работы. Пока выполняется операция с документом, любые сделанные изменения подвергаются изоляции уровня моментальных снимков. Этот механизм гарантирует, что если, например, запрос на создание нового документа завершается ошибкой, другой пользователь, одновременно запрашивающий базу данных, не увидит частичный документ, который затем удаляется.
- **Запросы DocumentDB также ограничиваются уровнем коллекции**. Один запрос может получать данные только из одной коллекции. Если требуется получить данные из нескольких коллекций, необходимо запросить каждую коллекцию отдельно и объединить результаты в коде приложения.
- **DocumentDB поддерживает программируемые элементы, которые могут храниться в коллекции вместе с документами**. Это хранимые процедуры, определяемые пользователем функции и триггеры (на языке JavaScript). Эти элементы могут получить доступ к любому документу в одной коллекции. Кроме того, эти элементы выполняются либо внутри области внешней транзакции (в случае триггера, срабатывающего в результате операций создания, удаления и замены документа), либо путем запуска новой транзакции (в случае хранимой процедуры, выполняемой в результате явного запроса клиента). Если код в программируемом элементе создает исключение, транзакция откатывается. Чтобы сохранить целостность и согласованность между документами, можно использовать хранимые процедуры и триггеры, но эти документы всегда должны быть частью одной коллекции.
- **Коллекции, которые планируется хранить в базах данных в учетной записи DocumentDB, вряд ли будут превышать ограничения пропускной способности, определяемые уровнями производительности коллекций**. Эти ограничения описаны на странице [Требования емкости DocumentDB] на веб-сайте Майкрософт. Если предполагается превышение этих ограничений, рассмотрите возможность разделения коллекций между базами данных в различных учетных записях DocumentDB, чтобы снизить нагрузку на коллекции.

## Стратегии секционирования для поиска Azure

Возможность поиска данных часто является основным методом навигации и просмотра, который предоставляют многие веб-приложения. Она позволяет пользователям быстро находить ресурсы (например продукты в приложении электронной коммерции) на основе сочетания условий поиска. Служба поиска Azure предоставляет возможности полнотекстового поиска по веб-содержимому и включает такие функции, как автозаполнение, предлагаемые запросы на основании совпадений и многогранная навигация. Полное описание этих возможностей см. на странице [Что такое поиск Azure] на веб-сайте Майкрософт.

Служба поиска Azure хранит подлежащее поиску содержимое как документы JSON в базе данных. Можно определить индексы, которые указывают поля для поиска в этих документах, и предоставить эти определения службе поиска Azure. Когда пользователь отправляет поисковый запрос, служба поиска Azure использует соответствующие индексы для поиска совпадающих элементов.

Чтобы снизить количество конфликтов, можно разделить хранилища, используемые службой поиска Azure, на 1, 2, 3, 4, 6 или 12 секций, и каждую секцию реплицировать до 6 раз. Произведение числа секций и числа реплик называется _единицей поиска_ (SU). Один экземпляр службы поиска Azure может содержать не более 36 единиц поиска (база данных с 12 секциями поддерживает не более 3 реплик).

Плата взимается за каждую единицу поиска, выделенную для службы. При увеличении объема содержимого для поиска или скорости запросов поиска можно добавить единицы поиска в существующий экземпляр службы поиска Azure для обработки дополнительной нагрузки. Сама служба поиска Azure отвечает за равномерное распределение документов по секциям. Сейчас стратегии секционирования вручную не поддерживаются.

Каждая секция может содержать не более 15 миллионов документов или занимать не более 300 ГБ дискового пространства (в зависимости от того, какое значение ниже). Можно создать до 50 индексов. Производительность службы зависит от сложности документов, доступных индексов и эффектов задержки в сети. В среднем одна реплика (1 единица поиска) должна уметь обрабатывать 15 запросов в секунду (QPS), хотя рекомендуется выполнить тестирование производительности со своими данными, чтобы получить более точные показатели пропускной способности. Дополнительные сведения см. на странице [Ограничения службы поиска Azure] на веб-сайте Майкрософт.

> [AZURE.NOTE] В документах для поиска можно хранить ограниченный набор типов данных: строки, логические значения, числовые данные, данные даты и времени и географические данные. Дополнительные сведения см. на странице [Поддерживаемые типы данных (поиск Azure)] на веб-сайте Майкрософт.

Вы можете лишь частично контролировать то, как служба поиска Azure секционирует данные для каждого экземпляра службы. Однако в глобальной среде можно повысить производительность и снизить задержку и количество конфликтов за счет секционирования самой службы одним из следующих способов.

- Создайте экземпляр службы поиска Azure в каждом географическом регионе и убедитесь, что клиентские приложения направляются к ближайшему доступному экземпляру. Эта стратегия требует своевременной репликации всех обновлений содержимого для поиска во всех экземплярах службы.

- Создайте два уровня службы поиска Azure:
    - локальную службу в каждом регионе, которая содержит наиболее часто применяемые пользователями этого региона данные. Пользователи могут направлять запросы в локальную службу для получения быстрых, но ограниченных результатов.
    - Глобальная служба, которая включает в себя все данные. Пользователи могут направлять запросы в глобальную службу для получения менее быстрых, но более полных результатов.

Этот подход наиболее эффективен при значительных региональных различиях в данных, по которым выполняется поиск.

## Стратегии секционирования кэша Redis для Azure

Кэш Redis для Azure предоставляет службу общего кэша в облаке, которая основана на хранилище данных Redis типа ключ-значение. Как понятно из названия, кэш Redis для Azure создан как решение для кэширования. Поэтому его следует использовать только для хранения временных данных, а не как постоянное хранилище данных. Приложения, использующие кэш Redis для Azure, должны иметь возможность продолжать работу, даже если кэш недоступен. Кэш Redis для Azure поддерживает первичную или вторичную репликацию для обеспечения высокой доступности, но сейчас максимальный размер кэша ограничен 53 ГБ. Если требуется больше места, необходимо создать дополнительные кэши. Дополнительные сведения см. на странице [Кэш Redis для Azure] на веб-сайте Майкрософт.

Секционирование хранилища данных Redis включает в себя разбиение данных по экземплярам службы Redis. Каждый экземпляр представляет одну секцию. Кэш Redis для Azure абстрагирует службы Redis за фасадом и не раскрывает их напрямую. Самый простой способ реализации секционирования — создание нескольких кэшей Redis для Azure и распределение информации между ними.

Каждый элемент данных можно связать с идентификатором (ключом секции), который указывает, в каком кэше его следует хранить. Логика клиентского приложения может использовать этот идентификатор для перенаправления запросов в соответствующую секцию. Эта схема очень проста, но при изменении схемы секционирования (например, если создаются дополнительные кэши Redis для Azure) может потребоваться изменение конфигурации клиентских приложений.

Собственный Redis (не кэш Redis для Azure) поддерживает серверную часть секционирования на основе кластеризации Redis. При таком подходе данные делятся поровну между серверами с помощью механизма хэширования. На каждом сервере Redis хранятся метаданные, описывающие диапазон содержащихся в секции хэш-ключей, а также сведения о хэш-ключах, которые находятся в секциях на других серверах.

Клиентские приложения просто отправляют запросы на любой сервер-участник Redis (скорее всего, на ближайший). Сервер Redis проверяет запрос клиента. Если его можно разрешить локально, сервер выполняет запрошенную операцию. В противном случае он перенаправляет запрос на соответствующий сервер.

Эта модель реализуется с помощью кластеризации Redis и более подробно описана на странице [Учебник по кластерам Redis] на веб-сайте Redis. Кластеризация Redis прозрачна для клиентских приложений. В кластер можно добавлять дополнительные серверы Redis (а также повторно секционировать данные) без необходимости перенастройки клиентов.

> [AZURE.IMPORTANT] Кэш Redis для Azure в настоящее время не поддерживает кластеризацию Redis. Если вы хотите реализовать такой подход с Azure, необходимо сначала реализовать собственные серверы Redis, установив Redis на набор виртуальных машин Azure и настроив их вручную. На странице [Запуск Redis на виртуальной машине CentOS Linux в Azure] на веб-сайте Майкрософт содержится пример, показывающий, как создать и настроить узел Redis, запущенный в качестве виртуальной машины Azure.

Подробнее о реализации секционирования с помощью Redis см. на странице [Секционирование: распределение данных между несколькими экземплярами Redis] на веб-сайте Redis. В оставшейся части этого раздела предполагается, что вы реализуете секционирование на стороне клиента или через прокси-сервер.

При выборе способа секционирования данных с помощью кэша Redis для Azure учитывайте следующие моменты.

- Кэш Redis для Azure не предназначен для работы в качестве постоянного хранилища данных, поэтому, какую бы схему секционирования вы ни выбрали, код приложения должен быть готов извлекать данные из источника, не являющегося кэшем.
- Часто используемые данные необходимо размещать в одной секции. Redis — это эффективное хранилище типа ключ-значение, которое предоставляет несколько значительно оптимизированных механизмов для структурирования данных. Механизмы могут быть следующими:
    - простые строки (двоичные данные длиной до 512 МБ);
    - агрегатные типы, такие как списки (которые могут выступать в качестве очередей и стеков);
    - наборы (упорядоченные и неупорядоченные);
    - хэши (которые могут группировать связанные поля, например элементы, представляющие поля в объекте).

- Агрегатные типы позволяют связывать несколько взаимосвязанных значений с одним ключом. Ключ Redis определяет список, набор или хэш, а не элементы данных, которые он содержит. Все эти типы доступны в кэше Redis для Azure и описаны на странице [Типы данных] на веб-сайте Redis. Например, в части системы электронной коммерции, отслеживающей размещенные клиентами заказы, подробные сведения о каждом клиенте могут храниться в хэше Redis, зашифрованном с помощью идентификатора клиента. Каждый хэш может содержать коллекцию идентификаторов заказов клиента. Отдельный набор Redis может содержать заказы, опять же структурированные как хэши, зашифрованные с помощью идентификатора заказа. Эта структура показана на рис. 10. Обратите внимание, что Redis не реализует какую-либо форму целостности данных, поэтому разработчик сам должен обеспечить связь между клиентами и заказами.

![Предлагаемая структура в хранилище Redis для записи заказов клиентов и сведений о них](media/best-practices-data-partitioning/RedisCustomersandOrders.png)

_Рис. 10. Предлагаемая структура в хранилище Redis для записи заказов клиентов и сведений о них_

> [AZURE.NOTE] В Redis все ключи являются значениями двоичных данных (например строки Redis) и могут содержать до 512 МБ данных. В теории ключ может содержать почти любую информацию. Однако рекомендуется использовать согласованный контекст именования ключей, согласно которому имя должно описывать тип данных и определять сущность, но не быть слишком длинным. Распространенный подход — использовать ключи в формате "entity\_type: ID". Например, можно использовать "customer: 99", чтобы указать ключ для клиента с идентификатором 99.

- Можно реализовать вертикальное секционирование, сохраняя связанные сведения в различных агрегатах в одной базе данных. Например, в приложении электронной коммерции можно хранить часто используемые сведения о продуктах в одном хэше Redis, а реже используемые сведения — в другом. Оба хэша могут использовать один и тот же идентификатор продукта как часть ключа. Например, "product:_nn_", где _nn_ — идентификатор продукта для сведений о продукте, и "product\_details:_nn_" для подробного описания. Эта стратегия позволяет сократить объем данных, к которым обращается большинство запросов.
- Перераспределение хранилища данных Redis является сложной задачей, которая требует много времени. Кластеризация Redis может секционировать данные автоматически, но эта возможность не поддерживается в кэше Redis для Azure. Таким образом, при разработке схемы секционирования попытайтесь оставить достаточно свободного места в каждой секции, чтобы учесть ожидаемый со временем рост данных. Однако помните, что кэш Redis для Azure предназначен для временного кэширования данных, а также что у данных, хранящихся в кэше, может быть ограниченное время существования, указанное как значение срока жизни (TTL). Для относительно временных данных значение TTL должно быть коротким, но для статических данных значение TTL может быть гораздо большим. Не следует хранить большие объемы долгоживущих данных в кэше, если эти данные, скорее всего, переполнят кэш. Можно указать политику вытеснения, согласно которой кэш Redis для Azure будет удалять данные, если места осталось мало.

	> [AZURE.NOTE] Кэш Redis для Azure дает возможность указать максимальный размер кэша (от 250 МБ до 53 ГБ) при выборе соответствующей ценовой категории. Однако после создания кэша Redis для Azure нельзя увеличить (или уменьшить) его размер.

- Пакеты и транзакции Redis не могут охватывать несколько подключений, поэтому все данные, затрагиваемые пакетом или транзакцией, должны храниться в одной базе данных (в одном сегменте).

	> [AZURE.NOTE] Последовательность операций в транзакции Redis не обязательно является неделимой. Команды, которые составляют транзакцию, проверяются и добавляются в очередь перед выполнением. Если на этом этапе возникает ошибка, вся очередь удаляется. Однако после успешной отправки транзакции команды в очереди будут выполняться последовательно. Если какая-либо из команд завершается ошибкой, прерывается только эта команда. Все предыдущие и последующие команды выполняются по очереди. Дополнительные сведения см. на странице [Транзакции] на веб-сайте Redis.

- Redis поддерживает ограниченное число атомарных операций. Единственными операциями такого типа, которые поддерживают несколько ключей, являются MGET и MSET. Операции MGET возвращают коллекцию значений для указанного списка ключей, а операции MSET сохраняют коллекцию значений для указанного списка ключей. Если необходимо использовать эти операции, пары ключ-значение, на которые ссылаются команды MSET и MGET, должны храниться в той же базе данных.

## Балансировка секций

По мере того как система развивается и схемы использования становятся более понятны, может возникнуть необходимость изменить схему секционирования. Например, отдельные секции могут начать привлекать непропорциональный объем трафика и становятся горячими точками, что приводит к слишком большому количеству конфликтов. Кроме того, вы могли недооценить объем данных в некоторых секциях, в результате чего достигли пределов емкости хранилища в этих секциях. Какой бы ни была причина, иногда необходимо повторно сбалансировать секции, чтобы более равномерно распределить нагрузку.

В некоторых случаях системы хранения данных, которые не демонстрируют способ распределения данных на серверах, могут автоматически балансировать секции в пределах доступных ресурсов. В других ситуациях перераспределение является административной задачей, которая состоит из двух этапов.

1. Сначала необходимо определить новую стратегию секционирования, чтобы понять следующие моменты:
    - Какие секции необходимо разделить (или, возможно, объединить).
    - Как разместить данные в этих новых секциях, создав новые ключи секций.
2. Затем необходимо перенести затронутые данные из старой схемы секционирования в новый набор секций.

> [AZURE.NOTE] Сопоставление коллекций DocumentDB серверам является прозрачным, но вы можете достигнуть предела емкости хранилища и пропускной способности учетной записи DocumentDB. В этом случае потребуется изменить схему секционирования и перенести данные.

В зависимости от технологии хранения данных и структуры системы хранения данных у вас может быть возможность перенести данные между секциями, не останавливая их использование (оперативная миграция). Если это невозможно, потребуется заблокировать доступ к соответствующим секциям на время перемещения данных (автономная миграция).

## Автономная миграция

Автономная миграция, возможно, является самым простым подходом, так как уменьшает вероятность возможных конфликтов. Не вносите никаких изменений в данные во время перемещения и реструктуризации.

По сути, этот процесс включает в себя следующие шаги:

1. пометить сегменты как отключенные;
2. разделить или объединить сегменты и переместить данные в новые сегменты;
3. проверить данные;
4. подключить новые сегменты;
5. удалить старый сегмент.

Чтобы сохранить некоторую доступность, можно в шаге 1 сделать исходный сегмент доступным только для чтения, а не полностью недоступным. Это позволит приложениям считывать данные во время перемещения, но не изменять их.

## Оперативная миграция

Оперативную миграцию реализовать сложнее, но удобнее для пользователей, так как данные остаются доступными во время всей процедуры. Процесс аналогичен процессу автономной миграции, за исключением того, что исходный сегмент не помечается как отключенный (шаг 1). В зависимости от гранулярности процесса миграции (например по элементу или по сегменту), коду доступа к данным в клиентских приложениях может понадобиться считывать и записывать данные, находящиеся в двух расположениях (в исходном сегменте и в новом).

Пример решения, которое поддерживает оперативную миграцию, см. в разделе [Масштабирование с применением средства разбиения и объединения гибкой базы данных] на веб-сайте Майкрософт.

## Связанные шаблоны и рекомендации

При выборе стратегии реализации согласованности данных для вашего сценария также могут быть полезны указанные далее шаблоны.

- [Руководство по согласованности данных] на веб-сайте Майкрософт описывает стратегии для поддержания согласованности в распределенной среде, например в облаке.
- На странице [Рекомендации по секционированию данных] на веб-сайте Майкрософт предоставлены общие сведения по проектированию секций для удовлетворения различных критериев в распределенном решении.
- [Шаблон сегментирования], описанный на веб-сайте Майкрософт, включает некоторые распространенные стратегии для сегментирования данных.
- [Шаблон таблицы индексов], описанный на веб-сайте Майкрософт, иллюстрирует создание вторичных индексов данных. Такой подход позволяет приложению быстро получить данные с помощью запросов, которые не ссылаются на первичный ключ коллекции.
- [Шаблон материализованного представления], представленный на веб-сайте Майкрософт, описывает, как создавать предварительно заполненные представления, которые отображают итоговые данные для поддержки операций быстрого запроса. Этот подход можно использовать в секционированном хранилище данных, если секции, содержащие итоговые данные, распределены по нескольким сайтам.
- Статья [Использование CDN для Azure] на веб-сайте Майкрософт предоставляет дополнительные рекомендации по настройке и использовании сети доставки содержимого с помощью Azure.

## Дополнительные сведения

- На странице [Что такое база данных SQL Azure] на веб-сайте Майкрософт представлена подробная документация, в которой описываются способы создания и использования базы данных SQL.
- Дополнительные сведения об эластичной базе данных см. на странице [Общие сведения о возможностях эластичных баз данных] на веб-сайте Майкрософт.
- На странице [Масштабирование с использованием инструмента разбиения и объединения эластичных баз данных] веб-сайта Майкрософт содержатся сведения об использовании службы разбиения и объединения для управления сегментами эластичной базы данных.
- На странице [Целевые показатели производительности и масштабируемости хранилища Azure](https://msdn.microsoft.com/library/azure/dn249410.aspx) на веб-сайте Майкрософт перечислены текущие ограничения размера и пропускной способности хранилища Azure.
- На странице [Выполнение групповых транзакций сущности] на веб-сайте Майкрософт предоставлены подробные сведения о реализации транзакционных операций по сущностям, хранящимся в хранилище таблиц Azure.
- Статья [Руководство по разработке таблиц хранилища Azure] на веб-сайте Майкрософт содержит подробные сведения о секционировании данных в хранилище таблиц Azure.
- На странице [Использование CDN для Azure] веб-сайта Майкрософт описывается, как реплицировать данные, хранящиеся в хранилище BLOB-объектов Azure, с помощью сети доставки содержимого Azure.
- Страница [Управление потребностями в емкости DocumentDB] на веб-сайте Майкрософт содержит сведения о том, каким образом Azure DocumentDB выделяет ресурсы базам данных.
- Страница [Что такое поиск Azure] на веб-сайте Майкрософт содержит полное описание возможностей, доступных в службе поиска Azure.
- На странице [Ограничения службы поиска Azure] на веб-сайте Майкрософт представлены сведения о емкости каждого экземпляра службы поиска Azure.
- На странице [Поддерживаемые типы данных (служба поиска Azure)] на веб-сайте Майкрософт перечислены типы данных, которые можно использовать в документах и индексах для поиска.
- На странице [Кэш Redis для Azure] на веб-сайте Майкрософт представлено введение в кэш Redis для Azure.
- На странице [Секционирование: распределение данных между несколькими экземплярами Redis] на веб-сайте Redis содержатся сведения о реализации секционирования с использованием Redis.
- На странице [Запуск Redis на виртуальной машине CentOS Linux в Azure] на веб-сайте Майкрософт содержится пример, показывающий, как создать и настроить узел Redis, запущенный в качестве виртуальной машины Azure.
- На странице [Типы данных] на веб-сайте Redis описаны типы данных, которые доступны в Redis и кэше Redis для Azure.

[Кэш Redis для Azure]: http://azure.microsoft.com/services/cache/
[Кэш Redis для Azure]: http://azure.microsoft.com/services/cache/
[Целевые показатели масштабируемости и производительности хранилища Azure]: storage/storage-scalability-targets.md
[Целевые показатели производительности и масштабируемости хранилища Azure]: storage/storage-scalability-targets.md
[Руководство по разработке таблиц хранилища Azure]: storage/storage-table-design-guide.md
[Руководство по разработке хранилищ таблиц Azure]: storage/storage-table-design-guide.md
[Построение решения Polyglot]: https://msdn.microsoft.com/library/dn313279.aspx
[Доступ к данным для масштабируемых решений: с помощью SQL, NoSQL и Polyglot Persistence]: https://msdn.microsoft.com/library/dn271399.aspx
[Руководство по согласованности данных]: http://aka.ms/Data-Consistency-Primer
[руководстве по согласованности]: http://aka.ms/Data-Consistency-Primer
[руководством по согласованности данных]: http://aka.ms/Data-Consistency-Primer
[Рекомендации по секционированию данных]: https://msdn.microsoft.com/library/dn589795.aspx
[Типы данных]: http://redis.io/topics/data-types
[Ограничения и квоты DocumentDB]: documentdb/documentdb-limits.md
[Общие сведения о возможностях эластичных баз данных]: sql-database/sql-database-elastic-scale-introduction.md
[программы миграции федераций]: https://code.msdn.microsoft.com/vstudio/Federations-Migration-ce61e9c1
[Шаблон таблицы индексов]: http://aka.ms/Index-Table-Pattern
[шаблона таблицы индексов]: http://aka.ms/Index-Table-Pattern
[Требования емкости DocumentDB]: documentdb/documentdb-manage.md
[Управление потребностями в емкости DocumentDB]: documentdb/documentdb-manage.md
[Шаблон материализованного представления]: http://aka.ms/Materialized-View-Pattern
[Запросы к нескольким сегментам]: sql-database/sql-database-elastic-scale-multishard-querying.md
[Секционирование: распределение данных между несколькими экземплярами Redis]: http://redis.io/topics/partitioning
[Уровни производительности в DocumentDB]: documentdb/documentdb-performance-levels.md
[Выполнение групповых транзакций сущности]: https://msdn.microsoft.com/library/azure/dd894038.aspx
[Учебник по кластерам Redis]: http://redis.io/topics/cluster-tutorial
[Запуск Redis на виртуальной машине CentOS Linux в Azure]: http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx
[Масштабирование с использованием инструмента разбиения и объединения эластичных баз данных]: sql-database/sql-database-elastic-scale-overview-split-and-merge.md
[Масштабирование с применением средства разбиения и объединения гибкой базы данных]: sql-database/sql-database-elastic-scale-overview-split-and-merge.md
[Масштабирование с применением средства разбиения и объединения эластичной базы данных]: sql-database/sql-database-elastic-scale-overview-split-and-merge.md
[Использование CDN для Azure]: cdn/cdn-how-to-use-cdn.md
[Использование сети доставки содержимого для Azure]: cdn/cdn-how-to-use-cdn.md
[Квоты на служебную шину]: service-bus/service-bus-quotas.md
[Ограничения службы поиска Azure]: search/search-limits-quotas-capacity.md
[Ограничения службы поиска Azure]: search/search-limits-quotas-capacity.md
[Шаблон сегментирования]: http://aka.ms/Sharding-Pattern
[Поддерживаемые типы данных (поиск Azure)]: https://msdn.microsoft.com/library/azure/dn798938.aspx
[Поддерживаемые типы данных (служба поиска Azure)]: https://msdn.microsoft.com/library/azure/dn798938.aspx
[Транзакции]: http://redis.io/topics/transactions
[Что такое поиск Azure]: search/search-what-is-azure-search.md
[Что такое база данных SQL Azure]: sql-database/sql-database-technical-overview.md

<!---HONumber=AcomDC_0330_2016-->