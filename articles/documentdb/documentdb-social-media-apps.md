<properties 
	pageTitle="Конструктивный шаблон DocumentDB: приложения социальных сетей | Microsoft Azure" 
	description="Узнайте о конструктивном шаблоне для социальных сетей, используя гибкие возможности хранения данных DocumentDB и другие службы Azure." 
	keywords="Приложения социальных сетей"
	services="documentdb" 
	authors="ealsur" 
	manager="" 
	editor="" 
	documentationCenter=""/>

<tags 
	ms.service="documentdb" 
	ms.workload="data-services" 
	ms.tgt_pltfrm="na" 
	ms.devlang="na" 
	ms.topic="article" 
	ms.date="03/28/2016" 
	ms.author="ealsur@hotmail.com"/>

# Использование социальных сетей с помощью DocumentDB

Жизнь в сильно взаимосвязанном обществе означает, что в определенный момент вы присоединяетесь к **социальной сети**. Мы используем социальные сети, чтобы поддерживать связь с друзьями, коллегами и родными, а иногда — чтобы делиться увлечением с теми, кто разделяет ваши интересы.

Как специалисты и разработчики, мы могли задаваться вопросом, как эти сети хранят и связывают наши данные, или даже самостоятельно участвовать в создании или проектировании новой социальной сети для какой-нибудь специфической ниши рынка. Именно тогда возникает главный вопрос: как хранятся все эти данные?

Предположим, что мы создаем новую яркую социальную сеть, где наши пользователи могут публиковать статьи с сопутствующими материалами, например изображениями, видео или даже музыкой. Пользователи могут комментировать записи и оценивать их с помощью очков. В сети будет веб-канал записей, которые пользователи смогут видеть, также они смогут взаимодействовать с целевой страницей основного веб-сайта. Все выглядит не очень сложным (сначала), но для простоты давайте остановимся на этом (можно углубиться в настраиваемые пользовательские веб-каналы, на которые влияют связи, но это не входит в задачи этой статьи).

Итак, как все это хранить и где?

Многие из вас могут иметь опыт работы с базами данных SQL или хотя бы иметь понятие о [реляционном моделировании данных](https://en.wikipedia.org/wiki/Relational_model), и вам не терпится начать рисовать примерно следующее.

![Схема, иллюстрирующая относительную реляционную модель](./media/documentdb-social-media-apps/social-media-apps-sql.png)

Идеально нормализованная и аккуратная структура данных… которая не масштабируется.

Не поймите меня неправильно, я всю жизнь работал с базами данных SQL. Они удобны, но, как и в случае с любой методикой, практикой и программной платформой, они не подходят идеально для всех сценариев.

Почему SQL — не наилучший вариант для этого сценария? Рассмотрим структуру одной записи. Чтобы показать эту запись на веб-сайте или в приложения, мне потребовалось бы сделать запрос с 8 соединениями таблиц (!) только для того, чтобы показать одну запись. Теперь представьте поток записей, которые динамически загружаются и отображаются на экране, и вы поймете, о чем я.

Конечно, мы могли бы использовать огромный экземпляр SQL с вычислительной мощностью, достаточной для обработки тысяч запросов с этим количеством соединений, чтобы обслуживать наше содержимое, но для чего тогда существует более простое решение?

## Путь NoSQL

Существуют специальные графовые базы данных, которые можно [использовать в Azure](http://neo4j.com/developer/guide-cloud-deployment/#_windows_azure), но они не дешевые, и для них требуются службы IaaS (инфраструктура как служба, в основном это виртуальные машины) и обслуживание. Я собираюсь посвятить эту статью более дешевому решению, которое подойдет для большинства сценариев и выполняется в базе данных NoSQL для Azure, [DocumentDB](https://azure.microsoft.com/services/documentdb/). Используя [NoSQL](https://en.wikipedia.org/wiki/NoSQL), храня данные в формате JSON и применяя [денормализацию](https://en.wikipedia.org/wiki/Denormalization), нашу запись, которая ранее представлялась сложной, можно преобразовать в один [документ](https://en.wikipedia.org/wiki/Document-oriented_database).

    {
        "id":"ew12-res2-234e-544f",
        "title":"post title",
        "date":"2016-01-01",
        "body":"this is an awesome post stored on NoSQL",
        "createdBy":User,
        "images":["http://myfirstimage.png","http://mysecondimage.png"],
        "videos":[
            {"url":"http://myfirstvideo.mp4", "title":"The first video"},
            {"url":"http://mysecondvideo.mp4", "title":"The second video"}
        ],
        "audios":[
            {"url":"http://myfirstaudio.mp3", "title":"The first audio"},
            {"url":"http://mysecondaudio.mp3", "title":"The second audio"}
        ]
    }

И его можно получить с помощью одного запроса без каких-либо операций соединения. Это намного проще, эффективнее и экономнее, и для достижения наилучшего результата требуется меньше ресурсов.

Azure DocumentDB обеспечивает индексирование всех свойств с помощью [автоматического индексирования](documentdb-indexing.md), которое даже можно [настроить](documentdb-indexing-policies.md). Эта методика без использования схемы позволяет хранить документы с различными динамическими структурами. Возможно, завтра нам понадобятся записи со списком категорий или хэш-тегами, связанными с ними. DocumentDB будет обрабатывать новые документы с помощью добавленных атрибутов, и для этого нам не придется ничего делать дополнительно.

Комментарии к записи можно считать такими же записями, но со свойством родительской записи (это упрощает сопоставление объектов).

    {
        "id":"1234-asd3-54ts-199a",
        "title":"Awesome post!",
        "date":"2016-01-02",
        "createdBy":User2,
        "parent":"ew12-res2-234e-544f"
    }

    {
        "id":"asd2-fee4-23gc-jh67",
        "title":"Ditto!",
        "date":"2016-01-03",
        "createdBy":User3,
        "parent":"ew12-res2-234e-544f"
    }

И все взаимодействия в социальной сети могут храниться в отдельном объекте как счетчики.

    {
        "id":"dfe3-thf5-232s-dse4",
        "post":"ew12-res2-234e-544f",
        "comments":2,
        "likes":10,
        "points":200
    }

Создание веб-каналов — это просто создание документов, которые могут содержать список идентификаторов записей в указанном порядке релевантности.

    [
        {"relevance":9, "post":"ew12-res2-234e-544f"},
        {"relevance":8, "post":"fer7-mnb6-fgh9-2344"},
        {"relevance":7, "post":"w34r-qeg6-ref6-8565"}
    ]

Мы можем создать поток "Последние" с сообщениями, упорядоченными по дате создания, а также поток "Популярные" с записями, которые понравились наибольшему числу пользователей за последние 24 часа. Мы даже можем реализовать настраиваемый поток для каждого пользователя, например, основанный на логике, учитывающей число подписчиков и интересы, и все равно это будет список записей. Важно то, как создаются эти списки, а производительность чтения остается неизменной. Получив один из этих списков, мы выполним один запрос к DocumentDB с помощью [оператора IN](documentdb-sql-query.md#where-clause), чтобы получить сразу несколько страниц записей.

Потоки веб-канала можно создать с использованием фоновых процессов [служб приложений Azure](https://azure.microsoft.com/services/app-service/) — [веб-заданий](../app-service-web/web-sites-create-web-jobs.md). После создания записи фоновую обработку можно активировать с помощью [очередей](../storage/storage-dotnet-how-to-use-queues.md) [хранилища Azure](https://azure.microsoft.com/services/storage/), а веб-задания можно активировать с помощью [пакета SDK веб-заданий](../app-service-web/websites-dotnet-webjobs-sdk.md), реализовав распространение записей в потоках на основе собственной настраиваемой логики.

Очки и отметки "Нравится" записи могут обрабатываться с отсрочкой, этот же подход применяется для создания согласованной среды.

## Дублирование данных и шаблон "Лестница"

Как можно заметить, в документе JSON, на который ссылается запись, существует несколько вхождений данных пользователя. Как вы уже догадались, это означает, что данные, представляющие пользователя (с учетом денормализации), могут находиться в нескольких местах.

Чтобы ускорить обработку запросов, мы применяем дублирование данных. Побочный эффект состоит в том, что если какое-либо действие меняет данные пользователя, нам нужно найти все действия, которые он когда-либо выполнил, и обновить их. Звучит не слишком практично, верно?

Графовые базы данных устраняют эту проблему по-своему, мы же определим ключевые атрибуты пользователя, которые отображаются в нашем приложении для каждого действия. Если мы показываем запись в приложении только с именем и изображением автора, зачем хранить в атрибуте createdBy все данные пользователя? Если для каждого комментария мы показываем только изображение пользователя, остальные его данные не нужны. Вот когда нам пригодится то, что я называю шаблоном "Лестница".

Для примера рассмотрим информацию о пользователе.

    {
        "id":"dse4-qwe2-ert4-aad2",
        "name":"John",
        "surname":"Doe",
        "address":"742 Evergreen Terrace",
        "birthday":"1983-05-07",
        "email":"john@doe.com",
        "twitterHandle":"@john",
        "username":"johndoe",
        "password":"some_encrypted_phrase",
        "totalPoints":100,
        "totalPosts":24
    }
    
Посмотрев на эту информацию, мы можем быстро определить, какая информация важна, а какая — нет, тем самым строя "лестницу".

![Схема шаблона "Лестница"](./media/documentdb-social-media-apps/social-media-apps-ladder.png)

Наименьший объект называется блоком пользователя, это минимальный объем информации, идентифицирующий пользователя и используемый для дублирования данных. Уменьшая размер дублируемых данных только до "видимой" информации, мы снизим вероятность масштабных обновлений.

Средний объект называется пользователем, это полные данные, которые будут использоваться в большинстве зависящих от производительности запросов в DocumentDB. Это наиболее используемые и важные данные. Пользователь содержит информацию, представленную в блоке пользователя.

Самый большой объект — расширенный пользователь. Он содержит все критически важные данные пользователя, а также другие данные, которые не требуется очень быстро считывать или которые используются при определенных условиях (например, при входе в систему). Эти данные могут храниться за пределами DocumentDB, в базе данных SQL Azure или таблицах хранилища Azure.

Зачем разделять данные пользователя и хранить эту информацию в разных местах? Затем, что объем хранилища в DocumentDB не бесконечный, а с точки зрения производительности, чем больше документы, тем дороже обходятся запросы. Используйте небольшие документы, содержащие только данные, необходимые для выполнения всех зависящих от производительности запросов для социальной сети, и храните отдельно дополнительные данные, которые используются при определенных условиях, например для полного изменения профилей, входа в систему и даже интеллектуального анализа данных для получения аналитики по использованию и инициатив по большим данным. Нам действительно не важно, если сбор данных для интеллектуального анализа данных идет медленнее, так как выполняется в базе данных SQL Azure. Зато нам важно обеспечить быстрое и удобное взаимодействие с пользователями. Данные пользователя, хранящиеся в DocumentDB, будут выглядеть следующим образом.

    {
        "id":"dse4-qwe2-ert4-aad2",
        "name":"John",
        "surname":"Doe",
        "email":"john@doe.com",
        "twitterHandle":"@john",
        "totalPoints":100,
        "totalPosts":24,
        "following":{
            "count":2,
            "list":[
                UserChunk1, UserChunk2
            ]
        }
    }

И в случае изменения, затрагивающего один из атрибутов блока, несложно найти требуемые документы с помощью запросов, которые указывают на индексированные атрибуты (SELECT * FROM posts p WHERE p.createdBy.id == “edited\_user\_id”), и затем обновить эти блоки.

## Поле поиска

К счастью, пользователи будут формировать много содержимого. И мы должны дать возможность искать и находить содержимое, которое может отсутствовать непосредственно в их потоках содержимого, возможно, потому, что они не подписались на их авторов или просто пытаются найти старую запись, созданную 6 месяцев назад.

Благодаря тому, что мы используем Azure DocumentDB, мы можем всего за несколько минут легко реализовать механизм поиска с помощью [Поиска Azure](https://azure.microsoft.com/services/search/), не вводя ни одной строки кода (кроме, разумеется, процесса поиска и пользовательского интерфейса).

Почему это так просто?

Поиск Azure реализует так называемые [индексаторы](https://msdn.microsoft.com/library/azure/dn946891.aspx), фоновые процессы, которые привязываются к репозиториям данных и автоматически добавляют, обновляют или удаляют объекты в индексах. Они поддерживают [индексаторы базы данных SQL Azure](https://blogs.msdn.microsoft.com/kaevans/2015/03/06/indexing-azure-sql-database-with-azure-search/), [индексаторы больших двоичных объектов Azure](../search/search-howto-indexing-azure-blob-storage.md) и, к счастью, [индексаторы Azure DocumentDB](../documentdb/documentdb-search-indexer.md). Переместить информацию из DocumentDB в Поиск Azure просто, так как и там, и там она хранится в формате JSON, и нам нужно [создать индекс](../search/search-create-index-portal.md) и сопоставить атрибуты из документов, которые мы хотим индексировать, и все. Через нескольких минут (зависит от размера данных) все наше содержимое будет доступно для поиска с использованием лучшего решения для "поиска как службы" в облачной инфраструктуре.

Дополнительные сведения о Поиске Azure см. в статье [Hitchhiker’s Guide to Search](https://blogs.msdn.microsoft.com/mvpawardprogram/2016/02/02/a-hitchhikers-guide-to-search/).

## Базовый набор знаний

Храня все это содержимое, которое ежедневно увеличивается, мы можем задуматься: что делать с потоком информации, поступающей от моих пользователей?

Ответ прост: включить его в работу и учиться.

Но как мы можем учиться? Из простых примеров можно привести [анализ мнений](https://en.wikipedia.org/wiki/Sentiment_analysis), т. е. рекомендации содержимого на основе предпочтений пользователя, или даже автоматический модератор содержимого, который гарантирует, что все содержимое, публикуемое в нашей социальной сети, безопасно для семьи.

Теперь, когда я заинтересовал вас, скорее всего вы думаете, что нужна кандидатская степень по математике, чтобы извлечь эти шаблоны и информацию из простых баз данных и файлов, но это не так.

[Машинное обучение Azure](https://azure.microsoft.com/services/machine-learning/), являющееся частью [Cortana Analytics Suite](https://www.microsoft.com/en/server-cloud/cortana-analytics-suite/overview.aspx), — это полностью управляемая облачная служба, которая позволяет создавать рабочие процессы с помощью алгоритмов, используя простой интерфейс с перетаскиванием, а также позволяет программировать собственные алгоритмы на [R] (https://en.wikipedia.org/wiki/R_(programming_language)) или использовать некоторые встроенные и готовые к использованию API, например [Text Analytics](https://gallery.cortanaanalytics.com/MachineLearningAPI/Text-Analytics-2), [Content Moderator](https://www.microsoft.com/moderator) или [Recommendations](https://gallery.cortanaanalytics.com/MachineLearningAPI/Recommendations-2).

## Заключение

В этой статье я попытался пролить свет на возможности создания социальных сетей полностью на платформе Azure с помощью недорогих служб, что дает превосходные результаты, поощряя к использованию решения для многоуровневого хранения данных и распределения данных, которое называется "Лестница".

![Схема взаимодействия между службами Azure для социальных сетей](./media/documentdb-social-media-apps/social-media-apps-azure-solution.png)

Дело в том, что не существует единственно верного решения для таких сценариев. Это синергия отличных служб, обеспечивающих качественную работу: скорость и свобода Azure DocumentDB для создания отличного приложения социальных сетей, интеллектуальность первоклассного решения для поиска (например, Поиска Azure), гибкость служб приложений Azure для размещения не только языконезависимых приложений, но и мощных фоновых процессов; расширяемая служба хранилища Azure и база данных SQL Azure для хранения больших объемов данных, большие аналитические возможности Машинного обучения Azure для формирования знаний и аналитики, позволяющих получать отзывы о наших процессах и доставлять пользователям именно то содержимое, которое им нужно.

## Дальнейшие действия

Узнайте больше о моделировании данных, прочитав статью [Моделирование данных в DocumentDB](documentdb-modeling-data.md). Если вас интересуют другие примеры использования DocumentDB, см. раздел [Распространенные примеры использования DocumentDB](documentdb-use-cases.md).

Или узнайте больше о DocumentDB, следуя [схеме обучения DocumentDB](https://azure.microsoft.com/documentation/learning-paths/documentdb/).

<!---HONumber=AcomDC_0330_2016-->