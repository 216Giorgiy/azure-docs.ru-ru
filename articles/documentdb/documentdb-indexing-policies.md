<properties 
    pageTitle="Политики индексирования DocumentDB | Microsoft Azure" 
    description="В этом документе объясняется, как работает индексирование для базы данных DocumentDB и как настроить и изменить политику индексирования." 
    services="documentdb" 
    documentationCenter="" 
    authors="arramac" 
    manager="jhubbard" 
    editor="monicar"/>

<tags 
    ms.service="documentdb" 
    ms.devlang="na" 
    ms.topic="article" 
    ms.tgt_pltfrm="na" 
    ms.workload="data-services" 
    ms.date="08/03/2015" 
    ms.author="mimig"/>


# Политики индексации DocumentDB

Хотя многие клиенты с удовольствием позволяют DocumentDB автоматически регулировать [все аспекты индексирования](documentdb-indexing.md), DocumentDB также поддерживает задание пользовательской **политики индексирования** для коллекций во время их создания. Политики индексирования DocumentDB обладают большей гибкостью и возможностями, чем дополнительные индексы, предлагаемые в других платформах базы данных, так как они позволяют разработать и настроить форму индекса без ущерба гибкости схемы. Управляя политикой индексирования, можно найти точный компромисс между дополнительными затратами на хранение индекса, пропускной способностью записи и запросов и согласованностью запросов.

В этой статье мы подробнее рассмотрим политики индексирования DocumentDB, настройку политики индексирования и связанные с ней компромиссы.

Ознакомившись с данной статьей, вы сможете ответить на следующие вопросы.

- Как DocumentDB поддерживает автоматическое индексирование по умолчанию?
- Как переопределить свойства, которые необходимо включить в индексацию или исключить из нее?
- Как настроить индекс для возможных обновлений?
- Как настроить индексацию для выполнения предложений Order By или запросов в диапазоне?
- Как внести изменения в политику индексирования коллекции?
- Как сравнить затраты на хранение и производительность различных политик индексирования?

##<a id="CustomizingIndexingPolicy"></a> Настройка политики индексирования коллекции

Разработчики могут регулировать компромиссы между хранилищем, производительностью записи или запросов и согласованностью запросов, переопределяя политику индексирования по умолчанию для коллекции DocumentDB и настраивая следующие аспекты.

- **Включение документов и путей в индекс и исключение их из него**. Разработчики могут выбрать определенные документы, чтобы исключить из индекса или включить их в него во время вставки или замены этих документов в коллекции. Разработчики также могут включить или исключить определенные свойства JSON, так называемые пути (включая шаблоны с подстановочными знаками), из индексации для документов, которые включены в индекс.
- **Настройка различных типов индекса**. Для каждого включенного пути разработчики могут также указать требуемый тип индекса для коллекции на основе их данных, ожидаемой рабочей нагрузки запросов и числовой или строковой «точности» каждого пути.
- **Настройка режимов обновления индекса**. DocumentDB поддерживает три режима индексирования, которые могут быть настроены с помощью политики индексирования для коллекции DocumentDB: Consistent, Lazy и None. 

В следующем фрагменте кода .NET показано, как задать пользовательскую политику индексирования во время создания коллекции. Здесь мы задаем политику с диапазонным индексом для строк и чисел с максимальной точностью. Эта политика позволяет выполнять запросы Order By к строкам.

    var collection = new DocumentCollection { Id = "myCollection" };
    
    collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;
    
    collection.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/*", 
            Indexes = new Collection<Index> { 
                new RangeIndex(DataType.String) { Precision = -1 }, 
                new RangeIndex(DataType.Number) { Precision = -1 }
            }
        });

    await client.CreateDocumentCollectionAsync(database.SelfLink, collection);   


>[AZURE.NOTE]Схема JSON для политики индексации была изменена с помощью выпуска REST API (версия 2015-06-03), чтобы поддержать диапазонные индексы для строковых значений. Новую схему политики поддерживают пакет .NET SDK 1.2.0 и Java, Python и пакеты Node.js SDK 1.1.0. Более старые пакеты SDK используют REST API версии 2015-04-08 и поддерживают старую схему политики индексации.
>
>По умолчанию DocumentDB согласованно индексирует все свойства строк в документах с помощью хэш-индекса, а числовые свойства — с помощью диапазонного индекса.

### Режимы индексирования

DocumentDB поддерживает три режима индексирования, которые могут быть настроены с помощью политики индексирования для коллекции DocumentDB — Consistent, Lazy и None.

**Consistent** (Согласованный). Если для коллекции DocumentDB указана политика «Consistent», запросы к данной коллекции DocumentDB соответствуют уровню согласованности, указанному для точечных операций чтения (т. е. strong (строгая), bounded-staleness (ограниченная с запаздыванием), session (уровня сеанса) и eventual (согласованная в конечном счете). Индекс обновляется синхронно при обновлении документа (т. е. при вставке, замене, обновлении и удалении документа в коллекции DocumentDB). Согласованное индексирование поддерживает согласованность запросов за счет возможного сокращения пропускной способности записи. Это сокращение является функцией уникальных путей, которые должны быть проиндексированы, и «уровня согласованности». Режим согласованного индексирования предназначен для рабочих нагрузок типа «быстрая запись, немедленный запрос».

**Lazy** (Асинхронный). Чтобы обеспечить максимальную пропускную способность приема документов, для коллекции DocumentDB можно настроить асинхронную согласованность, то есть когда запросы являются согласованным в конечном счете. Индекс обновляется асинхронно, когда коллекция DocumentDB не загружена, т. е. когда пропускная способность коллекции не используется полностью для обслуживания запросов пользователя. Для рабочих нагрузок типа «прием сейчас, запрос позже», требующих беспрепятственного приема документов, может подойти асинхронный режим индексирования.

**None** (Нет). У коллекции с режимом индексирования None нет связанного индекса. Настройка политики индексирования None имеет побочный эффект — удаляется любой существующий индекс.

>[AZURE.NOTE]Настройка политики индексирования None имеет побочный эффект — удаляется любой существующий индекс. Используйте этот режим, если шаблонам доступа требуются только идентификатор и (или) самоссылающаяся ссылка.

В следующем примере показано, как создать коллекцию DocumentDB с помощью пакета SDK для .NET с согласованным автоматическим индексированием всех операций вставки документа.

В следующей таблице показана согласованность запросов на основе режима индексирования (Consistent и Lazy), настроенного для коллекции, и уровня согласованности, указанного для запроса. Это относится к запросам, выполняемых с помощью любого интерфейса — интерфейс REST API, пакетов SDK или из хранимых процедур и триггеров.

<table border="0" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td valign="top">
                <p>
                </p>
            </td>
            <td valign="top">
                <p>
                    <strong>Согласованная</strong>
                </p>
            </td>
            <td valign="top">
                <p>
                    <strong>Отложенная</strong>
                </p>
            </td>            
        </tr>
        <tr>
            <td valign="top">
                <p>
                    <strong>Строгая</strong>
                </p>
            </td>
            <td valign="top">
                <p>
                    Строгая
                </p>
            </td>
            <td valign="top">
                <p>
                    В конечном счете
                </p>
            </td>            
        </tr>       
        <tr>
            <td valign="top">
                <p>
                    <strong>Ограниченное запаздывание</strong>
                </p>
            </td>
            <td valign="top">
                <p>
                    Ограниченное запаздывание
                </p>
            </td>
            <td valign="top">
                <p>
                    В конечном счете
                </p>
            </td>            
        </tr>          
        <tr>
            <td valign="top">
                <p>
                    <strong>Сеанс</strong>
                </p>
            </td>
            <td valign="top">
                <p>
                    Сеанс
                </p>
            </td>
            <td valign="top">
                <p>
                    В конечном счете
                </p>
            </td>            
        </tr>      
        <tr>
            <td valign="top">
                <p>
                    <strong>В конечном счете</strong>
                </p>
            </td>
            <td valign="top">
                <p>
                    В конечном счете
                </p>
            </td>
            <td valign="top">
                <p>
                    В конечном счете
                </p>
            </td>            
        </tr>         
    </tbody>
</table>

По умолчанию для всех запросов возвращается ошибка, если для коллекции задан режим индексирования None, чтобы указать, что для обслуживания запроса может потребоваться проверка. Эти запросы можно выполнять без диапазонного индекса с помощью заголовка `x-ms-documentdb-enable-scans` в REST API или параметра запроса `EnableScanInQuery`, используя пакет SDK для .NET. Например, некоторые запросы, которые используют ORDER BY, не допускается в режиме None даже с параметром `EnableScanInQuery`.

В следующей таблице показана согласованность запросов на основе режима индексирования (Consistent, Lazy и None), если указан параметр EnableScanInQuery.

<table border="0" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td valign="top">
                <p>
                </p>
            </td>
            <td valign="top">
                <p>
                    <strong>Согласованная</strong>
                </p>
            </td>
            <td valign="top">
                <p>
                    <strong>Отложенная</strong>
                </p>
            </td>       
            <td valign="top">
                <p>
                    <strong>None</strong>
                </p>
            </td>             
        </tr>
        <tr>
            <td valign="top">
                <p>
                    <strong>Строгая</strong>
                </p>
            </td>
            <td valign="top">
                <p>
                    Строгая
                </p>
            </td>
            <td valign="top">
                <p>
                    В конечном счете
                </p>
            </td>    
            <td valign="top">
                <p>
                    Строгая
                </p>
            </td>                
        </tr>       
        <tr>
            <td valign="top">
                <p>
                    <strong>Ограниченное запаздывание</strong>
                </p>
            </td>
            <td valign="top">
                <p>
                    Ограниченное запаздывание
                </p>
            </td>
            <td valign="top">
                <p>
                    В конечном счете
                </p>
            </td>      
            <td valign="top">
                <p>
                    Ограниченное запаздывание
                </p>
            </td> 
        </tr>          
        <tr>
            <td valign="top">
                <p>
                    <strong>Сеанс</strong>
                </p>
            </td>
            <td valign="top">
                <p>
                    Сеанс
                </p>
            </td>
            <td valign="top">
                <p>
                    В конечном счете
                </p>
            </td>   
            <td valign="top">
                <p>
                    Сеанс
                </p>
            </td>             
        </tr>      
        <tr>
            <td valign="top">
                <p>
                    <strong>В конечном счете</strong>
                </p>
            </td>
            <td valign="top">
                <p>
                    В конечном счете
                </p>
            </td>
            <td valign="top">
                <p>
                    В конечном счете
                </p>
            </td>      
            <td valign="top">
                <p>
                    В конечном счете
                </p>
            </td>              
        </tr>         
    </tbody>
</table>

В следующем примере кода показано, как создать коллекцию DocumentDB с помощью пакета SDK для .NET с согласованным индексированием всех операций вставки документа.

     // Default collection creates a hash index for all string and numeric    
     // fields. Hash indexes are compact and offer efficient
     // performance for equality queries.
     
     var collection = new DocumentCollection { Id ="defaultCollection" };
     
     collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;
     
     collection = await client.CreateDocumentCollectionAsync(database.SelfLink, collection);


### Пути индекса

DocumentDB представляет документы JSON и индексы в виде деревьев и позволяет настраивать политики для путей в дереве. Дополнительную информацию можно найти в этом [введении в индексирование DocumentDB](documentdb-indexing.md). В документах вы можете выбрать, какие пути необходимо включить или исключить из индексирования. Такой подход может обеспечить повышение производительности при записи и понижение требований к хранилищу индекса при сценариях, когда шаблоны запросов известны заранее.

Пути индекса начинаются с корневой (/) и, как правило, заканчиваются оператором подстановочного знака ?, обозначающего, что существует несколько возможных значений префикса. Например, чтобы обслуживать запрос SELECT * FROM Families F WHERE F.familyName = "Andersen", вам нужно включить путь индекса для /familyName/? в политику индекса коллекции.

В путях индекса можно также использовать оператор подстановочного знака * для задания алгоритма пути рекурсивно по префиксу. Например, /payload/* можно использовать для исключения из индексации всего, что находится по свойству payload.

Вот распространенные шаблоны задания путей индекса:

<table border="0" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td valign="top">
                <p>
                    <strong>Путь</strong>
                </p>
            </td>
            <td valign="top">
                <p>
                    <strong>Описание/вариант использования</strong>
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    /*
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь коллекции по умолчанию. Рекурсивный и применяется ко всему дереву документа.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    /prop/?
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь индекса, необходимый для обслуживания следующих запросов (с типами хэш, диапазон, соответственно):
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop = "value"
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop > 5
                </p>
                <p>
                    SELECT * FROM collection c ORDER BY c.prop
                </p>                
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    /prop/*
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь индекса для всех путей по заданной метке. Работает со следующими запросами
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop = "value"
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop.subprop > 5
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop.subprop.nextprop = "value"
                </p>
                <p>
                    SELECT * FROM collection c ORDER BY c.prop
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    /props/[]/?
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь индекса, необходимый для обслуживания запросов с итерацией и соединения, отправляемых в массивы скалярных выражений, например, ["a", "b", "c"]:
                </p>
                <p>
                    SELECT tag FROM tag IN collection.props WHERE tag = "value"
                </p>
                <p>
                    SELECT tag FROM collection c JOIN tag IN c.props WHERE tag > 5
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    /props/[]/subprop/?
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь индекса, необходимый для обслуживания запросов с итерацией и соединения, отправляемых в массивы объектов, например, [{subprop: "a"}, {subprop: "b"}]:
                </p>
                <p>
                    SELECT tag FROM tag IN collection.props WHERE tag.subprop = "value"
                </p>
                <p>
                    SELECT tag FROM collection c JOIN tag IN c.props WHERE tag.subprop = "value"
                </p>
            </td>
        </tr>        
        <tr>
            <td valign="top">
                <p>
                    /prop/subprop/?
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь индекса, необходимый для обслуживания запросов (с типами хэш, диапазон, соответственно):
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop.subprop = "value"
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop.subprop > 5
                </p>
                <p>
                    SELECT * FROM collection c ORDER BY c.prop.subprop
                </p>                
            </td>
        </tr>
    </tbody>
</table>

>[AZURE.NOTE]При задании пути пользовательского индекса необходимо выбрать правило индексации по умолчанию для всего дерева документов, указав специальный путь "/*".

В следующем примере показана настройка конкретного пути с диапазонной индексацией и пользовательским значением точности в 20 байт:

    var collection = new DocumentCollection { Id = "rangeSinglePathCollection" };    
    
    collection.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/Title/?", 
            Indexes = new Collection<Index> { 
                new RangeIndex(DataType.String) { Precision = 20 } } 
            });

    // Default for everything else
    collection.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/*" ,
            Indexes = new Collection<Index> {
                new HashIndex(DataType.String) { Precision = 3 }, 
                new RangeIndex(DataType.Number) { Precision = -1 } 
            }
        });
        
    collection = await client.CreateDocumentCollectionAsync(database.SelfLink, pathRange);

### Типы данных, виды и степени точности индекса

Теперь, когда мы изучили способы указания путей, рассмотрим параметры, которые можно использовать для настройки политики индексирования пути. Можно указать одно или несколько определений индексирования для каждого пути.

- Тип данных: **String**, **Number** или **Point** (может содержать только одну запись для каждого типа данных пути).
- Тип индекса: **хэш-индекс** (запросы равенства), **диапазонный индекс** (запросы равенства, диапазона или ORDER BY) или **пространственный индекс** (пространственные запросы). 
- Точность: 1–8 или -1 (максимальная точность) для чисел, 1–100 (максимальная точность) для строки

#### Вид индекса

DocumentDB поддерживает хэш-индексы и диапазонные индексы для каждого пути (их можно настроить для чисел, строк или и того и другого).

- **Хэш-индекс** поддерживает эффективные запросы равенства и запросы JOIN. Для большинства случаев использования хэш-индексов не требуется более высокая точность, чем разрядность по умолчанию, т. е. 3 байта.
- **Диапазонный индекс** поддерживает эффективные запросы равенства, запросы диапазона (с использованием >, <, >=, <=, !=) и запросы ORDER BY. Запросы Order By по умолчанию также требуют максимальной точности индекса (-1).

DocumentDB также поддерживает тип пространственного индекса для каждого пути, который может быть указан для типа данных точки. Значение по указанному пути должно быть действительным значением точки GeoJSON, например `{"type": "Point", "coordinates": [0.0, 10.0]}`.

- **Пространственный** индекс обеспечивает эффективность выполнения пространственных запросов (запросов нахождения в пределах и расстояния).

Ниже приведены виды поддерживаемых индексов и примеры запросов, для обслуживания которых их можно использовать:

<table border="0" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td valign="top">
                <p>
                    <strong>Вид индекса</strong>
                </p>
            </td>
            <td valign="top">
                <p>
                    <strong>Описание/вариант использования</strong>
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    Хэш
                </p>
            </td>
            <td valign="top">
                <p>
                    Hash over /prop/? (или /*) можно использовать для эффективной обработки следующих запросов: SELECT * FROM collection c WHERE c.prop = "value" Hash over /props/[]/? (или /*, или /props/*) позволяет эффективно обрабатывать следующие запросы: SELECT tag FROM collection c JOIN tag IN c.props WHERE tag = 5
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    Диапазон
                </p>
            </td>
            <td valign="top">
                <p>
                    Range over /prop/? (или /*) позволяет эффективно обрабатывать следующие запросы: SELECT * FROM collection c WHERE c.prop = "value" SELECT * FROM collection c WHERE c.prop > 5 SELECT * FROM collection c ORDER BY c.prop
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    Пространственный
                </p>
            </td>
            <td valign="top">
                <p>
                    Range over /prop/? (или /*) позволяет эффективно обрабатывать следующие запросы: SELECT * FROM collection c WHERE ST_DISTANCE(c.prop, {"type": "Point", "coordinates": [0.0, 10.0]}) &lt; 40 SELECT * FROM collection c WHERE ST_WITHIN(c.prop, {"type": "Polygon", ... })
                </p>
            </td>
        </tr>        
    </tbody>
</table>

По умолчанию возвращается сообщение об ошибке для запросов с операторами диапазона, например > =, если отсутствует диапазонный индекс (любой точности), чтобы указать, что для обслуживания запроса может потребоваться проверка. Диапазонные запросы можно выполнять без диапазонного индекса с помощью заголовка x-ms-documentdb-enable-scans в REST API или параметра запроса EnableScanInQuery, используя .NET SDK. Если в запросе есть какие-либо другие фильтры, по которым DocumentDB может отфильтровать индекс, сообщение об ошибке не появится.

Те же правила применяются для пространственных запросов. По умолчанию для пространственных запросов при отсутствии пространственного индекса возвращается ошибка. Они могут выполняться как сканирование с использованием x-ms-documentdb-enable-scan/EnableScanInQuery.

#### Точность индекса

Точность индекса обеспечивает компромисс между дополнительными затратами на хранение индекса и производительностью запросов. Для чисел рекомендуется использовать конфигурацию точности по умолчанию (-1, максимальная точность). Поскольку числа включают 8 байт в JSON, это эквивалентно 8-байтовой конфигурации. Выбор меньшего значения точности, например 1–7, означает, что значения в некоторых диапазонах соответствуют той же записи индекса. Таким образом, можно уменьшить место хранения индекса, но при выполнении запроса может возникнуть необходимость обработки большего количества документов, в результате чего потребуется более высокая пропускная способность, т. е. больше единиц запроса.

Конфигурацию точности индекса более удобно использовать с диапазонами строки. Поскольку строки могут быть любой длины, выбор точности индекса может повлиять на производительность запросов диапазона строки и повлиять на объем требуемого для индекса хранилища. Для индексов диапазона строки можно настроить значения 1–100 или -1 (максимум). Если вы хотите выполнить запросы ORDER BY с строковыми свойствами, необходимо указать точность -1 для соответствующих путей.

Пространственные индексы всегда используют точность индекса по умолчанию для точек, и переопределить ее нельзя.

В следующем примере показывается, как повысить точность для диапазонных индексов в коллекции с использованием .NET SDK. Обратите внимание, что используется путь по умолчанию «/ *».

**Создание коллекции с пользовательской точностью индекса**

    var rangeDefault = new DocumentCollection { Id = "rangeCollection" };
    
    rangeDefault.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/*", 
            Indexes = new Collection<Index> { 
                new RangeIndex(DataType.String) { Precision = -1 }, 
                new RangeIndex(DataType.Number) { Precision = -1 }
            }
        });

    await client.CreateDocumentCollectionAsync(database.SelfLink, rangeDefault);   


> [AZURE.NOTE]DocumentDB возвращает ошибку, если запрос использует предложение Order By, но не имеет диапазонного индекса для запрашиваемого пути с максимальной точностью.

Аналогичным образом пути можно полностью исключить из индексации. В следующем примере показано, как исключить из индексации раздел сущностей документов (так называемое поддерево) с помощью подстановочного знака "*".

    var collection = new DocumentCollection { Id = "excludedPathCollection" };
    collection.IndexingPolicy.IncludedPaths.Add(new IncludedPath { Path = "/" });
    collection.IndexingPolicy.ExcludedPaths.Add(new ExcludedPath { Path = "/nonIndexedContent/*");
    
    collection = await client.CreateDocumentCollectionAsync(database.SelfLink, excluded);


## Включение индексирования и отказ от него

Вы можете выбрать, хотите ли вы, чтобы коллекция автоматически индексировала все документы. По умолчанию все документы автоматически индексируются, но вы можете отключить эту функцию. При выключенном индексировании документы могут быть доступны только через свои собственные ссылки или запросы, использующие идентификатор.

При выключенном автоматическом индексировании вы все равно можете выборочно добавлять в индекс только некоторые документы. И наоборот, вы можете оставить включенным автоматическое индексирование и выборочно указать, какие документы необходимо исключить. Настройка включения или выключения индексирования полезна, когда у вас есть только подмножество документов, к которым требуется выполнить запрос.

Так, следующий пример показывает, как добавить документ явным образом с помощью пакета [DocumentDB .NET SDK](https://github.com/Azure/azure-documentdb-java) и свойства [RequestOptions.IndexingDirective](http://msdn.microsoft.com/library/microsoft.azure.documents.client.requestoptions.indexingdirective.aspx).

    // If you want to override the default collection behavior to either
    // exclude (or include) a Document from indexing,
    // use the RequestOptions.IndexingDirective property.
    client.CreateDocumentAsync(defaultCollection.SelfLink,
        new { id = "AndersenFamily", isRegistered = true },
        new RequestOptions { IndexingDirective = IndexingDirective.Include });

## Изменение политики индексирования коллекции

DocumentDB позволяет внести изменения в политику индексирования коллекции в режиме реального времени. Изменение политики индексирования коллекции DocumentDB может привести к изменению в формы индекса, включая индексируемые пути, их точность, а также модель согласованности самого индекса. Таким образом изменение политики индексирования фактически требует преобразования старого индекса в новый.

**Преобразование индексов в сети**

![Преобразование индексов в сети](media/documentdb-indexing-policies/index-transformations.png)

Преобразования индексов выполняются в сети. Это означает, что документы, индексированные по старой политике, эффективно преобразуются согласно новой политике **без ущерба доступности для записи или подготовленной пропускной способности** коллекции. Согласованность операций чтения и записи, выполняемых с помощью API REST, пакетов SDK или изнутри хранимых процедур и триггеров, не затрагивается во время преобразования индекса. Это означает, что при изменении политики индексирования производительность не падает и отсутствует простой приложений.

Тем не менее, во время преобразования индекса запросы являются в конечном счете согласованными вне зависимости от конфигурации режима индексирования (Consistent или Lazy). Это также относится к запросам из всех интерфейсов: REST API, пакетов SDK и из хранимых процедур и триггеров. Как и индексирование в режиме Lazy, преобразование индекса выполняется асинхронно в фоновом режиме на репликах с помощью запасных ресурсов, доступных для заданной реплики.

Преобразование индекса также выполняется **на месте**, т. е. DocumentDB не хранит две копии индекса и не заменяет старый индекс новым. Это означает, что при выполнении преобразования индекса не требуется использовать дополнительное место на диске или в коллекции.

При изменении политики индексирования то, как применяются изменения для перехода от старого индекса к новому, больше зависит от конфигураций режима индексирования, чем от других значений, таких как включенные или исключенные пути, типы индекса и точности. Если в старой и новой политике используется согласованное индексирование, то DocumentDB выполняет преобразование индекса в сети. Во время выполнения преобразования нельзя применить другое изменение политики индексирования с согласованным режимом индексирования.

Однако во время преобразования можно перейти в режим индексирования Lazy или None.

- При переходе в режим Lazy изменение политики индексирования вступает в силу немедленно, и DocumentDB начинает асинхронно повторно создавать индекс. 
- При переходе в режим None индекс немедленно удаляется. Переход в режим None удобен, если необходимо отменить выполняемое преобразование и начать «с нуля» с другой политикой индексирования. 

При использовании пакета SDK для .NET можно запустить изменение политики индексирования с помощью нового метода **ReplaceDocumentCollectionAsync** и отслеживать ход выполнения преобразования индекса в процентах с помощью свойства ответа **IndexTransformationProgress** из вызова **ReadDocumentCollectionAsync**. Другие пакеты SDK и REST API поддерживают эквивалентные свойства и методы для изменения политики индексирования.

Вот фрагмент кода, который показывает, как изменить режим политики индексирования коллекции с Consistent на Lazy.

**Изменение режима политики индексирования с Consistent на Lazy**

    // Switch to lazy indexing.
    Console.WriteLine("Changing from Default to Lazy IndexingMode.");

    collection.IndexingPolicy.IndexingMode = IndexingMode.Lazy;

    await client.ReplaceDocumentCollectionAsync(collection);


Можно проверить ход выполнения преобразования индекса, вызвав, например, ReadDocumentCollectionAsync, как показано ниже.

**Отслеживание хода выполнения преобразования индекса**

    long smallWaitTimeMilliseconds = 1000;
    long progress = 0;

    while (progress < 100)
    {
        ResourceResponse<DocumentCollection> collectionReadResponse = await     client.ReadDocumentCollectionAsync(collection.SelfLink);
        progress = collectionReadResponse.IndexTransformationProgress;

        await Task.Delay(TimeSpan.FromMilliseconds(smallWaitTimeMilliseconds));
    }

Можно удалить индекс для коллекции, перейдя в режим индексирования None. Это может быть удобным рабочим инструментом, если требуется отменить выполняющееся преобразование и немедленно начать новое.

**Удаление индекса для коллекции**

    // Switch to lazy indexing.
    Console.WriteLine("Dropping index by changing to to the None IndexingMode.");

    collection.IndexingPolicy.IndexingMode = IndexingMode.None;

    await client.ReplaceDocumentCollectionAsync(collection);

Когда вы вносите изменения в политики индексирования для своих коллекция DocumentDB? Ниже перечислены наиболее распространенные случаи использования:

- Обеспечиваете согласованные результаты во время обычной работы, но возвращаетесь к режиму индексирования Lazy при массовом импорте данных.
- Вы начинаете использовать новые функции индексирования для своих текущих коллекций DocumentDB, например геопространственных запросов, для которых необходим пространственный индекс, для запросов ORDER BY и запросов диапазона строки, для которых необходим индекс диапазона строки.
- Вручную выбираете свойства для индексирования и со временем меняете их.
- Настраиваете точность индексирования для повышения производительности запросов или уменьшения используемого хранилища.

>[AZURE.NOTE]Для изменения политики индексирования с помощью ReplaceDocumentCollectionAsync требуется версия пакета SDK для .NET не ниже 1.3.0.

## Настройка производительности

API DocumentDB предоставляют сведения о метриках производительности, таких как используемое хранилище индекса и стоимость пропускной способности (единицы запроса) для каждой операции. Эту информацию можно использовать для сравнения различных политик индексирования и настройки производительности.

Чтобы оценить квоты хранения и использования коллекции, запустите запрос HEAD или GET для ресурсов коллекции и выберите заголовки запросов x-ms-request-quota и x-ms-request-usage. В пакете SDK для .NET свойства [DocumentSizeQuota](http://msdn.microsoft.com/library/dn850325.aspx) и [DocumentSizeUsage](http://msdn.microsoft.com/library/azure/dn850324.aspx) на вкладке [ResourceResponse<T>](http://msdn.microsoft.com/library/dn799209.aspx) содержат соответствующие значения.

     // Measure the document size usage (which includes the index size) against   
     // different policies.        
     ResourceResponse<DocumentCollection> collectionInfo = await client.ReadDocumentCollectionAsync(collectionSelfLink);  
     Console.WriteLine("Document size quota: {0}, usage: {1}", collectionInfo.DocumentQuota, collectionInfo.DocumentUsage);


Для оценки расходов на индексирование в каждой операции записи (создание, обновление или удаление) выберите заголовок x-ms-request-charge (или эквивалентное свойство [RequestCharge](http://msdn.microsoft.com/library/dn799099.aspx) на вкладке [ResourceResponse<T>](http://msdn.microsoft.com/library/dn799209.aspx) в SDK для .NET), чтобы измерить число единиц запроса, используемых такими операциями.

     // Measure the performance (request units) of writes.     
     ResourceResponse<Document> response = await client.CreateDocumentAsync(collectionSelfLink, myDocument);              
     Console.WriteLine("Insert of document consumed {0} request units", response.RequestCharge);
     
     // Measure the performance (request units) of queries.    
     IDocumentQuery<dynamic> queryable =  client.CreateDocumentQuery(collectionSelfLink, queryString).AsDocumentQuery();                                  
     double totalRequestCharge = 0;
     while (queryable.HasMoreResults)
     {
        FeedResponse<dynamic> queryResponse = await queryable.ExecuteNextAsync<dynamic>(); 
        Console.WriteLine("Query batch consumed {0} request units",queryResponse.RequestCharge);
        totalRequestCharge += queryResponse.RequestCharge;
     }
     
     Console.WriteLine("Query consumed {0} request units in total", totalRequestCharge);

## Изменения в спецификации политики индексации
Изменение в схеме для политики индексации было представлено 7 июля 2015 года с помощью интерфейса API REST версии 2015-06-03. Представленные классы в версиях пакетов SDK имеют новые реализации, соответствующие схеме.

В спецификации JSON были реализованы следующие изменения:

- Политика индексации поддерживает диапазонные индексы для строк.
- Каждый путь может иметь несколько определений индекса, по одному для каждого типа данных.
- Поддерживаемая точность индексации: 1–8 для чисел, 1–100 для строк и –1 (максимальная точность).
- Двойные кавычки в сегментах путей для экранирования каждого пути не требуются. Например, вы можете добавить путь для /title/? вместо /"title"/?
- Корневой путь, представляющий "все пути", можно указать в виде "/*" (в дополнение к "/").

Если у вас имеется код, который подготавливает коллекции с пользовательской политикой индексации, написанный с помощью пакета SDK .NET версии 1.1.0 или более ранней, необходимо изменить код приложения, чтобы обработать эти изменения с целью переноса в пакет SDK версии 1.2.0. Если у вас нет кода, который настраивает политику индексации, или если вы планируете продолжить использование старой версии пакета SDK, изменения не требуются.

Для практического сравнения ниже приведен один пример пользовательской политики индексирования, написанный с помощью API REST версии 2015-06-03 и предыдущей версии 2015-04-08.

**Предыдущая политика индексации JSON**

    {
       "automatic":true,
       "indexingMode":"Consistent",
       "IncludedPaths":[
          {
             "IndexType":"Hash",
             "Path":"/",
             "NumericPrecision":7,
             "StringPrecision":3
          }
       ],
       "ExcludedPaths":[
          "/"nonIndexedContent"/*"
       ]
    }

**Текущая политика индексации JSON**

    {
       "automatic":true,
       "indexingMode":"Consistent",
       "includedPaths":[
          {
             "path":"/*",
             "indexes":[
                {
                   "kind":"Hash",
                   "dataType":"String",
                   "precision":3
                },
                {
                   "kind":"Hash",
                   "dataType":"Number",
                   "precision":7
                }
             ]
          }
       ],
       "ExcludedPaths":[
          {
             "path":"/nonIndexedContent/*"
          }
       ]
    }

## Дальнейшие действия

Используйте ссылки ниже для примеров управления политиками индексации и получения дополнительных сведений о языке запросов DocumentDB.

1.	[Примеры кода управления индексами для DocumentDB .NET](https://github.com/Azure/azure-documentdb-net/blob/master/samples/code-samples/IndexManagement/Program.cs)
2.	[Операции с коллекциями DocumentDB REST API](https://msdn.microsoft.com/library/azure/dn782195.aspx)
3.	[Формирование запросов с помощью DocumentDB SQL](documentdb-sql-query.md)

 

<!---HONumber=August15_HO7-->