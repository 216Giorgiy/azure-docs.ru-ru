<properties 
    pageTitle="Политики индексации DocumentDB | Azure" 
    description="В этом документе объясняется, как работает индексирование для базы данных DocumentDB и как настроить и изменить политику индексирования." 
    services="documentdb" 
    documentationCenter="" 
    authors="mimig1" 
    manager="jhubbard" 
    editor="monicar"/>

<tags 
    ms.service="documentdb" 
    ms.devlang="na" 
    ms.topic="article" 
    ms.tgt_pltfrm="na" 
    ms.workload="data-services" 
    ms.date="07/19/2015" 
    ms.author="mimig"/>


# Политики индексации DocumentDB

DocumentDB является базой данных без использования каких-либо схем. Она не подразумевает и не требует указания каких-либо схем для документов JSON. Это позволяет быстро определять и выполнять итерации на моделях прикладных данных. По мере добавления документов в коллекцию DocumentDB автоматически индексирует все свойства документов, чтобы они стали доступны для выполнения вами запросов. Автоматическая индексация также позволяет сохранять разнородные типы документов.

Автоматическая индексация документов обеспечена возможностью записи, оптимизирована, с нее снята блокировка и предусмотрены методы обслуживания структурированных индексов протокола. DocumentDB поддерживает устойчивый объем быстрых операций записи, при этом обслуживая согласованные запросы.

Подсистема индексации DocumentDB рассчитана на поддержку следующего:

-  Эффективные, расширенные иерархические и реляционные запросы без определений схем или индексов.
-  Согласованные результаты запросов при обработке устойчивого объема записи. В случае высоких нагрузок записи данных с согласованными запросами индекс обновляется постепенно, эффективно и оперативно при обработке устойчивого объема записи.
- Эффективность хранения. для повышения эффективности затрат накладные расходы дискового пространства при индексировании являются ограниченными и предсказуемыми.
- Несколько владельцев. Обновления индекса выполняются в рамках бюджета системных ресурсов, выделяемых на каждую коллекцию DocumentDB. 

Для большинства приложений вы можете использовать автоматическую политику индексации по умолчанию, так как она обеспечивает максимальную гибкость и оптимальный компромисс между производительностью и эффективностью хранения. С другой стороны, задав пользовательскую политику индексирования, вы сможете дискретно настраивать степень компромисса между производительностью запросов, скоростью записи и дополнительными затратами ресурсов на хранение индекса.

Например, за счет исключения из индексации некоторых документов или путей в документах вы сможете уменьшить как объем памяти в хранилище, используемой для индексирования, так и временные затраты на вставку данных при обслуживании индекса. Вы можете изменить тип индекса, чтобы он точнее соответствовал запросам по диапазону, или повысить точность индекса в байтах для улучшения производительности запросов. В этой статье описываются различные параметры настройки индексирования, поддерживаемые в DocumentDB, а также изложен порядок настройки политики индексирования для ваших рабочих нагрузок.

Ознакомившись с данной статьей, вы сможете ответить на следующие вопросы.

- Как DocumentDB поддерживает индексацию всех свойств по умолчанию?
- Как переопределить свойства, которые необходимо включить в индексацию или исключить из нее?
- Как настроить индекс для возможных обновлений?
- Как настроить индексацию для выполнения предложений Order By или запросов в диапазоне?

## Принцип индексирования в DocumentDB

Индексирование в DocumentDB основано на том факте, что грамматика JSON позволяет представлять документы **в виде деревьев**. Чтобы представить документ JSON в виде дерева, требуется создать фиктивный корневой узел, который будет являться родителем остальные реальных узлов в подчиненном документе. Каждая метка, включая и индексы массива в документе JSON, становится узлом дерева. На рисунке ниже показан пример документа JSON и его соответствующее представление в виде дерева.

![Политики индексации](media/documentdb-indexing-policies/image001.png)

Например, свойство JSON `{"headquarters": "Belgium"}` в приведенном выше примере соответствует пути `/headquarters/Belgium`. Массив JSON `{"exports": [{"city": “Moscow"}, {"city": Athens"}]}` соответствует пути `/exports/[]/city/Moscow` и `/exports/[]/city/Athens`.

>[AZURE.NOTE]Представление пути размывает границу между структурой или схемой и значениями экземпляров в документах, поэтому в DocumentDB действительно нет схем.

В DocumentDB документы организованы в коллекции, запросы к которым можно выполнять с помощью SQL или обрабатывать в ходе одиночной транзакции. Каждую коллекцию можно настроить в соответствии с собственной политикой индексации, выраженной с помощью указания путей. В следующем разделе мы рассмотрим, как настроить алгоритм индексирования коллекции DocumentDB.

## Настройка политики индексирования коллекции

Для каждой коллекции DocumentDB можно настроить следующие параметры.

- Режим индексирования: **Consistent**, **Lazy** (для асинхронного обновления) или **None** (доступ только на основе идентификатора)
- Включенные и исключенные пути: выберите, какие пути в рамках JSON включить и исключить
- Тип индекса: **хэш** (для запросов равенства), **диапазон** (для запросов равенства, диапазона и Order By с хранилищем более высокого уровня)
- Точность индекса: 1–8 или максимальная (-1) для баланса между хранилищем и производительностью
- Автоматическое: **true** или **false** для включения либо **manual** (запрос согласия в каждой операции вставки)

В следующем фрагменте кода .NET показано, как задать пользовательскую политику индексирования во время создания коллекции. Здесь мы задаем политику с диапазонным индексом для строк и чисел с максимальной точностью. Эта политика позволяет выполнять запросы Order By к строкам.

    var collection = new DocumentCollection { Id = "myCollection" };
    
    collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;
    
    collection.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/*", 
            Indexes = new Collection<Index> { 
                new RangeIndex(DataType.String) { Precision = -1 }, 
                new RangeIndex(DataType.Number) { Precision = -1 }
            }
        });

    await client.CreateDocumentCollectionAsync(database.SelfLink, collection);   


>[AZURE.NOTE]Схема JSON для политики индексации была изменена с помощью выпуска REST API (версия 2015-06-03), чтобы поддержать диапазонные индексы для строковых значений. Новую схему политики поддерживают пакет .NET SDK 1.2.0 и Java, Python и пакеты Node.js SDK 1.1.0. Более старые пакеты SDK используют REST API версии 2015-04-08 и поддерживают старую схему политики индексации.
>
>По умолчанию DocumentDB согласованно индексирует все свойства строк в документах с помощью хэш-индекса, а числовые свойства — с помощью диапазонного индекса.

### Режимы индексирования

Можно выбрать синхронное (**Consistent**) или асинхронное (**Lazy**) обновление индекса или отсутствие обновления (**None**). По умолчанию, индекс обновляется синхронно при каждой операции вставки, замены или удаления документа в коллекции. Это позволяет выполнять запросы, обеспечивая тот же уровень согласованности, что и при чтении документа, без каких-либо задержек, чтобы индекс "успевал" обновиться.

Поскольку DocumentDB оптимизирован для операций записи и поддерживает устойчивые объемы записей документов вместе с синхронным обслуживанием индекса, вы можете настроить определенные коллекции для отложенного обновления своего индекса. Отложенное индексирование отлично подходит для сценариев, при которых происходит запись данных пачками, а вы хотите уменьшить нагрузку при выполнении работы, необходимой для индексирования содержания в течение более длительного периода времени. Это позволяет эффективно использовать отведенную пропускную способность и обслуживать запросы на запись в часы пик с минимальной задержкой. При включенном отложенном индексировании результаты запросов будут в конечном итоге согласованы независимо от уровня согласованности, настроенного в учетной записи базы данных.

В следующем примере показано, как создать коллекцию DocumentDB с помощью пакета SDK для .NET с согласованным автоматическим индексированием всех операций вставки документа.


     // Default collection creates a hash index for all string and numeric    
     // fields. Hash indexes are compact and offer efficient
     // performance for equality queries.
     
     var collection = new DocumentCollection { Id ="defaultCollection" };
     
     // Optional. Override Automatic to false for opt-in indexing of documents.
     collection.IndexingPolicy.Automatic = true;
     
     // Optional. Set IndexingMode to Lazy for bulk import/read heavy        
     // collections. Queries might return stale results with Lazy indexing.
     collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;
     
     collection = await client.CreateDocumentCollectionAsync(database.SelfLink, collection);

### Пути индекса

В документах вы можете выбрать, какие пути необходимо включить или исключить из индексирования. Такой подход может обеспечить повышение производительности при записи и понижение требований к хранилищу индекса при сценариях, когда шаблоны запросов известны заранее.

Пути индекса начинаются с корневой (/) и, как правило, заканчиваются оператором подстановочного знака ?, обозначающего, что существует несколько возможных значений префикса. Например, чтобы обслуживать запрос SELECT * FROM Families F WHERE F.familyName = "Andersen", вам нужно включить путь индекса для /familyName/? в политику индекса коллекции.

В путях индекса можно также использовать оператор подстановочного знака * для задания алгоритма пути рекурсивно по префиксу. Например, /payload/* можно использовать для исключения из индексации всего, что находится по свойству payload.

Вот распространенные шаблоны задания путей индекса:

<table border="0" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td valign="top">
                <p>
                    <strong>Путь</strong>
                </p>
            </td>
            <td valign="top">
                <p>
                    <strong>Описание/вариант использования</strong>
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    /*
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь коллекции по умолчанию. Рекурсивный и применяется ко всему дереву документа.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    /prop/?
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь индекса, необходимый для обслуживания следующих запросов (с типами хэш, диапазон, соответственно):
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop = "value"
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop > 5
                </p>
                <p>
                    SELECT * FROM collection c ORDER BY c.prop
                </p>                
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    /prop/*
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь индекса для всех путей по заданной метке. Работает со следующими запросами
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop = "value"
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop.subprop > 5
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop.subprop.nextprop = "value"
                </p>
                <p>
                    SELECT * FROM collection c ORDER BY c.prop
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    /props/[]/?
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь индекса, необходимый для обслуживания запросов с итерацией и соединения, отправляемых в массивы скалярных выражений, например, ["a", "b", "c"]:
                </p>
                <p>
                    SELECT tag FROM tag IN collection.props WHERE tag = "value"
                </p>
                <p>
                    SELECT tag FROM collection c JOIN tag IN c.props WHERE tag > 5
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    /props/[]/subprop/?
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь индекса, необходимый для обслуживания запросов с итерацией и соединения, отправляемых в массивы объектов, например, [{subprop: "a"}, {subprop: "b"}]:
                </p>
                <p>
                    SELECT tag FROM tag IN collection.props WHERE tag.subprop = "value"
                </p>
                <p>
                    SELECT tag FROM collection c JOIN tag IN c.props WHERE tag.subprop = "value"
                </p>
            </td>
        </tr>        
        <tr>
            <td valign="top">
                <p>
                    /prop/subprop/?
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь индекса, необходимый для обслуживания запросов (с типами хэш, диапазон, соответственно):
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop.subprop = "value"
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop.subprop > 5
                </p>
                <p>
                    SELECT * FROM collection c ORDER BY c.prop.subprop
                </p>                
            </td>
        </tr>
    </tbody>
</table>

>[AZURE.NOTE]При задании пути пользовательского индекса необходимо выбрать правило индексации по умолчанию для всего дерева документов, указав специальный путь "/*".

В следующем примере показана настройка конкретного пути с диапазонной индексацией и пользовательским значением точности в 20 байт:

    var collection = new DocumentCollection { Id = "rangeSinglePathCollection" };    
    
    collection.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/Title/?", 
            Indexes = new Collection<Index> { 
                new RangeIndex(DataType.String) { Precision = 20 } } 
            });

    // Default for everything else
    collection.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/*" ,
            Indexes = new Collection<Index> {
                new HashIndex(DataType.String) { Precision = 3 }, 
                new RangeIndex(DataType.Number) { Precision = -1 } 
            }
        });
        
    collection = await client.CreateDocumentCollectionAsync(database.SelfLink, pathRange);

### Типы данных, виды и степени точности индекса

Теперь, когда мы изучили способы указания путей, рассмотрим параметры, которые можно использовать для настройки политики индексирования пути. Можно указать одно или несколько определений индексирования для каждого пути.

- Тип данных: **String** или **Number** (может содержать только одну запись для каждого типа данных пути)
- Тип индекса: **хэш-индекс** (запросы равенства) или **диапазонный индекс** (запросы равенства, диапазона или Order By).
- Точность: 1–8 или -1 (максимальная точность) для чисел, 1–100 (максимальная точность) для строки

#### Вид индекса

DocumentDB поддерживает два вида индекса для каждой пары пути и типа данных.

- **Хэш-индекс** поддерживает эффективные запросы равенства. Для большинства случаев использования хэш-индексов не требуется более высокая точность, чем разрядность по умолчанию, т. е. 3 байта.
- **Диапазонный индекс** поддерживает эффективные запросы равенства, запросы диапазона (с использованием >, <, >=, <=, !=) и запросы Order By. Запросы Order By по умолчанию также требуют максимальной точности индекса (-1).

#### Точность индекса

Точность индекса обеспечивает баланс между издержками хранилища индекса и производительностью запросов. Для чисел рекомендуется использовать конфигурацию точности по умолчанию (-1). Поскольку числа включают 8 байт в JSON, это эквивалентно 8-байтовой конфигурации. Выбор меньшего значения точности, например 1–7, означает, что значения в некоторых диапазонах соответствуют той же записи индекса. Таким образом, можно уменьшить место хранения индекса, но при выполнении запроса может возникнуть необходимость обработки большего количества документов, в результате чего потребуется более высокая пропускная способность, т. е. больше единиц запроса.

Конфигурацию точности индекса более полезно использовать с диапазонами строки. Поскольку строки могут быть любой длины, выбор точности индекса может повлиять на производительность запросов диапазона строки и повлиять на объем требуемого для индекса хранилища. Для индексов диапазона строки можно настроить значения 1–100 или максимальную точность (-1). Если требуется запрос Order By для строк, необходимо указать по указанному пути (-1).

В следующем примере показывается, как повысить точность для диапазонных индексов в коллекции с использованием .NET SDK. Обратите внимание, что используется путь по умолчанию «/ *».

    var rangeDefault = new DocumentCollection { Id = "rangeCollection" };
    
    rangeDefault.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/*", 
            Indexes = new Collection<Index> { 
                new RangeIndex(DataType.String) { Precision = -1 }, 
                new RangeIndex(DataType.Number) { Precision = -1 }
            }
        });

    await client.CreateDocumentCollectionAsync(database.SelfLink, rangeDefault);   


> [AZURE.NOTE]DocumentDB возвращает ошибку, если запрос использует предложение Order By, но не имеет диапазонного индекса для запрашиваемого пути с максимальной точностью.
>
> Если для запросов с операторами диапазона типа >= не указан диапазонный индекс (любой точности), возвращается ошибка, однако они могут обрабатываться, если существуют фильтры, которые можно применить из этого индекса.
> 
> Диапазонные запросы можно выполнять без диапазонного индекса с помощью заголовка x-ms-documentdb-enable-scans в REST API или параметра запроса EnableScanInQuery, используя .NET SDK.

Аналогичным образом пути можно полностью исключить из индексации. В следующем примере показано, как исключить из индексации раздел сущностей документов (так называемое поддерево) с помощью подстановочного знака "*".

    var collection = new DocumentCollection { Id = "excludedPathCollection" };
    collection.IndexingPolicy.IncludedPaths.Add(new IncludedPath { Path = "/" });
    collection.IndexingPolicy.ExcludedPaths.Add(new ExcludedPath { Path = "/nonIndexedContent/*");
    
    collection = await client.CreateDocumentCollectionAsync(database.SelfLink, excluded);


### Автоматическое индексирование

Вы можете выбрать, хотите ли вы, чтобы коллекция автоматически индексировала все документы. По умолчанию все документы автоматически индексируются, но вы можете отключить эту функцию. При выключенном индексировании документы могут быть доступны только через свои собственные ссылки или запросы, использующие идентификатор.

При выключенном автоматическом индексировании вы все равно можете выборочно добавлять в индекс только некоторые документы. И наоборот, вы можете оставить включенным автоматическое индексирование и выборочно указать, какие документы необходимо исключить. Настройка включения или выключения индексирования полезна, когда у вас есть только подмножество документов, к которым требуется выполнить запрос.

Так, следующий пример показывает, как добавить документ явным образом с помощью пакета [DocumentDB .NET SDK](https://github.com/Azure/azure-documentdb-java) и свойства [RequestOptions.IndexingDirective](http://msdn.microsoft.com/library/microsoft.azure.documents.client.requestoptions.indexingdirective.aspx).

    // If you want to override the default collection behavior to either
    // exclude (or include) a Document from indexing,
    // use the RequestOptions.IndexingDirective property.
    client.CreateDocumentAsync(defaultCollection.SelfLink,
        new { id = "AndersenFamily", isRegistered = true },
        new RequestOptions { IndexingDirective = IndexingDirective.Include });

## Настройка производительности

API DocumentDB предоставляют сведения о метриках производительности, таких как используемое хранилище индекса и стоимость пропускной способности (единицы запроса) для каждой операции. Эту информацию можно использовать для сравнения различных политик индексирования и настройки производительности.

Чтобы оценить квоты хранения и использования коллекции, запустите запрос HEAD или GET для ресурсов коллекции и выберите заголовки запросов x-ms-request-quota и x-ms-request-usage. В пакете SDK для .NET свойства [DocumentSizeQuota](http://msdn.microsoft.com/library/dn850325.aspx) и [DocumentSizeUsage](http://msdn.microsoft.com/library/azure/dn850324.aspx) на вкладке [ResourceResponse<T>](http://msdn.microsoft.com/library/dn799209.aspx) содержат соответствующие значения.

     // Measure the document size usage (which includes the index size) against   
     // different policies.        
     ResourceResponse<DocumentCollection> collectionInfo = await client.ReadDocumentCollectionAsync(collectionSelfLink);  
     Console.WriteLine("Document size quota: {0}, usage: {1}", collectionInfo.DocumentQuota, collectionInfo.DocumentUsage);


Для оценки расходов на индексирование в каждой операции записи (создание, обновление или удаление) выберите заголовок x-ms-request-charge (или эквивалентное свойство [RequestCharge](http://msdn.microsoft.com/library/dn799099.aspx) на вкладке [ResourceResponse<T>](http://msdn.microsoft.com/library/dn799209.aspx) в SDK для .NET), чтобы измерить число единиц запроса, используемых такими операциями.

     // Measure the performance (request units) of writes.     
     ResourceResponse<Document> response = await client.CreateDocumentAsync(collectionSelfLink, myDocument);              
     Console.WriteLine("Insert of document consumed {0} request units", response.RequestCharge);
     
     // Measure the performance (request units) of queries.    
     IDocumentQuery<dynamic> queryable =  client.CreateDocumentQuery(collectionSelfLink, queryString).AsDocumentQuery();                                  
     double totalRequestCharge = 0;
     while (queryable.HasMoreResults)
     {
        FeedResponse<dynamic> queryResponse = await queryable.ExecuteNextAsync<dynamic>(); 
        Console.WriteLine("Query batch consumed {0} request units",queryResponse.RequestCharge);
        totalRequestCharge += queryResponse.RequestCharge;
     }
     
     Console.WriteLine("Query consumed {0} request units in total", totalRequestCharge);

## Изменения в спецификации политики индексации
Изменение в схеме для политики индексации было представлено 7 июля 2015 года с помощью интерфейса API REST версии 2015-06-03. Представленные классы в версиях пакетов SDK имеют новые реализации, соответствующие схеме.

В спецификации JSON были реализованы следующие изменения:

- Политика индексации поддерживает диапазонные индексы для строк.
- Каждый путь может иметь несколько определений индекса, по одному для каждого типа данных.
- Поддерживаемая точность индексации: 1–8 для чисел, 1–100 для строк и –1 (максимальная точность).
- Двойные кавычки в сегментах путей для экранирования каждого пути не требуются. Например, вы можете добавить путь для /title/? вместо /"title"/?
- Корневой путь, представляющий "все пути", можно указать в виде "/*" (в дополнение к "/").

Если у вас имеется код, который подготавливает коллекции с пользовательской политикой индексации, написанный с помощью пакета SDK .NET версии 1.1.0 или более ранней, необходимо изменить код приложения, чтобы обработать эти изменения с целью переноса в пакет SDK версии 1.2.0. Если у вас нет кода, который настраивает политику индексации, или если вы планируете продолжить использование старой версии пакета SDK, изменения не требуются.

Для практического сравнения ниже приведен один пример пользовательской политики индексирования, написанный с помощью API REST версии 2015-06-03 и предыдущей версии 2015-04-08.

**Предыдущая политика индексации JSON**

    {
       "automatic":true,
       "indexingMode":"Consistent",
       "IncludedPaths":[
          {
             "IndexType":"Hash",
             "Path":"/",
             "NumericPrecision":7,
             "StringPrecision":3
          }
       ],
       "ExcludedPaths":[
          "/"nonIndexedContent"/*"
       ]
    }

**Текущая политика индексации JSON**

    {
       "automatic":true,
       "indexingMode":"Consistent",
       "includedPaths":[
          {
             "path":"/*",
             "indexes":[
                {
                   "kind":"Hash",
                   "dataType":"String",
                   "precision":3
                },
                {
                   "kind":"Hash",
                   "dataType":"Number",
                   "precision":7
                }
             ]
          }
       ],
       "ExcludedPaths":[
          {
             "path":"/nonIndexedContent/*"
          }
       ]
    }

## Дальнейшие действия

Используйте ссылки ниже для примеров управления политиками индексации и получения дополнительных сведений о языке запросов DocumentDB.

1.	[Примеры кода управления индексами для DocumentDB .NET](https://github.com/Azure/azure-documentdb-net/blob/master/samples/code-samples/IndexManagement/Program.cs)
2.	[Операции с коллекциями DocumentDB REST API](https://msdn.microsoft.com/library/azure/dn782195.aspx)
3.	[Формирование запросов с помощью DocumentDB SQL](documentdb-sql-query.md)

 

<!---HONumber=July15_HO4-->