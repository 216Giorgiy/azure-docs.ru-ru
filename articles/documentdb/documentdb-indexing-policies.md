<properties 
    pageTitle="Политики индексации DocumentDB | Azure" 
    description="В этом документе объясняется, как работает индексирование для базы данных DocumentDB и как настроить политику индексирования." 
    services="documentdb" 
    documentationCenter="" 
    authors="mimig1" 
    manager="jhubbard" 
    editor="monicar"/>

<tags 
    ms.service="documentdb" 
    ms.devlang="na" 
    ms.topic="article" 
    ms.tgt_pltfrm="na" 
    ms.workload="data-services" 
    ms.date="07/06/2015" 
    ms.author="mimig"/>


# Политики индексации DocumentDB

DocumentDB является базой данных без использования каких-либо схем. Она не подразумевает и не требует указания каких-либо схем для документов JSON. Это позволяет быстро определять и выполнять итерации на моделях прикладных данных. По мере добавления документов в коллекцию DocumentDB автоматически индексирует все свойства документов, чтобы они стали доступны для выполнения вами запросов. Автоматическая индексация также позволяет сохранять разнородные типы документов.

Автоматическая индексация документов обеспечена возможностью записи, оптимизирована, с нее снята блокировка и предусмотрены методы обслуживания структурированных индексов протокола. DocumentDB поддерживает устойчивый объем быстрых операций записи, при этом обслуживая согласованные запросы.

Подсистема индексации DocumentDB рассчитана на поддержку следующего:

-  Эффективные, расширенные иерархические и реляционные запросы без определений схем или индексов.
-  Согласованные результаты запросов при обработке устойчивого объема записи. В случае высоких нагрузок записи данных с согласованными запросами индекс обновляется постепенно, эффективно и оперативно при обработке устойчивого объема записи.
- Эффективность хранения. для повышения эффективности затрат накладные расходы дискового пространства при индексировании являются ограниченными и предсказуемыми.
- Несколько владельцев. Обновления индекса выполняются в рамках бюджета системных ресурсов, выделяемых на каждую коллекцию DocumentDB. 

Для большинства приложений вы можете использовать автоматическую политику индексации по умолчанию, так как она обеспечивает максимальную гибкость и оптимальный компромисс между производительностью и эффективностью хранения. С другой стороны, задав пользовательскую политику индексирования, вы сможете дискретно настраивать степень компромисса между производительностью запросов, скоростью записи и дополнительными затратами ресурсов на хранение индекса.

Например, за счет исключения из индексации некоторых документов или путей в документах вы сможете уменьшить как объем памяти в хранилище, используемой для индексирования, так и временные затраты на вставку данных при обслуживании индекса. Вы можете изменить тип индекса, чтобы он точнее соответствовал запросам по диапазону, или повысить точность индекса в байтах для улучшения производительности запросов. В этой статье описываются различные параметры настройки индексирования, поддерживаемые в DocumentDB, а также изложен порядок настройки политики индексирования для ваших рабочих нагрузок.

Ознакомившись с данной статьей, вы сможете ответить на следующие вопросы.

- Как DocumentDB поддерживает индексацию всех свойств по умолчанию?
- Как переопределить свойства, которые необходимо включить в индексацию или исключить из нее?
- Как настроить индекс для возможных обновлений?
- Как настроить индексацию для выполнения предложений Order By или запросов в диапазоне?


## Принцип индексирования в DocumentDB

Индексирование в DocumentDB основано на том факте, что грамматика JSON позволяет представлять документы **в виде деревьев**. Чтобы представить документ JSON в виде дерева, требуется создать фиктивный корневой узел, который будет являться родителем остальные реальных узлов в подчиненном документе. Каждая метка, включая и индексы массива в документе JSON, становится узлом дерева. На рисунке ниже показан пример документа JSON и его соответствующее представление в виде дерева.

![Политики индексации](media/documentdb-indexing-policies/image001.png)

Например, свойство JSON {"headquarters": "Belgium"} в вышеприведенном примере соответствует пути /"headquarters"/"Belgium". Массив JSON {"exports": [{"city": “Moscow"}, {"city": Athens"}]} соответствует путям /"exports"/0/"city"/"Moscow" и /"exports"/1/"city"/"Athens".

>[AZURE.NOTE]Представление пути размывает границу между структурой или схемой и значениями экземпляров в документах, поэтому в DocumentDB действительно нет схем.

В DocumentDB документы организованы в коллекции, запросы к которым можно выполнять с помощью SQL или обрабатывать в ходе одиночной транзакции. Каждую коллекцию можно настроить в соответствии с собственной политикой индексации, выраженной с помощью указания путей. В следующем разделе мы рассмотрим, как настроить алгоритм индексирования коллекции DocumentDB.

## Настройка политики индексирования коллекции

На следующем примере показано, как задать пользовательскую политику индексирования во время создания коллекции с помощью API REST в DocumentDB. Пример представляет собой политику индексации, выраженную в виде путей, типов индекса и степеней точности.

    POST https://<REST URI>/colls HTTP/1.1
    Accept: application/json 

    {
       "id":"customIndexCollection",
       "indexingPolicy":{
          "automatic":true,
          "indexingMode":"Consistent",
          "includedPaths":[
             {
                "path":"/*",
                "indexes":[
    
                ]
             }
          ],
          "excludedPaths":[
             {
                "path":"/nonIndexedContent/*"
             }
          ]
       }
    }
     ...


     HTTP/1.1 201 Created

>[AZURE.NOTE]Схема JSON для политики индексации была изменена с помощью выпуска REST API (версия 2015-06-03), чтобы поддержать диапазонные индексы для строковых значений. Новую схему политики поддерживают пакет .NET SDK 1.2.0 и Java, Python и пакеты Node.js SDK 1.1.0. Более старые пакеты SDK используют REST API версии 2015-04-08 и поддерживают старую схему политики индексации.
>
>Во время создания необходимо указать политику индексации коллекции. Изменение политики индексации после создания коллекции не допускается (эта возможность будет поддерживаться в последующих версиях DocumentDB).
>
>По умолчанию DocumentDB согласованно индексирует все пути в документах с помощью хэш-индекса. Внутренний путь отметки времени (_ts) хранится с индексом диапазона.

### Автоматическое индексирование

Вы можете выбрать, хотите ли вы, чтобы коллекция автоматически индексировала все документы, или нет. По умолчанию все документы автоматически индексируются, но вы можете отключить эту функцию. При выключенном индексировании документы могут быть доступны только через свои собственные ссылки или запросы, использующие идентификатор.

При выключенном автоматическом индексировании вы все равно можете выборочно добавлять в индекс только некоторые документы. И наоборот, вы можете оставить включенным автоматическое индексирование и выборочно указать, какие документы необходимо исключить. Настройка включения или выключения индексирования полезна, когда у вас есть только подмножество документов, к которым требуется выполнить запрос.

Вы можете настроить политику по умолчанию, задав значение свойства автоматизации равным true или false. Чтобы изменить его для одного документа, можно задать заголовок запроса x-ms-indexingdirective во время вставки или замены документа.

Так, следующий пример показывает, как добавить документ явным образом с помощью пакета [DocumentDB .NET SDK](https://github.com/Azure/azure-documentdb-java) и свойства [RequestOptions.IndexingDirective](http://msdn.microsoft.com/library/microsoft.azure.documents.client.requestoptions.indexingdirective.aspx).

    // If you want to override the default collection behavior to either
    // exclude (or include) a Document from indexing,
    // use the RequestOptions.IndexingDirective property.
    client.CreateDocumentAsync(defaultCollection.SelfLink,
        new { id = "AndersenFamily", isRegistered = true },
        new RequestOptions { IndexingDirective = IndexingDirective.Include });
        


### Режимы индексирования

Можно выбрать синхронное (**Согласованное**) или асинхронное (**Отложенное**) обновления индекса. По умолчанию, индекс обновляется синхронно при каждой операции вставки, замены или удаления документа в коллекции. Это позволяет выполнять запросы, обеспечивая тот же уровень согласованности, что и при чтении документа, без каких-либо задержек, чтобы индекс "успевал" обновиться.

Поскольку DocumentDB оптимизирован для операций записи и поддерживает устойчивые объемы записей документов вместе с синхронным обслуживанием индекса, вы можете настроить определенные коллекции для отложенного обновления своего индекса. Отложенное индексирование отлично подходит для сценариев, при которых происходит запись данных пачками, а вы хотите уменьшить нагрузку при выполнении работы, необходимой для индексирования содержания в течение более длительного периода времени. Это позволяет эффективно использовать отведенную пропускную способность и обслуживать запросы на запись в часы пик с минимальной задержкой. При включенном отложенном индексировании результаты запросов будут в конечном итоге согласованы независимо от уровня согласованности, настроенного в учетной записи базы данных.

В следующем примере показано, как создать коллекцию с помощью пакета SDK для .NET с согласованным автоматическим индексированием всех операций вставки документа.


     // Default collection creates a hash index for all string and numeric    
     // fields. Hash indexes are compact and offer efficient
     // performance for equality queries.
     
     var collection = new DocumentCollection { Id ="defaultCollection" };
     
     // Optional. Override Automatic to false for opt-in indexing of documents.
     collection.IndexingPolicy.Automatic = true;
     
     // Optional. Set IndexingMode to Lazy for bulk import/read heavy        
     // collections. Queries might return stale results with Lazy indexing.
     collection.IndexingPolicy.IndexingMode = IndexingMode.Consistent;
     
     collection = await client.CreateDocumentCollectionAsync(database.SelfLink, collection);

### Типы индексов и степени точности

Тип или схема, используемая для записей индекса, оказывает прямое влияние на хранение и производительность индекса. При схеме с использованием более высокой точности запросы, как правило, более быстрые. В то же время, при этом увеличивается дополнительный расход ресурса для хранения индекса. Выбор пониженной точности означает, что потребуется обработать больше документов во время выполнения запроса, но дополнительные расходы на хранение будут меньше.

Точность индекса для значений в любом пути может находиться в диапазоне от 1 до 8. Если установить значение -1, это будет указывать, что путь должен использовать максимальный уровень требуемой точности. Каждый путь можно настроить с помощью массива индексов, по одному для каждого типа данных (строковый и числовой), и указать точность каждого из них.

Кроме того, поддерживаются индексы двух типов — хэш и диапазон. Индекс типа **Хэш** позволяет создавать эффективные запросы равенства. Для большинства случаев использования хэш-индексов не требуется более высокая точность, чем разрядность по умолчанию, т. е. 3 байта.

Индекс типа **Диапазон** позволяет выполнять диапазонные запросы (с использованием >, <, >=, <=, !=), а также запросы **Order By**. Запросы «Order By» по умолчанию также требуют создания диапазонного индекса с максимальной точностью индекса (-1), чтобы гарантировать общий порядок результатов.

Для путей, которые имеют большие диапазоны значений, рекомендуется использовать повышенную точность с разрядностью в 6 байт. Распространенный вариант использования, при котором требуется более высокая степень точности индекса диапазона, – временные метки, которые хранятся как время эпохи.

Если ваш случай использования не требует предложений Order BY и/или эффективных диапазонных запросов, то по умолчанию хэш-индексы обеспечивают наилучший компромисс между хранением и производительностью. Обратите внимание, что для поддержки предложения Order By или диапазонных запросов вам необходимо задать политику настраиваемого/нестандартного индекса.

В следующем примере показывается, как повысить точность для диапазонных индексов в коллекции с использованием .NET SDK. Обратите внимание, что при этом используется специальный путь "/" — это объясняется в следующем разделе.

    var rangeDefault = new DocumentCollection { Id = "rangeCollection" };
    
    rangeDefault.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/*", 
            Indexes = new Collection<Index> { 
                new RangeIndex(DataType.String) { Precision = -1 }, 
                new RangeIndex(DataType.Number) { Precision = -1 }
            }
        });

    await client.CreateDocumentCollectionAsync(database.SelfLink, rangeDefault);   


### Пути индекса

В документах вы можете выбрать, какие пути необходимо включить или исключить из индексирования. Такой подход может обеспечить повышение производительности при записи и понижение требований к хранилищу индекса при сценариях, когда шаблоны запросов известны заранее.

Пути индекса начинаются с корневой (/) и, как правило, заканчиваются оператором подстановочного знака ?, обозначающего, что существует несколько возможных значений префикса. Например, чтобы обслуживать запрос SELECT * FROM Families F WHERE F.familyName = "Andersen", вам нужно включить путь индекса для /familyName/? в политику индекса коллекции.

В путях индекса можно также использовать оператор подстановочного знака * для задания алгоритма пути рекурсивно по префиксу. Например, /payload/* можно использовать для исключения из индексации всего, что находится по свойству payload.

Вот распространенные шаблоны задания путей индекса:

<table border="0" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td valign="top">
                <p>
                    <strong>Путь</strong>
                </p>
            </td>
            <td valign="top">
                <p>
                    <strong>Описание/вариант использования</strong>
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    /*
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь коллекции по умолчанию. Рекурсивный и применяется ко всему дереву документа.
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    /prop/?
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь индекса, необходимый для обслуживания следующих запросов (с типами хэш, диапазон, соответственно):
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop = "value"
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop > 5
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    /prop/*
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь индекса для всех путей по заданной метке. Работает со следующими запросами
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop = "value"
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop.subprop > 5
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop.subprop.nextprop = "value"
                </p>

            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    /props/[]/?
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь индекса, необходимый для обслуживания запросов с итерацией и соединения, отправляемых в массивы скалярных выражений, например, ["a", "b", "c"]:
                </p>
                <p>
                    SELECT tag FROM tag IN collection.props WHERE tag = "value"
                </p>
                <p>
                    SELECT tag FROM collection c JOIN tag IN c.props WHERE tag > 5
                </p>
            </td>
        </tr>
        <tr>
            <td valign="top">
                <p>
                    /props/[]/subprop/?
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь индекса, необходимый для обслуживания запросов с итерацией и соединения, отправляемых в массивы объектов, например, [{subprop: "a"}, {subprop: "b"}]:
                </p>
                <p>
                    SELECT tag FROM tag IN collection.props WHERE tag.subprop = "value"
                </p>
                <p>
                    SELECT tag FROM collection c JOIN tag IN c.props WHERE tag.subprop = "value"
                </p>
            </td>
        </tr>        
        <tr>
            <td valign="top">
                <p>
                    /prop/subprop/?
                </p>
            </td>
            <td valign="top">
                <p>
                    Путь индекса, необходимый для обслуживания запросов (с типами хэш, диапазон, соответственно):
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop.subprop = "value"
                </p>
                <p>
                    SELECT * FROM collection c WHERE c.prop.subprop > 5
                </p>
            </td>
        </tr>
    </tbody>
</table>

>[AZURE.NOTE]При задании пути пользовательского индекса необходимо выбрать правило индексации по умолчанию для всего дерева документов, указав специальный путь "/*".

В следующем примере показана настройка конкретного пути с диапазонной индексацией и пользовательским значением точности в 20 байт:

    var collection = new DocumentCollection { Id = "rangeSinglePathCollection" };    
    
    collection.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/Title/?", 
            Indexes = new Collection<Index> { 
                new RangeIndex(DataType.String) { Precision = 20 } } 
            });

    collection.IndexingPolicy.IncludedPaths.Add(
        new IncludedPath { 
            Path = "/*" 
        });
        
    collection = await client.CreateDocumentCollectionAsync(database.SelfLink, pathRange);


DocumentDB возвращает ошибку, если запрос использует предложение Order By, но не имеет диапазонного индекса для запрашиваемого пути с максимальной точностью. Если для запросов с операторами диапазона типа >= не указан диапазонный индекс (любой точности), возвращается ошибка, однако они могут обрабатываться, если существуют фильтры, которые можно применить из этого индекса. Диапазонные запросы можно выполнять без диапазонного индекса с помощью заголовка x-ms-documentdb-enable-scans в REST API или параметра запроса EnableScanInQuery, используя .NET SDK.

Аналогичным образом пути можно полностью исключить из индексации. В следующем примере показано, как исключить из индексации раздел сущностей документов (так называемое поддерево) с помощью подстановочного знака "*".

    var collection = new DocumentCollection { Id = "excludedPathCollection" };
    collection.IndexingPolicy.IncludedPaths.Add(new IncludedPath { Path = "/" });
    collection.IndexingPolicy.ExcludedPaths.Add(new ExcludedPath { Path = "/nonIndexedContent/*");
    
    collection = await client.CreateDocumentCollectionAsync(database.SelfLink, excluded);


## Настройка производительности

При оценке различных конфигураций политики индексирования следует оценить последствия политики для хранилища и пропускной способности с помощью API-интерфейсов DocumentDB.

Чтобы оценить квоты хранения и использования коллекции, запустите запрос HEAD или GET для ресурсов коллекции и выберите заголовки запросов x-ms-request-quota и x-ms-request-usage. В пакете SDK для .NET свойства [DocumentSizeQuota](http://msdn.microsoft.com/library/dn850325.aspx) и [DocumentSizeUsage](http://msdn.microsoft.com/library/azure/dn850324.aspx) на вкладке [ResourceResponse<T>](http://msdn.microsoft.com/library/dn799209.aspx) содержат соответствующие значения.

     // Measure the document size usage (which includes the index size) against   
     // different policies.        
     ResourceResponse<DocumentCollection> collectionInfo = await client.ReadDocumentCollectionAsync(collectionSelfLink);  
     Console.WriteLine("Document size quota: {0}, usage: {1}", collectionInfo.DocumentQuota, collectionInfo.DocumentUsage);


Для оценки расходов на индексирование в каждой операции записи (создание, обновление или удаление) выберите заголовок x-ms-request-charge (или эквивалентное свойство [RequestCharge](http://msdn.microsoft.com/library/dn799099.aspx) на вкладке [ResourceResponse<T>](http://msdn.microsoft.com/library/dn799209.aspx) в SDK для .NET), чтобы измерить число единиц запроса, используемых такими операциями.

     // Measure the performance (request units) of writes.     
     ResourceResponse<Document> response = await client.CreateDocumentAsync(collectionSelfLink, myDocument);              
     Console.WriteLine("Insert of document consumed {0} request units", response.RequestCharge);
     
     // Measure the performance (request units) of queries.    
     IDocumentQuery<dynamic> queryable =  client.CreateDocumentQuery(collectionSelfLink, queryString).AsDocumentQuery();                                  
     double totalRequestCharge = 0;
     while (queryable.HasMoreResults)
     {
        FeedResponse<dynamic> queryResponse = await queryable.ExecuteNextAsync<dynamic>(); 
        Console.WriteLine("Query batch consumed {0} request units",queryResponse.RequestCharge);
        totalRequestCharge += queryResponse.RequestCharge;
     }
     
     Console.WriteLine("Query consumed {0} request units in total", totalRequestCharge);

## Изменения в спецификации политики индексации
Изменение в схеме для политики индексации было представлено 7 июля 2015 года с помощью интерфейса API REST версии 2015-06-03. Представленные классы в версиях пакетов SDK имеют новые реализации, соответствующие схеме.

В спецификации JSON были реализованы следующие изменения:

- Политика индексации поддерживает диапазонные индексы для строк.
- Каждый путь может иметь несколько определений индекса, по одному для каждого типа данных.
- Поддерживаемая точность индексации: 1–8 для чисел, 1–100 для строк и –1 (максимальная точность).
- Двойные кавычки в сегментах путей для экранирования каждого пути не требуются. Например, вы можете добавить путь для /title/? вместо /"title"/?
- Корневой путь, представляющий "все пути", можно указать в виде "/*" (в дополнение к "/").

Если у вас имеется код, который подготавливает коллекции с пользовательской политикой индексации, написанный с помощью пакета SDK .NET версии 1.1.0 или более ранней, необходимо изменить код приложения, чтобы обработать эти изменения с целью переноса в пакет SDK версии 1.2.0. Если у вас нет кода, который настраивает политику индексации, или если вы планируете продолжить использование старой версии пакета SDK, изменения не требуются.

Ниже приведены несколько примеров, демонстрирующих различия между API версии 2015-06-03 и предыдущей версии 2015-04-08.

**Предыдущая политика индексации JSON**

    {
       "automatic":true,
       "indexingMode":"Consistent",
       "IncludedPaths":[
          {
             "IndexType":"Hash",
             "Path":"/",
             "NumericPrecision":7,
             "StringPrecision":3
          }
       ],
       "ExcludedPaths":[
          "/"nonIndexedContent"/*"
       ]
    }

**Текущая политика индексации JSON**

    {
       "automatic":true,
       "indexingMode":"Consistent",
       "includedPaths":[
          {
             "path":"/*",
             "indexes":[
                {
                   "kind":"Hash",
                   "dataType":"String",
                   "precision":3
                },
                {
                   "kind":"Hash",
                   "dataType":"Number",
                   "precision":7
                }
             ]
          }
       ],
       "ExcludedPaths":[
          {
             "path":"/nonIndexedContent/*"
          }
       ]
    }

## Дальнейшие действия

Используйте ссылки ниже для примеров управления политиками индексации и получения дополнительных сведений о языке запросов DocumentDB.

1.	[Примеры кода управления индексами для DocumentDB .NET](https://github.com/Azure/azure-documentdb-net/blob/master/samples/code-samples/IndexManagement/Program.cs)
2.	[Операции с коллекциями DocumentDB REST API](https://msdn.microsoft.com/library/azure/dn782195.aspx)
3.	[Формирование запросов с помощью DocumentDB SQL](documentdb-sql-query.md)

 

<!---HONumber=July15_HO3-->