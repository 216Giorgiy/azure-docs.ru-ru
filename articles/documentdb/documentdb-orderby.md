<properties 
	pageTitle="Сортировка данных DocumentDB с помощью Order By | Azure" 
	description="Узнайте, как использовать предложение ORDER BY в запросах DocumentDB с LINQ и SQL и как задать политику индексации для запросов ORDER BY." 
	services="documentdb" 
	authors="arramac" 
	manager="jhubbard" 
	editor="cgronlun" 
	documentationCenter=""/>

<tags 
	ms.service="documentdb" 
	ms.workload="data-services" 
	ms.tgt_pltfrm="na" 
	ms.devlang="na" 
	ms.topic="article" 
	ms.date="06/04/2015" 
	ms.author="arramac"/>

# Сортировка данных DocumentDB с помощью Order By
Служба Microsoft Azure DocumentDB поддерживает запросы документов с помощью SQL через документы JSON. Результаты запроса можно упорядочить с помощью предложения ORDER BY в инструкции запроса SQL.

Ознакомившись с данной статьей, вы сможете ответить на следующие вопросы.

- Как реализовать запрос с помощью предложения Order By?
- Как настроить политику индексации для предложения Order By?
- Что дальше?

Вы также найдете [образцы](#samples) и [часто задаваемые вопросы](#faq).

Более подробные сведения о запросах SQL см. в [учебнике по запросам DocumentDB](documentdb-sql-query.md).

## Реализация запроса с помощью предложения Order By
Как и в ANSI-SQL, вы теперь можете включать необязательное предложение Order By в инструкции SQL при запросе DocumentDB. Предложение может включать необязательный аргумент ASC/DESC, указывающий порядок, в котором должны быть получены результаты.

### Упорядочение с помощью SQL
Например, вот запрос для получения книг в порядке убывания PublishTimestamp.

    SELECT * 
    FROM Books 
    ORDER BY Books.PublishTimestamp DESC

### Упорядочение с помощью SQL с фильтрацией
Можно упорядочить результаты с помощью любого вложенного свойства в рамках документов, например Books.ShippingDetails.Weight. Кроме того, можно указать дополнительный фильтр в предложении WHERE в сочетании с предложением Order By, как в этом примере:

    SELECT * 
    FROM Books 
	WHERE Books.SalePrice > 4000
    ORDER BY Books.ShippingDetails.Weight

### Упорядочение с помощью поставщика LINQ для .NET
С помощью пакета SDK для .NET версии 1.2.0 и выше можно использовать предложение OrderBy() или OrderByDescending() в запросах LINQ, как в этом примере:

    foreach (Book book in client.CreateDocumentQuery<Book>(booksCollection.SelfLink)
        .OrderBy(b => b.PublishTimestamp)) 
    {
        // Iterate through books
    }

### Упорядочение по страницам с помощью пакета SDK для .NET
С помощью встроенной поддержки разбиения по страницам пакетов SDK для DocumentDB можно получать по одной странице результатов, как в следующем фрагменте кода .NET. Здесь мы получаем до 10 результатов одновременно с помощью FeedOptions.MaxItemCount и интерфейса IDocumentQuery.

    var booksQuery = client.CreateDocumentQuery<Book>(
        booksCollection.SelfLink,
        "SELECT * FROM Books ORDER BY Books.PublishTimestamp DESC"
        new FeedOptions { MaxItemCount = 10 })
      .AsDocumentQuery();
            
    while (booksQuery.HasMoreResults) 
    {
        foreach(Book book in await booksQuery.ExecuteNextAsync<Book>())
        {
            // Iterate through books
        }
    }

В этой предварительной версии компонента DocumentDB поддерживает упорядочение для числовых типов (не строк) и только для одного свойства Order By на запрос. Подробнее см. в разделе [Что дальше?](#Whats_coming_next).

## Настройка политики индексации для предложения Order By
Для выполнения запросов Order By необходимо выполнить одно из следующих действий:

- индексировать конкретные пути в документах с максимальной точностью; (или) 
- индексировать *все* пути рекурсивно для всей коллекции с максимальной точностью. 

Максимальная точность (представленная как точность -1 в файле конфигурации JSON) использует переменное число байт в зависимости от значения, которое индексируется. Таким образом:

- свойства с большими числовыми значениями, например метки времени эпохи, при максимальной точности будут иметь высокие затраты на индексирование; 
- свойства с меньшими числовыми значениями (перечисления, нули, почтовые индексы, века и т. д.) будут иметь низкие затраты на индексирование.

Подробнее см. в разделе [Политики индексации DocumentDB](documentdb-indexing-policies.md).

### Индексирование в предложении Order By для всех числовых свойств
Вот как можно создать коллекцию с индексированием в предложении Order By для любого (числового) свойства.
                   

    booksCollection.IndexingPolicy.IncludedPaths.Add(
        new IndexingPath {
            IndexType = IndexType.Range, 
            Path = "/",
            NumericPrecision = -1 });

    await client.CreateDocumentCollectionAsync(databaseLink, 
        booksCollection);  

### Индексирование Order By для одного свойства
Вот как можно создать коллекцию с индексированием в предложении Order By только для свойства PublishTimestamp.

    booksCollection.IndexingPolicy.IncludedPaths.Add(
        new IndexingPath {
            IndexType = IndexType.Range,
            Path = "/\"PublishTimestamp\"/?",
            NumericPrecision = -1
        });

    booksCollection.IndexingPolicy.IncludedPaths.Add(
        new IndexingPath {
            Path = "/"
        });


## Примеры
Обратите внимание на этот [проект образцов Github](https://github.com/Azure/azure-documentdb-net/tree/master/samples/orderby), который показывает, как использовать Order By, включая создание политик индексации и разбиение по страницам с помощью Order By. Образцы содержат открытый исходный код, и мы рекомендуем вам отправлять запросы с материалами, которые могут принести пользу другим разработчикам DocumentDB. Инструкции о том, как принять участие, см. в разделе [Рекомендации по участию](https://github.com/Azure/azure-documentdb-net/blob/master/Contributing.md).

## Что дальше?

Будущие обновления службы будут включать поддержку предложения Order By, представленного здесь. Мы работаем над следующими дополнениями и будем определять приоритет выпуска этих улучшений на основе ваших отзывов.

- Политики динамической индексации: поддержка изменения политики индексации после создания коллекции
- Индексы диапазона строки: индекс для поддержки запросов в диапазоне (>, <, >=, <=) для строковых значений. Чтобы обеспечить поддержку этих возможностей, корпорация Майкрософт представит новую более широкую схему для политик индексации.
- Поддержка строки Order By в запросе DocumentDB.
- Возможность обновления политики индексации на портале предварительной версии Azure.
- Поддержка составных индексов для повышения эффективности Order By и Order By с несколькими свойствами.

## Часто задаваемые вопросы

**Какие платформы и версии SDK поддерживают упорядочение?**

Поскольку предложение Order By является серверным обновлением, для использования этой функции нет необходимости загружать новую версию пакета SDK. Все платформы и версии пакета SDK, включая серверный пакет SDK JavaScript, могут использовать Order By с помощью строк запроса SQL. При использовании LINQ необходимо загрузить версию 1.2.0 или более позднюю версию из Nuget.

**Какой расход единиц запроса (RU) ожидается для запросов Order By?**

Поскольку предложение Order By использует индекс DocumentDB для уточняющих запросов, количество единиц запроса, используемых запросами Order By, аналогично таковому эквивалентных запросов без Order By. Как и в случае любой другой операции DocumentDB, число единиц запроса зависит от размера и формы документов, а также от сложности запроса.


**Каковы ожидаемые затраты на индексирование для Order By?**

Затраты хранилища индексирования будут пропорциональны количеству числовых свойств. В худшем случае затраты индексирования составят 100 % данных. Нет никакой разницы в затратах по пропускной способности (единицы запроса), между индексированием Range/Order By и индексированием Hash по умолчанию.

**Влияет ли это изменение на запросы без Order By?**

Изменения в работе запросов без Order By в настоящее время отсутствуют. До выпуска этого компонента все запросы DocumentDB возвращали результаты в порядке ResourceId (_rid). При использовании Order By запросы, естественно, возвращаются в указанном порядке значений. В запросах Order By _rid будет использоваться в качестве дополнительной сортировки при наличии нескольких документов, возвращаемых с одинаковыми значениями.

**Как запросить существующие данные в DocumentDB с помощью Order By?**

Эта возможность будет поддерживаться за счет доступности улучшения политик динамической индексации, упомянутого в разделе [Что дальше?](what's-coming-next). В настоящее время для этого необходимо экспортировать данные и повторно импортировать их в новую коллекцию DocumentDB, созданную с индексом Range/Order By. Средство импорта DocumentDB можно использовать для переноса данных между коллекциями.

**Каковы текущие ограничения Order By?**

Предложение Order By можно указать только для числовых свойств и только при индексированном диапазоне с максимальной точностью индексирования (-1). Order By поддерживается только для коллекций документов.

Невозможно выполнить следующие задачи.
 
- Использовать Order By со строковыми свойствами (ожидается вскоре).
- Использовать Order By с внутренними строковыми свойствами, такими как id, _rid и _self (ожидается вскоре). - Использовать Order By со свойствами, полученными в результате объединения внутри документа (ожидается вскоре).
- Использовать Order By с несколькими свойствами (ожидается вскоре).
- Использовать Order By с вычисляемыми свойствами, например, с результатом выражения или с определяемой пользователем или встроенной функцией.
- Использовать Order By с запросами к базам данных, коллекциям, пользователям, разрешениям или вложениям.

## Дальнейшие действия

Скопируйте [проект образцов Github](https://github.com/Azure/azure-documentdb-net/tree/master/samples/orderby) и запустите упорядочение данных!

## Ссылки
* [Справочник по запросам DocumentDB](documentdb-sql-query.md)
* [Справочник по политике индексации DocumentDB](documentdb-indexing-policies.md)
* [Справочник по языку SQL DocumentDB](https://msdn.microsoft.com/library/azure/dn782250.aspx)
* [Образцы Order By в DocumentDB](https://github.com/Azure/azure-documentdb-net/tree/master/samples/orderby)
 

<!---HONumber=62-->