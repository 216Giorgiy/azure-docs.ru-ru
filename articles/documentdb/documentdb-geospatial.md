<properties 
    pageTitle="Работа с геопространственными данными в Azure DocumentDB | Microsoft Azure" 
    description="Узнайте, как создать, индексировать и запрашивать пространственные объекты в Azure DocumentDB." 
    services="documentdb" 
    documentationCenter="" 
    authors="arramac" 
    manager="jhubbard" 
    editor="monicar"/>

<tags 
    ms.service="documentdb" 
    ms.devlang="na" 
    ms.topic="article" 
    ms.tgt_pltfrm="na" 
    ms.workload="data-services" 
    ms.date="02/03/2016" 
    ms.author="arramac"/>
    
# Работа с геопространственными данными в Azure DocumentDB

Эта статья содержит вводную информацию о геопространственной функциональности [Azure DocumentDB](https://azure.microsoft.com/services/documentdb/). После прочтения этой статьи вы сможете ответить на следующие вопросы:

- Как хранить пространственные данные в Azure DocumentDB?
- Как запрашивать геопространственные данные в Azure DocumentDB с помощью SQL и LINQ?
- Как включить или отключить пространственное индексирование в DocumentDB?

Примеры кода можно найти в [следующем проекте Github](https://github.com/Azure/azure-documentdb-dotnet/blob/master/samples/code-samples/Geospatial/Program.cs).

## Общие сведения о пространственных данных

Пространственные данные описывают положение и форму объектов в пространстве. В большинстве приложений они соответствуют объектам на поверхности Земли, т. е. геопространственным данным. Пространственные данные могут использоваться для представления местонахождения человека, мест, представляющих интерес, или границ города или озера. Наиболее распространенные случаи часто включают запросы близости, например "найти все кафе рядом с моим текущим местоположением".

### GeoJSON
DocumentDB поддерживает индексацию и запросы к геопространственным данным точки, представляемым [спецификацией GeoJSON](http://geojson.org/geojson-spec.html). Структуры данных GeoJSON всегда являются действительными объектами JSON, поэтому их можно сохранять и опрашивать с помощью DocumentDB без специальных средств или библиотек. Пакеты SDK DocumentDB предоставляют вспомогательные классы и методы, которые позволяют легко работать с пространственными данными.

### Точки, объекты LineString и многоугольники
**Точка** обозначает одно положение в пространстве. В геопространственных данных точка представляет точное расположение, которое может быть адресом продуктового магазина, киоска, точкой расположения автомобиля или города. В GeoJSON (и DocumentDB) точка представляется в виде пары координат или широты и долготы. Ниже приведен пример JSON для точки.

**Точки в DocumentDB**

    {
       "type":"Point",
       "coordinates":[ 31.9, -4.8 ]
    }

>[AZURE.NOTE] В спецификации GeoJSON сначала указывается широта, затем долгота. Как и в других картах, широта и долгота представляют собой углы и выражаются в градусах. Значение долготы отсчитывается от нулевого меридиана и находится в диапазоне от -180 до 180.0 градусов, а значение широты отсчитывается от экватора и находится в диапазоне от-90.0 до 90.0 градусов.
>
> В DocumentDB координаты интерпретируются в соответствии с системой координат WGS-84. Дополнительные сведения о системах координат см. ниже.

Их можно включить в документ DocumentDB, как показано в следующем примере профиля пользователя, содержащего данные о местоположении:

**Использование профиля с данными о местоположении, которые хранятся в DocumentDB**

    {
       "id":"documentdb-profile",
       "screen_name":"@DocumentDB",
       "city":"Redmond",
       "topics":[ "NoSQL", "Javascript" ],
       "location":{
          "type":"Point",
          "coordinates":[ 31.9, -4.8 ]
       }
    }

Наряду с точками GeoJSON также поддерживает объекты LineString и многоугольники. **Объект LineString** представляет собой последовательность из двух или более точек в пространстве и отрезков, которые их соединяют. В геопространственных данных объекты LineString обычно используются для представления автомагистралей или рек. **Многоугольник** представляет собой область, ограниченную соединенными друг с другом точками, которая образует замкнутый объект LineString. Многоугольники обычно используются для представления естественных природных образований, таких как озера, или географических единиц, таких как города и области. Ниже приведен пример многоугольника в DocumentDB.

**Многоугольники в DocumentDB**

    {
       "type":"Polygon",
       "coordinates":[
           [ 31.8, -5 ],
           [ 31.8, -4.7 ],
           [ 32, -4.7 ],
           [ 32, -5 ],
           [ 31.8, -5 ]
       ]
    }

>[AZURE.NOTE] По спецификации GeoJSON для действительного многоугольника последняя пара координат должна совпадать с первой, чтобы фигура стала замкнутой.
>
>Точки внутри многоугольника должны указываться в порядке против часовой стрелки. Если точки указаны в порядке по часовой стрелке, то многоугольник представляет регион, расположенный снаружи от него.

Наряду с точками, объектами LineString и многоугольниками в GeoJSON также определяется способ группировки нескольких геопространственных местоположений, а также способ задания произвольных свойств географического положения в качестве **Функций**. Поскольку эти объекты являются действительными объектами JSON, их можно хранить и обрабатывать в DocumentDB. Однако DocumentDB поддерживает только автоматическую индексацию точек.

### Системы координат

Поскольку Земля имеет неправильную форму, координаты геопространственных данных представляются во многих системах координат, каждая из которых имеет собственные границы отсчета и единицы измерения. Например, "Национальная система координат Великобритании" (National Grid of Britain) обладает высокой точностью в Великобритании, но не за ее пределами.

Самой популярной системой координат на данный момент является [WGS-84](http://earth-info.nga.mil/GandG/wgs84/). WGS-84 используют устройства GPS и многие службы географических карт, в том числе Карты Google и API-интерфейсы Карт Bing. DocumentDB поддерживает индексирование и опрашивание геопространственных данных только с использованием WGS-84.

## Создание документов с пространственными данными
При создании документов, содержащих значения GeoJSON, они автоматически индексируются с пространственным индексом в соответствии с политикой индексирования коллекции. При работе с пакетом SDK DocumentDB в динамически типизированных языках программирования, таких как Python или Node.js, необходимо создавать действительные объекты GeoJSON.

**Создание документа с геопространственными данными в Node.js**

    var userProfileDocument = {
       "name":"documentdb",
       "location":{
          "type":"Point",
          "coordinates":[ -122.12, 47.66 ]
       }
    };

    client.createDocument(collectionLink, userProfileDocument, function (err, created) {
        // additional code within the callback
    });

Если вы работаете с пакетами SDK .NET (или Java), то можете использовать новые классы Point и Polygon в пространстве имен Microsoft.Azure.Documents.Spatial для включения информации о местоположении в свои объекты приложения. Эти классы помогают упростить сериализацию и десериализацию пространственных данных в GeoJSON.

**Создание документа с геопространственными данными в .NET**

    using Microsoft.Azure.Documents.Spatial;
    
    public class UserProfile
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("location")]
        public Point Location { get; set; }
        
        // More properties
    }
    
    await client.CreateDocumentAsync(
        collection.SelfLink, 
        new UserProfile 
        { 
            Name = "documentdb", 
            Location = new Point (-122.12, 47.66) 
        });

Если у вас нет информации о широте и долготе, но есть физический адрес или название местоположения, например название города или страны, то фактические координаты можно определить с помощью службы геокодирования, такой как служба REST Карт Bing. Дополнительные сведения о геокодировании в Картах Bing можно найти [здесь](https://msdn.microsoft.com/library/ff701713.aspx).

## Типы запросов к пространственным данным

Теперь, когда мы рассмотрели способы внедрения геопространственных данных, обратимся к тому, как запрашивать эти данные в DocumentDB с помощью SQL и LINQ.

### Встроенные функции для обработки пространственных данных в SQL
DocumentDB поддерживает следующие встроенные функции Открытого геопространственного консорциума (OGC) для выполнения запросов к геопространственным данным. Дополнительные сведения о всех встроенных функциях SQL см. в разделе [Запросы в DocumentDB](documentdb-sql-query.md).

<table>
<tr>
  <td><strong>Использование</strong></td>
  <td><strong>Описание</strong></td>
</tr>
<tr>
  <td>ST_DISTANCE (point_expr, point_expr)</td>
  <td>Возвращает расстояние между двумя выражениями точек GeoJSON.</td>
</tr>
<tr>
  <td>ST_WITHIN (point_expr, polygon_expr)</td>
  <td>Возвращает логическое выражение, указывающее, располагается ли точка GeoJSON, указанная в первом аргументе, внутри многоугольника GeoJSON, указанного в качестве второго аргумента.</td>
</tr>
<tr>
  <td>ST_ISVALID</td>
  <td>Возвращает логическое значение, указывающее, является ли действительным указанное выражение точки или многоугольника GeoJSON.</td>
</tr>
<tr>
  <td>ST_ISVALIDDETAILED</td>
  <td>Возвращает значение JSON, содержащее логическое значение, указывающее, является ли выражение точки или многоугольника GeoJSON действительным. Если оно является недействительным, возвращаемое значение также содержит строку с описанием причины.</td>
</tr>
</table>

Пространственные функции могут использоваться для выполнения запросов близости к пространственным данным. Например, ниже приведен запрос, возвращающий все документы семейств, которые находятся в пределах 30 км от заданного расположения, с помощью встроенной функции ST\_DISTANCE.

**Запрос**

    SELECT f.id 
    FROM Families f 
    WHERE ST_DISTANCE(f.location, {'type': 'Point', 'coordinates':[31.9, -4.8]}) < 30000

**Результаты**

    [{
      "id": "WakefieldFamily"
    }]

При включении пространственного индексирования в политику индексирования "запросы для определения расстояния" будут эффективно обрабатываться с помощью индекса. Дополнительные сведения о пространственном индексировании см. в следующем разделе. При отсутствии пространственного индекса для указанных путей вы все равно сможете выполнять пространственные запросы, указывая заголовок запроса `x-ms-documentdb-query-enable-scan` со значением "true". В .NET это можно сделать, указав необязательный аргумент запроса **FeedOptions** со свойством [EnableScanInQuery](https://msdn.microsoft.com/library/microsoft.azure.documents.client.feedoptions.enablescaninquery.aspx#P:Microsoft.Azure.Documents.Client.FeedOptions.EnableScanInQuery), установленным в true.

С помощью ST\_WITHIN можно проверить, находится ли точка внутри многоугольника. Многоугольники обычно используются для представления границ, например почтовых зон, границ штатов или границ природных образований. При включении пространственного индексирования в политику индексирования "запросы нахождения внутри" будут эффективно обрабатываться с помощью индекса.

Аргументы многоугольника в ST\_WITHIN могут содержать только одно кольцо, т. е. в многоугольниках не должно быть "дыр". Ознакомьтесь с [ограничениями DocumentDB](documentdb-limits.md) на максимальное количество точек многоугольника в запросе ST\_WITHIN.

**Запрос**

    SELECT * 
    FROM Families f 
    WHERE ST_WITHIN(f.location, {
    	'type':'Polygon', 
    	'coordinates': [[[31.8, -5], [32, -5], [32, -4.7], [31.8, -4.7], [31.8, -5]]]
    })

**Результаты**

    [{
      "id": "WakefieldFamily",
    }]
    
>[AZURE.NOTE] По аналогии с несоответствием типов в запросе DocumentDB: если значение местоположения, указанное в любом из аргументов, имеет неправильный формат или является недопустимым, то оно приравнивается к значению **не определено** и соответствующий документ исключается из результатов запроса. Если запрос не возвращает результатов, выполните запрос ST\_ISVALIDDETAILED для выяснения причин, по которым тип пространственных данных является недействительным.

Чтобы проверить, является ли пространственный объект действительным, можно воспользоваться ST\_ISVALID и ST\_ISVALIDDETAILED. Например, следующий запрос проверяет действительность точки, значение широты для которой выходит за пределы допустимого диапазона (-132.8). ST\_ISVALID возвращает логическое значение, а ST\_ISVALIDDETAILED возвращает логическое значение и строку, содержащую причину, по которой значение считается недействительным.

** Запрос **

    SELECT ST_ISVALID({ "type": "Point", "coordinates": [31.9, -132.8] })

**Результаты**

    [{
      "$1": false
    }]

Эти функции также могут использоваться для проверки многоугольников. Например, здесь мы используем ST\_ISVALIDDETAILED для того, чтобы проверить, что многоугольник не является замкнутым.

**Запрос**

    SELECT ST_ISVALIDDETAILED({ "type": "Polygon", "coordinates": [[ 
    	[ 31.8, -5 ], [ 31.8, -4.7 ], [ 32, -4.7 ], [ 32, -5 ] 
    	]]})

**Результаты**

    [{
       "$1": { 
      	  "valid": false, 
      	  "reason": "The Polygon input is not valid because the start and end points of the ring number 1 are not the same. Each ring of a polygon must have the same start and end points." 
      	}
    }]
    
### Запросы LINQ в пакете SDK для .NET

В пакете SDK для .NET DocumentDB также содержатся заглушки методов `Distance()` и `Within()` для использования с помощью выражений LINQ. Поставщик LINQ DocumentDB преобразует эти вызовы методов в эквивалентные вызовы встроенных функций SQL (ST\_DISTANCE и ST\_WITHIN соответственно).

Ниже приведен пример запроса LINQ, который находит все документы в коллекции DocumentDB с "местоположением" в радиусе 30 км от указанной точки.

**Запросы LINQ для определения расстояния**

    foreach (UserProfile user in client.CreateDocumentQuery<UserProfile>(collection.SelfLink)
        .Where(u => u.ProfileType == "Public" && a.Location.Distance(new Point(32.33, -4.66)) < 30000))
    {
        Console.WriteLine("\t" + user);
    }

Ниже приведен аналогичный запрос для поиска всех документов с "местоположением" в пределах указанного прямоугольника или многоугольника.

**Запросы LINQ для определения принадлежности**

    Polygon rectangularArea = new Polygon(
        new[]
        {
            new LinearRing(new [] {
                new Position(31.8, -5),
                new Position(32, -5),
                new Position(32, -4.7),
                new Position(31.8, -4.7),
                new Position(31.8, -5)
            })
        });

    foreach (UserProfile user in client.CreateDocumentQuery<UserProfile>(collection.SelfLink)
        .Where(a => a.Location.Within(rectangularArea)))
    {
        Console.WriteLine("\t" + user);
    }


Теперь, когда мы познакомились с запросами к документам с помощью LINQ и SQL, рассмотрим способы настройки DocumentDB для пространственного индексирования.

## Индексация

Как было описано в документе [Схемонезависимое индексирование с помощью Azure DocumentDB](http://www.vldb.org/pvldb/vol8/p1668-shukla.pdf), СУБД DocumentDB является по-настоящему схемонезависимой и обеспечивает превосходную поддержку JSON. СУБД DocumentDB с оптимизацией записи также изначально поддерживает пространственные данные, представленные в стандарте GeoJSON.

По сути, геометрия формируется путем проецирования геодезических координат на двумерную плоскость, которая затем постепенно разделяется на ячейки с помощью **дерева квадрантов**. Эти ячейки связываются с одномерным пространством на основе расположения ячейки на **кривой заполнения гильбертова пространства**, что позволяет сохранить расположение точек. Кроме того, при индексировании данных расположения ячейки проходят через так называемый процесс **тесселяции**, т. е. все ячейки, которые пересекают расположение, обнаруживаются и сохраняются в виде ключей в индексе DocumentDB. Во время обработки запроса такие аргументы, как точки и многоугольники, также тесселируются для извлечения диапазонов идентификаторов соответствующих ячеек, а затем используются для получения данных из индекса.

При указании политики индексирования, которая включает пространственный индекс для /* (все пути), все точки, обнаруженные внутри коллекции, индексируются для эффективного выполнения пространственных запросов (ST\_WITHIN и ST\_DISTANCE). Пространственные индексы не имеют значения точности и всегда используют значение точности по умолчанию.

Следующий фрагмент JSON демонстрирует политику индексирования с включенным пространственным индексированием, т. е. индексированием любой точки GeoJSON, обнаруженной в документах, для пространственных запросов. При изменении политики индексирования с помощью портала Azure можно указать следующий JSON политики индексирования для включения в коллекции пространственного индексирования.

**Политика индексирования коллекции JSON с пространственным индексированием**

    {
       "automatic":true,
       "indexingMode":"Consistent",
       "includedPaths":[
          {
             "path":"/*",
             "indexes":[
                {
                   "kind":"Hash",
                   "dataType":"String",
                   "precision":3
                },
                {
                   "kind":"Range",
                   "dataType":"Number",
                   "precision":-1
                },
                {
                   "kind":"Spatial",
                   "dataType":"Point"
                }
             ]
          }
       ],
       "excludedPaths":[
       ]
    }

Ниже приведен фрагмент кода .NET, который показывает, как создать коллекцию со включенным пространственным индексированием для всех путей, содержащих точки.

**Создание коллекции с пространственным индексированием**

    IndexingPolicy spatialIndexingPolicy = new IndexingPolicy();
    spatialIndexingPolicy.IncludedPaths.Add(new IncludedPath
    {
        Path = "/*",
        Indexes = new System.Collections.ObjectModel.Collection<Index>()
            {
                new RangeIndex(DataType.Number) { Precision = -1 },
                new RangeIndex(DataType.String) { Precision = -1 },
                new SpatialIndex(DataType.Point)
            }
    });

    Console.WriteLine("Creating new collection...");
    collection = await client.CreateDocumentCollectionAsync(dbLink, collectionDefinition);

А вот как можно изменить существующую коллекцию, чтобы воспользоваться преимуществами пространственного индексирования всех точек, которые хранятся в документах.

**Изменение коллекции с пространственным индексированием**

    Console.WriteLine("Updating collection with spatial indexing enabled in indexing policy...");
    collection.IndexingPolicy = spatialIndexingPolicy; 
    await client.ReplaceDocumentCollectionAsync(collection);

    Console.WriteLine("Waiting for indexing to complete...");
    long indexTransformationProgress = 0;
    while (indexTransformationProgress < 100)
    {
        ResourceResponse<DocumentCollection> response = await client.ReadDocumentCollectionAsync(collection.SelfLink);
        indexTransformationProgress = response.IndexTransformationProgress;

        await Task.Delay(TimeSpan.FromSeconds(1));
    }

> [AZURE.NOTE] Если значение расположения GeoJSON в документе сформировано неверно или является недействительным, оно не будет индексироваться для пространственных запросов. Проверить значение расположения можно с помощью ST\_ISVALID и ST\_ISVALIDDETAILED.

## Дальнейшие действия
Теперь, когда вы ознакомились с предварительными сведениями о поддержке геопространственных данных в DocumentDB, вы можете сделать следующее.

- Начните программировать с помощью [Примеров кода для работы с геопространственными данными с помощью .NET на Github](https://github.com/Azure/azure-documentdb-dotnet/blob/e880a71bc03c9af249352cfa12997b51853f47e5/samples/code-samples/Geospatial/Program.cs).
- Освойте геопространственные запросы на [Игровой площадке запросов DocumentDB](http://www.documentdb.com/sql/demo#geospatial)
- Узнайте подробнее о [Запросах в DocumentDB](documentdb-sql-query.md).
- Узнайте подробнее о [Политиках индексирования DocumentDB](documentdb-indexing-policies.md).

<!---HONumber=AcomDC_0204_2016-->