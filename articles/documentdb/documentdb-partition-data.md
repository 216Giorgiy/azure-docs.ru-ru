---
title: "Секционирование и масштабирование в Azure DocumentDB | Документация Майкрософт"
description: "Сведения о работе секционирования в Azure DocumentDB, настройке секционирования и ключей секций, а также о выборе подходящего ключа секции для вашего приложения."
services: documentdb
author: arramac
manager: jhubbard
editor: monicar
documentationcenter: 
ms.assetid: 702c39b4-1798-48dd-9993-4493a2f6df9e
ms.service: documentdb
ms.workload: data-services
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 03/14/2017
ms.author: arramac
ms.custom: H1Hack27Feb2017
translationtype: Human Translation
ms.sourcegitcommit: afe143848fae473d08dd33a3df4ab4ed92b731fa
ms.openlocfilehash: ed0910e4843ab8ab80dae1c16b15487d92017e24
ms.lasthandoff: 03/17/2017


---
# <a name="partitioning-partition-keys-and-scaling-in-documentdb"></a>Секционирование, ключи секции и масштабирование в DocumentDB

[Microsoft Azure DocumentDB](https://azure.microsoft.com/services/documentdb/) разработана таким образом, чтобы обеспечивать высокую и прогнозируемую производительность и легко масштабироваться по мере расширения вашего приложения. В этой статье рассматривается, как работает секционирование в DocumentDB, и описывается, как настроить коллекции DocumentDB для эффективного масштабирования приложений.

После прочтения этой статьи вы сможете ответить на следующие вопросы:   

* Как работает секционирование в Azure DocumentDB?
* Как настроить секционирование в DocumentDB
* Что такое ключи секций и как выбрать правильный ключ секции для моего приложения?

Чтобы начать работу с кодом, скачайте проект со страницы [примера драйвера для тестирования производительности DocumentDB](https://github.com/Azure/azure-documentdb-dotnet/tree/a2d61ddb53f8ab2a23d3ce323c77afcf5a608f52/samples/documentdb-benchmark). 

Секционирование и ключи секций также рассматриваются в этом видео из цикла "Azure, пятница" от Скотта Хансельмана (Scott Hanselman) и главного технического руководителя DocumentDB, Ширеша Тоты (Shireesh Thota).

> [!VIDEO https://channel9.msdn.com/Shows/Azure-Friday/Azure-DocumentDB-Elastic-Scale-Partitioning/player]
> 

## <a name="partitioning-in-documentdb"></a>Секционирование в DocumentDB
В DocumentDB можно хранить документы JSON без схемы и запрашивать их, получая ответ за миллисекунды вне зависимости от масштаба. DocumentDB предоставляет контейнеры для хранения данных, которые называются **коллекциями**. Коллекции — это логические ресурсы, они могут включать в себя одну или несколько физических секций или серверов. Число секций определяется DocumentDB по размеру хранилища и пропускной способности, выделенных для коллекции. С каждой секцией в DocumentDB связано фиксированное хранилище на основе SSD, которое реплицируются для обеспечения высокого уровня доступности. Управление секциями полностью осуществляется Azure DocumentDB, и нет необходимости создавать сложный код или управлять секциями. Коллекции DocumentDB **практически не ограничены** с точки зрения объема хранилища и пропускной способности. 

Секционирование полностью прозрачно для вашего приложения. DocumentDB поддерживает быстрое выполнение операций чтения и записи, SQL- и LINQ-запросы, транзакционную логику на основе JavaScript, уровни согласованности и точный контроль доступа благодаря вызовам REST API для отдельных ресурсов коллекции. Служба обрабатывает распределение данных в секциях и направляет запросы в нужную секцию. 

Как это работает? При создании коллекции в DocumentDB вы можете указать значение конфигурации **свойства ключа секции**. Это свойство JSON (или путь) в документах, которое может использоваться DocumentDB для распределения данных между несколькими серверами или секциями. DocumentDB применит хэш-функцию к ключу секции и использует хэшированный результат, чтобы определить секцию, в которой будет храниться документ JSON. Все документы с одинаковым ключом секции будут храниться в одной секции. 

Для примера рассмотрим приложение, которое хранит данные о сотрудниках и их отделах в DocumentDB. Выберем `"department"` в качестве свойства ключа секции, чтобы разворачивать данные по отделам. Каждый документ в DocumentDB должен содержать обязательное свойство `"id"`, которое должно быть уникальным для каждого из документов с одинаковым значением ключа секции, например `"Marketing`. Каждый документ, хранящийся в коллекции, должен иметь уникальное сочетание ключа секции и идентификатора, например `{ "Department": "Marketing", "id": "0001" }`, `{ "Department": "Marketing", "id": "0002" }` и `{ "Department": "Sales", "id": "0001" }`. Другими словами, составное свойство (ключ секции и идентификатор) является первичным ключом для коллекции.

DocumentDB создает небольшое количество физических разделов за каждой коллекцией на основе размера хранилища и подготовленной пропускной способности. Свойство, определяемое как ключ раздела, является логическим разделом. Несколько значений ключа раздела обычно используют один физический раздел, но одно значение никогда не будет охватывать весь раздел. Хорошо, если у вас есть ключ раздела с большим количеством значений, так как балансировка нагрузки, выполняемая DocumentDB, будет более эффективной по мере увеличения данных или увеличения подготовленной пропускной способности.

Предположим, вы создали коллекцию с пропускной способностью 25 000 запросов в секунду, а DocumentDB поддерживает 10 000 запросов в секунду на каждый физический раздел. DocumentDB создаст для коллекции 3 физических раздела — P1, P2 и P3. Во время вставки или чтения документа служба DocumentDB хэширует соответствующее значение `Department`, чтобы сопоставить данные с одним из трех разделов — P1, P2 и P3. Например, если подразделения "Маркетинг" и "Продажи" имеют хэшированное значение 1, тогда они будут храниться в разделе P1. Когда этот раздел будет заполнен, DocumentDB разделит его на два новых раздела — P4 и P5. Затем служба поместит подразделение "Маркетинг" в раздел P4, а "Продажи" — в раздел P5, после чего раздел P1 можно будет удалить. Эти перемещения ключей раздела между разделами являются прозрачными для приложения и никак не связаны с доступностью коллекции.

## <a name="sharding-in-api-for-mongodb"></a>Сегментирование в API для MongoDB
Сегментированные коллекции в API для MongoDB используют ту же инфраструктуру, что и секционированные коллекции DocumentDB. Как и секционированные коллекции, сегментированные коллекции могут иметь любое количество сегментов. При этом с каждым сегментом связано хранилище на основе SSD определенной емкости. Сегментированные коллекции практически не ограничены с точки зрения объема хранилища и пропускной способности. Ключ сегмента API для MongoDB идентичен ключу секции DocumentDB. При выборе ключа сегмента обязательно ознакомьтесь с разделами [Ключи секции](#partition-keys) и [Проектирование секционирования](#designing-for-partitioning).

<a name="partition-keys"></a>
## <a name="partition-keys"></a>Ключи секции
Выбор ключа секции — важное решение, которое придется принять на этапе проектирования. Необходимо выбрать имя свойства JSON, предусматривающего широкий диапазон значений и, скорее всего, схемы равномерно распределенного доступа. 

> [!NOTE]
> Мы рекомендуем иметь ключ раздела с большим количеством уникальных значений (как минимум сотней и тысячей). Многие клиенты используют DocumentDB в качестве хранилища значений ключей, в котором уникальный идентификатор представляет ключ секции среди огромного множества других ключей.
>

В следующей таблице приведены примеры определений для ключей секции и соответствующие значения JSON. Ключ секции указывается в виде пути JSON, например `/department` представляет свойство отдела. 

<table border="0" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td valign="top"><p><strong>Путь к ключу секции</strong></p></td>
            <td valign="top"><p><strong>Описание</strong></p></td>
        </tr>
        <tr>
            <td valign="top"><p>/department</p></td>
            <td valign="top"><p>Соответствует значению JSON doc.department, где "doc" — это документ.</p></td>
        </tr>
        <tr>
            <td valign="top"><p>/properties/name</p></td>
            <td valign="top"><p>Соответствует значению JSON doc.properties.name, где "doc" — это документ (вложенное свойство).</p></td>
        </tr>
        <tr>
            <td valign="top"><p>/id</p></td>
            <td valign="top"><p>Соответствует значению JSON doc.id (идентификатор и ключ секции — это одно и то же свойство).</p></td>
        </tr>
        <tr>
            <td valign="top"><p>/"имя отдела"</p></td>
            <td valign="top"><p>Соответствует значению JSON doc ["имя отдела"], где "doc" — это документ.</p></td>
        </tr>
    </tbody>
</table>

> [!NOTE]
> Синтаксис пути к ключу секции аналогичен политике индексации; основное отличие состоит в том, что путь соответствует свойству, а не значению, т. е. в конце нет подстановочного знака. Например, для индексации значений в отделе используется /department/?, а в качестве определения ключа секции — /department. Путь к ключу секции индексируется неявно и не может быть исключен из индексирования с помощью переопределений политики индексирования.
> 
> 

Давайте рассмотрим, как выбор ключа секции влияет на производительность приложения.

## <a name="partitioning-and-provisioned-throughput"></a>Секционирование и подготовленная пропускная способность
Система DocumentDB предназначена для обеспечения прогнозируемой производительности. Создавая коллекцию, вы резервируете пропускную способность в **[единицах запросов](documentdb-request-units.md) в секунду**. На каждый запрос расходуется определенное число единиц запроса, пропорциональное объему системных ресурсов, например ЦП и операций ввода-вывода, потребляемых операцией. Чтение документа размером 1 КБ с согласованностью сеанса потребляет 1 единицу запроса. На операцию чтения требуется 1 единица запроса вне зависимости от числа хранящихся элементов или количества параллельных запросов, выполняемых одновременно. Документы большего размера требуют больше единиц запроса. Если вы знаете размер сущностей и количество операций чтения, необходимых для работы вашего приложения, то можете подготовить точную величину пропускной способности, необходимую приложению для операций чтения. 

Когда DocumentDB сохраняет документы, они равномерно распределяются между секциями по значению ключа секции. Пропускная способность также распределяется равномерно между доступными секциями, т. е. пропускная способность каждой секции = (общая пропускная способность для коллекции) / (число секций). 

> [!NOTE]
> Чтобы достичь полной пропускной способности коллекции, необходимо выбрать ключ секции, который позволяет равномерно распределять запросы по нескольким разным значениям ключа секции.
> 
> 

## <a name="single-partition-and-partitioned-collections"></a>Односекционные и секционированные коллекции
DocumentDB поддерживает создание односекционных и секционированных коллекций. 

* **Секционированные коллекции** могут охватывать несколько секций и поддерживают неограниченные объем хранилища и пропускную способность. Для такой коллекции необходимо указать ключ секции. 
* **Односекционные коллекции** дешевле, но они ограничены с точки зрения максимальных объема хранилища и пропускной способности. Для таких коллекций не нужно указывать ключ секции. Мы рекомендуем использовать не односекционные, а секционированные коллекции для всех сценариев, за исключением в ситуаций, в которых потребуется только небольшой объем хранилища и мало запросов.

![Секционированные коллекции в DocumentDB][2] 

Секционированные коллекции могут поддерживать неограниченные объем хранилища и пропускную способность.

В следующей таблице перечислены различия в работе с односекционными и секционированными коллекциями.

<table border="0" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td valign="top"><p></p></td>
            <td valign="top"><p><strong>Односекционная коллекция</strong></p></td>
            <td valign="top"><p><strong>Секционированная коллекция</strong></p></td>
        </tr>
        <tr>
            <td valign="top"><p>Ключ раздела</p></td>
            <td valign="top"><p>None</p></td>
            <td valign="top"><p>Обязательно</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Первичный ключ для документа</p></td>
            <td valign="top"><p>идентификатор</p></td>
            <td valign="top"><p>Составной ключ: &lt;ключ_секции&gt; и идентификатор</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Минимальный объем хранилища</p></td>
            <td valign="top"><p>0 ГБ</p></td>
            <td valign="top"><p>0 ГБ</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Максимальный объем хранилища</p></td>
            <td valign="top"><p>10 ГБ</p></td>
            <td valign="top"><p>Без ограничений</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Минимальная пропускная способность</p></td>
            <td valign="top"><p>400 единиц запроса в секунду</p></td>
            <td valign="top"><p>2500 единиц запроса в секунду</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Максимальная пропускная способность</p></td>
            <td valign="top"><p>10 000 единиц запроса в секунду</p></td>
            <td valign="top"><p>Без ограничений</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Версии API</p></td>
            <td valign="top"><p>Все</p></td>
            <td valign="top"><p>API 2015-12-16 и более поздней версии</p></td>
        </tr>
    </tbody>
</table>

## <a name="working-with-the-documentdb-sdks"></a>Работа с пакетами SDK для DocumentDB
В Azure DocumentDB добавлена поддержка автоматического секционирования с использованием [REST API версии 2015-12-16](https://msdn.microsoft.com/library/azure/dn781481.aspx). Для создания секционированных коллекций необходимо скачать пакет SDK версии 1.6.0 или более поздней версии для одной из поддерживаемых платформ SDK (.NET, Node.js, Java, Python). 

### <a name="creating-partitioned-collections"></a>Создание секционированных коллекций
В приведенном ниже примере показан фрагмент кода .NET для создания коллекции, предназначенной для хранения данных телеметрии устройств, которой выделяется пропускная способность в 20 000 единиц запроса в секунду. Пакет SDK устанавливает значение OfferThroughput (которое в свою очередь задает заголовок запроса `x-ms-offer-throughput` в REST API). Здесь мы задаем `/deviceId` в качестве ключа секции. Выбранный ключ секции сохраняется вместе с остальными метаданными коллекции, такими как имя и политики индексирования.

Для этого примера мы выбрали `deviceId`, т. к. нам известно, что: (а) ввиду большого количества устройств операции записи их можно равномерно распределить между секциями, что позволяет масштабировать базу данных для приема больших объемов данных; (б) многие из запросов, например получение последних показаний устройства, относятся к одному deviceId и могут быть получены из одной секции.

```csharp
DocumentClient client = new DocumentClient(new Uri(endpoint), authKey);
await client.CreateDatabaseAsync(new Database { Id = "db" });

// Collection for device telemetry. Here the JSON property deviceId will be used as the partition key to 
// spread across partitions. Configured for 10K RU/s throughput and an indexing policy that supports 
// sorting against any number or string property.
DocumentCollection myCollection = new DocumentCollection();
myCollection.Id = "coll";
myCollection.PartitionKey.Paths.Add("/deviceId");

await client.CreateDocumentCollectionAsync(
    UriFactory.CreateDatabaseUri("db"),
    myCollection,
    new RequestOptions { OfferThroughput = 20000 });
```

> [!NOTE]
> Для создания секционированных коллекций необходимо использовать пакет SDK. Вы должны указать значение пропускной способности более 10 100 единиц запросов в секунду. Чтобы указать для секционированных коллекций значение пропускной способности от 2500 до 10 000, необходимо временно использовать портал Azure, так как новые низкие значения еще не доступны в пакете SDK.
> 
> 

Этот метод выполняет вызов REST API в DocumentDB, а служба подготавливает число секций, основываясь на запрошенной пропускной способности. Пропускную способность коллекции можно изменить, когда требуется повысить ее производительность. 

### <a name="reading-and-writing-documents"></a>Чтение и запись документов
Пора перейти к вставке данных в DocumentDB. Ниже приведен пример класса, содержащего показание устройства, и вызов CreateDocumentAsync для добавления нового показания устройства в коллекцию.

```csharp
public class DeviceReading
{
    [JsonProperty("id")]
    public string Id;

    [JsonProperty("deviceId")]
    public string DeviceId;

    [JsonConverter(typeof(IsoDateTimeConverter))]
    [JsonProperty("readingTime")]
    public DateTime ReadingTime;

    [JsonProperty("metricType")]
    public string MetricType;

    [JsonProperty("unit")]
    public string Unit;

    [JsonProperty("metricValue")]
    public double MetricValue;
  }

// Create a document. Here the partition key is extracted as "XMS-0001" based on the collection definition
await client.CreateDocumentAsync(
    UriFactory.CreateDocumentCollectionUri("db", "coll"),
    new DeviceReading
    {
        Id = "XMS-001-FE24C",
        DeviceId = "XMS-0001",
        MetricType = "Temperature",
        MetricValue = 105.00,
        Unit = "Fahrenheit",
        ReadingTime = DateTime.UtcNow
    });
```

Давайте прочитаем документ по ключу секции и идентификатору, обновим его, а затем удалим с помощью ключа секции и идентификатора. Обратите внимание, что операции чтения включают в себя значение PartitionKey (соответствующее заголовку запроса `x-ms-documentdb-partitionkey` в REST API).

```csharp
// Read document. Needs the partition key and the ID to be specified
Document result = await client.ReadDocumentAsync(
  UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
  new RequestOptions { PartitionKey = new PartitionKey("XMS-0001") });

DeviceReading reading = (DeviceReading)(dynamic)result;

// Update the document. Partition key is not required, again extracted from the document
reading.MetricValue = 104;
reading.ReadingTime = DateTime.UtcNow;

await client.ReplaceDocumentAsync(
  UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
  reading);

// Delete document. Needs partition key
await client.DeleteDocumentAsync(
  UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
  new RequestOptions { PartitionKey = new PartitionKey("XMS-0001") });
```

### <a name="querying-partitioned-collections"></a>Запрос секционированных коллекций
При запросе данных из секционированных коллекций DocumentDB автоматически направляет запрос в секции, соответствующие значению ключа секции, указанному в фильтре (если таковой имеется). Например, этот запрос направляется только в секцию, которая содержит ключ секции XMS-0001.

```csharp
// Query using partition key
IQueryable<DeviceReading> query = client.CreateDocumentQuery<DeviceReading>(
    UriFactory.CreateDocumentCollectionUri("db", "coll"))
    .Where(m => m.MetricType == "Temperature" && m.DeviceId == "XMS-0001");
```
    
Следующий запрос не имеет фильтра ключа секции (DeviceId) и "прочесывает" все секции, где он выполняется с использованием индекса секции. Обратите внимание, что требуется указать EnableCrossPartitionQuery (`x-ms-documentdb-query-enablecrosspartition` в REST API), чтобы пакет SDK выполнил запрос в секциях.

```csharp
// Query across partition keys
IQueryable<DeviceReading> crossPartitionQuery = client.CreateDocumentQuery<DeviceReading>(
    UriFactory.CreateDocumentCollectionUri("db", "coll"), 
    new FeedOptions { EnableCrossPartitionQuery = true })
    .Where(m => m.MetricType == "Temperature" && m.MetricValue > 100);
```

DocumentDB поддерживает [статистические функции](documentdb-sql-query.md#Aggregates) `COUNT`, `MIN`, `MAX`, `SUM` и `AVG` для секционированных коллекций с помощью SQL с пакетом SDK 1.12.0 и выше. Запросы должны содержать один статистический оператор и одно значение в проекции.

### <a name="parallel-query-execution"></a>Параллельное выполнение запросов
Пакеты SDK для DocumentDB версии 1.9.0 и более поздних версий поддерживают параллельное выполнение запросов, что позволяет выполнять запросы с низким уровнем задержки к секционированным коллекциям, даже если число секций в них очень велико. Например, следующий запрос настроен на выполнение параллельно по секциям.

```csharp
// Cross-partition Order By Queries
IQueryable<DeviceReading> crossPartitionQuery = client.CreateDocumentQuery<DeviceReading>(
    UriFactory.CreateDocumentCollectionUri("db", "coll"), 
    new FeedOptions { EnableCrossPartitionQuery = true, MaxDegreeOfParallelism = 10, MaxBufferedItemCount = 100})
    .Where(m => m.MetricType == "Temperature" && m.MetricValue > 100)
    .OrderBy(m => m.MetricValue);
```
    
Вы можете управлять параллельным выполнением запросов, регулируя следующие параметры.

* Параметр `MaxDegreeOfParallelism` позволяет управлять степенью параллелизма, т. е. устанавливать максимальное число одновременных сетевых подключений к секциям коллекции. Если установить значение -1, то степень параллелизма будет регулироваться пакетом SDK. Если параметр `MaxDegreeOfParallelism` не указан или имеет значение 0 (значение по умолчанию), к секциям коллекции будет установлено одно сетевое подключение.
* Параметр `MaxBufferedItemCount` обеспечивает баланс между задержкой запросов и использованием памяти на стороне клиента. Если пропустить этот параметр или задать значение -1, то число буферизованных элементов при параллельном выполнении запросов будет регулироваться пакетом SDK.

При неизменном состоянии коллекции параллельный запрос будет возвращать результаты в том же порядке, что и при последовательном выполнении. При выполнении межсекционного запроса, включающего в себя сортировку (ORDER BY и/или TOP), пакет SDK для DocumentDB параллельно выполняет запрос между секциями и объединяет частично отсортированные результаты на стороне клиента для получения глобально упорядоченных результатов.

### <a name="executing-stored-procedures"></a>Выполнение хранимых процедур
Также можно выполнять атомарные транзакции с документами с одинаковым идентификатором устройства, т. е. если вы храните статистические выражения или последнее состояние устройства в одном документе. 

```csharp
await client.ExecuteStoredProcedureAsync<DeviceReading>(
    UriFactory.CreateStoredProcedureUri("db", "coll", "SetLatestStateAcrossReadings"),
    new RequestOptions { PartitionKey = new PartitionKey("XMS-001") }, 
    "XMS-001-FE24C");
```
    
В следующем разделе мы рассмотрим переход на секционированные коллекции с односекционных коллекций.

## <a name="creating-an-api-for-mongodb-sharded-collection"></a>Создание сегментированной коллекции API для MongoDB
Самый простой способ создать сегментированную коллекцию API для MongoDB — воспользоваться привычным для вас инструментом, драйвером или пакетом SDK. В этом примере для создания коллекции мы используем оболочку Mongo.

В оболочке Mongo:

```
db.runCommand( { shardCollection: "admin.people", key: { region: "hashed" } } )
```
    
Результат:

```JSON
{
    "_t" : "ShardCollectionResponse",
    "ok" : 1,
    "collectionsharded" : "admin.people"
}
```

<a name="migrating-from-single-partition"></a>

## <a name="migrating-from-single-partition-to-partitioned-collections-in-documentdb"></a>Переход с односекционных на секционированные коллекции в DocumentDB

> [!IMPORTANT]
> Если выполняется импорт в API для MongoDB, то следуйте этим [инструкциям](documentdb-mongodb-migrate.md).
> 
> 

Когда приложению, использующему односекционную коллекцию, требуется более высокая пропускная способность (более 10 000 единиц запросов) или хранилище данных большего размера (более 10 ГБ), можно использовать [средство переноса данных DocumentDB](http://www.microsoft.com/downloads/details.aspx?FamilyID=cda7703a-2774-4c07-adcc-ad02ddc1a44d), чтобы перенести данные из односекционной коллекции в секционированную. 

Переход с односекционной коллекции на секционированную

1. Экспортируйте данные из односекционной коллекции в JSON. Дополнительные сведения см. в разделе [Экспорт в файл JSON](documentdb-import-data.md#export-to-json-file).
2. Импортируйте данные в секционированную коллекцию, созданную с определением ключа секции и пропускной способностью более 2500 единиц запросов в секунду, как показано в следующем примере. Дополнительные сведения см. в разделе [Импорт в DocumentDB (последовательный импорт записей)](documentdb-import-data.md#DocumentDBSeqTarget).

![Перенос данных в секционированную коллекцию в DocumentDB][3]  

> [!TIP]
> Для ускорения импорта рекомендуется увеличить количество параллельных запросов до 100 и более, чтобы воспользоваться преимуществами повышенной пропускной способности, доступной для секционированных коллекций. 
> 
> 

Теперь, когда мы изучили основы, давайте ознакомимся с несколькими важными рекомендациями по проектированию, касающимися работы с ключами секции в DocumentDB.

<a name="designing-for-partitioning"></a>
## <a name="designing-for-partitioning"></a>Проектирование секционирования
Выбор ключа секции — важное решение, которое придется принять на этапе проектирования. В этом разделе описываются некоторые компромиссы, имеющие место при выборе ключа секции для коллекции.

### <a name="partition-key-as-the-transaction-boundary"></a>Ключ секции как граница транзакции
Выбранный ключ секции должен сбалансировать необходимость использования транзакций и требование к распределению сущностей по нескольким ключам секции для реализации масштабируемого решения. С одной стороны, можно задать один ключ секции для всех документов, но это может ограничить масштабируемость решения. С другой стороны, можно назначить уникальный ключ секции каждому документу, что обеспечит высокую масштабируемость, но не позволит использовать транзакции между документами с помощью хранимых процедур и триггеров. Идеальный ключ секции позволяет применять эффективные запросы и обеспечивает достаточную кратность, чтобы гарантировать масштабируемость решения. 

### <a name="avoiding-storage-and-performance-bottlenecks"></a>Как избежать узких мест хранилища и производительности
Кроме описанного выше, важно выбрать свойство, которое позволяет распределять операции записи по множеству различных значений. Запросы по одному и тому же ключу секции не могут превышать пропускную способность одной секции, поэтому они будут регулироваться. Поэтому важно выбрать ключ секции, который не создает **"горячие точки"** в вашем приложении. Так как все данные для ключа отдельной секции должны храниться в пределах секции, рекомендуется также избегать использования ключей секций с большими объемами данных для одного значения. 

### <a name="examples-of-good-partition-keys"></a>Примеры отличных ключей секции
Вот несколько примеров того, как выбрать ключ секции для приложения.

* Если вы реализуете серверную часть профиля пользователя, то в качестве ключа секции удобно выбрать идентификатор пользователя.
* Если вы храните данные IoT, например состояние устройства, то в качестве ключа секции удобно выбрать идентификатор устройства.
* Если вы используете DocumentDB для ведения журнала данных временных рядов, то в качестве ключа секции удобно выбрать имя узла или идентификатор процесса.
* Если вы используете мультитенантную архитектуру, то в качестве ключа секции удобно выбрать идентификатор клиента.

Обратите внимание, что в некоторых случаях использования (например, IoT и профили пользователей, как описано выше) ключ секции может быть таким же, как и ваш идентификатор (ключ документа). В других случаях, например для данных временных рядов, может потребоваться ключ секции, который отличается от этого идентификатора.

### <a name="partitioning-and-loggingtime-series-data"></a>Секционирование и ведение журнала (данные временных рядов)
Одним из наиболее распространенных вариантов использования DocumentDB является ведение журналов и телеметрия. Важно выбрать подходящий ключ секции, поскольку может понадобиться считывать или записывать огромные объемы данных. Выбор будет зависеть от количества операций чтения и записи, а также типов запросов, которые предполагается выполнять. Ниже приведены некоторые советы по выбору подходящего ключа секции.

* Если ваш вариант использования подразумевает небольшое количество операций записи, накапливаемых в течение длительного срока, а также необходимость запроса по диапазонам меток времени и другим фильтрам, то в качестве ключа секции будет уместно использовать свертку метки времени, например дату. Это позволяет выполнять запросы по всем данным для даты из одной секции. 
* Если, как это чаще бывает, рабочая нагрузка подразумевает большое число операций записи, следует использовать ключ секции, который не зависит от метки времени, чтобы DocumentDB мог выполнять равномерную запись в несколько секций. В этом случае хорошим выбором станет имя узла, идентификатор процесса, идентификатор действия или другое свойство с большим количеством элементов. 
* Третий подход является гибридным. В нем предусмотрено несколько коллекций — по одной на каждый день и месяц, а ключ секции является фрагментарным свойством, таким как имя узла. Преимущество такого подхода в том, что вы можете задать разные уровни пропускной способности в зависимости от периода. Например, коллекция для текущего месяца подготавливается с более высокой пропускной способностью, так как она обслуживает операции как чтения, так и записи, при этом коллекции за предыдущие месяцы имеют сниженную пропускную способность, так как обслуживают только чтение.

### <a name="partitioning-and-multi-tenancy"></a>Секционирование и мультитенантность
Если вы реализуете мультитенантное приложение с помощью DocumentDB, то существует два основных метода реализации механизма аренды с помощью DocumentDB: использовать один ключ секции на клиент или одну коллекцию на клиент. Ниже приведены преимущества и недостатки каждого из методов.

* Один ключ секции на клиент: в этой модели клиенты совместно размещены в одной коллекции. Однако запросы и операции вставки для документов в рамках одного клиента можно выполнить с одной секцией. Кроме того, можно реализовать логику транзакций для всех документов в пределах клиента. Так как несколько клиентов совместно используют одну коллекцию, можно сократить затраты на хранилище и пропускную способность, организовав пул ресурсов для клиентов в пределах одной коллекции, а не подготавливая дополнительный запас для каждого клиента. Недостатком является отсутствие изоляции производительности каждого клиента. Повышение производительности или пропускной способности действует для всей коллекции, а не для выбранных клиентов.
* Одна коллекция на клиент: каждый клиент имеет собственную коллекцию. В этой модели можно резервировать производительность для каждого клиента. Благодаря новой модели ценообразования на основе потребления DocumentDB эта модель является более экономичной для мультитенантных приложений с небольшим числом клиентов.

Также можно использовать комбинированный или многоуровневый подход, при котором маленькие клиенты размещаются совместно, а большие переносятся в свои собственные коллекции.

## <a name="next-steps"></a>Дальнейшие действия
В этой статье мы рассмотрели, как действует секционирование в Azure DocumentDB, а также узнали, как создать секционированные коллекции и как выбрать подходящий ключ секции для приложения. 

* Выполняйте проверку масштабирования и производительности с помощью DocumentDB. Пример см. в статье [Проверка производительности и масштабирования с помощью Azure DocumentDB](documentdb-performance-testing.md).
* Приступите к созданию кода с помощью [пакетов SDK](documentdb-sdk-dotnet.md) или [REST API](https://msdn.microsoft.com/library/azure/dn781481.aspx).
* Узнайте больше о [подготовленной пропускной способности в DocumentDB](documentdb-performance-levels.md)

[1]: ./media/documentdb-partition-data/partitioning.png
[2]: ./media/documentdb-partition-data/single-and-partitioned.png
[3]: ./media/documentdb-partition-data/documentdb-migration-partitioned-collection.png  



