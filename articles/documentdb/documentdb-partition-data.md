<properties 
	pageTitle="Секционирование и масштабирование данных в DocumentDB | Microsoft Azure"      
	description="Ознакомьтесь с тем, как масштабировать данные с помощью методики сегментирования. Узнайте о том, что такое сегменты, как секционировать данные в DocumentDB и когда использовать хэш-секционирование и секционирование по диапазонам."         
	keywords="Масштабирование данных, сегмент, сегментирование, documentdb, azure, Microsoft azure"
	services="documentdb" 
	authors="arramac" 
	manager="jhubbard" 
	editor="monicar" 
	documentationCenter=""/>

<tags 
	ms.service="documentdb" 
	ms.workload="data-services" 
	ms.tgt_pltfrm="na" 
	ms.devlang="na" 
	ms.topic="article" 
	ms.date="03/30/2016" 
	ms.author="arramac"/>

# Секционирование и масштабирование в Azure DocumentDB
Система [Microsoft Azure DocumentDB](https://azure.microsoft.com/services/documentdb/) разработана таким образом, чтобы обеспечивать высокую и прогнозируемую производительность и легко осуществлять масштабирование по мере расширения вашего приложения. В этой статье рассматривается, как работает секционирование в DocumentDB, и описывается, как настроить коллекции DocumentDB для эффективного масштабирования приложений.

После прочтения этой статьи вы сможете ответить на следующие вопросы:

- Как работает секционирование в Azure DocumentDB?
- Как настроить секционирование в DocumentDB
- Что такое ключи секций и как выбрать правильный ключ секции для моего приложения?

## Секционирование в DocumentDB

В DocumentDB можно хранить документы JSON без схемы и запрашивать их, получая ответ за миллисекунды вне зависимости от масштаба. DocumentDB предоставляет контейнеры для хранения данных, которые называются **коллекциями**. Коллекции — это логические ресурсы, они могут включать в себя одну или несколько физических секций или серверов. Число секций определяется DocumentDB по размеру хранилища и пропускной способности, выделенных для коллекции. С каждой секцией в DocumentDB связано фиксированное хранилище на основе SSD, которое реплицируются для обеспечения высокого уровня доступности. Управление секциями полностью осуществляется Azure DocumentDB, и нет необходимости создавать сложный код или управлять секциями. Коллекции DocumentDB **практически не ограничены** с точки зрения объема хранилища и пропускной способности.

Секционирование полностью прозрачно для вашего приложения. DocumentDB поддерживает быстрое выполнение операций чтения и записи, SQL- и LINQ-запросы, транзакционную логику на основе JavaScript, уровни согласованности и точный контроль доступа благодаря вызовам REST API для отдельных ресурсов коллекции. Служба обрабатывает распределение данных в секциях и направляет запросы в нужную секцию.

Как это работает? При создании коллекции в DocumentDB можно заметить, что существует такое значение конфигурации, как **свойство ключа секции**, которое можно указать. Это свойство JSON (или путь) в документах, которое может использоваться DocumentDB для распределения данных между несколькими серверами или секциями. DocumentDB применит хэш-функцию к ключу секции и использует хэшированный результат, чтобы определить секцию, в которой будет храниться документ JSON. Все документы с одинаковым ключом секции будут храниться в одной секции.

Для примера рассмотрим приложение, которое хранит данные о сотрудниках и их отделах в DocumentDB. Выберем `"department"` в качестве свойства ключа секции, чтобы разворачивать данные по отделам. Каждый документ в DocumentDB должен содержать обязательное свойство `"id"`, которое должно быть уникальным для каждого из документов с одинаковым значением ключа секции, например `"Marketing`. Каждый документ, хранящийся в коллекции, должен иметь уникальное сочетание ключа секции и идентификатора, например `{ "Department": "Marketing", "id": "0001" }`, `{ "Department": "Marketing", "id": "0002" }` и `{ "Department": "Sales", "id": "0001" }`. Другими словами, составное свойство (ключ секции и идентификатор) является первичным ключом для коллекции.

### Ключи секции
Выбор ключа секции — важное решение, которое придется принять на этапе проектирования. Необходимо выбрать имя свойства JSON, предусматривающего широкий диапазон значений и, скорее всего, схемы равномерно распределенного доступа. Давайте посмотрим, как выбор ключа секции влияет на производительность приложения.

### Секционирование и подготовленная пропускная способность
Система DocumentDB предназначена для обеспечения прогнозируемой производительности. При создании коллекции вы резервируете пропускную способность в **единицах запроса в секунду**. На каждый запрос расходуется определенное число единиц запроса, пропорциональное объему системных ресурсов, например ЦП и операций ввода-вывода, потребляемых операцией. Чтение документа размером 1 КБ с согласованностью сеанса потребляет 1 единицу запроса. Чтение является 1 единицей запроса вне зависимости от числа хранящихся элементов или количества параллельных запросов, выполняемых одновременно. Документы большего размера требуют больше единиц запроса. Если вы знаете размер сущностей и количество операций чтения, необходимых для работы вашего приложения, то можете подготовить точную величину пропускной способности, необходимую приложению для операций чтения.

Когда DocumentDB сохраняет документы, они равномерно распределяются между секциями по значению ключа секции. Пропускная способность также распределяется равномерно между доступными секциями, т. е. пропускная способность каждой секции = (общая пропускная способность для коллекции) / (число секций).

> [AZURE.NOTE] Чтобы достичь полной пропускной способности коллекции, необходимо выбрать ключ секции, который позволяет равномерно распределять запросы по нескольким разным значениям ключа секции.

## Односекционные и секционированные коллекции
DocumentDB поддерживает создание односекционных и секционированных коллекций.

- **Секционированные коллекции** могут охватывать несколько секций и поддерживают очень большой объем хранилища и пропускную способность. Для такой коллекции необходимо указать ключ секции.
- **Односекционные коллекции** обладают более низкой ценой и меньшими возможностями для выполнения запросов и транзакций со всеми данными коллекции. Их масштабируемость и размер хранилища ограничены одной секцией. Для таких коллекций не нужно указывать ключ секции. 

![Секционированные коллекции в DocumentDB][2]

Для сценариев, не требующих больших объемов хранилища или пропускной способности, подходят односекционные коллекции. Обратите внимание, что возможности масштабирования и хранения данных односекционных коллекций ограничены одной секцией, что составляет до 10 ГБ хранилища и до 10 000 единиц запроса в секунду.

Секционированные коллекции могут поддерживать очень большой объем хранилища и пропускную способность. Однако предложения по умолчанию настроены для хранения до 250 ГБ данных и увеличения масштаба до 250 000 единиц запроса в секунду. Если для коллекции требуется большее хранилище или пропускная способность, обратитесь в [службу поддержки Azure](documentdb-increase-limits), чтобы увеличить их для своей учетной записи.

В следующей таблице перечислены различия в работе с односекционными и секционированными коллекциями.

<table border="0" cellspacing="0" cellpadding="0">
    <tbody>
        <tr>
            <td valign="top"><p></p></td>
            <td valign="top"><p><strong>Односекционная коллекция</strong></p></td>
            <td valign="top"><p><strong>Секционированная коллекция</strong></p></td>
        </tr>
        <tr>
            <td valign="top"><p>Ключ раздела</p></td>
            <td valign="top"><p>None</p></td>
            <td valign="top"><p>Обязательно</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Первичный ключ для документа</p></td>
            <td valign="top"><p>идентификатор</p></td>
            <td valign="top"><p>составной ключ: &lt;ключ секции> и идентификатор</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Минимальный объем хранилища</p></td>
            <td valign="top"><p>0 ГБ</p></td>
            <td valign="top"><p>0 ГБ</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Максимальный объем хранилища</p></td>
            <td valign="top"><p>10&#160;ГБ</p></td>
            <td valign="top"><p>Без ограничений (по умолчанию 250 ГБ)</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Минимальная пропускная способность</p></td>
            <td valign="top"><p>400 единиц запроса в секунду</p></td>
            <td valign="top"><p>10 000 единиц запроса в секунду</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Максимальная пропускная способность</p></td>
            <td valign="top"><p>10 000 единиц запроса в секунду</p></td>
            <td valign="top"><p>Без ограничений (по умолчанию 250 000 единиц запроса в секунду)</p></td>
        </tr>
        <tr>
            <td valign="top"><p>Версии API</p></td>
            <td valign="top"><p>Все</p></td>
            <td valign="top"><p>API 2015-12-16 и более поздней версии</p></td>
        </tr>
    </tbody>
</table>

## Работа с пакетами SDK

В Azure DocumentDB добавлена поддержка автоматического секционирования с использованием [REST API версии 2015-12-16](https://msdn.microsoft.com/library/azure/dn781481.aspx). Для создания секционированных коллекций необходимо скачать пакет SDK версии 1.6.0 или более поздней версии для одной из поддерживаемых платформ SDK (.NET, Node.js, Java, Python).

В приведенном ниже примере показан фрагмент кода .NET для создания коллекции, предназначенной для хранения данных телеметрии устройств, которой выделяется пропускная способность в 20 000 единиц запроса в секунду. Пакет SDK устанавливает значение OfferThroughput (которое в свою очередь задает заголовок запроса `x-ms-offer-throughput` в REST API). Здесь мы задаем `/deviceId` в качестве ключа секции. Выбранный ключ секции сохраняется вместе с остальными метаданными коллекции, такими как имя и политики индексирования.

Для этого примера мы выбрали `deviceId`, потому что нам известно, что: (а) ввиду большого количества устройств операции записи можно равномерно распределить между секциями, что позволяет масштабировать базу данных для приема больших объемов данных; (б) многие из запросов, например получение последних показаний устройства, относятся к одному deviceId и могут быть получены из одной секции.

    DocumentClient client = new DocumentClient(new Uri(endpoint), authKey);
    await client.CreateDatabaseAsync(new Database { Id = "db" });

    // Collection for device telemetry. Here the JSON property deviceId will be used as the partition key to 
    // spread across partitions. Configured for 10K RU/s throughput and an indexing policy that supports 
    // sorting against any number or string property.
    DocumentCollection myCollection = new DocumentCollection();
    myCollection.Id = "coll";
    myCollection.PartitionKey.Paths.Add("/deviceId");

    await client.CreateDocumentCollectionAsync(
        UriFactory.CreateDatabaseUri("db"),
        myCollection,
        new RequestOptions { OfferThroughput = 20000 });
        
Этот метод выполняет вызов REST API в DocumentDB, а служба подготавливает число секций, основываясь на запрошенной пропускной способности. Пора перейти к вставке данных в DocumentDB. Ниже приведен пример класса, содержащего показание устройства, и вызов CreateDocumentAsync для добавления нового показания устройства в коллекцию.

    public class DeviceReading
    {
        [JsonProperty("id")]
        public string Id;

        [JsonProperty("deviceId")]
        public string DeviceId;

        [JsonConverter(typeof(IsoDateTimeConverter))]
        [JsonProperty("readingTime")]
        public DateTime ReadingTime;

        [JsonProperty("metricType")]
        public string MetricType;

        [JsonProperty("unit")]
        public string Unit;

        [JsonProperty("metricValue")]
        public double MetricValue;
      }

    // Create a document. Here the partition key is extracted as "XMS-0001" based on the collection definition
    await client.CreateDocumentAsync(
        UriFactory.CreateDocumentCollectionUri("db", "coll"),
        new DeviceReading
        {
            Id = "XMS-001-FE24C",
            DeviceId = "XMS-0001",
            MetricType = "Temperature",
            MetricValue = 105.00,
            Unit = "Fahrenheit",
            ReadingTime = DateTime.UtcNow
        });


Давайте прочитаем документ по ключу секции и идентификатору, обновим его, а затем удалим с помощью ключа секции и идентификатора. Обратите внимание, что операции чтения включают в себя значение PartitionKey (соответствующее заголовку запроса `x-ms-documentdb-partitionkey` в REST API).

    // Read document. Needs the partition key and the ID to be specified
    Document result = await client.ReadDocumentAsync(
      UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
      new RequestOptions { PartitionKey = new object[] { "XMS-0001" }});

    DeviceReading reading = (DeviceReading)(dynamic)result;

    // Update the document. Partition key is not required, again extracted from the document
    reading.MetricValue = 104;
    reading.ReadingTime = DateTime.UtcNow;

    await client.ReplaceDocumentAsync(
      UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
      reading);

    // Delete document. Needs partition key
    await client.DeleteDocumentAsync(
      UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
      new RequestOptions { PartitionKey = new object[] { "XMS-0001" } });

При запросе данных из секционированных коллекций DocumentDB автоматически направляет запрос в секции, соответствующие значению ключа секции, указанному в фильтре (если таковой имеется). Например, этот запрос направляется только в секцию, которая содержит ключ секции XMS-0001.

    // Query using partition key
    IQueryable<DeviceReading> query = client.CreateDocumentQuery<DeviceReading>(
    	UriFactory.CreateDocumentCollectionUri("db", "coll"))
        .Where(m => m.MetricType == "Temperature" && m.DeviceId == "XMS-0001");

Следующий запрос не имеет фильтра ключа секции (DeviceId) и "прочесывает" все секции, где он выполняется с использованием индекса секции. Обратите внимание, что требуется указать EnableCrossPartitionQuery (`x-ms-documentdb-query-enablecrosspartition` в REST API), чтобы пакет SDK выполнил запрос в секциях.

    // Query across partition keys
    IQueryable<DeviceReading> crossPartitionQuery = client.CreateDocumentQuery<DeviceReading>(
        UriFactory.CreateDocumentCollectionUri("db", "coll"), 
        new FeedOptions { EnableCrossPartitionQuery = true })
        .Where(m => m.MetricType == "Temperature" && m.MetricValue > 100);

Также можно выполнять атомарные транзакции с документами с одинаковым идентификатором устройства, т. е. если вы храните статистические выражения или последнее состояние устройства в одном документе.

    await client.ExecuteStoredProcedureAsync<DeviceReading>(
        UriFactory.CreateStoredProcedureUri("db", "coll", "SetLatestStateAcrossReadings"),
        "XMS-001-FE24C",
        new RequestOptions { PartitionKey = new PartitionKey("XMS-001") });

Теперь, когда мы изучили основы, давайте ознакомимся с несколькими важными рекомендациями по проектированию, касающимися работы с ключами секции в DocumentDB.

## Планирование секционирования
Выбор ключа секции — важное решение, которое придется принять на этапе проектирования. В этом разделе описываются некоторые компромиссы, имеющие место при выборе ключа секции для коллекции.

### Ключ секции как граница транзакции
Выбранный ключ секции должен сбалансировать необходимость использования транзакций и требование к распределению сущностей по нескольким секциям для реализации масштабируемого решения. С одной стороны, все сущности можно хранить в одной секции, но это может ограничить масштабируемость решения. С другой стороны, можно хранить по одному документу на ключ секции, что обеспечит высокую масштабируемость, но не позволит использовать транзакции между документами с помощью хранимых процедур и триггеров. Идеальный ключ секции позволяет применять эффективные запросы и обеспечивает достаточное число секций, чтобы гарантировать масштабируемость решения.

### Как избежать узких мест хранилища и производительности 
Кроме описанного выше, важно выбрать свойство, которое позволяет распределять операции записи по множеству различных значений. Запросы по одному и тому же ключу секции не могут превышать пропускную способность одной секции, поэтому они будут регулироваться. По этой причине важно выбрать ключ секции, который не создает **"горячие точки"** в вашем приложении. Общий размер хранилища для документов с одинаковым ключом секции также не может превышать 10 ГБ.

### Примеры отличных ключей секции
Вот несколько примеров того, как выбрать ключ секции для приложения.

* Если вы реализуете серверную часть профиля пользователя, то в качестве ключа секции удобно выбрать идентификатор пользователя.
* Если вы храните данные IoT, например состояние устройства, то в качестве ключа секции удобно выбрать идентификатор устройства.
* Если вы используете DocumentDB для ведения журнала данных временных рядов, то в качестве ключа секции удобно выбрать дату из метки времени.
* Если вы используете мультитенантную архитектуру, то в качестве ключа секции удобно выбрать идентификатор клиента.

Обратите внимание, что в некоторых случаях использования (например, IoT и профили пользователей, как описано выше) ключ секции может быть таким же, как и ваш идентификатор (ключ документа). В других случаях, например для данных временных рядов, может потребоваться ключ секции, который отличается от этого идентификатора.

### Секционирование и мультитенантность
Если вы реализуете мультитенантное приложение с помощью DocumentDB, то существует два основных метода реализации механизма аренды с помощью DocumentDB: использовать один ключ секции на клиент или одну коллекцию на клиент. Ниже приведены преимущества и недостатки каждого из методов.

* Один ключ секции на клиент: в этой модели клиенты совместно размещены в одной коллекции. Однако запросы и операции вставки для документов в рамках одного клиента можно выполнить с одной секцией. Кроме того, можно реализовать логику транзакций для всех документов в пределах клиента. Так как несколько клиентов совместно используют одну коллекцию, можно сократить затраты на хранилище и пропускную способность, организовав пул ресурсов для клиентов в пределах одной коллекции, а не подготавливая дополнительный запас для каждого клиента. Недостатком является отсутствие изоляции производительности каждого клиента. Повышение производительности или пропускной способности действует для всей коллекции, а не для выбранных клиентов.
* Одна коллекция на клиент: каждый клиент имеет собственную коллекцию. В этой модели можно резервировать производительность для каждого клиента. Благодаря новой модели ценообразования на основе потребления DocumentDB, эта модель является более экономичной для мультитенантных приложений с небольшим числом клиентов.

Также можно использовать комбинированный или многоуровневый подход, при котором маленькие клиенты размещаются совместно, а большие переносятся в свои собственные коллекции.

## Дальнейшие действия
В этой статье мы рассмотрели, как действует секционирование в Azure DocumentDB, а также узнали, как создать секционированные коллекции и как выбрать подходящий ключ секции для приложения.

-   Приступите к созданию кода с помощью [пакета SDK](documentdb-sdk-dotnet.md) или [REST API](https://msdn.microsoft.com/library/azure/dn781481.aspx).
-   Узнайте больше о [подготовленной пропускной способности в DocumentDB](documentdb-performance-levels.md).
-   Если вы хотите настроить секционирование, выполняемое приложением, то можете подключить собственную реализацию секционирования на стороне клиента. См. раздел [Секционирование на стороне клиента](documentdb-sharding.md).

[1]: ./media/documentdb-partition-data/partitioning.png
[2]: ./media/documentdb-partition-data/single-and-partitioned.png

 

<!---HONumber=AcomDC_0330_2016-->