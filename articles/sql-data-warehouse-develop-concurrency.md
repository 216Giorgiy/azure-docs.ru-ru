<properties
   pageTitle="Управление параллелизмом и рабочей нагрузкой в хранилище данных SQL | Microsoft Azure"
   description="Общие сведения управлении параллелизмом и рабочей нагрузкой в хранилище данных SQL Azure для разработки решений."
   services="sql-data-warehouse"
   documentationCenter="NA"
   authors="jrowlandjones"
   manager="barbkess"
   editor=""/>

<tags
   ms.service="sql-data-warehouse"
   ms.devlang="NA"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="data-services"
   ms.date="06/26/2015"
   ms.author="JRJ@BigBangData.co.uk;barbkess"/>

# Управление параллелизмом и рабочей нагрузкой в хранилище данных SQL
Для обеспечения прогнозируемой высокой производительности в хранилище данных SQL реализованы механизмы распределения рабочей нагрузки и выделения вычислительных ресурсов.

В этой статье рассматриваются понятия параллелизма и управления рабочей нагрузкой и объясняется, каким образом реализованы эти функции и как управлять ими в хранилище данных.

## Параллелизм
Важно понимать, что параллелизмом в хранилище данных SQL управляют два фактора: **количество одновременных запросов** и **количество слотов выдачи**.

Количество одновременных запросов — это количество запросов, выполняемых в одно и то же время. Хранилище данных SQL поддерживает до 32 **одновременных запросов**. Выполнение каждого запроса считается одним запросом независимо от того, выполняется ли он последовательно (один поток) или параллельно (несколько потоков). Это фиксированное ограничение, которое действует на всех уровнях обслуживания.

Количество слотов выдачи — более динамическое понятие, соотносимое с количеством предоставленных вам единиц использования хранилища данных (DWU). Чем больше DWU выделяется хранилищу данных SQL, тем больше вычислительных ресурсов ему предоставляется. В то же время с увеличением DWU растет и число доступных **слотов выдачи**.

При настройке хранилища данных SQL необходимо учитывать каждое из этих ограничений. В случае одновременного выполнения более 32 запросов или превышения количества слотов выдачи запрос помещается в очередь до тех пор, пока не будут выполнены оба ограничения.

Каждый выполняемый одновременно запрос задействует один или несколько слотов выдачи. Точное количество слотов зависит от двух факторов:

1. Значение DWU для хранилища данных SQL.
2. **Класс ресурсов**, к которому относится пользователь. 

<!--
| Concurrency Slot Consumption | DW100 | DW200 | DW300 | DW400 | DW500 | DW600 | DW1000 | DW1200 | DW1500 | DW2000 | DW3000 | DW6000 |
| :--------------------------- | :---- | :---- | :---- | :---- | :---- | :---- | :----- | :----- | :----- | :----- | :----- | :----- |
| Max Concurrent Queries       | 32    | 32    | 32    | 32    | 32    | 32    | 32     | 32     | 32     | 32     | 32     | 32     |
| Max Concurrency Slots        | 4     | 8     | 12    | 16    | 20    | 24    | 40     | 48     | 60     | 80     | 120    | 240    |
-->

| Использование слотов выдачи | DW100 | DW200 | DW300 | DW400 | DW500 | DW600 | DW1000 | DW1200 | DW1500 | DW2000 |
| :--------------------------- | :---- | :---- | :---- | :---- | :---- | :---- | :----- | :----- | :----- | :----- | 
| Макс. число одновременных запросов | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 
| Макс. число слотов выдачи | 4. | 8 | 12 | 16 | 20 | 24 | 40 | 48 | 60 | 80 | 

Классы ресурсов составляют неотъемлемую часть рабочей нагрузки по управлению хранилищем данных SQL, поскольку определяют объем вычислительных ресурсов, выделяемых для каждого запроса. Они рассматриваются ниже, в разделе об управлении рабочей нагрузкой.

## Управление рабочей нагрузкой

Хранилище данных SQL предоставляет четыре разных класса ресурсов в виде **ролей баз данных**, входящих в систему управления рабочей нагрузкой.

Вот эти роли:

- smallrc
- mediumrc
- largerc
- xlargerc

Увидеть эти роли позволяет следующий запрос:

```
SELECT  ro.[name]           AS [db_role_name]
FROM    sys.database_principals ro
WHERE   ro.[type_desc]      = 'DATABASE_ROLE'
AND     ro.[is_fixed_role]  = 0
;
```

По умолчанию каждый пользователь является членом малого класса ресурсов — smallrc, однако любого пользователя можно добавить в один или несколько классов ресурсов более высокого уровня. Для выполнения запросов хранилище данных SQL требует принадлежности к самой высокой роли. Добавление пользователя в более высокий класс ресурсов означает, что этот пользователь будет получать больше ресурсов и в то же время использовать больше слотов выдачи, что может ограничить параллелизм системы. Это связано с тем, что предоставление дополнительных ресурсов для выполнения одного запроса требует ограничения ресурсов, доступных другим запросам. За все приходится платить.

Наиболее важным ресурсом, который регулируется более высоким классом, является память. В большинстве размещенных в хранилище данных таблиц любого значимого размера используются кластеризованные индексы columnstore. Это означает, что таблицы активно используют память, что, как правило, позволяет сделать рабочую нагрузку на хранилище данных максимально эффективной. Зачастую для операций по управлению данными, таких как перестроение индекса, выгодно назначать более высокие классы ресурсов.

Чтобы увеличить память, просто добавьте своего пользователя базы данных в одну из указанных выше ролей.

Добавлять и удалять себя из роли базы данных по управлению рабочей нагрузкой можно с помощью процедур `sp_addrolemember` и `sp_droprolemember`. Обратите внимание, что для этого требуется разрешение `ALTER ROLE`. Синтаксис ALTER ROLE DDL в данном случае не работает. Используйте хранимые процедуры, указанные выше.

> [AZURE.NOTE]Вместо добавления пользователя в группу управления рабочей нагрузкой и его удаления из этой группы зачастую бывает проще использовать для запуска ресурсоемких операций отдельный логин или отдельного пользователя, назначенного более высокому классу ресурсов на постоянной основе.

В следующей таблице показано, на сколько может быть увеличен объем памяти, доступной для каждого запроса, с учетом того, какой класс ресурсов применен к пользователю, выполняющему этот запрос:

<!--
| Memory Available (per dist) | Priority | DW100  | DW200  | DW300  | DW400   | DW500   | DW600   | DW1000  | DW1200  | DW1500  | DW2000  | DW3000  | DW6000   |
| :-------------------------- | :------- | :----  | :----- | :----- | :------ | :------ | :------ | :------ | :------ | :------ | :------ | :------ | :------- |
| smallrc(default) (s)        | Medium   | 100 MB | 100 MB | 100 MB | 100  MB | 100 MB  | 100 MB  | 100 MB  | 100 MB  | 100 MB  | 100 MB  | 100  MB | 100   MB |
| mediumrc (m)                | Medium   | 100 MB | 200 MB | 200 MB | 400  MB | 400 MB  | 400 MB  | 800 MB  | 800 MB  | 800 MB  | 1600 MB | 1600 MB | 3200  MB |
| largerc (l)                 | High     | 200 MB | 400 MB | 400 MB | 800  MB | 800 MB  | 800 MB  | 1600 MB | 1600 MB | 1600 MB | 3200 MB | 3200 MB | 6400  MB |
| xlargerc (xl)               | High     | 400 MB | 800 MB | 800 MB | 1600 MB | 1600 MB | 1600 MB | 3200 MB | 3200 MB | 3200 MB | 6400 MB | 6400 MB | 12800 MB |
-->
| Доступная память (на запрос) | Приоритет | DW100 | DW200 | DW300 | DW400 | DW500 | DW600 | DW1000 | DW1200 | DW1500 | DW2000 |
| :-------------------------- | :------- | :----  | :----- | :----- | :------ | :------ | :------ | :------ | :------ | :------ | :------ |
| smallrc(default) (s) | Средний | 100 МБ | 100 МБ | 100 МБ | 100 МБ | 100 МБ | 100 МБ | 100 МБ | 100 МБ | 100 МБ | 100 МБ |
| mediumrc (m) | Средний | 100 МБ | 200 МБ | 200 МБ | 400 МБ | 400 МБ | 400 МБ | 800 МБ | 800 МБ | 800 МБ | 1600 МБ |
| largerc (l) | Высокий | 200 МБ | 400 МБ | 400 МБ | 800 МБ | 800 МБ | 800 МБ | 1600 МБ | 1600 МБ | 1600 МБ | 3200 МБ |
| xlargerc (l) | Высокий | 400 МБ | 800 МБ | 800 МБ | 1600 МБ | 1600 МБ | 1600 МБ | 3200 МБ | 3200 МБ | 3200 МБ | 6400 МБ |


При этом нужно помнить о том, что, как уже говорилось, чем выше назначенный пользователю класс ресурсов, тем больше слотов выдачи он использует. В следующей таблице показано использование слотов выдачи запросами определенного класса ресурсов:

<!--
| Concurrency slot consumption | DW100 | DW200 | DW300 | DW400 | DW500 | DW600 | DW1000 | DW1200 | DW1500 | DW2000 | DW3000 | DW6000 |
| :--------------------------- | :---- | :---- | :---- | :---- | :---- | :---- | :----- | :----- | :----- | :----- | :----- | :----- |
| Max Concurrent Queries       | 32    | 32    | 32    | 32    | 32    | 32    | 32     | 32     | 32     | 32     | 32     | 32     |
| Max Concurrency Slots        | 4     | 8     | 12    | 16    | 20    | 24    | 40     | 48     | 60     | 80     | 120    | 240    |
| smallrc(default) (s)         | 1     | 1     | 1     | 1     | 1     | 1     | 1      | 1      | 1      | 1      | 1      | 1      |
| mediumrc (m)                 | 1     | 2     | 2     | 4     | 4     | 4     | 8      | 8      | 8      | 16     | 16     | 32     |
| largerc (l)                  | 2     | 4     | 4     | 8     | 8     | 8     | 16     | 16     | 16     | 32     | 32     | 64     |
| xlargerc (xl)                | 4     | 8     | 8     | 16    | 16    | 16    | 32     | 32     | 32     | 64     | 64     | 128    |
-->

| Использование слотов выдачи | DW100 | DW200 | DW300 | DW400 | DW500 | DW600 | DW1000 | DW1200 | DW1500 | DW2000 |
| :--------------------------- | :---- | :---- | :---- | :---- | :---- | :---- | :----- | :----- | :----- | :----- |
| Макс. число одновременных запросов | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 |
| Макс. число слотов выдачи | 4. | 8 | 12 | 16 | 20 | 24 | 40 | 48 | 60 | 80 |
| smallrc(default) (s) | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| mediumrc (m) | 1 | 2 | 2 | 4 | 4 | 4 | 8 | 8 | 8 | 16 |
| largerc (l) | 2 | 4 | 4 | 8 | 8 | 8 | 16 | 16 | 16 | 32 |
| xlargerc (l) | 4 | 8 | 8 | 16 | 16 | 16 | 32 | 32 | 32 | 64 |

Важно помнить, что активная рабочая нагрузка должна соответствовать ограничениям как на количество одновременных запросов, так и на число слотов выдачи. В случае превышения любого из этих порогов запросы помещаются в очередь. Запросы в очереди выполняются в порядке приоритета, который определяется временем их подачи.

## Определение запросов, поставленных в очередь
Для выявления запросов, попавших в параллельную очередь, используйте динамическое административное представление `sys.dm_pdw_exec_requests`.

```
SELECT 	 r.[request_id]									AS Request_ID
		,r.[status]										AS Request_Status
		,r.[submit_time]								AS Request_SubmitTime
		,r.[start_time]									AS Request_StartTime
        ,DATEDIFF(ms,[submit_time],[start_time])		AS Request_InitiateDuration_ms
FROM    sys.dm_pdw_exec_requests r
;
```

В хранилище данных SQL предусмотрены особые типы ожиданий для измерения параллелизма.

К ним относятся:
 
- LocalQueriesConcurrencyResourceType
- UserConcurrencyResourceType
- DmsConcurrencyResourceType
- BackupConcurrencyResourceType

LocalQueriesConcurrencyResourceType относится к запросам, которые не входят в систему слотов выдачи. В качестве примеров таких запросов можно привести запросы и системные функции динамических административных представлений, такие как SELECT @@VERSION.

UserConcurrencyResourceType относится к запросам, которые входят в систему слотов выдачи. В качестве примеров использования этого типа ресурсов можно привести запросы к таблицам конечного пользователя.

DmsConcurrencyResourceType относится к ожиданиям, связанным с операциями перемещения данных.

BackupConcurrencyResourceType может использоваться при создании резервной копии базы данных. Максимальное значение для этого типа ресурсов равно 1. При одновременном запросе сразу нескольких резервных копий все остальные запросы помещаются в очередь.


Для анализа поставленных в очередь запросов и определения необходимых ресурсов используйте динамическое административное представление `sys.dm_pdw_waits`.

```
SELECT  w.[wait_id]
,       w.[session_id]
,       w.[type]											AS Wait_type
,       w.[object_type]
,       w.[object_name]
,       w.[request_id]
,       w.[request_time]
,       w.[acquire_time]
,       w.[state]
,       w.[priority]
,		SESSION_ID()										AS Current_session
,		s.[status]											AS Session_status
,		s.[login_name]
,		s.[query_count]
,		s.[client_id]
,		s.[sql_spid]
,		r.[command]											AS Request_command
,		r.[label]
,		r.[status]											AS Request_status
,		r.[submit_time]
,		r.[start_time]
,		r.[end_compile_time]
,		r.[end_time]
,		DATEDIFF(ms,r.[submit_time],r.[start_time])			AS Request_queue_time_ms
,		DATEDIFF(ms,r.[start_time],r.[end_compile_time])	AS Request_compile_time_ms
,		DATEDIFF(ms,r.[end_compile_time],r.[end_time])		AS Request_execution_time_ms
,		r.[total_elapsed_time]
FROM    sys.dm_pdw_waits w
JOIN    sys.dm_pdw_exec_sessions s  ON w.[session_id] = s.[session_id]
JOIN    sys.dm_pdw_exec_requests r  ON w.[request_id] = r.[request_id]
WHERE	w.[session_id] <> SESSION_ID()
;
```

Для просмотра ресурса, ожидаемого конкретным запросом, используйте динамическое административное представление `sys.dm_pdw_resource_waits`. Время ожидания ресурсов указывает только на время, в течение которого запросы ожидают предоставления ресурсов, а время ожидания сигнала — время, необходимое базовому экземпляру SQL Server, чтобы спланировать выделение запросу ресурсов процессора.

```
SELECT  [session_id]
,       [type]
,       [object_type]
,       [object_name]
,       [request_id]
,       [request_time]
,       [acquire_time]
,       DATEDIFF(ms,[request_time],[acquire_time])  AS acquire_duration_ms
,       [concurrency_slots_used]                    AS concurrency_slots_reserved
,       [resource_class]
,       [wait_id]                                   AS queue_position
FROM    sys.dm_pdw_resource_waits
WHERE	[session_id] <> SESSION_ID()
;
```

И, наконец, для анализа тенденций по времени ожидания за прошедший период используйте динамическое административное представление `sys.dm_pdw_wait_stats`.

```
SELECT	w.[pdw_node_id]
,		w.[wait_name]
,		w.[max_wait_time]
,		w.[request_count]
,		w.[signal_time]
,		w.[completed_count]
,		w.[wait_time]
FROM	sys.dm_pdw_wait_stats w
;
```

## Дальнейшие действия
Дополнительные советы по разработке см. в статье [Общие сведения о разработке][].

<!--Image references-->

<!--Article references-->
[Общие сведения о разработке]: sql-data-warehouse-overview-develop.md

<!--MSDN references-->


<!--Other Web references-->

<!---HONumber=July15_HO1-->