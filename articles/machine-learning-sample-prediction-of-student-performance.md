<properties title="Azure Machine Learning Sample: Prediction of student performance" pageTitle="Machine Learning Sample: Predict student performance | Azure" description="A sample Azure Machine Learning experiment to develop a model that predicts student performance on tests." metaKeywords="" services="" solutions="" documentationCenter="" authors="garye" videoId="" scriptId="" />

<tags ms.service="machine-learning" ms.workload="tbd" ms.tgt_pltfrm="na" ms.devlang="na" ms.topic="article" ms.date="01/01/1900" ms.author="garye"></tags>

# Пример машинного обучения Azure: прогнозирование успеваемости учащихся

*Пример эксперимента, связанный с этой моделью в ML Studio, можно найти в разделе **ЭКСПЕРИМЕНТЫ** на вкладке **ПРИМЕРЫ**. Имя эксперимента:*

    Sample Experiment - Student Performance - Development

## Набор данных и описание проблемы

В этом эксперименте наш набор данных представляет собой обучающий набор данных Algebra\_2008\_2009 из конкурса KDD Cup 2010. Этот набор данных можно загрузить из Интернета: [][]<https://pslcdatashop.web.cmu.edu/KDDCup/downloads.jsp></a>. Набор данных содержит файлы журнала обучающей системы. Задаваемыми функциями являются идентификатор проблемы и ее краткое описание, идентификатор учащегося, метка времени, а также количество попыток, который сделал учащийся перед правильным решением проблемы. Проблема обучения заключается в прогнозировании, решит ли учащийся заданную проблему с первой попытки. В соответствии с правилами KDD Cup, мы измеряем точность алгоритмов обучения с помощью [среднеквадратичной ошибки (RMSE)][среднеквадратичной ошибки (RMSE)]. Исходный набор данных содержит 8,9 млн.записей. Для ускорения эксперимента мы сократили набор данных до первых 100000 строк. Набор данных имеет 23 столбца различного типа: числовые, категориальные и метки времени. Столбцы разделяются знаками табуляции.

## Рабочий процесс разработки

Набор данных имеет символы, отличные от стандарта ASCII, которые не могут быть обработаны модулем **Применить операцию R**. Перед использованием набора данных в университете Пассау мы удалили символы, не используемые в стандарте ASCII, с помощью следующих команд Powershell:

    gc algebra_2008_2009_train.txt –head 100000 | sc algebra_train_small.txt
    sc tmp.txt -Encoding ASCII -Value (gc algebra_train_small.txt)
    cat tmp.txt | %{$_ -replace "\?\?sqrt","+sqrt"} | sc algebra_train_small.txt_ascii  

Результирующий файл algebra\_train\_small.txt\_ascii по-прежнему имеет довольно большой размер (36 M). Мы сохраняет данный файл в хранилище больших двоичных объектов Azure, а затем загружаем его в эксперимент с помощью модуля **Считыватель**. Для сохранения файла в хранилище больших двоичных объектов используются следующие команды Powershell:

    Add-AzureAccount
    $key = Get-AzureStorageKey -StorageAccountName <your storage account name>
    $ctxt = New-AzureStorageContext -StorageAccountName $key.StorageAccountName -StorageAccountKey $key.Primary
    Set-AzureStorageBlobContent –Container <container name in your storage account> -File "algebra_train_small.txt_ascii" –Context $ctxt

![][]

Выше показаны параметры модуля **Считыватель**. В этом примере имя учетной записи хранилища — «datascience», файл набора данных algebra\_train\_small.txt\_ascii помещается в контейнер «sampleexperiments». Ключ учетной записи представляет собой ключ доступа для учетной записи хранилища Azure. Этот ключ можно найти в своей учетной записи на портале управления Azure ([][1]<https://manage.windowsazure.com></a>).

![][2]

В ходе следующих шагов, показанных выше, мы выполняем несколько преобразований, чтобы получить набор данных в формате, который будет соответствовать нашим алгоритмам обучения. Для преобразования столбца метки времени «Время первой транзакции» в строковый формат мы используем **Редактор метаданных**. Он позволяет разделить обучение/тест. Затем, с помощью **столбцов проекта** мы удаляем столбцы, которые не будут применяться в эксперименте. Для замены всех отсутствующих значений на 0 мы используем модуль очистки отсутствующих значений. На следующем шаге мы разделяем столбец «Имя блока, имя раздела» на два столбца — «Имя блока» и «Имя раздела». Это выполняется с помощью следующего кода R в модуле **Выполнение скрипта R**:

    dataset <- maml.mapInputPort(1)
    b <- data.frame(do.call(rbind,strsplit(as.vector(dataset[,3]),",")))
    names(b) <- c("Unit Name","Section Name")
    data.set <- cbind(dataset[,1:2],b,dataset[,4:15])
    maml.mapOutputPort("data.set")  

Выше показаны первые шаги эксперимента, которые включают в себя загрузку данных и начальные преобразования. После уплотнения данных мы разделяем эксперимент на 4 ветви. В каждой ветви мы тестируем разный набор функций. Некоторые наши наборы функций ранее использовались в [1][1]. В первой ветви, описанной ниже, нашим набором функций являются StudentID, Имя блока,

![][3]

![][4]

Имя раздела, Имя проблемы, Представление проблемы и Возможность, а также Текстовое описание проблемы. Нецелочисленные функции представляются в виде категориальных функций. В этой ветви мы сначала удаляем столбец «Подсказки» с помощью **столбцов проекта**, так как этот столбец при прогнозировании успеха нового учащегося отсутствует. Затем мы используем модуль **Разделение** для разделения набора данных на обучающий и тестовый набор. Так как все примеры имеют метки времени, наше разделение будет основано на времени. Все строки с временем первой транзакции, начиная с 2008 г., находятся в обучающем наборе, а строки, начиная с 2009 г. — в тестовом наборе. Справа показаны параметры модуля **Разделение**. После разделения мы формируем двоичную модель классификации с помощью "повышенного" дерева принятия решений и оцениваем тестовые данные. Столбец метки в модуле **Обучение модели** называется "Правильная первая попытка".

![][5]

В следующей последовательности модулей **Применение математической операции** и **Элементарная статистика**, показанных выше, мы вычисляем значение RMSE модели с помощью необработанных оценок и меток истинности. Следует отметить, что для регрессионных моделей эта метрика вычисляется модулем **Анализатор**. Но, для других моделей нам нужно вычислить эту метрику вручную. В первом модуле **Применение математической операции** мы вычисляем разницу между столбцом метки и столбцом оценки, который был сформирован модулем **Оценка модели**. Во втором модуле **Применение математической операции** мы вычисляем квадрат этой разницы. Затем модуль **Элементарная статистика** вычисляет среднее значение квадратов разности. Наконец, последний модуль **Применение математической операции** используется для вычисления квадратного корня. Параметры этих четырех модулей показаны ниже.

![][6]

![][7]

![][8]

![][9]

Во второй ветви, показанной выше, мы также используем измерение времени. В дополнение к функциям из первой ветви мы используем имена двух последних шагов проблемы, которая в настоящее время решается пользователем, вместе с их описанием. В предоставленном наборе данных все действия пользователя хранятся в восходящем порядке метки времени. В то же время, в этом наборе данных действия пользователей не чередуются. То есть, сначала идут все строки первого пользователя, затем все строки второго пользователя и так далее. Таким образом, для поиска последних шагов пользователя мы используем столбец «RowID». Для конкретного пользователя этот столбец служит осью времени. Благодаря добавлению "1" в этом столбце с помощью модуля "Применение математической операции"\*\*\*\* мы сдвигаем каждую строку на одну единицу времени вперед. Затем мы используем модуль **Объединение** для объединения исходного набора данных со смещенным модулем с помощью ключей RowID, StudentID и ProblemName. В результате мы получаем расширенный набор данных, где каждая строка имеет запись в моменты времени "t" и "t-1" для одних и тех же значений StudentID и ProblemName. Для сохранения значений StudentID и ProblemID для строк, которые не имеют предыдущих шагов, мы используем модуль *Левое внешнее объединение*. Для получения функций на два шага назад мы применяем комбинацию **Применение математической операции** и **Объединение** еще раз. Ниже показаны точные параметры модулей **Применение математической операции** и **Объединение**.

![][10]

![][11]

![][12]

После выполнения этих операций мы получаем несколько идентичных столбцов. Например, благодаря применению модулю «Объединение», столбец «ProblemName» реплицируется три раза для шагов t, t-1 и t-2. Для удаления избыточных столбцов мы используем модуль **Столбцы проекта**. Наконец, так как мы использовали модуль *Левое внешнее объединение*, некоторые строки, сформированные оператором "Объединение, могут иметь отсутствующие значения. Для замены всех отсутствующих значений на строку с «0» мы используем **Модуль очистки отсутствующих значений**. Выше показаны параметры **Модуля очистки отсутствующих значений**.

После вычисления нового набора функций рабочий процесс для второй ветви идентичен процессу для первой ветви.

![][13]

В третьей ветви, в дополнение к функциям, используемым во второй ветви, мы также применяем квадратичные и кубические функции, которые являются объединениями исходных функций из первой ветви. Квадратичные и кубические функции вычисляются с помощью модуля **Выполнение операции R** с кодом R, показанным выше. После вычисления нового набора функций мы продолжаем процесс обучения, оценки и анализа таким же образом, как и в первых двух ветвях.

В четвертой ветви мы используем функции, которые полностью отличаются от функций в первых трех ветвях. Для каждого StudentID мы вычисляем среднее значение "правильной первой попытки" вплоть до (но не включая) времени "t". Мы называем это значение CFA(StudentID,t). Аналогичным образом мы применяем обозначение Hints(StudentID,t) для среднего значения "подсказок" для заданного StudentID вплоть до (но не включая) времени "t". Для ускорения вычисления этих средних значений мы не рассматриваем весь набор данных, но только 10 последних записей перед временем "t". Определения CFA(Problem Name,t), CFA(Step Name,t), CFA(Description,t), Hints(Problem Name,t), Hints(Step Name,t) and Hints(Description,t) похожи друг на друга. На основе примера "x", где First Transaction Time=t(x), и используя значения столбцов StudentID(x), Problem Name(x), Step Name(x) и Description(x), мы формируем вышеупомянутые 8 функций CFA и Hints (подсказки):

    CFA(StudentID(x),t(x)), CFA(Problem Name(x),t(x)), CFA(Step Name(x),t(x)), CFA(Description(x),t(x)), 
    Hints(StudentID(x),t(x)), Hints(Problem Name(x),t(x)), Hints(Step Name(x),t(x)), Hints(Description(x),t(x))  

![][14]

Аналогичным образом мы также вычисляем 8 дополнительных функций CFA и Hints с помощью объединений значений столбцов StudentID и Имя проблемы, Имя проблемы и Имя шага, StudentId и UnitName, StudentID и Описание проблемы. В результате мы получаем 16 функций, которые используются для прогнозирования значения столбца «Правильная первая попытка». Вычисление этих 16 функций выполняется с помощью кода R в модуле **Выполнение операции R**. Данный код является длинным и громоздким, но высоко оптимизированным. После вычисления указанных функций мы удаляем некоторые вспомогательные столбцы, которые были добавлены кодом R. С этой целью мы используем модуль **Столбцы проекта**. Выше показан полный рабочий процесс для вычисления функций в четвертой ветви. После вычисления нового набора функций мы продолжаем процесс обучения, оценки и анализа таким же образом, как и в первых трех ветвях.

После вычисления значений RMSE во всех четырех ветвях мы собираем результаты с помощью модуля **Добавление строки**. Мы также формируем аннотации с помощью модуля **Выполнение операции R**. Ниже показан рабочий процесс данной последней части эксперимента.

![][15]

Последними выходными данными эксперимента является следующая таблица, первый столбец которой представляет собой имя набора функций, а вторая строка — значение RSME, измеренное в тестовых примерах:

![][16]

Мы приходим к заключению, что четвертый набор функций дает наименьшее значение RMSE.

## Ссылки

H.-F. Yu и др. Инжиниринг функций и множество классификаторов для состязания KDD Cup 2010. Семинар KDD Cup 2010 г., 2010 г.

  []: https://pslcdatashop.web.cmu.edu/KDDCup/downloads.jsp
  [среднеквадратичной ошибки (RMSE)]: http://en.wikipedia.org/wiki/Root-mean-square_deviation
  []: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-1.jpg
  [1]: https://manage.windowsazure.com
  [2]: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-2.jpg
  [3]: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-3.jpg
  [4]: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-4.jpg
  [5]: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-5.jpg
  [6]: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-6.jpg
  [7]: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-7.jpg
  [8]: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-8.jpg
  [9]: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-9.jpg
  [10]: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-10.jpg
  [11]: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-11.jpg
  [12]: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-12.jpg
  [13]: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-13.jpg
  [14]: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-14.jpg
  [15]: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-15.jpg
  [16]: ./media/machine-learning-sample-prediction-of-student-performance/student-performance-16.jpg
