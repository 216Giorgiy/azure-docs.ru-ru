<properties title="Query with Azure DocumentDB" pageTitle="Query with DocumentDB | Azure" description="DocumentDB's SQL query language supports a subset of ANSI SQL grammar and adds document-oriented support. Queries are served through up-to-date indexes that don't require index management."  metaKeywords="NoSQL, DocumentDB,  database, document-orientated database, JSON, account" services="documentdb"  solutions="data-management" documentationCenter=""  authors="bradsev" manager="jhubbard" editor="cgronlun" videoId="" scriptId="" />

<tags ms.service="documentdb" ms.workload="data-services" ms.tgt_pltfrm="na" ms.devlang="na" ms.topic="article" ms.date="08/20/2014" ms.author="bradsev"></tags>

# Создание запросов с помощью Azure DocumentDB

## Мотивация

Язык запросов SQL DocumentDB поддерживает грамматику подмножества ANSI SQL и добавляет ориентированную на документы поддержку в форме вложенных структур данных, массивов и конструкций объектов. Запросы эффективно обслуживаются через индексы DocumentDB, которые автоматически обновляются для всех свойств документов без расходов на управление индексами. Разработчики могут также использовать полную мощь JavaScript в запросах с помощью определяемых пользователем функций (UDF).

## Почему SQL-запросы?

DocumentDB поддерживает SQL и обеспечивает очень простой и удобный интерфейс для запросов данных. Язык SQL отличается структурной простотой, но имеет мощные возможности и широко используется разработчиками приложений. База данных DocumentDB отвечает всем требованиям, которые предъявляют открытые платформы и такие стандарты, как HTTP, JSON, JavaScript, а теперь и SQL.
Запросы SQL поддерживаются через API REST, а также клиентские SDK для .NET, Node.js и JavaScript. Запросы SQL также поддерживаются в хранимых процедурах и триггерах API JavaScript на стороне сервера. В дополнение к запросам SQL база данных DocumentDB также поддерживает запросы LINQ в .NET SDK.

# Типы данных

В DocumentDB формат данных документов и метаданных выражается в нотации объектов JavaScript (JSON) . JSON широко используется за счет роста количества приложений JavaScript и его эволюции в независимый от платформы формат обмена данных. Благодаря самоописываемому характеру формат JSON также хорошо подходит для баз данных без схем.

Примитивные типы данных, поддерживаемые в запросах DocumentDB, такие же как в JSON. Формат JSON имеет простую систему типов, которая состоит из:

-   строк
-   чисел (IEEE754 с двойной точностью)
-   логических значений – true (истина) и false (ложь)
-   пустых значений — Null

Более сложные типы данных могут быть представлены в JSON и DocumentDB посредством создания вложенных объектов с помощью оператора { } и массивов с помощью оператора [ ].

# Грамматика запросов

С помощью языка DocumentDB SQL пользователи могут извлекать данные из документов JSON с использованием инструкций **SELECT**. Ниже приводится пример инструкции SQL для коллекции документов, содержащих записи в социальной сети.

     SELECT p.message, p.user.id AS user_id, p.tags[0] AS first_tag 
     FROM posts p 
     WHERE p.type = "Comment"

Выход запроса представляет собой массив фрагментов документов JSON, по одному для каждого документа, который соответствует заданным ограничениям.

    {
      "Documents": [
        {
            "message": "JSON rocks!"
            "user_id": "@documentdb"
            "first_tag": "#documentstore"
        },
        {
            "message": "SQL rocks!"
            "user_id": "@documentdb"
            "first_tag": "#documentstore"
        }
      ]
    }

Полная формальная грамматика (BNF) для языка запросов SQL помещена в конец этого документа.

# Предложение FROM

Предложение **FROM**, как правило, представляет собой имя текущей коллекции, в которой выполняется запрос. Например, это предложение выбирает все документы в коллекции с именем “posts”. Если имя неверно, пользователю возвращается ошибка.

    SELECT * 
    FROM posts

Ключевое слово **ROOT** можно использовать вместо ссылки на коллекцию по имени, так как с помощью SDK или API REST запросы могут направляться в определенную область коллекции.

    SELECT * 
    FROM ROOT

Выходным свойствам FROM могут присваиваться псевдонимы. Это полезно при применении нескольких источников FROM с использованием **СОЕДИНЕНИЙ**. Данная тема будет рассмотрена позже.

    SELECT P.* 
    FROM posts P

Кроме этого, возможно направление запроса из вложенного свойства. Например, если записи документов содержат вложенный документ для пользователя, который сделал запись, можно создать запрос с использованием следующего синтаксиса.

    SELECT U.* 
    FROM posts.user U

Источником инструкции FROM может быть также скалярный массив (упорядоченный набор).

    SELECT E
    FROM ["documentdb", "json", "sql"] E

Кроме этого, можно полностью опускать инструкцию FROM при оценке скалярных выражений.

`SELECT "documentdb"`

# Предложение WHERE (фильтрация)

Язык DocumentDB SQL поддерживает необязательное предложение **WHERE**, выполняющее фильтрацию результатов на основе определенных условий, которым должен удовлетворять документ. Выражение фильтра может содержать логические сравнения с любыми свойством или вложенным путем в документах.

Например, в запросах может использоваться любое свойство, такое как сообщение. Эффективное выполнение фильтрации обеспечивается с помощью автоматического индекса DocumentDB.

    SELECT * 
    FROM posts p 
    WHERE p.message = "DocumentDB now supports SQL!"

Вложенные свойства могут использоваться для фильтрации с использованием нотации с точками. Пути могут иметь произвольную длину в зависимости от схемы документов.

    SELECT * 
    FROM posts p 
    WHERE p.user.name = "Azure DocumentDB"

На отдельные значения в массивах можно ссылаться с помощью оператора разыменовывания массива. Раскрутка массива поддерживается с помощью ключевого слова **IN** (обсуждается далее).

    SELECT * 
    FROM posts p 
    WHERE p.views[0] = 100

Сравнения диапазонов (\>, \<. \>=, \<=, !=) поддерживаются для числовых значений. Числа могут также сравниваться с результатом арифметического выражения, как указано ниже.

    SELECT * 
    FROM posts p 
    WHERE p.views[0] > 100 * 2

Логические операторы могут объединяться с использованием операторов AND, OR и NOT также, как в обычном SQL. Их эффективна обработка обеспечивается через пересечение индексов для заданных свойств.

    SELECT * 
    FROM posts p 
    WHERE ((p.user.name = "Azure DocumentDB")
    OR (p.views[0] = 100 AND p.message = "DocumentDB now supports SQL!"))

## Обработка отсутствующих свойств и свойств Null

NULL поддерживается как ключевое слово, и свойства могут сравниваться со значением null, как и другие скалярные выражения.

    SELECT * 
    FROM posts p 
    WHERE p.message IS NULL

Так как схема документов может быстро изменяться или может быть неизвестна заранее, язык также поддерживает специальные операторы для проверки отсутствующих свойств с использованием оператора ISUNDEFINED, аналогичного оператору **undefined** в JavaScript .

    SELECT * 
    FROM posts p 
    WHERE p.message IS UNDEFINED

> Примечание. Подобно JavaScript, = undefined всегда возвращает значение «false».

# Предложение SELECT (Проекция)

Предложение **SELECT** может использоваться для извлечения определенных свойств из запроса. Оператор-звездочка (\*) возвращает полные документы, соответствующие запросу.

    SELECT * 
    FROM posts

В предложении SELECT могут извлекаться заданные поля. Поля могут быть атомарными (строки, числа, логические выражения) или сложными (массивы, объекты JSON). Сложные типы в предложении SELECT такие, как “user” в указанном ниже примере, возвращают целый объект JSON по свойству. Свойства в предложении SELECT должны иметь уникальные имена или псевдонимы.

    SELECT posts.id, posts.user
    FROM posts

> Примечание. Так как JSON неупорядочен, отдельные свойства в документе не возвращаются в каком-либо определенном порядке.

> Примечание. Имена полей должны быть явно полными. Вследствие того, что документы не имеют фиксированной схемы, это требуется для среды выполнения запроса с целью правильной привязки.

Альтернативный способ доступа к свойствам состоит в использовании синтаксиса поиска словаря, как показано ниже:

    SELECT posts.id, posts["user"], posts["from"]
    FROM posts

> Примечание. Синтаксис поиска словаря следует применять для того, чтобы избежать имен свойств, которые используют зарезервированные ключевые слова, подобные FROM в указанном ниже примере.

## Оценка выражения

Скалярные выражения могут также использоваться с выражениями. Если не задается имя, то используется автоматически созданное имя в качестве местозаполнителя ($1, $2, $3 и т.д.).

    SELECT ((2 + 11 % 7) – 2)/3
    FROM posts

С выражениями запросов SQL могут использоваться следующие выражения. Операторы строго типизированы, как в SQL. Например, равно (=) — это строго равенство, которое означает, что 5 != “5”.

|--------------------------|--------------------------------------------------|
| Арифметические операторы | +, -, \*, /, % (модуль)                          |
| Логические операторы     | AND, OR, NOT                                     |
| Битовые операторы        | & (битовое AND), | (битовое OR), ^ (битовое XOR) |
| Строковые операторы      | || (конкатенация)                                |
| Операторы сравнения      | =, !=, \>, \<, \>=, \<=                          |

## Преобразование JSON

Запросы SQL могут возвращать фрагменты JSON, а не только целые документы. Для этого используется ключевое слово **VALUE**. Например, следующий документ возвратит “2” вместо {“id”: “2”}.

    SELECT VALUE posts.id
    FROM posts

Более сложные выражения JSON могут конструироваться как JavaScript с использованием операторов {} и []. Это обеспечивает гибкость запросов при преобразовании формы результирующих наборов.

    SELECT {"user_name": p.user.name, "recent_views": [p.views[0], p.views[1]]}
    FROM posts p

> Примечание. Значения должны быть допустимыми выражениями, но метки должны быть литералами (строками)

# Соединения и итерация

В базах данных документов ссылочные данные встраиваются как вложенные документы или внутренние массивы. Таким образом, язык SQL поддерживает внутридокументные или самостоятельные соединения с использованием ключевого слова **JOIN**.

    SELECT p.id, tag 
    FROM posts p 
    JOIN tag IN p.tags

> Примечание. Соединения формально представляют собой перекрестные соединения, но вследствие того, что данные встроены, они действуют, как внутренние соединения.

В примере оператор **IN** используется для итерации всех элементов источника. Источником для предложения IN может быть массив или объект. При использовании с объектом итератор проходит через каждое свойство. IN можно также использовать напрямую, как указано ниже. Кроме того, IN можно использовать с литералами массивов.

    SELECT tag 
    FROM tag IN posts.tags

В инструкции SQL могут использоваться несколько соединений, как указано ниже:

    SELECT p.id, tag, liked
    FROM posts p 
    JOIN tag IN p.tags
    JOIN liked IN p.likes  

# Определяемые пользователем функции (UDF)

Запросы DocumentDB поддерживают программируемые расширения в форме определяемых пользователем функций JavaScript. Каждая коллекция может иметь один или несколько сохраненных **UDF**, которые преобразуют фрагменты JSON и ссылаются на них прямо по имени в скриптах.

Например, использующая создание определяемых пользователем функций функция “regex\_match” может быть задана следующим образом:

    function regex_match(input, pattern) {
        getContext().getResponse().setBody(pattern.test(input));
    }

Далее на нее можно ссылаться в запросах, как в этом примере:

    SELECT *
    FROM posts p
    WHERE regex_match(p.message, "doc.*db") = true

> Примечание. UDF имеют доступ только ко входным параметрам. Операции сохранения DocumentDB (чтение, запись, запрос и т.д.) в UDF не поддерживаются.

> Примечание. В настоящее время только одна UDF может использоваться в запросе.

UDF могут обрабатывать и возвращать фрагменты JSON, а не только литералы. Например, функция “array\_count” может быть определена как:

    function array_count(input) {
        getContext().getResponse().setBody(input.length);
    }

А далее ее можно использовать в запросах для поиска размера массива внутри документа.

    SELECT *
    FROM posts p
    WHERE array_count(p.likes) > 5

Кроме того, UDF могут задаваться в предложении SELECT или FROM запроса. Например:

    SELECT array_count(p.likes) AS count
    FROM posts p

Более подробную информацию о создании и управлении UDF см. в документации по программированию JavaScript.

# Разбиение по страницам

Выполнение каждого запроса возвращает пакет результатов согласно размеру страницы, настроенному клиентом. Чтобы прочесть все результаты запроса, приложения должны разбивать на страницы каждый результирующий набор до тех пор, пока больше не останется данных для чтения. Например, чтобы прочитать не более 10 документов, клиенты могут изменить размер страницы на 10 и ограничить максимальное количество возвращаемых документов. Обратите внимание, что запросы могут возвращать меньше результатов, чем размер страницы, или вообще не возвращать результаты для отдельных запросов. Чтобы прочесть все результаты запроса, клиенты должны извлечь следующий пакет с использованием маркера продолжения ответа до тех пор, пока он не окажется пустым.

    // Fetch pages of results up to 10 at a time. FeedOptions is optional
    DocumentServiceQuery<Database> query = (
        from db in client.CreateDatabaseQuery(new FeedOptions { MaxItemCount = 10 })
        where db.Name == dbName
        select db).AsDocumentServiceQuery();

    while (query.HasMoreResults)
    {
        databases.AddRange(await query.ExecuteNextAsync<Database>());
    }

Это не реализуется в грамматике SQL как ключевое слово TOP или LIMIT, поскольку указанная функциональность уже доступна через маркеры продолжения в базовом клиенте SDK/ API REST. Для получения дополнительной информации и знакомства с примерами см. документацию API REST для документов GET или методы ReadFeed в пакетах SDK.

# Режимы работы согласованности запросов

DocumentDB поддерживает четыре уровня согласованности, которые может включать разработчик — Strong (сильный), Bounded-Staleness (ограниченный), Session (уровень сеанса) и Eventual (согласованный в конечном счете). Запросы предлагают гарантии в соответствии с уровнями согласованности. По умолчанию результаты запроса гарантированно соответствуют уровню согласованности, который запрашивается клиентом. Индекс DocumentDB журнально-структурирован и разработан таким образом, чтобы постоянно обновляться и обеспечивать согласованность с данными независимо от объема. При вставке или обновлении документов они становятся немедленно доступными в результатах запросов.

Для приложений, которым необходима согласованность в конечном счете, политика индексации дополнительно может быть настроена для использования отложенной индексации. В таком случае индекс обновляется согласованным в конечном счете способом всякий раз, когда коллекция находится в ждущем режиме. В качестве обобщения приведем таблицу режимов работы согласованности запросов с различными конфигурациями учетных записей базы данных.

| Согласованность данных    | Политика индексации | Режим работы запроса      |
|---------------------------|---------------------|---------------------------|
| Строгая                   | Согласованная       | Строгая                   |
| Ограниченное запаздывание | Согласованная       | Ограниченное запаздывание |
| Сеанс                     | Согласованная       | Сеанс                     |
| В конечном счете          | Согласованная       | В конечном счете          |
| Строгая                   | Отложенная          | В конечном счете          |
| Ограниченное запаздывание | Отложенная          | В конечном счете          |
| Сеанс                     | Отложенная          | В конечном счете          |
| В конечном счете          | Отложенная          | В конечном счете          |

Дополнительную информацию см. в документации по политике индексации и настройке.

# API и SDK

Запросы могут выполняться с использованием API REST, клиентских SDK, а также API JavaScript API на стороне сервера с применением грамматики SQL.

## Запрос с использованием API REST

Приложения могут формировать запросы POST к коллекции с использованием API REST. В запросы должно быть включено следующее:

-   заголовок x-ms-documentdb-isquery: «True» для указания, что это запрос
-   заголовок Content-Type: приложение/sql для указания использования языка SQL
-   тело, содержащее инструкцию SELECT
    <!-- -->

    POST .../docs/executeQuery HTTP/1.1
    authorization: ...
    x-ms-continuation:
    x-ms-activity-id: 82342881-769e-4113-a662-a85c7617ed5b
    x-ms-date: Fri, 30 May 2014 22:46:13 GMT
    Match:
    x-docdb-resource-id: 9MEKcum9C2g=
    x-docdb-entity-id:
    x-ms-documentdb-isquery: True
    Cache-Control: no-cache
    x-ms-version: 2014-02-25
    User-Agent: Microsoft.Azure.Documents.Client/1.0.0.0
    Content-Type: application/sql
    Host: ...
    Content-Length: 59
    Expect: 100-continue

    SELECT b.title FROM books b WHERE b.title = 'War and Peace'

> Примечание. Запрос не поддерживается с использованием GET или строковых запросов.

## Запрос с использованием .NET SDK

.NET SDK поддерживает запросы с использованием метода CreateDocumentQuery, который поддерживает запросы SQL как строки. Выходом запроса является интерфейс IQueryable, который может обрабатываться с использованием LINQ на стороне клиента.

    IQueryable<dynamic> results = client.CreateDocumentQuery(collectionId).AsSQL<dynamic>(
       "SELECT b.title FROM books b WHERE b.title = 'War and Peace'");

Дополнительную информацию см. в документации .NET SDK.

## Запросы внутри сохраняемых процедур и триггеров

API JavaScript на стороне сервера для сохраняемых процедур и триггеров также поддерживает запросы с использованием SQL.

    collection.queryDocuments(collection.GetSelfLink(),
    "SELECT b.title FROM books b WHERE b.title = 'War and Peace'",
    callback);

Дополнительную информацию см. в документации SDK для JavaScript на стороне сервера.

# Приложение A – Синтаксис SQL

В последующих синтаксических диаграммах показана формальная грамматика SQL для языка запросов DocumentDB

![][]

![][1]

![][2]

![][3]

![][4]

![][5]

![][6]

![][7]

![][8]

![][9]

![][10]

![][11]

![][12]

![][13]

![][14]

![][15]

![][16]

  []: ./media/documentdb-query/query1.png
  [1]: ./media/documentdb-query/query2.png
  [2]: ./media/documentdb-query/query3.png
  [3]: ./media/documentdb-query/query4.png
  [4]: ./media/documentdb-query/query5.png
  [5]: ./media/documentdb-query/query6.png
  [6]: ./media/documentdb-query/query7.png
  [7]: ./media/documentdb-query/query8.png
  [8]: ./media/documentdb-query/query9.png
  [9]: ./media/documentdb-query/query10.png
  [10]: ./media/documentdb-query/query11.png
  [11]: ./media/documentdb-query/query12.png
  [12]: ./media/documentdb-query/query13.png
  [13]: ./media/documentdb-query/query14.png
  [14]: ./media/documentdb-query/query15.png
  [15]: ./media/documentdb-query/query16.png
  [16]: ./media/documentdb-query/query17.png
