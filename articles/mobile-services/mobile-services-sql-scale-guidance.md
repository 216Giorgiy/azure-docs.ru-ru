<properties
	pageTitle="Масштабирование мобильных служб, работающих с Базой данных Azure SQL | Microsoft Azure"
	description="Узнайте, как определить и устранить проблемы масштабируемости в мобильных службах на основе Базы данных SQL"
	services="mobile-services"
	documentationCenter=""
	authors="lindydonna"
	manager="dwrede"
	editor="mollybos"/>


<tags 
	ms.service="mobile-services" 
	ms.workload="mobile" 
	ms.tgt_pltfrm="na" 
	ms.devlang="multiple" 
	ms.topic="article" 
	ms.date="12/01/2015" 
	ms.author="donnam;ricksal"/>

# Масштабирование мобильных служб, поддерживаемых базой данных Azure SQL

[AZURE.INCLUDE [mobile-service-note-mobile-apps](../../includes/mobile-services-note-mobile-apps.md)]

&nbsp;


Мобильные службы Azure существенно упрощают процесс ознакомления и формирования приложения, которое подключается к облачному серверу, где данные хранятся в базе данных SQL. По мере роста вашего приложения процедура масштабирования ваших экземпляров службы является такой же простой, как и настройка параметров масштабирования на портале для добавления дополнительных вычислительных и сетевых ресурсов. Однако для масштабирования базы данных SQL, поддерживающей вашу службу, требуется выполнить определенное предварительное планирование и мониторинг, так как нагрузка на службу возрастает. В этом документе представлены несколько эффективных методов непрерывного обеспечения высокого уровня производительности мобильных служб, которые поддерживаются с помощью SQL.

В этом разделе рассматриваются следующие основные разделы:

1. [Диагностирование проблем](#Diagnosing)
2. [Индексирование](#Indexing)
3. [Структура схемы](#Schema)
4. [Конструктор запросов](#Query)
5. [Архитектура службы](#Architecture)
6. [Расширенный поиск проблем](#Advanced)

<a name="Diagnosing"></a>
## Диагностирование проблем

Если вы предполагаете, что ваша мобильная служба испытывает проблемы под нагрузкой, перейдите сначала на вкладку **Панель мониторинга** для вашей службы на [классическом портале Azure]. Здесь следует проверить следующее:

- Ваши измерители использования, включая **вызовы API** и счетчики **активных устройств** не нарушили квоту
- Состояние **Мониторинг конечной точки** указывает, что служба активна (состояние доступно только в том случае, если служба использует уровень Standard, и мониторинг конечной точки включен)

Если какое-либо из вышеупомянутых условий не соблюдается, попробуйте настроить параметры масштабирования на вкладке *Масштаб*. Если это не устраняет проблему, проанализируйте, может ли база данных Azure SQL быть источником данной проблемы. В следующих разделах рассматриваются несколько разных подходов для диагностики потенциальных проблем.

### Выбор правильного уровня базы данных SQL

Важно понимать различные уровни базы данных, имеющиеся в вашем распоряжении. Это позволит обеспечивать выбор нужного уровня с учетом потребностей вашего приложения. База данных SQL Azure предлагает три разных уровня служб:

- базовая;
- Standard
- Premium


Ниже приведены несколько рекомендаций по выбору правильного уровня для вашей базы данных:

- **Basic** - используйте во время разработки или для небольших производственных служб, где в заданный момент времени в базу данных предполагается отправлять одиночный запрос
- **Standard** - используйте для производственных служб, где предполагается одновременная отправка нескольких запросов в базу данных
- **Premium** - используйте для крупных производственных служб с большим количеством одновременных запросов, высокой пиковой нагрузкой и ожидаемым малым временем задержки для каждого запроса.

Дополнительные сведения о том, когда следует использовать тот или иной уровень, см. в разделе [Причины применения новых уровней служб]

### Анализ метрик базы данных

После знакомства с уровнями базы данных можно рассмотреть метрики производительности базы данных, которые помогают выбрать варианты масштабировании в пределах отдельного уровня, а также между уровнями.

1. Откройте [классический портал Azure].
2. На вкладке «Мобильные службы» выберите службу, с которой вы хотите работать.
3. Перейдите на вкладку **Настройка**.
4. Выберите имя **База данных SQL** в разделе **Параметры базы данных**. В результате вы перейдете на вкладку «База данных Azure SQL» на портале.
5. Перейдите на вкладку **Монитор**
6. С помощью кнопки **Добавить метрики** добавьте необходимые метрики. Включите следующие метрики:
    - *Процент ЦП* (доступна только на уровнях Basic/Standard/Premium)

    - *Процент операций ввода/вывода данных* (доступен только на уровнях Basic/Standard/Premium)
    - *Процент операций ввода/вывода журналов* (доступен только на уровнях Basic/Standard/Premium)
    - *Хранилище* 
7. Следите за метриками во временном окне, когда ваша служба будет испытывать проблемы. 

    ![Классический портал Azure — метрики базы данных SQL][PortalSqlMetrics]

Если какая-либо метрика превышает 80%-ый уровень использования в течение длительного периода времени, это может указывать на проблему производительности. Дополнительные сведения об уровнях использования базы данных см. в разделе [Основные сведения об использовании ресурсов](http://msdn.microsoft.com/library/azure/dn369873.aspx#Resource).

Если метрики указывают на высокий уровень использования вашей базы данных, в качестве первой меры уменьшения уровня нагрузки рассмотрите возможность **масштабирования вверх базы данных на более высокий уровень службы**. Для немедленного устранения проблем перейдите на вкладку **Масштаб** для базы данных и масштабируйте вверх базу данных. При этом размер оплаты увеличится. ![Классический портал Azure — масштабирование базы данных SQL][PortalSqlScale]

Как можно скорее рассмотрите следующие дополнительные шаги по уменьшению уровня нагрузки:

- **Настройте свою базу данных.** Благодаря оптимизации базы данных во многих случаях степень использования базы данных можно уменьшить, предотвратив необходимость масштабирования до более высокого уровня.
- **Проанализируйте архитектуру своей службы.** Часто нагрузка на службу не распределяется равномерно в течение времени, а содержит "всплески" с большим числом запросов. Вместо масштабирования вверх базы данных для обработки таких всплесков, в результате чего в период малого числа запросов нагрузка на базу будет низкой, часто можно настроить архитектуру службы так, чтобы избежать появления таких всплесков, или обрабатывать их без перегрузки базы данных.

В остальных разделах этого документа изложены рекомендации по реализации таких способов уменьшения уровня нагрузки.


### Настройка предупреждений

В качестве профилактической меры для основных метрик базы данных часто полезно настроить предупреждения, чтобы убедиться, чтобы у вас будет достаточно времени для реагирования в случае истощения ресурсов.

1. Перейдите на вкладку **Мониторинг** для базы данных, для которой вы хотите настроить предупреждения.
2. Убедитесь, что отображаются соответствующие метрики (см. предыдущий раздел)
3. Выберите метрику, для которой необходимо задать предупреждение, а затем выберите команду **Добавить правило**.

    ![Портал управления Azure — предупреждение SQL][PortalSqlAddAlert]

4. Укажите имя и описание предупреждения. ![Портал управления Azure — имя и описание предупреждения SQL][PortalSqlAddAlert2]

5. Укажите значение, используемое в качестве порога предупреждения. Выберите значение **80%**, чтобы предусмотреть некоторое время на реагирование. Кроме этого, обязательно укажите адрес электронной почты, который вы активно отслеживаете.
 
    ![Портал управления Azure — порог и адрес электронной почты предупреждения SQL][PortalSqlAddAlert3]


Дополнительный сведения о диагностике проблем SQL см. в разделе [Расширенная диагностика](#AdvancedDiagnosing) ниже в этом документе.

<a name="Indexing"></a>
## Индексация

При обнаружении проблем производительности запросов в первую очередь следует проанализировать структуру своих индексов. Индексы имеют важное значение, так как они непосредственно влияют на способ выполнения запросов ядром SQL.

Например, если вам часто приходится искать элемент в конкретном поле, для этого столбца целесообразно добавить индекс. В противном случае ядро SQL будет принудительно выполнять сканирование таблицы и считывать каждую физическую запись (или, по крайней мере, столбец запроса), и число записей на диске может оказаться довольно большим.

Следовательно, при частом применении операторов WHERE или JOIN в конкретных столбцах необходимо убедиться, что вы их индексируете. Дополнительные сведения см. в разделе [Создание индексов](#CreatingIndexes).

Если индексы настолько хороши, а сканирование таблицы настолько плохое, не означает ли это, что необходимо просто индексировать каждый столбец в таблице? Если ответить коротко, то «вероятно нет». Индексы требуют дополнительного места и сами имеют издержки: при каждой вставке в таблицу требуется обновить структуры индексов для каждого из индексируемых столбцов. Ниже приведены рекомендации по выбору индексов столбцов.

### Рекомендации по структуре индексов

Как указано выше, не всегда целесообразно добавлять большое количество индексов в таблицу, так как сами индексы могут оказаться дорогостоящим инструментом (как с точки зрения производительности, так и с точки зрения расходования памяти).

#### Рекомендации по запросам

- Добавляйте индексы в столбцы, которые часто используются в предикатах (например, предложения WHERE) и условиях объединения, а также учитывайте рекомендации по базе данных, изложенные ниже.
- Создавайте запросы, которые вставляют или изменяют максимально возможное число строк в одном операторе, вместо того, чтобы использовать несколько запросов для обновления тех же строк. Если имеется только один оператор, ядро базы данных будет обрабатывать индексы более оптимальным образом.

#### Рекомендации по базе данных

Большое количество индексов в таблице влияет на производительность операторов INSERT, UPDATE, DELETE и MERGE, так как при изменении данных в таблице все индексы необходимо будет соответствующим образом настраивать.

- Для **активно обновляемых** таблиц старайтесь не индексировать активно обновляемые столбцы.
- Для таблиц, которые **обновляются редко**, но содержат большой объем данных, используйте много индексов. Это может улучшить производительность запросов, которые не изменяют данные (например, операторы SELECT), так как оптимизатор запросов будет иметь больше возможностей поиска наилучшего метода доступа.

Индексация небольших таблиц может оказаться неоптимальным решением, так как в данном случае оптимизатору запросов при поиске данных может потребоваться больше времени для прохода по индексу, чем простое сканирование таблицы. Следовательно, индексы в небольших таблицах могут никогда не использоваться, но их будет необходимо всегда обрабатывать при изменении данных в таблице.


<a name="CreatingIndexes"></a>
### Создание индексов

#### Серверная служба JavaScript

Для настройки индекса для столбца на сервере JavaScript выполните следующую процедуру:

1. Откройте свою мобильную службу на [классическом портале Azure].
2. Перейдите на вкладку **Данные**.
3. Выберите таблицу, которую нужно изменить.
4. Нажмите вкладку **Столбцы**.
5. Выберите столбец. В командной строке щелкните **Задать индекс**:

	![Портал мобильных служб - Задание индекса][SetIndexJavaScriptPortal]

В этом представлении также можно удалять индексы.

#### Сервер .NET.

Для определения индекса на платформе Entity Framework используйте атрибут `[Index]` в полях, которые необходимо индексировать. Например:

    public class TodoItem : EntityData
    {
        public string Text { get; set; }

		[Index]
        public bool Complete { get; set; }
    }

Дополнительные сведения об индексах см. в разделе [Заметки об индексе на платформе Entity Framework][]. Дополнительные рекомендации по оптимизации индексов см. в разделе [Расширенная индексация](#AdvancedIndexing) ниже в этом документе.

<a name="Schema"></a>
## Структура схемы

Ниже рассматриваются несколько вопросов, которые следует учитывать при выборе типов данных для своих объектов, что, в свою очередь, влияет на схему базы данных SQL. Настройка схемы может во многих случаях существенно повышать уровень производительности, так как SQL поддерживает настраиваемые оптимизированные способы обработки индексации и хранения для различных( типов данных:

- **Используйте предоставленный столбец идентификаторов**. Каждая таблица мобильной службы поступает со столбцом идентификаторов по умолчанию, настроенным как первичный ключ, и имеет свой индекс. Дополнительный столбец идентификаторов создавать не нужно.
- **Используйте корректные типы данных в своей модели.** Если вы знаете, что некоторое свойство вашей модели будет численным или логическим значением, используйте его именно в таком виде в своей модели, а не в виде строки. На сервере JavaScript используйте литералы (например, `true` вместо `"true"` и `5` вместо `"5"`). На сервере .NET используйте типы `int` и `bool` при объявлении свойств своей модели. Это позволит базе данных SQL создать правильную схему для данных типов, что в результате повысит эффективность запросов.

<a name="Query"></a>
## Структура запросов

Ниже приведены несколько рекомендаций, которые следует учитывать при запросе базы данных:

- **Всегда выполняйте операции объединения в базе данных.** Часто будет необходимо объединять записи из нескольких таблиц, когда в объединяемых записях есть общее поле (которое также называется *объединением*). Данная операция может оказаться неэффективной, если она выполняется неправильно, так как она может извлекать все объекты из обеих таблиц, а затем выполнять итерации со всеми такими объектами. Операции такого типа лучше всего оставить самой базе данных (иногда может сложиться ошибочное мнение, что их легче выполнять в клиенте или в коде мобильной службы).
    - Не выполняйте операции объединения в коде своего приложения
    - Не выполняйте операции объединения в коде своей мобильной службы. При использовании сервера JavaScript убедитесь, что [объект таблицы](http://msdn.microsoft.com/library/windowsazure/jj554210.aspx) не обрабатывает операции объединения. Используйте непосредственно [объект mssql](http://msdn.microsoft.com/library/windowsazure/jj554212.aspx), чтобы обеспечить выполнение операций объединения в базе данных. Дополнительные сведения см. в разделе [Объединение реляционных таблиц](mobile-services-how-to-use-server-scripts.md#joins). При использовании сервера .NET и выполнении запроса через LINQ объединения автоматически обрабатываются на уровне базы данных платформой Entity Framework.
- **Реализуйте подкачку.** Запросы, отправляемые в базу данных, иногда могут приводить к тому, что клиенту будет возвращаться большое количество записей. Для уменьшения размера и времени задержки операций используйте режим постраничного просмотра.

    - По умолчанию, ваша мобильная служба будет ограничивать все входящие запросы по размеру страницы (до 50), а вручную можно запрашивать до 1000 записей. Дополнительные сведения см. в разделе «Возврат данных на страницах» для [магазина Windows](mobile-services-windows-dotnet-how-to-use-client-library.md#paging), [iOS](mobile-services-ios-how-to-use-client-library.md#paging), [Android](mobile-services-android-how-to-use-client-library.md#paging), [HTML/JavaScript](mobile-services-html-how-to-use-client-library#paging) и [Xamarin](partner-xamarin-mobile-services-how-to-use-client-library.md#paging).
    - Для запросов, отправляемых из кода вашей мобильной службы, размер страницы, задаваемый по умолчанию, отсутствует. Если ваше приложение не реализует постраничный просмотр, применяйте для своих запросов ограничения по умолчанию (это можно использовать и в качестве профилактической меры). На сервере JavaScript в **объекте запроса** используйте оператор [take](http://msdn.microsoft.com/library/azure/jj613353.aspx). При использовании сервера .NET используйте [метод Take] как часть своего запроса LINQ.  


Дополнительные сведения об улучшении структуры запросов, включая способ анализа планов запроса, см. в разделе [Структура расширенных запросов](#AdvancedQuery) ниже в этом документе.

<a name="Architecture"></a>
## Архитектура службы

Представьте себе сценарий, когда вы собираетесь отправлять push-уведомление всем своим клиентам для проверки некоторого нового контента в вашем приложении. В случае, когда клиенты отвечают, используя ссылку в уведомлении, будет запускаться приложение. В этом случае может отправляться вызов в вашу мобильную службу и выполняться запрос в вашей базы данных SQL. Так как потенциально миллионы клиентов выполняют данное действие в течение всего нескольких минут, это будет формировать скачок нагрузки на SQL, уровень которой может быть на несколько порядков выше, чем допустимый уровень нагрузки для вашего приложения в устойчивом состоянии. Для устранения такой проблемы можно масштабировать ваше приложение вверх на более высокий уровень SQL во время всплеска, а затем вниз, однако такое решение требует ручного вмешательства и приводит к увеличению затрат. Во многих случаях незначительные тонкие настройки архитектуры вашей мобильной службы могут существенно выравнивать нагрузку, создаваемую клиентами на вашу базу данных SQL, и устранять нежелательные всплески из-за большого числа запросов. Такие изменения можно часто реализовать очень легко при минимальном воздействии на удобство работы ваших клиентов. Ниже приведены некоторые примеры:

- **Распределяйте нагрузку по времени.** Если вы контролируете временные параметры определенных событий (например, широковещательную передачу push-уведомлений), которые, предположительно будут создавать всплеск запросов, и временные параметры таких событий не являются критически важными, распределяйте их по времени. В примере выше пользователям вашего приложения, возможно, будет удобно получать уведомления о новом контенте приложения в виде пакетов в течение всего дня, а не практически одновременно. Объединяйте своих клиентов в группы — это позволит обеспечивать поочередную доставку пакетов. В случае использования концентраторов уведомлений можно применять дополнительный тег для отслеживания пакета, а затем отправлять push-уведомление на этот тег — это очень удобный и несложный способ реализации данной стратегии. Дополнительные сведения о тегах см. в разделе [Использование концентраторов уведомлений для отправки экстренных сообщений](../notification-hubs-windows-store-dotnet-send-breaking-news.md).
- **Если это возможно, широко используйте хранилище больших двоичных объектов и таблиц.** Во многих случаях контент, который клиенты будут просматривать во время всплеска, является фактически статическим и не подлежит хранению в базе данных SQL, так как маловероятно, что вам будет нужна возможность реляционного запроса данного контента. В таком случае контент рекомендуется хранить в хранилище больших двоичных объектов или таблиц. Доступ к общедоступным большим двоичным объектам в хранилище больших двоичных объектов можно получать непосредственно из устройства. Чтобы получать безопасный доступ к большим двоичным объектам или использовать хранилище таблиц, для защиты своего ключа доступа к хранилищу вам будет нужно проходить через пользовательский интерфейс API мобильных служб. Дополнительные сведения см. в разделе [Загрузка изображений в хранилище Azure с помощью мобильных служб](mobile-services-dotnet-backend-windows-store-dotnet-upload-data-blob-storage.md).
- **Используйте кэш в памяти**. Другим возможным способом хранения данных, который может применяться во время всплесков трафика, является использование кэша в памяти, например, [кэша Azure](https://azure.microsoft.com/services/cache/). Это означает, что входящие запросы смогут получать необходимую информацию прямо из памяти, а не постоянно запрашивать ее в базе данных.

<a name="Advanced"></a>
## Расширенный поиск проблем
В этом разделе рассматриваются некоторые расширенные диагностические задачи, которые могут оказаться полезными, если уже выполненные действия не позволили полностью устранить проблему.

### Предварительные требования
Для выполнения некоторых диагностических задач в этом разделе вам будет необходим доступ к инструменту управления базами данных SQL, например **SQL Server Management Studio**, или функция управления, встроенная в **классический портал Azure**.

SQL Server Management Studio представляет собой бесплатное приложение Windows, которое предоставляет наиболее широкие возможности. Если у вас нет доступа к компьютеру Windows (например, в случае использования ПК Mac), провизионируйте виртуальную машину в Azure, как показано в разделе [Создание виртуальной машины, на которой выполняется Windows Server](../virtual-machines-windows-tutorial.md), а затем дистанционно подключитесь к ней. Если вы планируете использовать ВМ, прежде всего, для выполнения пакета SQL Server Management Studio, то будет достаточно применить экземпляр **Basic A0** (ранее назывался «Очень мелкий»).

Классический портал Azure содержит встроенные функции управления, которые несколько ограничены по своим возможностям, но доступны без локальной установки.

Следующая процедура позволяет получить информацию о соединении для базы данных SQL, поддерживающей вашу мобильную службу, а затем использовать любой из этих двух инструментов для подключения к ней. Вы можете выбрать любой инструмент.

#### Получение информации о соединении SQL
1. Откройте [классический портал Azure].
2. На вкладке «Мобильные службы» выберите службу, с которой вы хотите работать.
3. Перейдите на вкладку **Настройка**.
4. Выберите имя **База данных SQL** в разделе **Параметры базы данных**. В результате вы перейдете на вкладку «База данных Azure SQL» на портале.
5. Выберите пункт **Настроить правила брандмауэра Azure для этого IP-адреса**.
6. Запишите адрес сервера в разделе **Подключение к базе данных**, например: *mcml4otbb9.database.windows.net*.

#### SQL Server Management Studio
1. Перейдите в раздел [Выпуски SQL Server - Express](http://www.microsoft.com/server-cloud/products/sql-server-editions/sql-server-express.aspx)
2. Найдите раздел **SQL Server Management Studio** и нажмите кнопку **Загрузка** внизу.
3. Выполняйте процедуру настройки до тех пор, пока не будет запущено приложение:

    ![SQL Server Management Studio][SSMS]

4. В диалоговом окне **Подключение к серверу** введите следующие значения:
    - Имя сервера: *адрес сервера, который вы получили ранее*.
    - Проверка подлинности: *проверка подлинности SQL Server*.
    - Имя для входа: *имя для входа в систему, которое вы выбрали при создании сервера*.
    - Пароль: *пароль, который вы выбрали при создании сервера*.
5. Теперь соединение должно быть установлено.

#### Портал управления базами данных SQL
1. На вкладке «База данных Azure SQL» для вашей базы данных нажмите кнопку **Управление**
2. Настройте соединение со следующими значениями:
    - Сервер: *необходимо ввести предварительно заданное правильное значение*.
    - База данных: *оставьте поле пустым*.
    - Имя пользователя: *имя для входа в систему, которое вы выбрали при создании сервера*.
    - Пароль: *пароль, который вы выбрали при создании сервера*.
3. Теперь соединение должно быть установлено.

    ![Классический портал Azure — база данных SQL][PortalSqlManagement]

<a name="AdvancedDiagnosing" />
### Расширенная диагностика

Прямо на **классическом портале Azure** можно выполнять много диагностических задач, однако некоторые сложные диагностические задачи можно выполнять только с помощью **SQL Server Management Studio** или на **портале управления базы данных SQL**. Мы будем использовать динамические административные представления, то есть, представления, в которых диагностическая информация о вашей базе данных появляется автоматически. В этом разделе рассматривается несколько запросов, которые можно выполнять в данных представлениях для анализа различных метрик. Дополнительные сведения см. в разделе [Мониторинг базы данных SQL с помощью динамических административных представлений][].

После выполнения процедуры в предыдущем разделе для подключения к базе данных в SQL Server Management Studio выберите базу данных в **обозревателе объектов**. Для вывода списка административных представлений разверните **Представления**, а затем **Системные представления**. Для выполнения запросов, указанных ниже, щелкните **Новый запрос** после выбора базы данных в **обозревателе объектов**, а затем вставьте запрос и щелкните **Выполнить**.

![SQL Server Management Studio - Динамические административные представления][SSMSDMVs]

С другой стороны, если вы используете портал управления базы данных SQL, выберите сначала свою базу данных, а затем щелкните **Новый запрос**.

![Портал управления базы данных SQL - Новый запрос][PortalSqlManagementNewQuery]

Для выполнения любого из запросов, указанных ниже, вставьте его в окно и щелкните **Запуск**.

![Портал управления базы данных SQL - Запуск запроса][PortalSqlManagementRunQuery]

#### Расширенные метрики


В случае использования уровней Basic, Standard и Premium портал управления предоставляет несколько готовых метрик. Независимо от применяемого уровня, эти и другие метрики можно очень просто получить с помощью административного представления **[sys.resource\_stats](http://msdn.microsoft.com/library/dn269979.aspx)**. Рассмотрим следующий запрос:

    SELECT TOP 10 *
    FROM sys.resource_stats
    WHERE database_name = 'todoitem_db'
    ORDER BY start_time DESC

> [AZURE.NOTE]
Выполните этот запрос в базе данных **master** на своем сервере. В этой базе данных присутствует только представление **sys.resource\_stats**.

Результат будет содержать следующие полезные метрики: ЦП (% от лимита уровня), хранилище (мегабайты), физические операции чтения данных (% от лимита уровня), операции записи в журнал (% от лимита уровня), память (% от лимита уровня), количество рабочих процессов, количество сеансов и т. д.

#### События связности SQL

Представление **[sys.event\_log](http://msdn.microsoft.com/library/azure/jj819229.aspx)** содержит подробные сведения о событиях, связанных с подключениями.

    select * from sys.event_log
    where database_name = 'todoitem_db'
    and event_type like 'throttling%'
    order by start_time desc

> [AZURE.NOTE]
Выполните этот запрос в базе данных **master** на своем сервере. В этой базе данных присутствует только представление **sys.event\_log**.

<a name="AdvancedIndexing" ></a>
### Расширенная индексация

Таблица или представление могут содержать следующие типы индексов:

- **Кластеризованный**. Кластеризованный индекс указывает, как записи физически хранятся на диске. Для таблицы должен иметься только один кластеризованный индекс, так как сами строки данных могут быть отсортированы только в одном порядке.

- **Некластеризованный**. Некластеризованные индексы хранятся отдельно от строк данных и используются для поиск на основе значения индекса. Все некластеризованные индексы в таблице используют значения ключей из кластеризованного индекса в качестве ключа поиска.

Рассмотрим аналогию из реального мира: представьте себе книгу или техническое руководство. Содержимое каждой страницы представляет собой запись, номер страницы — кластеризованный индекс, а индекс разделов в конце книги — некластеризованный индекс. Каждое значение в индексе разделов указывает на кластеризованный индекс, то есть, номер страницы.

> [AZURE.NOTE]
По умолчанию сервер базы данных JavaScript мобильных служб Azure задает **\_createdAt** в качестве кластеризованного индекса. Если вы удаляете этот столбец или хотите иметь другой кластеризованный индекс, выполните [рекомендации по структуре кластеризованного индекса](#ClusteredIndexes), указанные ниже. На сервере .NET класс `EntityData` определяет `CreatedAt` в качестве кластеризованного индекса с помощью заметки `[Index(IsClustered = true)]`.

<a name="ClusteredIndexes"></a>
#### Рекомендации по структуре кластеризованного индекса

Каждая таблица должна иметь кластеризованный индекс в столбце (или столбцах, в случае составного ключа) со следующими свойствами:

- Narrow - использует малый тип данных или является [составным ключом][Primary and Foreign Key Constraints] небольшого количества узких столбцов
- Unique или mostly unique (Уникальный или практически уникальный)
- Static - значение изменяется редко
- Ever-increasing (Постоянно увеличивающийся)
- (необязательно) Fixed-width (С фиксированной шириной)
- (необязательно) nonnull (непустой)

Причина для свойства **narrow** состоит в том, что все другие индексы в таблице используют значения ключей из кластеризованного индекса в качестве ключей поиска. В примере индекса разделов в конце книги кластеризованный индекс представляет собой номер страницы и является небольшим числом. Если бы вместо него в кластеризованный индекс было бы включено название главы, то сам индекс разделов был бы гораздо длиннее, так как значение ключа имело бы следующий вид — название главы, номер страницы.

Ключ должен иметь свойство **static** и **ever-increasing** во избежание обработки физического местоположения записей (это означает либо физическое перемещение записей, либо потенциальную фрагментацию хранилища путем разделения страниц, где хранятся записи).

Кластеризованный индекс будет самым удобным для запросов, выполняющим следующие действия:

- Возвращать диапазон значений с помощью операторов, например, BETWEEN, >, >=, < и <=.
	- После того, как будет найдена строка с первым значением при использовании кластеризованного индекса, строки с последующими индексированными значениями будут гарантированно физически смежными.
- Использовать предложения JOIN; обычно они представляют собой столбцы внешних ключей.
- Использовать предложения ORDER BY или GROUP BY.
	- Индекс в столбцах, указанных в предложении ORDER BY или GROUP BY, может устранить необходимость в сортировке данных для ядра базы данных, так как строки уже отсортированы. Это повышает производительность запросов.

#### Создание кластеризованных индексов на платформе Entity Framework

Чтобы настроить кластеризованный индекс на сервере .NET с помощью платформы Entity Framework, настройте свойство `IsClustered` заметки. Например, это определение атрибута `CreatedAt` в `Microsoft.WindowsAzure.Mobile.Service.EntityData`:

	[Index(IsClustered = true)]
	[DatabaseGenerated(DatabaseGeneratedOption.Identity)]
	[TableColumnAttribute(TableColumnType.CreatedAt)]
	public DateTimeOffset? CreatedAt { get; set; }

#### Создание индексов в схеме базы данных

Для сервера JavaScript кластеризованный индекс таблицы можно модифицировать только путем прямого изменения схемы базы данных либо в SQL Server Management Studio, либо на портале базы данных Azure SQL.

В следующих руководствах описывается, как настраивать кластеризованный или некластеризованный индекс путем прямого изменения схемы базы данных:

- [Создание и изменение ограничений для ПЕРВИЧНОГО КЛЮЧА][]
- [Создание некластеризованных индексов][]
- [Создание кластеризованных индексов][]
- [Создание уникальных индексов][]

#### Поиск верхних N отсутствующих индексов
SQL-запросы можно создавать в динамических административных представлениях, которые будут содержать более подробные сведения об использовании ресурсов отдельными запросами или эвристические данные о том, какие индексы следует добавить. Следующий запрос определяет, какие 10 отсутствующих индексов будут обеспечивать самое большое ожидаемое совокупное усовершенствование (в порядке убывания) для запросов пользователя.

    SELECT TOP 10 *
    FROM sys.dm_db_missing_index_group_stats
    ORDER BY avg_total_user_cost * avg_user_impact * (user_seeks + user_scans)
    DESC;

Следующий пример запроса выполняет операцию объединения среди этих таблиц с целью получения списка столбцов, которые должны быть частью каждого отсутствующего индекса, и вычисляет 'преимущество индекса', чтобы определить, нужно ли будет принимать во внимание заданный индекс:

    SELECT * from
    (
        SELECT
        (user_seeks+user_scans) * avg_total_user_cost * (avg_user_impact * 0.01) AS index_advantage, migs.*
        FROM sys.dm_db_missing_index_group_stats migs
    ) AS migs_adv,
      sys.dm_db_missing_index_groups mig,
      sys.dm_db_missing_index_details mid
    WHERE
      migs_adv.group_handle = mig.index_group_handle and
      mig.index_handle = mid.index_handle
      AND migs_adv.index_advantage > 10
    ORDER BY migs_adv.index_advantage DESC;

Дополнительные сведения см. в разделах [Мониторинг базы данных SQL с помощью динамических административных представлений][] и [Динамические административные представления отсутствующих индексов][].

<a name="AdvancedQuery" ></a>
### Усовершенствованная структура запросов 

Часто бывает сложно понять, какие запросы являются самыми дорогостоящими для базы данных.


#### Поиск верхних N запросов

В следующем примере возвращаются сведения о пяти первых запросах, отсортированных по среднему времени ЦП. В этом примере выполняется сбор запросов по хэшу запроса, то есть логически схожие запросы группируются по общему потреблению ресурсов.

	SELECT TOP 5 query_stats.query_hash AS "Query Hash",
	    SUM(query_stats.total_worker_time) / SUM(query_stats.execution_count) AS "Avg CPU Time",
	    MIN(query_stats.statement_text) AS "Statement Text"
	FROM
	    (SELECT QS.*,
	    SUBSTRING(ST.text, (QS.statement_start_offset/2) + 1,
	    ((CASE statement_end_offset
	        WHEN -1 THEN DATALENGTH(st.text)
	        ELSE QS.statement_end_offset END
	            - QS.statement_start_offset)/2) + 1) AS statement_text
	     FROM sys.dm_exec_query_stats AS QS
	     CROSS APPLY sys.dm_exec_sql_text(QS.sql_handle) as ST) as query_stats
	GROUP BY query_stats.query_hash
	ORDER BY 2 DESC;

Дополнительные сведения см. в разделе [Мониторинг базы данных SQL с помощью динамических административных представлений][]. В дополнение к выполнению запроса **Портал управления базы данных SQL** позволяет увидеть эти данные путем щелчка **Сводка** для базы данных, а затем **Производительность запросов**:

![Портал управления базы данных SQL - производительность запросов][PortalSqlManagementQueryPerformance]

#### Анализ плана запроса

Как только вы определили дорогостоящие запросы или планируете развернуть код с помощью новых запросов и хотели бы проанализировать их производительность, можно воспользоваться специальными средствами, которые позволяют эффективно анализировать **план запроса**. План запроса позволяет увидеть, какие операции занимают основные время ЦП и ресурсы ввода-вывода в ходе выполнения заданного SQL-запроса. Для анализа плана запроса в **SQL Server Management Studio** используйте выделенные кнопки панели инструментов.

![SQL Server Management Studio - план запроса][SSMSQueryPlan]

Для анализа плана запроса на **портале управления базы данных SQL** используйте выделенные кнопки панели инструментов.

![Портал управления базы данных SQL - план запроса][PortalSqlManagementQueryPlan]

## См. также

- [Документация по базе данных SQL Azure][]
- [Производительность и масштабирование базы данных SQL Azure][]
- [Устранение неполадок, связанных с базами данных SQL Azure][]

### Индексация

- [Общие сведения об индексировании][]
- [Общие правила проектирования индекса][]
- [Правила проектирования уникального индекса][]
- [Правила проектирования кластеризованного индекса][]
- [Ограничения для первичного и внешнего ключей][]
- [Сколько стоит ключ?][]

### Entity Framework
- [Вопросы производительности для платформы Entity Framework 5][]
- [Заметки к данным Code First][]

<!-- IMAGES -->

[SSMS]: ./media/mobile-services-sql-scale-guidance/1.png
[PortalSqlManagement]: ./media/mobile-services-sql-scale-guidance/2.png
[PortalSqlMetrics]: ./media/mobile-services-sql-scale-guidance/3.png
[PortalSqlScale]: ./media/mobile-services-sql-scale-guidance/4.png
[PortalSqlAddAlert]: ./media/mobile-services-sql-scale-guidance/5.png
[PortalSqlAddAlert2]: ./media/mobile-services-sql-scale-guidance/6.png
[PortalSqlAddAlert3]: ./media/mobile-services-sql-scale-guidance/7.png
[SetIndexJavaScriptPortal]: ./media/mobile-services-sql-scale-guidance/set-index-portal-ui.png
[SSMSDMVs]: ./media/mobile-services-sql-scale-guidance/8.png
[PortalSqlManagementNewQuery]: ./media/mobile-services-sql-scale-guidance/9.png
[PortalSqlManagementRunQuery]: ./media/mobile-services-sql-scale-guidance/10.png
[PortalSqlManagementQueryPerformance]: ./media/mobile-services-sql-scale-guidance/11.png
[SSMSQueryPlan]: ./media/mobile-services-sql-scale-guidance/12.png
[PortalSqlManagementQueryPlan]: ./media/mobile-services-sql-scale-guidance/13.png

<!-- LINKS -->

[классический портал Azure]: http://manage.windowsazure.com
[классическом портале Azure]: http://manage.windowsazure.com

[Документация по базе данных SQL Azure]: http://azure.microsoft.com/documentation/services/sql-database/
[Managing SQL Database using SQL Server Management Studio]: http://go.microsoft.com/fwlink/p/?linkid=309723&clcid=0x409
[Мониторинг базы данных SQL с помощью динамических административных представлений]: http://go.microsoft.com/fwlink/p/?linkid=309725&clcid=0x409
[Производительность и масштабирование базы данных SQL Azure]: http://go.microsoft.com/fwlink/p/?linkid=397217&clcid=0x409
[Устранение неполадок, связанных с базами данных SQL Azure]: http://msdn.microsoft.com/library/azure/ee730906.aspx
[Причины применения новых уровней служб]: http://msdn.microsoft.com/library/azure/dn369873.aspx#Reasons

[метод Take]: http://msdn.microsoft.com/library/vstudio/bb503062(v=vs.110).aspx

<!-- MSDN -->
[Создание и изменение ограничений для ПЕРВИЧНОГО КЛЮЧА]: http://technet.microsoft.com/library/ms181043(v=sql.105).aspx
[Создание кластеризованных индексов]: http://technet.microsoft.com/library/ms186342(v=sql.120).aspx
[Создание уникальных индексов]: http://technet.microsoft.com/library/ms187019.aspx
[Создание некластеризованных индексов]: http://technet.microsoft.com/library/ms189280.aspx

[Primary and Foreign Key Constraints]: http://msdn.microsoft.com/library/ms179610(v=sql.120).aspx
[Ограничения для первичного и внешнего ключей]: http://msdn.microsoft.com/library/ms179610(v=sql.120).aspx
[Общие сведения об индексировании]: http://technet.microsoft.com/library/ms190457(v=sql.105).aspx
[Общие правила проектирования индекса]: http://technet.microsoft.com/library/ms191195(v=sql.105).aspx
[Правила проектирования уникального индекса]: http://technet.microsoft.com/library/ms187019(v=sql.105).aspx
[Правила проектирования кластеризованного индекса]: http://technet.microsoft.com/library/ms190639(v=sql.105).aspx

[Динамические административные представления отсутствующих индексов]: http://technet.microsoft.com/library/ms345421.aspx

<!-- EF -->
[Вопросы производительности для платформы Entity Framework 5]: http://msdn.microsoft.com/data/hh949853
[Заметки к данным Code First]: http://msdn.microsoft.com/data/jj591583.aspx
[Заметки об индексе на платформе Entity Framework]: http://msdn.microsoft.com/data/jj591583.aspx#Index

<!-- BLOG LINKS -->
[Сколько стоит ключ?]: http://www.sqlskills.com/blogs/kimberly/how-much-does-that-key-cost-plus-sp_helpindex9/

<!---HONumber=AcomDC_0128_2016-->