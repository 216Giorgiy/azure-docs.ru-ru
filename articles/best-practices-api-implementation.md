<properties
   pageTitle="Руководство по реализации API | Microsoft Azure"
   description="Рекомендации по реализации API."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="masimms"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="rest-api"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="12/17/2015"
   ms.author="masashin"/>

# Руководство по реализации API

![](media/best-practices-api-implementation/pnp-logo.png)


Некоторые разделы в этом руководстве находятся в процессе обсуждения и могут быть изменены в дальнейшем. Будем рады вашим отзывам!

## Обзор
Тщательно спроектированный веб-API RESTful определяет ресурсы, связи и схемы навигации, которые доступны для клиентских приложений. При реализации и развертывании веб-API следует учитывать физические требования среды размещения веб-API и способ создания веб-API, а не логическую структуру данных. В этом руководстве рассматриваются советы и рекомендации по реализации веб-API и его публикации, чтобы сделать API доступными для клиентских приложений. Вопросы безопасности описаны отдельно в документе "Руководство по безопасности API". Подробные сведения о разработке веб-API представлены в документе "Руководство по проектированию API".

## Рекомендации по реализации веб-API RESTful
В разделах ниже приведены рекомендации по использованию шаблона веб-API ASP.NET для создания веб-API RESTful. Подробные сведения об использовании шаблона веб-API см. на странице [сведений о веб-API ASP.NET](http://www.asp.net/web-api) на веб-сайте Майкрософт.

## Рекомендации по реализации маршрутизации запроса

В службе, реализованной с помощью веб-API ASP.NET, каждый запрос направляется к методу в классе _controller_. Платформа веб-API предоставляет две основных возможности для реализации маршрутизации: маршрутизация _на основе соглашения_ и маршрутизация _на основе атрибута_. При определении наиболее подходящего способа маршрутизации запросов в веб-API необходимо учитывать указанные ниже моменты.

- **Ограничения и требования к маршрутизации на основе соглашения.**

	По умолчанию платформа веб-API использует маршрутизацию на основе соглашения. Она создает исходную таблицу маршрутизации, содержащую следующую запись:

	```C#
	config.Routes.MapHttpRoute(
  		name: "DefaultApi",
	  	routeTemplate: "api/{controller}/{id}",
	  	defaults: new { id = RouteParameter.Optional }
	);
	```

	Маршруты могут быть универсальными, включающими литералы, такие как _api_, и переменные, такие как _{controller}_ и _{id}_. В маршрутизации на основе соглашения некоторые элементы маршрута могут быть необязательными. Платформа веб-API определяет метод для вызова в контроллере путем сопоставления HTTP-метода в запросе с начальной частью имени метода в интерфейсе API, а затем путем сопоставления любых дополнительных параметров. Например, если контроллер с именем _orders_ содержит методы _GetAllOrders()_ или _GetOrderByInt (int id)_, запрос GET \__http://www.adventure-works.com/api/orders/_ будет направляться в метод _GetAlllOrders()_, а запрос GET \__http://www.adventure-works.com/api/orders/99_ — в метод _GetOrderByInt (int id)_. Если в контроллере отсутствует соответствующий метод, начинающийся с префикса Get, платформа веб-API выдает сообщение HTTP 405 (метод запрещен). Кроме того, имя параметра (id), указанное в таблице маршрутизации, должно совпадать с именем параметра для метода _GetOrderById_, в противном случае платформа веб-API выдаст ответ HTTP 404 (не найдено).

	Те же правила применяются для HTTP-запросов POST, PUT и DELETE; запрос PUT, который обновляет сведения о заказе 101, будет направляться на URI \__http://www.adventure-works.com/api/orders/101_, текст сообщения будет содержать новые сведения о заказе, и эти сведения будут передаваться как параметр в метод в контроллере orders с именем, которое начинается с префикса _Put_, например _PutOrder_.

	В таблице маршрутизации по умолчанию не будет отсутствовать соответствующий запрос, который ссылается на дочерние ресурсы в веб-API RESTful, например \__http://www.adventure-works.com/api/customers/1/orders_ (поиск подробных сведений обо всех заказах клиента 1). В таких случаях в таблицу маршрутизации можно добавить пользовательские маршруты:

	```C#
	config.Routes.MapHttpRoute(
	    name: "CustomerOrdersRoute",
	    routeTemplate: "api/customers/{custId}/orders",
	    defaults: new { controller="Customers", action="GetOrdersForCustomer" })
	);
	```

	Этот маршрут направляет запросы, соответствующие URI, в метод _GetOrdersForCustomer_ в контроллере _Customers_. Этот метод должен принимать один параметр с именем _custI_:

	```C#
	public class CustomersController : ApiController
	{
	    ...
	    public IEnumerable<Order> GetOrdersForCustomer(int custId)
	    {
	        // Find orders for the specified customer
	        var orders = ...
	        return orders;
	    }
	    ...
	}
	```

	> [AZURE.TIP] Используйте маршрутизацию по умолчанию, когда это возможно, и избегайте определения множества сложных пользовательских маршрутов, так как это может привести к уязвимости (можно с легкостью добавить методы в контроллер, что приведет к созданию неоднозначных маршрутов) и снижению производительности (чем больше таблица маршрутизации, тем больше вычислений следует выполнить платформе веб-API, чтобы определить, какой маршрут соответствует заданному URI). API и маршруты должны быть простыми. Дополнительные сведения см. в разделе, посвященном организации веб-API вокруг ресурсов, руководства по проектированию API. Если необходимо определить пользовательские маршруты, предпочтительным подходом является использование маршрутизации на основе атрибута, как описано далее в этом разделе.

	Дополнительные сведения о маршрутизации на основе соглашения см. на странице, посвященной [маршрутизации в веб-API ASP.NET](http://www.asp.net/web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api), на веб-сайте Майкрософт.

- **Избегайте неоднозначности в маршрутизации.**

	Маршрутизация на основе соглашения может привести к созданию неоднозначных путей, если маршрут соответствует нескольким методам в контроллере. В этих случаях платформа веб-API выдает сообщение HTTP 500 (внутренняя ошибка сервера), содержащее текст "Найдено несколько действий, соответствующих запросу".

- **Отдавайте предпочтение маршрутизации на основе атрибута.**

	Маршрутизация на основе атрибута предоставляет альтернативные способы подключения маршрутов к методам в контроллере. Вместо того чтобы полагаться на возможности сопоставления по образцу, которые предлагает маршрутизация на основе соглашений, можно явным образом снабдить методы в контроллере примечаниями с подробными сведениями о маршруте, с которым он должен быть связан. Этот подход позволяет исключить возможную неоднозначность маршрутов. Кроме того, поскольку явные маршруты определяются во время разработки, этот подход является более эффективным, чем маршрутизации на основе соглашения, выполняемая во время выполнения. В примере кода ниже демонстрируется, как применить атрибут _Route_ к методам в контроллере Customers. Эти методы также используют атрибут HttpGet, чтобы указать, что они должны отвечать на запросы _HTTP GET_. Этот атрибут позволяет присвоить имя методам с помощью любой удобной схемы именования, а не с помощью той, которая ожидается при маршрутизации на основе соглашения. Кроме того, можно добавлять примечания к методам с помощью атрибутов _HttpPost_, _HttpPut_ и _HttpDelete_, чтобы определить методы, реагирующие на другие типы HTTP-запросов.

	```C#
	public class CustomersController : ApiController
	{
	    ...
	    [Route("api/customers/{id}")]
	    [HttpGet]
	    public Customer FindCustomerByID(int id)
	    {
	        // Find the matching customer
	        var customer = ...
	        return customer;
	    }
	    ...
	    [Route("api/customers/{id}/orders")]
	    [HttpGet]
	    public IEnumerable<Order> FindOrdersForCustomer(int id)
	    {
	        // Find orders for the specified customer
	        var orders = ...
	        return orders;
	    }
	    ...
	}
	```

	Маршрутизация на основе атрибута также имеет еще одну полезную особенность: примечания можно использовать в качестве документации для разработчиков, которые будут обслуживать такой код в будущем. Им сразу очевидно, какой метод принадлежит тому или иному маршруту, а атрибут _HttpGet_ указывает на тип HTTP-запроса, на который реагирует метод.

	Маршрутизация на основе атрибутов позволяет определить ограничения относительно сопоставления параметров. Ограничения могут указывать на тип параметра, а в некоторых случаях они также могут указать допустимый диапазон значений параметров. В следующем примере параметр id для метода _FindCustomerByID_ должен быть неотрицательным целым числом. Если приложение отправляет запрос HTTP GET, содержащий отрицательное число клиента, платформа веб-API выдает сообщение HTTP 405 (метод запрещен):

	```C#
	public class CustomersController : ApiController
	{
	    ...
	    [Route("api/customers/{id:int:min(0)}")]
	    [HttpGet]
	    public Customer FindCustomerByID(int id)
	    {
	        // Find the matching customer
	        var customer = ...
	        return customer;
	    }
	    ...
	}
	```

	Дополнительные сведения о маршрутизации на основе атрибута см. на странице, посвященной [маршрутизации на основе атрибута в веб-API 2](http://www.asp.net/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2), на веб-сайте Майкрософт.

- **Реализуйте в маршрутах поддержку символов Юникода.**

	Ключи, используемые для идентификации ресурсов в запросах GET, могут быть строками. Таким образом, в глобальном приложении может потребоваться поддержка URI, содержащих символы национальных алфавитов.

- **Различайте методы, которые не следует направлять.**

	При использовании маршрутизации на основе соглашения обозначьте методы, которые не соответствуют действиям HTTP, дополнив их атрибутом _NonAction_. Это обычно относится ко вспомогательным методам, определенным для использования другими методами в контроллере. Этот атрибут позволяет предотвратить сопоставление таких методов и их вызов ошибочным HTTP-запросом.

- **Изучите преимущества и недостатки размещения API в поддомене.**

	По умолчанию веб-API ASP.NET помещает API-интерфейсы в каталог _/api_ в домене, например \__http://www.adventure-works.com/api/orders_. Этот каталог находится в том же домене, что и другие службы, предоставляемые этим же узлом. Может быть полезно разделить веб-API и разместить его в собственном поддомене, размещенном на отдельном сервере с такими URI, как \__http://api.adventure-works.com/orders_. Такое разделение позволяет более эффективно секционировать и масштабировать веб-API, не оказывая влияние на другие веб-приложения или службы в домене _www.adventure-works.com_.

	Однако размещение веб-API в другом поддомене также может привести к проблемам с безопасностью. Любое веб-приложение или служба, размещенные в домене _www.adventure-works.com_ и вызывающие веб-API в другом месте, могут нарушать политику одного источника во многих веб-браузерах. В этом случае необходимо включить между узлами общий доступ к ресурсам независимо от источника (CORS). Дополнительные сведения см. в руководстве по безопасности API.

## Рекомендации относительно обработки запросов

После успешной маршрутизации запроса из клиентского приложения в метод веб-API этот запрос должен быть максимально эффективно обработан. При реализации кода для обработки запросов необходимо учитывать перечисленные ниже моменты.

- **Действия GET, PUT, DELETE, HEAD и PATCH должны быть идемпотентными.**

	Код, который реализует эти запросы, не должен включать никаких побочных эффектов. Один и тот же запрос, выполненный повторно через тот же ресурс, должен возвращать результат в том же состоянии. Например, отправка нескольких запросов DELETE на один и тот же URI должна иметь одинаковый эффект, несмотря на то что код состояния HTTP в ответных сообщениях может отличаться (первый запрос DELETE может возвратить код состояния 204 [нет содержимого], а последующий запрос DELETE может возвратить код состояния 404 [не найдено]).

> [AZURE.NOTE] В статье, посвященной [шаблонам идемпотентности](http://blog.jonathanoliver.com/idempotency-patterns/), в блоге Джонатана Оливера (Jonathan Oliver) представлен обзор идемпотентности и его связь с операциями по управлению данными.

- **Действия POST, которые создают новые ресурсы, должны делать это без несвязанных побочных эффектов.**

	Если запрос POST предназначен для создания нового ресурса, результаты запроса должны быть ограничены новым ресурсом (и, возможно, всеми непосредственно связанными ресурсами, если существует связь определенного рода). Например, в системе электронной коммерции запрос POST, который создает новый заказ для клиента, может также исправить данные о складских запасах и сгенерировать сведения для выставления счетов, однако он не должен изменять сведения, не связанные непосредственно с заказом, или иметь любые другие побочные эффекты, влияющие на общее состояние системы.

- **Избегайте реализации неаккуратных операции POST, PUT и DELETE.**

	Реализуйте поддержку запросов POST, PUT и DELETE через коллекции ресурсов. Запрос POST может содержать сведения о нескольких новых ресурсах и добавить их все в одну и ту же коллекцию, запрос PUT может заменить весь набор ресурсов в коллекции, а запрос DELETE может удалить всю коллекцию.

	Обратите внимание, что поддержка OData, включенная в веб-API ASP.NET 2, предоставляет возможность создавать пакеты запросов. Клиентское приложение может упаковать несколько запросов веб-API и отправлять их на сервер в одном HTTP-запросе, а также получать один ответ HTTP, который содержит ответы на каждый запрос. Дополнительные сведения см. на странице [Поддержка пакетных операций в веб-API и веб-API OData](http://blogs.msdn.com/b/webdev/archive/2013/11/01/introducing-batch-support-in-web-api-and-web-api-odata.aspx) на веб-сайте Майкрософт.

- **Соблюдайте правила протокола HTTP при отправке ответа обратно в клиентское приложение.**

	Веб-интерфейс API должен возвращать сообщения, содержащие правильный код состояния HTTP, чтобы клиент мог определить способ обработки результатов, соответствующие заголовки HTTP, чтобы клиент мог понять характер результата, и подходящим образом форматированный текст, чтобы клиент мог проанализировать результат. При использовании шаблона веб-API ASP.NET стратегия по умолчанию для реализации методов, которые отвечают на запросы HTTP POST, заключается в том, чтобы просто получить копию нового созданного ресурса, как показано в следующем примере:

	```C#
	public class CustomersController : ApiController
	{
	    ...
	    [Route("api/customers")]
	    [HttpPost]
	    public Customer CreateNewCustomer(Customer customerDetails)
	    {
	        // Add the new customer to the repository
	        // This method returns a customer with a unique ID allocated
	        // by the repository
	        var newCust = repository.Add(customerDetails);
	        // Return the newly added customer
	        return newCust;
	    }
	    ...
	}
	```

	При успешном выполнении операции POST платформа веб-API создает ответ HTTP с кодом состояния 200 (ОК) и указывает в тексте сообщения подробные сведения о клиенте. Однако в этом случае, согласно протоколу HTTP, операция POST должна возвращать код состояния 201 (создано), а ответное сообщение должно содержать в заголовке Location URI нового созданного ресурса.

	Чтобы предоставить эти функции, для возврата ответного сообщения HTTP используйте интерфейс `IHttpActionResult`. Такой подход позволяет контролировать код состояния HTTP, заголовки в ответном сообщении и даже формат данных в теле ответного сообщения, как показано примере кода ниже. Эта версия метода `CreateNewCustomer` более точно соответствует ожиданиям клиента, использующего протокол HTTP. Метод `Created` класса `ApiController` создает ответное сообщение с использованием указанных данных и добавляет в результаты заголовок Location:

	```C#
	public class CustomersController : ApiController
	{
	    ...
	    [Route("api/customers")]
	    [HttpPost]
	    public IHttpActionResult CreateNewCustomer(Customer customerDetails)
	    {
	        // Add the new customer to the repository
	        var newCust = repository.Add(customerDetails);

	        // Create a value for the Location header to be returned in the response
	        // The URI should be the location of the customer including its ID,
	        // such as http://adventure-works.com/api/customers/99
	        var location = new Uri(...);

            // Return the HTTP 201 response,
            // including the location and the newly added customer
	        return Created(location, newCust);
	    }
	    ...
	}
	```

- **Поддержка согласования содержимого.**

	Текст ответного сообщения может содержать данные в различных форматах. Например, запрос HTTP GET может возвращать данные в формате JSON или в формате XML. Когда клиент отправляет запрос, он может включить заголовок Accept, указывающий форматы данных, которые он может обработать. Эти форматы задаются в виде типов мультимедиа. Например, клиент, отправляющий запрос GET, который извлекает изображения, может указать заголовок Accept, перечисляющий типы мультимедиа, которые может обработать клиент (например, "image/jpeg, image/gif, image/png"). Когда веб-API возвращает результат, ему следует форматировать данные с помощью одного из этих типов мультимедиа и указать формат в заголовке Content-Type ответа.

	Если клиент не указывает заголовок Accept, то используйте формат по умолчанию для текста ответа. Например, платформа веб-API ASP.NET по умолчанию использует для текстовых данных формат JSON.

	> [AZURE.NOTE] Платформа веб-API ASP.NET выполняет некоторое автоматическое обнаружение заголовков Accept и обрабатывает их сам на основе типа данных в тексте ответного сообщения. Например, если в тексте ответного сообщения содержится объект среды CLR, веб-API ASP.NET автоматически оформляет ответ в формате JSON с заголовком Content-Type ответа в виде "application/json", если только клиент не указал, что результат требуется в формате XML. В таком случае платформа веб-API ASP.NET форматирует ответ в формате XML и задает для заголовка Content-Type значение "text/xml". Тем не менее, может потребоваться обработка заголовков Accept, которые явно указывают в коде реализации для операции различные типы мультимедиа.

- **Предоставляйте ссылки для поддержки переходов в стиле HATEOAS и обнаружения ресурсов.**

	В руководстве по проектированию API описывается, как использование подхода HATEOAS позволяет клиенту обнаружить ресурсы и перейти к ним из исходной точки начала. Это достигается за счет использования ссылок, содержащих URI; когда клиент отправляет запрос HTTP GET, чтобы получить доступ к ресурсу, ответ должен содержать URI, которые позволяют клиентскому приложению быстро найти все непосредственно связанные ресурсы. Например, в веб-API с поддержкой решения электронной коммерции заказчик может разместить много заказов. Когда клиентское приложение получает сведения о заказчике, ответ должен содержать ссылки, позволяющие первому отправлять запросы HTTP GET для извлечения этих заказов. Кроме того, ссылки в стиле HATEOAS должны содержать описания других операций (POST, PUT, DELETE и т. д.), которые поддерживает каждый связанный ресурс, а также соответствующий URI для выполнения каждого запроса. Более подробно этот подход описан в руководстве по проектированию API.

	В настоящее время отсутствуют стандарты, определяющие реализацию HATEOAS, однако в следующем примере показан один из возможных способов. В этом примере запрос HTTP GET, который находит сведения о заказчике, возвращает ответ, включающий ссылки HATEOAS на его заказы:

	```HTTP
	GET http://adventure-works.com/customers/2 HTTP/1.1
	Accept: text/json
	...
	```

	```HTTP
	HTTP/1.1 200 OK
	...
	Content-Type: application/json; charset=utf-8
	...
	Content-Length: ...
	{"CustomerID":2,"CustomerName":"Bert","Links":[
	  {"rel":"self",
	   "href":"http://adventure-works.com/customers/2",
	   "action":"GET",
	   "types":["text/xml","application/json"]},
	  {"rel":"self",
	   "href":"http://adventure-works.com/customers/2",
	   "action":"PUT",
	   "types":["application/x-www-form-urlencoded"]},
	  {"rel":"self",
	   "href":"http://adventure-works.com/customers/2",
	   "action":"DELETE",
	   "types":[]},
	  {"rel":"orders",
	   "href":"http://adventure-works.com/customers/2/orders",
	   "action":"GET",
	   "types":["text/xml","application/json"]},
	  {"rel":"orders",
	   "href":"http://adventure-works.com/customers/2/orders",
	   "action":"POST",
	   "types":["application/x-www-form-urlencoded"]}
	]}
	```

	В этом примере данные заказчика, представленные классом `Customer`, показаны в следующем фрагменте кода. Ссылки HATEOAS находятся в свойстве `Links` коллекции:

	```C#
	public class Customer
	{
    	public int CustomerID { get; set; }
    	public string CustomerName { get; set; }
    	public List<Link> Links { get; set; }
    	...
	}

	public class Link
	{
    	public string Rel { get; set; }
    	public string Href { get; set; }
    	public string Action { get; set; }
    	public string [] Types { get; set; }
	}
	```

	Операция HTTP GET получает данные заказчика из хранилища и создает объект `Customer`, а затем заполняет коллекцию `Links`. Результат представляется в формате ответного сообщения JSON. Каждая ссылка включает в себя следующие поля:

	- связь возвращаемого объекта с объектом, описанным в ссылке; в этом случае "self" указывает, что ссылка является ссылкой на сам объект (аналогично указателю `this` во многих языках объектно ориентированного программирования), а "orders" — это имя коллекции со сведениями, связанными с заказом;

	- гиперссылка (`Href`) для объекта, описываемого в ссылке в виде URI;

	- тип HTTP-запроса (`Action`), который можно отправлять на этот URI;

	- формат данных (`Types`), который необходимо предоставить в HTTP-запросе или которые могут быть возвращены в ответе, в зависимости от типа запроса.

	Ссылки HATEOAS, показанные в примере HTTP-ответа, указывают на то, что клиентское приложение может выполнять следующие операции:

	- запрос HTTP GET к URI \__http://adventure-works.com/customers/2_ для получения сведений о заказчике (снова); данные могут быть возвращены в формате XML или JSON;

	- запрос HTTP PUT к URI \__http://adventure-works.com/customers/2_ для изменения сведений о заказчике; новые данные должны быть представлены в сообщении запроса в формате x-www-form-urlencoded;

	- запрос HTTP DELETE к URI \__http://adventure-works.com/customers/2_ для удаления заказчика; запрос не ожидает никаких дополнительных сведений или возврата данных в теле ответного сообщения;

	- запрос HTTP GET к URI \__http://adventure-works.com/customers/2/orders_ для поиска всех заказов заказчика; данные могут быть возвращены в формате XML или JSON;

	- запрос HTTP PUT к URI \__http://adventure-works.com/customers/2/orders_ для создания нового заказа для этого заказчика; данные должны быть представлены в сообщении запроса в формате x-www-form-urlencoded.

## Рекомендации относительно обработки исключений
По умолчанию в платформе веб-API ASP.NET, если операция создает неперехваченное исключение, то платформа возвращает ответное сообщение с кодом состояния HTTP 500 (внутренняя ошибка сервера). Во многих случаях этот упрощенный подход не используется в одиночку, что усложняет определение причины исключения. Поэтому необходимо реализовать более комплексный подход к обработке исключений, учитывая указанные ниже моменты.

- **Фиксируйте исключения и возвращайте значимые ответы клиентам.**

	Код, который реализует операцию HTTP, должен обеспечивать полную обработку исключений, а не распространение неперехваченных исключений в платформе веб-API. Если исключение не позволяет успешно завершить операцию, его можно передать обратно в ответное сообщение, однако при этом оно должно включать значимое описание ошибки, вызвавшей исключение. Исключение также должно включать соответствующий код состояния HTTP, а не просто возвращаемый код состояния 500 для каждого случая. Например, если запрос пользователя приводит к обновлению базы данных, что нарушает ограничение (например, при попытке удалить заказчика, имеющего необработанные заказы), следует возвращать код состояния 409 (конфликт) и текст сообщения с указанием причины конфликта кода. Если же запрос определяется как невыполнимый по иной причине, можно возвратить код состояния 400 (неправильный запрос). Полный список кодов состояния HTTP представлен на странице [определений кодов состояния](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) на веб-сайте консорциума W3C.

	Ниже приведен пример кода для перехвата различных условий и возврата соответствующего ответа.

	```C#
	[HttpDelete]
	[Route("customers/{id:int}")]
	public IHttpActionResult DeleteCustomer(int id)
	{
		try
		{
			// Find the customer to be deleted in the repository
			var customerToDelete = repository.GetCustomer(id);

			// If there is no such customer, return an error response
			// with status code 404 (Not Found)
			if (customerToDelete == null)
			{
					return NotFound();
			}

			// Remove the customer from the repository
			// The DeleteCustomer method returns true if the customer
			// was successfully deleted
			if (repository.DeleteCustomer(id))
			{
				// Return a response message with status code 204 (No Content)
				// To indicate that the operation was successful
				return StatusCode(HttpStatusCode.NoContent);
			}
			else
			{
				// Otherwise return a 400 (Bad Request) error response
				return BadRequest(Strings.CustomerNotDeleted);
			}
		}
		catch
		{
			// If an uncaught exception occurs, return an error response
			// with status code 500 (Internal Server Error)
			return InternalServerError();
		}
	}
	```

	> [AZURE.TIP] Не включайте сведения, которые могут быть полезны для злоумышленников, пытающихся проникнуть в веб-API. Дополнительные сведения см. на странице [Обработка исключений в ASP.NET Web API](http://www.asp.net/web-api/overview/error-handling/exception-handling) на веб-сайте Майкрософт.

	> [AZURE.NOTE] Многие веб-серверы перехвата ошибки сами до попадания в веб-API. Например, если вы настроили проверку подлинности на веб-сайте и пользователь указал неправильные сведения для проверки подлинности, то веб-сервер должен предоставить ответ с кодом состояния 401 (отсутствует авторизация). После проверки подлинности клиента код может выполнить собственные проверки, чтобы убедиться, что клиенту можно предоставить доступ к запрашиваемому ресурсу. В случае сбоя проверки подлинности следует возвращать код состояния 403 (запрещено).

- **Обрабатывайте исключения согласованным способом и фиксируйте в журнале сведения об ошибках.**

	Для обработки исключений согласованным способом рассмотрите возможность применения глобальной стратегии обработки ошибок в рамках всего веб-API. Частично это можно реализовать, создав фильтр исключений, который выполняется каждый раз, когда контроллер выдает любое необработанное исключение, отличное от исключения `HttpResponseException`. Этот подход описан на странице [Обработка исключений в ASP.NET Web API](http://www.asp.net/web-api/overview/error-handling/exception-handling) на веб-сайте Майкрософт.

	Однако существует несколько ситуаций, когда фильтр исключений не перехватывает исключение, включая указанные ниже.

	- Исключения выброшены из конструкторов контроллеров.

	- Исключения выброшены из обработчиков сообщений.

	- Исключения выброшены при маршрутизации.

	- Исключения во время сериализации содержимого ответного сообщения.

	В таких случаях необходимо применять более функциональный подход. Кроме того, следует включить ведение журнала для записи подробных сведений о каждом исключении; этот журнал ошибок может содержать подробные сведения до тех пор, пока он не станет доступен клиентам через Интернет. В статье [Глобальная обработка ошибок веб-API](http://www.asp.net/web-api/overview/error-handling/web-api-global-error-handling) на веб-сайте Майкрософт демонстрируется один из способов выполнения этой задачи.

- **Различайте ошибки клиента и ошибки сервера.**

	Протокол HTTP позволяет различать ошибки, возникающие из-за клиентского приложения (коды состояния HTTP 4xx), и ошибки, вызванные неполадками на сервере (коды состояния HTTP 5xx). Обязательно учитывайте это при обработке ответных сообщений об ошибках.

<a name="considerations-for-optimizing"></a>
## Рекомендации по оптимизации доступа к данным на стороне клиента

В распределенной среде, например, включающей веб-сервер и клиентские приложения, одним из основных источников проблем является сеть. Это может оказаться значительным узким местом, особенно в том случае, если клиентское приложение часто отправляет запросы или получает данные. Поэтому следует стремиться к тому, чтобы свести к минимуму объем трафика, проходящего через сеть. При реализации кода для получения и хранения данных необходимо учитывать перечисленные ниже моменты.

- **Реализуйте поддержку кэширования на стороне клиента.**

	Протокол HTTP 1.1 поддерживает кэширование в клиентах и на промежуточных серверах, через которые направляется запрос, с помощью заголовка Cache-Control. Когда клиентское приложение отправляет в веб-API запрос HTTP GET, ответ может включать заголовок Cache-Control. Этот заголовок указывает, могут ли данные в теле ответа безопасно кэшироваться клиентом или промежуточным сервером, через который был направлен запрос, и как долго следует кэшировать данные, прежде чем срок их действия истечет и они будут считаться устаревшими. В следующем примере показан запрос HTTP GET и соответствующий ответ, который включает заголовок Cache-Control:

	```HTTP
	GET http://adventure-works.com/orders/2 HTTP/1.1
	...
	```

	```HTTP
	HTTP/1.1 200 OK
	...
	Cache-Control: max-age=600, private
	Content-Type: text/json; charset=utf-8
	Content-Length: ...
	{"orderID":2,"productID":4,"quantity":2,"orderValue":10.00}
	```

	В этом примере заголовок Cache-Control указывает, что срок действия возвращенных данных составляет 600 секунд, а сами данные предназначены только для одного клиента и не должны храниться в общем кэше, используемом другими клиентами (параметр _private_). В заголовке Cache-Control должен быть указан параметр _public_ вместо _private_, если требуется, чтобы данные хранились в общем кэше, или же может быть указан параметр _no-store_, чтобы данные **не** кэшировались клиентом. В следующем примере кода показано, как создать заголовок Cache-Control в ответном сообщении:

	```C#
	public class OrdersController : ApiController
	{
    	...
    	[Route("api/orders/{id:int:min(0)}")]
    	[HttpGet]
    	public IHttpActionResult FindOrderByID(int id)
    	{
    		// Find the matching order
    		Order order = ...;
    		...
    		// Create a Cache-Control header for the response
    		var cacheControlHeader = new CacheControlHeaderValue();
    		cacheControlHeader.Private = true;
    		cacheControlHeader.MaxAge = new TimeSpan(0, 10, 0);
    		...

    		// Return a response message containing the order and the cache control header
    		OkResultWithCaching<Order> response = new OkResultWithCaching<Order>(order, this)
    		{
    			CacheControlHeader = cacheControlHeader
    		};
    		return response;
    	}
    	...
	}
	```

	Этот код использует пользовательский класс `IHttpActionResult` с именем `OkResultWithCaching`. Этот класс позволяет контроллеру задавать содержимое заголовка кэша:

	```C#
	public class OkResultWithCaching<T> : OkNegotiatedContentResult<T>
    {
        public OkResultWithCaching(T content, ApiController controller)
            : base(content, controller) { }

        public OkResultWithCaching(T content, IContentNegotiator contentNegotiator, HttpRequestMessage request, IEnumerable<MediaTypeFormatter> formatters)
            : base(content, contentNegotiator, request, formatters) { }

        public CacheControlHeaderValue CacheControlHeader { get; set; }
        public EntityTagHeaderValue ETag { get; set; }

        public override async Task<HttpResponseMessage> ExecuteAsync(CancellationToken cancellationToken)
        {
            HttpResponseMessage response = await base.ExecuteAsync(cancellationToken);

            response.Headers.CacheControl = this.CacheControlHeader;
            response.Headers.ETag = ETag;

            return response;
        }
    }
	```

	> [AZURE.NOTE] Протокол HTTP также определяет директиву _no-cache_ для заголовка Cache-Control. Директива может ввести в заблуждение, поскольку означает не "не следует кэшировать", а "повторно проверить кэшированные данные на сервере перед их возвращением"; данные по-прежнему могут кэшироваться, но каждый раз, когда они используются, данные проверяются на предмет своей актуальности.

	Управление кэшем — это задача клиентского приложения или промежуточного сервера, однако при правильной реализации это позволяет сэкономить пропускную способность и повысить производительность за счет устранения необходимости в выборке данных, которые уже были получены недавно.

	Значение _max-age_ в заголовке Cache-Control носит исключительно информационный характер и не гарантирует, что соответствующие данные не изменятся в течение указанного времени. Веб-API следует задать для параметра max-age подходящее значение в зависимости от ожидаемой изменчивости данных. По истечении этого периода клиент удаляет объект из кэша.

	> [AZURE.NOTE] Большинство современных веб-браузеров поддерживают кэширование на стороне клиента за счет добавления соответствующих заголовков cache-control в запросы и проверки заголовков результатов, как описано в этой статье. Однако некоторые устаревшие браузеры не будут кэшировать значения, возвращаемые из URL-адреса, который включает строку запроса. Обычно это не является проблемой для пользовательских клиентских приложений, реализующих собственные стратегии управления кэшем на основе протокола, описанного здесь.
	>
	> Некоторые устаревшие прокси-серверы демонстрируют такое же поведение и могут не кэшировать запросы на основе URL-адреса со строками запросов. Это может оказаться проблемой для пользовательских клиентских приложений, подключающихся к веб-серверу через такой прокси-сервер.

- **Используйте теги ETag для оптимизации обработки запросов.**

	Когда клиентское приложение получает объект, в ответном сообщении также может содержаться _ETag_ (тег сущности). ETag представляет собой непрозрачную строку, в которой указывается версия ресурса; при каждом изменении ресурса изменяется и его ETag. Этот ETag должен кэшироваться клиентским приложением как часть данных. В следующем примере кода показано, как добавить ETag в ответ на запрос HTTP GET. Этот код использует метод `GetHashCode` объекта для формирования числового значения, идентифицирующего объект (при необходимости этот метод можно переопределить и создать собственный хэш с помощью такого алгоритма, как MD5):

	```C#
	public class OrdersController : ApiController
	{
    	...
    	public IHttpActionResult FindOrderByID(int id)
    	{
    		// Find the matching order
    		Order order = ...;
    		...

    		var hashedOrder = order.GetHashCode();
    		string hashedOrderEtag = String.Format(""{0}"", hashedOrder);
    		var eTag = new EntityTagHeaderValue(hashedOrderEtag);

    		// Return a response message containing the order and the cache control header
    		OkResultWithCaching<Order> response = new OkResultWithCaching<Order>(order, this)
    		{
    			...,
    			ETag = eTag
    		};
    		return response;
    	}
    	...
    }
	```

	Ответное сообщение, отправленное веб-API, выглядит следующим образом:

	```HTTP
	HTTP/1.1 200 OK
	...
	Cache-Control: max-age=600, private
	Content-Type: text/json; charset=utf-8
	ETag: "2147483648"
	Content-Length: ...
	{"orderID":2,"productID":4,"quantity":2,"orderValue":10.00}
	```

	> [AZURE.TIP] По соображениям безопасности запретите кэширование конфиденциальных данные или данных, возвращаемых через подключение с проверкой подлинности (HTTPS).

	Клиентское приложение может в любое время выдать последующий запрос GET для получения того же ресурса, и если ресурс был изменен (имеет разные теги ETag), кэшированную версию следует удалить и добавить в кэш новую версию. Если ресурс большой и для передачи его обратно клиенту требуется значительный объем пропускной способности, повторная отправка запросов для получения тех же данных может оказаться неэффективной. Для решения этой проблемы протокол HTTP определяет следующий процесс оптимизации запросов GET, которые должны поддерживать в веб-API:

	- Клиент создает запрос GET, содержащий ETag для кэшированной в настоящее время версии ресурса, указанный в заголовке HTTP If-None-Match:

	```HTTP
	GET http://adventure-works.com/orders/2 HTTP/1.1
	If-None-Match: "2147483648"
	...
	```

	- Операция GET в веб-API получает текущий ETag для запрошенных данных (заказ 2 в примере выше) и сравнивает его со значением заголовка If-None-Match.

	- Если текущий ETag для запрошенных данных соответствует тегу ETag, предоставленному в запросе, то это означен, что ресурс не был изменен, а веб-API должен возвратить ответ HTTP с пустым текстом и кодом состояния 304 (не изменено).

	- Если текущий ETag для запрошенных данных не соответствует тегу ETag, предоставленному в запросе, то это означен, что данные были изменены, и веб-API должен возвратить ответ HTTP с новыми данными в теле сообщения и кодом состояния 200 (ОК).

	- Если запрошенные данные больше не существуют, веб-API должен возвратить ответ HTTP с кодом состояния 404 (не найдено).

	- Клиент использует код состояния для поддержания кэша в актуальном состоянии. Если данные не изменились (код состояния 304), то объект может оставаться в кэше и клиентское приложение будет использовать эту версию объекта. Если данные изменились (код состояния 200), то кэшированный объект следует удалить и вставить новый. В случае отсутствия данных (код состояния 404) объекта следует удалить из кэша.

	> [AZURE.NOTE] Если заголовок ответа содержит заголовок Cache-Control с параметром no-store, то объект следует всегда удалять из кэша, независимо от кода состояния HTTP.

	Во фрагменте кода ниже показан метод `FindOrderByID`, расширенный для поддержки заголовка If-None-Match. Обратите внимание, если заголовок If-None-Match опущен, то извлечение всегда выполняется в заданном порядке:

	```C#
	public class OrdersController : ApiController
	{
   		...
    	[Route("api/orders/{id:int:min(0)}")]
    	[HttpGet]
    	public IHttpActionResult FindOrderById(int id)
        {
            try
            {
                // Find the matching order
    		    Order order = ...;

                // If there is no such order then return NotFound
                if (order == null)
                {
                    return NotFound();
                }

                // Generate the ETag for the order
                var hashedOrder = order.GetHashCode();
                string hashedOrderEtag = String.Format(""{0}"", hashedOrder);

                // Create the Cache-Control and ETag headers for the response
                IHttpActionResult response = null;
                var cacheControlHeader = new CacheControlHeaderValue();
                cacheControlHeader.Public = true;
                cacheControlHeader.MaxAge = new TimeSpan(0, 10, 0);
                var eTag = new EntityTagHeaderValue(hashedOrderEtag);

                // Retrieve the If-None-Match header from the request (if it exists)
                var nonMatchEtags = Request.Headers.IfNoneMatch;

                // If there is an ETag in the If-None-Match header and
                // this ETag matches that of the order just retrieved,
                // then create a Not Modified response message
                if (nonMatchEtags.Count > 0 &&
                    String.Compare(nonMatchEtags.First().Tag, hashedOrderEtag) == 0)
                {
                    response = new EmptyResultWithCaching()
                    {
                        StatusCode = HttpStatusCode.NotModified,
                        CacheControlHeader = cacheControlHeader,
                        ETag = eTag
                    };
                }
                // Otherwise create a response message that contains the order details
                else
                {
                    response = new OkResultWithCaching<Order>(order, this)
                    {
                        CacheControlHeader = cacheControlHeader,
                        ETag = eTag
                    };
                }

                return response;
            }
            catch
            {
                return InternalServerError();
            }
        }
    ...
    }
	```

	Этот пример включает дополнительный настраиваемый класс `IHttpActionResult` с именем `EmptyResultWithCaching`. Этот класс выступает в роли простой оболочки объекта `HttpResponseMessage`, которая не содержит текст ответа:

	```C#
    public class EmptyResultWithCaching : IHttpActionResult
    {
        public CacheControlHeaderValue CacheControlHeader { get; set; }
        public EntityTagHeaderValue ETag { get; set; }
        public HttpStatusCode StatusCode { get; set; }
		public Uri Location { get; set; }

        public async Task<HttpResponseMessage> ExecuteAsync(CancellationToken cancellationToken)
        {
            HttpResponseMessage response = new HttpResponseMessage(StatusCode);
            response.Headers.CacheControl = this.CacheControlHeader;
            response.Headers.ETag = this.ETag;
            response.Headers.Location = this.Location;
            return response;
        }
    }
	```

	> [AZURE.TIP] В этом примере значение ETag для данных формируется путем хэширования данных, полученных из базового источника данных. Если ETag можно вычислить другим способом, можно дополнительно оптимизировать процесс, и данные необходимо извлекать из источника данных только, если они изменились. Этот подход особенно полезен, если имеется большой объем данных или доступ к источнику данных может привести к значительным задержкам (например, если источником данных является удаленная база данных).

- **Используйте теги ETag для поддержки оптимистичного параллелизма.**

	Чтобы включить обновление ранее кэшированных данных, протокол HTTP поддерживает стратегию оптимистичного параллелизма. Если после выборки и кэширования ресурса клиентское приложение отправляет запрос PUT или DELETE для изменения или удаления ресурса, то такой запрос должен включать заголовок If-Match, который ссылается на ETag. Затем веб-API может использовать эту информацию для определения того, был ли ресурс уже изменен другим пользователем после его получения и отправки соответствующего ответа обратно в клиентское приложение, следующим образом:

	- Клиент создает запрос PUT, содержащий сведения о новом ресурсе и ETag для кэшированной в настоящее время версии ресурса, который указан в заголовке HTTP If-Match. В следующем примере показан запрос PUT, который обновляет заказ:

	```HTTP
	PUT http://adventure-works.com/orders/1 HTTP/1.1
	If-None-Match: "2282343857"
	Content-Type: application/x-www-form-urlencoded
	...
	Date: Fri, 12 Sep 2014 09:18:37 GMT
	Content-Length: ...
	productID=3&quantity=5&orderValue=250
	```

	- Операция PUT в веб-API получает текущий ETag для запрошенных данных (заказ 1 в примере выше) и сравнивает его со значением заголовка If-Match.

	- Если текущий ETag для запрошенных данных соответствует ETag, предоставленному в запросе, то это означает, что ресурс не был изменен и веб-API следует выполнить обновление и возвратить сообщение с кодом состояния HTTP 204 (нет содержимого) при успешном выполнении. Ответ может включать заголовки Cache-Control и ETag для обновленной версии ресурса. Ответ всегда должен содержать заголовок Location, указывающий URI обновленного ресурса.

	- Если текущий ETag для запрошенных данных не соответствует ETag, предоставленному в запросе, то это означает, что данные были изменены другим пользователем, поскольку была выполнена выборка, и веб-API должен вернуть ответ HTTP с пустым текстом и кодом состояния 412 (необходимое условие не выполнено).

	- Если ресурс, который требуется обновить, больше не существует, веб-API должен возвратить ответ HTTP с кодом состояния 404 (не найдено).

	- Клиент использует код состояния и заголовки ответа для поддержания кэша в актуальном состоянии. Если данные были обновлены (код состояния 204), то объект может оставаться в кэше (при условии, что в заголовке Cache-Control отсутствует параметр no-store), однако ETag следует обновить. Если данные были изменены другим пользователем (код состояния 412) или вообще не найдены (код состояния 404), то кэшированный объект следует удалить.

	В следующем примере кода показана реализация операции PUT для контроллера Orders:

	```C#
	public class OrdersController : ApiController
	{
   		...
    	[HttpPut]
    	[Route("api/orders/{id:int}")]
    	        public IHttpActionResult UpdateExistingOrder(int id, DTOOrder order)
        {
            try
            {
                var baseUri = Constants.GetUriFromConfig();
                var orderToUpdate = this.ordersRepository.GetOrder(id);
                if (orderToUpdate == null)
                {
                    return NotFound();
                }

                var hashedOrder = orderToUpdate.GetHashCode();
                string hashedOrderEtag = String.Format(""{0}"", hashedOrder);

                // Retrieve the If-Match header from the request (if it exists)
                var matchEtags = Request.Headers.IfMatch;

                // If there is an Etag in the If-Match header and
                // this etag matches that of the order just retrieved,
                // or if there is no etag, then update the Order
                if (((matchEtags.Count > 0 &&
                     String.Compare(matchEtags.First().Tag, hashedOrderEtag) == 0)) ||
                     matchEtags.Count == 0)
                {
                    // Modify the order
                    orderToUpdate.OrderValue = order.OrderValue;
                    orderToUpdate.ProductID = order.ProductID;
                    orderToUpdate.Quantity = order.Quantity;

                    // Save the order back to the data store
                    // ...

                    // Create the No Content response with Cache-Control, ETag, and Location headers
                    var cacheControlHeader = new CacheControlHeaderValue();
                    cacheControlHeader.Private = true;
                    cacheControlHeader.MaxAge = new TimeSpan(0, 10, 0);

                    hashedOrder = order.GetHashCode();
                    hashedOrderEtag = String.Format(""{0}"", hashedOrder);
                    var eTag = new EntityTagHeaderValue(hashedOrderEtag);

                    var location = new Uri(string.Format("{0}/{1}/{2}", baseUri, Constants.ORDERS, id));
                    var response = new EmptyResultWithCaching()
                    {
                        StatusCode = HttpStatusCode.NoContent,
                        CacheControlHeader = cacheControlHeader,
                        ETag = eTag,
                        Location = location
                    };

                    return response;
                }

                // Otherwise return a Precondition Failed response
                return StatusCode(HttpStatusCode.PreconditionFailed);
            }
            catch
            {
                return InternalServerError();
            }
        }
        ...
    }
	```

	> [AZURE.TIP] Использование заголовка If-Match вовсе необязательно, и если он не указан, веб-API будет всегда пытаться обновить указанный заказ, возможно, путем машинальной перезаписи обновления, внесенного другим пользователем. Чтобы избежать проблем, связанных с потерей обновлений, всегда указывайте заголовок If-Match.

<a name="considerations-for-handling-large"></a>
## Рекомендации относительно обработки больших запросов и ответов

Возможны случаи, когда клиентское приложение должно выдавать запросы, в которых отправляется или получается большой объем данных (несколько мегабайт или даже больше). Ожидание завершения передачи такого объема данных может привести к тому, что клиентское приложение перестанет отвечать на запросы. Если необходимо обрабатывать запросы, включающие значительные объемы данных, обязательно учитывайте указанные ниже моменты.

- **Оптимизируйте запросы и ответы, включающие большие объекты.**

	Некоторые ресурсы могут быть большими объектами или включать большие поля (например, изображения или другие типы двоичных данных). Веб-API должен поддерживать потоковую передачу для оптимизации отправки и загрузки этих ресурсов.

	Протокол HTTP обеспечивает механизм поблочного кодирования для потоковой передачи больших объектов данных обратно клиенту. Когда клиент отправляет запрос HTTP GET для большого объекта, веб-API может отправить ответ обратно в поэтапные _фрагменты_ по протоколу HTTP. Длина данных в ответе может быть изначально неизвестна (она может быть сгенерирована), поэтому серверу, на котором размещен веб-API, следует отправить ответное сообщение с каждым фрагментом, указывающим заголовок Transfer-Encoding: Chunked, а не заголовок Content-Length. В свою очередь, клиентское приложение может получать каждый блок для создания ответа. Когда сервер отправляет обратно последний фрагмент данных с нулевым размером, передача данных завершается. Реализовать фрагментацию в веб-API ASP.NET можно с помощью класса `PushStreamContent`.

	В следующем примере показана операция, которая отвечает на запросы HTTP GET для изображений продуктов:

	```C#
	public class ProductImagesController : ApiController
	{
    	...
    	[HttpGet]
        [Route("productimages/{id:int}")]
        public IHttpActionResult Get(int id)
        {
            try
            {
                var container = ConnectToBlobContainer(Constants.PRODUCTIMAGESCONTAINERNAME);

                if (!BlobExists(container, string.Format("image{0}.jpg", id)))
                {
                    return NotFound();
                }
                else
                {
                    return new FileDownloadResult()
                    {
                        Container = container,
                        ImageId = id
                    };
                }
            }
            catch
            {
                return InternalServerError();
            }
        }
    	...
	}
	```

	В этом примере `ConnectBlobToContainer` является вспомогательным методом, который подключается к указанному контейнеру (имя не указано) в хранилище BLOB-объектов Azure. `BlobExists` — это другой вспомогательный метод, возвращающий логическое значение, указывающее, существует ли в контейнере хранилища больших двоичных объектов BLOB-объект с указанным именем.

	Каждый продукт имеет собственный образ в хранилище BLOB-объектов. Класс `FileDownloadResult` является пользовательским классом `IHttpActionResult`, который использует объект `PushStreamContent` для чтения данных образа из соответствующего большого двоичного объекта и асинхронно передает их в виде содержимого ответного сообщения:

	```C#
	public class FileDownloadResult : IHttpActionResult
    {
        public CloudBlobContainer Container { get; set; }
        public int ImageId { get; set; }

        public async Task<HttpResponseMessage> ExecuteAsync(CancellationToken cancellationToken)
        {
            var response = new HttpResponseMessage();
            response.Content = new PushStreamContent(async (outputStream, _, __) =>
            {
                try
                {
                    CloudBlockBlob blockBlob = Container.GetBlockBlobReference(String.Format("image{0}.jpg", ImageId));
                    await blockBlob.DownloadToStreamAsync(outputStream);
                }
                finally
                {
                    outputStream.Close();
                }
            });

            response.StatusCode = HttpStatusCode.OK;
            response.Content.Headers.ContentType = new MediaTypeHeaderValue("image/jpeg");
            return response;
        }
    }
	```

	Для отправки операций можно также применить потоковую передачу, если клиенту требуется РАЗМЕСТИТЬ новый ресурс, включающий большой объект. В следующем примере показан метод Post для контроллера `ProductImages`. Этот метод позволяет клиенту передавать новое изображение продукта:

	```C#
	public class ProductImagesController : ApiController
	{
    	...
        [HttpPost]
        [Route("productimages")]
        public async Task<IHttpActionResult> Post()
        {
            try
            {
                if (!Request.Content.Headers.ContentType.MediaType.Equals("image/jpeg"))
                {
                    return StatusCode(HttpStatusCode.UnsupportedMediaType);
                }
                else
                {
                    var id = new Random().Next(); // Use a random int as the key for the new resource. Should probably check that this key has not already been used
                    var container = ConnectToBlobContainer(Constants.PRODUCTIMAGESCONTAINERNAME);
                    return new FileUploadResult()
                    {
                        Container = container,
                        ImageId = id,
                        Request = Request
                    };
                }
            }
            catch
            {
                return InternalServerError();
            }
        }
    	...
	}
	```

	В этом коде используется другой настраиваемый класс `IHttpActionResult` с именем `FileUploadResult`. Этот класс содержит логику для асинхронной передачи данных:

	```C#
    public class FileUploadResult : IHttpActionResult
    {
        public CloudBlobContainer Container { get; set; }
        public int ImageId { get; set; }
        public HttpRequestMessage Request { get; set; }

        public async Task<HttpResponseMessage> ExecuteAsync(CancellationToken cancellationToken)
        {
            var response = new HttpResponseMessage();
            CloudBlockBlob blockBlob = Container.GetBlockBlobReference(String.Format("image{0}.jpg", ImageId));
            await blockBlob.UploadFromStreamAsync(await Request.Content.ReadAsStreamAsync());
            var baseUri = string.Format("{0}://{1}:{2}", Request.RequestUri.Scheme, Request.RequestUri.Host, Request.RequestUri.Port);
            response.Headers.Location = new Uri(string.Format("{0}/productimages/{1}", baseUri, ImageId));
            response.StatusCode = HttpStatusCode.OK;
            return response;
        }
    }
	```

	> [AZURE.TIP] Объем данных, который можно загрузить в веб-службу, не ограничивается потоковой передачей, и один запрос предположительно может привести к передаче большого объекта, который потребляет много ресурсов. Если в процессе потоковой передачи веб-API определяет, что объем данных в запросе превысил некоторые допустимые ограничения, можно отменить операцию и вернуть ответное сообщение с кодом состояния 413 (слишком большой объект запроса).

	Можно свести к минимуму размер больших объектов, передаваемых по сети, с помощью сжатия HTTP. Такой подход позволяет сократить объем сетевого трафика и связанные с этим сетевые задержки, но для этого требуется дополнительная обработка на стороне клиента и на сервере, где размещен веб-API. Например, клиентское приложение, которое ожидает получить сжатые данные, может включать заголовок запроса Accept-Encoding: gzip (также могут быть указаны другие алгоритмы сжатия данных). Если сервер поддерживает сжатие, он должен предоставлять в теле сообщения ответ с содержимым, хранящимся в формате GZIP, и заголовок ответа Content-Encoding: gzip.

	> [AZURE.TIP] Можно объединять закодированное сжатие с потоковой передачей; перед потоковой передачей данные сначала необходимо сжать, а затем указать в заголовках сообщений кодировку содержимого GZIP и поблочное кодирование. Кроме того, некоторые веб-серверы (такие как Internet Information Server) можно настроить на автоматическое сжатие HTTP-ответов, независимо от того, сжимает веб-API данные или нет.

- **Реализуйте частичные ответы для клиентов, которые не поддерживают асинхронные операции.**

	В качестве альтернативы асинхронной потоковой передаче клиентское приложение может явно запросить данные для больших объектов в виде фрагментов, которые также называются частичными ответами. Клиентское приложение отправляет запрос HTTP HEAD для получения сведений об объекте. Если веб-API поддерживает частичные ответы, ему следует отвечать на запрос HEAD ответным сообщением, содержащим заголовок Accept-Ranges и заголовок Content-Length, который указывает общий размер объекта, однако тело сообщения должно быть пустым. Клиентское приложение может использовать эти сведения для создания ряда запросов GET, которые указывают диапазон байтов для получения. Веб-API должен вернуть ответное сообщение с кодом состояния HTTP 206 (частичное содержимое), заголовок Content-Length, который указывает фактический объем данных, включенных в текст ответного сообщения, и заголовок Content-Range, который указывает, какую часть объекта (4000 до 8000 байт) представляют эти данные.

	Более подробно запросы HTTP HEAD и частичные ответы описаны в руководстве по проектированию API.

- **Избегайте отправки в клиентские приложения ненужных сообщений о состоянии продолжения.**

	Клиентское приложение, которое собирается передать на сервер большой объем данных, может сначала определить, желает ли сервер фактически принять такой запрос. Перед отправкой данных клиентское приложение может отправить HTTP-запрос с заголовком Expect: 100-Continue, заголовком Content-Length, который указывает размер данных, но с пустым текстом сообщения. Если сервер готов обработать запрос, он должен отправить ответное сообщение с кодом состояния HTTP 100 (продолжить). Клиентское приложение затем может продолжить выполнение операции и отправить полный запрос, включая данные в теле сообщения.

	Если служба размещается с помощью служб IIS, драйвер HTTP.sys автоматически обнаруживает и обрабатывает заголовки Expect: 100-Continue перед передачей запросов в веб-приложение. Это означает, что существует небольшая вероятность увидеть эти заголовки в коде приложения, и можно предположить, что IIS уже отсортировали любые сообщения, которые они посчитали неподходящими или слишком большими.

	Если вы создаете клиентские приложения с помощью .NET Framework, то все сообщения POST и PUT по умолчанию сначала будут отправлять сообщения с заголовком Expect: 100-Continue. Так же, как и на стороне сервера, этот процесс обрабатывается прозрачно платформой .NET Framework. Однако этот процесс приводит к тому, что каждый запрос POST и PUT проходит 2 цикла обработки на сервере, даже если запрос небольшой. Если приложение не отправляет запросы с большими объемами данных, можно отключить эту функцию с помощью класса `ServicePointManager` для создания объектов `ServicePoint` в клиентском приложении. Объект `ServicePoint` обрабатывает соединение, которое клиент устанавливает с сервером, на основе схемы и фрагментов узла из кодов URI, которые определяют ресурсы на сервере. Затем можно присвоить свойству `Expect100Continue` объекта `ServicePoint` значение false. Все последующие запросы POST и PUT, сделанные клиентом через URI, который соответствует схеме и фрагментам узла объекта `ServicePoint`, будут отправляться без заголовков Expect: 100-Continue. В примере кода ниже показано, как настроить объект `ServicePoint`, который настраивает все запросы, отправленные на URI со схемой `http` и узлом `www.contoso.com`.

	```C#
	Uri uri = new Uri("http://www.contoso.com/");
	ServicePoint sp = ServicePointManager.FindServicePoint(uri);
	sp.Expect100Continue = false;
	```

	Можно также задать статическое свойство `Expect100Continue` класса `ServicePointManager` и указать для этого свойства значение по умолчанию для всех создаваемых в последующем объектов `ServicePoint`. Дополнительные сведения см. на странице [Класс ServicePoint](https://msdn.microsoft.com/library/system.net.servicepoint.aspx) на веб-сайте Майкрософт.

- **Реализуйте поддержку разбиения запросов, которые могут возвращать большое количество объектов, на страницы.**

	Если коллекция содержит большое количество ресурсов, отправка запроса GET на соответствующий URI может привести значительной обработки на сервере, на котором размещен веб-API, что влияет на производительность и создает значительный объем сетевого трафика. В свою очередь это приводит к увеличению времени задержки.

	В таких случаях веб-API должен поддерживать строки запроса, которые позволяют клиентскому приложению уточнять запросы или делать выборку данных в виде более управляемых, отдельных блоках (или страницах). Платформа веб-API ASP.NET выполняет синтаксический анализ строк запросов и разделяет их на пары "параметр-значение", которые передаются в соответствующий метод, руководствуясь правилами маршрутизации, описанными выше. Метод должен быть реализован таким образом, чтобы принимать эти параметры, используя те же имена, указанные в строке запроса. Кроме того, эти параметры должны быть необязательными (в случае, если клиент опустит в запросе строку запроса) и они должны иметь существенные стандартные значения. В примере кода ниже показан метод `GetAllOrders` контроллера `Orders`. Этот метод получает сведения о заказах. В случае отсутствия ограничений он может возвратить большой объем данных. Параметры `limit` и `offset` предназначены для сокращения объема данных до небольшого подмножества, в этом случае — только первые 10 заказов по умолчанию:

	```C#
	public class OrdersController : ApiController
	{
    	...
    	[Route("api/orders")]
    	[HttpGet]
    	public IEnumerable<Order> GetAllOrders(int limit=10, int offset=0)
    	{
    	    // Find the number of orders specified by the limit parameter
    	    // starting with the order specified by the offset parameter
    	    var orders = ...
    	    return orders;
    	}
    	...
	}
	```

	Клиентское приложение может выдать запрос для получения 30 заказов, начиная со смещения 50, с помощью URI \__http://www.adventure-works.com/api/orders?limit=30&offset=50_.

	> [AZURE.TIP] Избегайте предоставления клиентским приложениям возможности задавать строки запроса, которые приводят к созданию URI длиной более 2000 символов. Многие веб-клиенты и серверы не в состоянии обработать URI такой длины.

<a name="considerations-for-maintaining-responsiveness"></a>
## Рекомендации относительно обеспечения доступности, масштабируемости и скорости реагирования

Один и тот же веб-API может использоваться несколькими клиентскими приложениями, работающими в любой точек мира. Очень важно убедиться, что веб-API реализован так, что обеспечивает одинаковую скорость реагирования при интенсивной нагрузке, масштабируемость для поддержки непостоянной рабочей нагрузки, а также гарантирует доступность для клиентов, выполняющих критически важные бизнес-операции. При определении того, как обеспечить соответствие этим требованиям, необходимо учитывать указанные ниже моменты.

- **Обеспечьте поддержку асинхронных операций для длительных запросов.**

	Запрос, обработка которого может занять много времени, следует выполнять без блокирования клиента, отправившего этот запрос. Веб-API может выполнить некоторую начальную проверку запроса, инициировать отдельную задачу для выполнения работы, а затем вернуть ответное сообщение с кодом HTTP 202 (принято). Задача может выполняться асинхронно в рамках обработки веб-API, или же она может быть передана веб-заданию Azure (если веб-API размещен на веб-сайте Azure) или рабочей роли (если веб-API реализован в виде облачной службы Azure).

	> [AZURE.NOTE] Дополнительные сведения об использовании веб-заданий с веб-сайта Azure см. на странице [Использование веб-заданий для выполнения фоновых задач на веб-сайтах Microsoft Azure](web-sites-create-web-jobs.md) на веб-сайте Майкрософт.

	В веб-API также должен быть реализован механизм для возвращения результатов обработки обратно в клиентское приложение. Добиться этого можно за счет предоставления механизма опроса для клиентских приложений с целью периодически запрашивать у них сведения о завершении обработки и получить результат. Либо веб-API можно настроить на отправку уведомлений по завершении операции.

	Реализовать простой механизм опроса можно путем предоставления URI _polling_, который выступает в качестве виртуального ресурса, используя следующий подход:

	1. Клиентское приложение отправляет первоначальный запрос в веб-API.

	2. Веб-API сохраняет сведения о запросе в таблице, находящейся в хранилище таблиц или в кэше Microsoft Azure, и генерирует уникальный ключ для этой записи, возможно, в виде идентификатора GUID.

	3. Веб-API инициирует обработку в рамках отдельной задачи. Веб-API записывает состояние задачи в таблице как _Running_.

	4. Веб-API возвращает ответное сообщение с кодом состояния HTTP 202 (принято) и идентификатором GUID записи в таблице в теле сообщения.

	5. По завершении задачи веб-API сохраняет результаты в таблице и задает для задачи состояние _Complete_. Обратите внимание, если задача завершается сбоем, веб-API может сохранить сведения об ошибке и установить состояние _Failed_.

	6. Пока выполняется задача, клиент может продолжать выполнять собственную обработку. Он может периодически отправлять запрос к URI _/polling/{guid}_ где _{guid}_ — это идентификатор GUID, возвращенный веб-API в ответном сообщении с кодом 202.

	7. Веб-API по универсальному коду ресурса (URI) _/polling/{guid}_ запрашивает состояние соответствующей задачи в таблице и возвращает ответное сообщение с кодом состояния HTTP 200 (ОК), содержащее это состояние (_Running_, _Complete_ или _Failed_). Если задача завершена успешно или с ошибкой, ответное сообщение также может включать результаты обработки или любые доступные сведения о причине сбоя.

	Если вы предпочитаете реализовать уведомлений, то вам доступны следующие варианты:

	- Использование центра уведомлений Azure для отправки асинхронных ответов клиентским приложениям. Дополнительные сведения представлены на странице [Уведомление пользователей посредством центров уведомлений Azure](notification-hubs-aspnet-backend-windows-dotnet-notify-users.md) на веб-сайте Майкрософт.

	- Использование модели Comet для сохранения постоянного сетевого соединения между клиентом и сервером, на котором размещен веб-API, и использование этого подключения для отправки сообщения от сервера обратно клиенту. В статье [Создание простого Comet-приложения в Microsoft .NET Framework](https://msdn.microsoft.com/magazine/jj891053.aspx) в журнале MSDN описывается пример решения.

	- Использование SignalR для передачи данных в режиме реального времени с веб-сервера клиенту через постоянное сетевое подключение. SignalR доступен для веб-приложений ASP.NET в виде пакета NuGet. Дополнительные сведения см.на веб-сайте [ASP.NET SignalR](http://signalr.net/).

	> [AZURE.NOTE] И Comet, и SignalR используют постоянные сетевые подключения между веб-сервером и клиентским приложением. Это может влиять на масштабируемость, поскольку большому количеству клиентов может потребоваться одинаково большое число одновременных подключений.

- **Обеспечьте обработку каждого запроса без учета состояния.**

	Каждый запрос следует считать атомарным. Должны отсутствовать зависимости между одним запросом от клиентского приложения и всеми последующими запросами, отправленными от того же клиента. Такой подход способствует масштабируемости; экземпляры веб-службы можно развернуть на нескольких серверах. Клиентские запросы можно направить в любой из этих экземпляров, и результаты при этом всегда должны быть одинаковыми. По этой же причине повышается и доступность; в случае сбоя веб-сервера запросы можно передать в другой экземпляр (с помощью диспетчера трафика Azure), пока сервер перезапускается, что не оказывает никакого влияния на клиентские приложения.

- **Отслеживайте клиентов и реализуйте регулирование, чтобы снизить вероятность DOS-атак.**

	Если определенный клиент выполняет большое количество запросов в течение заданного периода времени, он может монополизировать службу и повлиять на производительность других клиентов. Чтобы устранить эту проблему, веб-API может отслеживать вызовы от клиентских приложений с помощью отслеживания IP-адреса для всех входящих запросов или путем регистрации в журнале каждой операции доступа с проверкой подлинности. Эти сведения можно использовать для ограничения доступа к ресурсам. Если клиент превышает заданный предел, веб-API может вернуть ответное сообщение с состоянием 503 (служба недоступна) и включить заголовок Retry-After, указывающий, когда клиент сможет отправить следующий запрос, который не будет отклонен. Эта стратегия помогает снизить вероятность атак типа "отказ в обслуживании" от ряда клиентов, замедляющих работу системы.

- **Внимательно управляйте постоянными HTTP-подключениями.**

	Протокол HTTP поддерживает постоянные HTTP-подключения, где они доступны. В спецификации HTTP 1.0 был добавлен заголовок Connection:Keep-Alive, который позволяет клиентскому приложению указать серверу, что последний может использовать то же подключение для отправки последующих запросов, вместо того чтобы открывать новые сеансы. Подключение закрывается автоматически, если клиент не использовал подключение повторно в течение промежутка времени, определенного узлом. Это поведение применяется по умолчанию в HTTP 1.1 и используется службами Azure, поэтому нет необходимости включать в сообщения заголовки Keep-Alive.

	Постоянно открытое подключение может помочь повысить скорость реагирования за счет снижения задержки и перегрузки сети, однако это может помешать масштабируемости, поскольку остается больше открытых подключений, чем требуется, а это ограничивает возможность параллельного подключения других клиентов. Это также может повлиять на время работы от батареи, если клиентское приложение выполняется на мобильном устройстве; если приложение выполняет лишь редкие запросы к серверу, постоянно открытое подключение может привести к более быстрому разряду батареи. Для указания того, чтобы подключение по HTTP 1.1 не было постоянным, клиент может включить в сообщения заголовок Connection:Close. Это позволит переопределить поведение по умолчанию. Аналогично, если сервер обрабатывает большое количество клиентов, он может включить в ответные сообщения заголовок Connection:Close, что позволяет закрыть подключение и сэкономить ресурсы сервера.

	> [AZURE.NOTE] Постоянные HTTP-подключения абсолютно необязательны. Они призваны уменьшить нагрузку на сеть, связанную с многократным установлением канала связи. Ни веб-API, ни клиентское приложение не должно зависеть от постоянного HTTP-подключения, которое доступно. Не используйте постоянные HTTP-подключения для реализации систем уведомлений на базе Comet; вместо этого рекомендуется использовать сокеты (или соединения WebSocket, если они доступны) на уровне TCP. Наконец, обратите внимание, что возможности использования заголовков Keep-Alive ограничены, если клиентское приложение подключается к серверу через прокси-сервер; постоянным в этом случае будет только соединение между клиентом и прокси-сервером.

## Рекомендации относительно публикации веб-API и управления им

Чтобы сделать веб-API доступным для клиентских приложений, веб-API следует развернуть в среде узла. Такой средой обычно является веб-сервер, хотя это может быть и другой тип хост-процесса. При публикации веб-API следует учитывать следующие моменты.

- Все запросы должны пройти проверку подлинности и авторизацию, а также необходимо обеспечить соответствующий уровень контроля доступа.
- В отношении коммерческого веб-API могут применяться различные гарантии качества, касающиеся времени ответа. Очень важно убедиться, что среда размещения является масштабируемой, если со временем нагрузка может значительно меняться.
- Может потребоваться отслеживать запросы в финансовых целях.
- Может потребоваться направлять поток трафика веб-API, а также реализовать регулирование для определенных клиентов, исчерпавших свои квоты.
- Согласно нормативным требованиям может оказаться обязательным вести журнал и аудит всех запросов и ответов.
- Чтобы обеспечить доступность, может потребоваться отслеживать работоспособностью сервера, на котором размещен веб-API, и при необходимости перезапускать сервер.

Полезно иметь возможность отделять эти проблемы от технических проблем, касающихся реализации веб-API. По этой причине рассмотрите возможность создания конструктивного шаблона [façade](http://en.wikipedia.org/wiki/Facade_pattern), выполняющегося в виде отдельного процесса и направляющего запросы в веб-API. façade может предоставлять операции управления и пересылать проверенные запросы в веб-API. С помощью façade также можно реализовать множество функциональных преимуществ включая указанные ниже.

- Использование façade в качестве точки интеграции для нескольких веб-API.
- Преобразование сообщений и протоколов связи для клиентов, созданных с использованием различных технологий.
- Кэширование запросов и ответов для снижения нагрузки на сервер, на котором размещен веб-API.

## Рекомендации относительно тестирования веб-API
Веб-API следует тестировать так же тщательно, как и любой другой компонент программного обеспечения. Рекомендуется создать модульные тесты для проверки работы каждой операции, как и в случае с любым другим типом приложений. Дополнительные сведения см. на странице [Проверка кода при помощи модульных тестов](https://msdn.microsoft.com/library/dd264975.aspx) на веб-сайте Майкрософт.

> [AZURE.NOTE] Пример веб-API, представленный в этом руководстве, содержит тестовый проект, демонстрирующий, как выполнять модульное тестирование выбранных операций.

Характер веб-API привносит свои определенные требования к проверке правильности его работы. Следует уделять особое внимание указанным ниже моментам.

- Проверьте все маршруты и убедитесь, что они вызывают все необходимые операции. Особое внимание следует уделять коду состояния HTTP 405 (метод запрещен), который может быть неожиданно возвращен, поскольку это может означать несоответствие маршрута и методов HTTP (GET, POST, PUT, DELETE), которые можно передавать по этому маршруту.

	Отправляйте HTTP-запросы по маршрутам, которые их не поддерживают (например, отправьте запрос POST к определенному ресурсу [запросы POST должны отправляться только к коллекции ресурсов]). В этих случаях единственным допустимым ответа _должен быть_ код состояния 405 (запрещено).

- Убедитесь, что все маршруты защищены надлежащим образом и используют необходимые процедуры проверки подлинности и авторизации.

	> [AZURE.NOTE] Некоторые аспекты безопасности, такие как проверка подлинности пользователя, вероятнее всего реализуются средой размещения, а не веб-API, однако вам по-прежнему необходимо включить в процесс развертывания тесты безопасности.

- Проверьте обработку исключений, выполняемую каждой операцией, и убедитесь, что в клиентское приложение обратно передается соответствующий и значимый ответ HTTP.
- Убедитесь, что запросы и ответные сообщения имеют правильный формат. Например, если запрос HTTP POST содержит данные для нового ресурса в формате x-www-form-urlencoded, убедитесь, что соответствующая операция правильно анализирует данные, создает ресурсы и возвращает ответ, содержащий сведения о новом ресурсе, включая правильный заголовок Location.
- Проверяйте все ссылки и URI в ответных сообщениях. Например, в сообщении HTTP POST должен возвращаться URI нового созданного ресурса. Все ссылки HATEOAS должно быть действительными.

	> [AZURE.IMPORTANT] При публикации веб-API через службу управления API эти URI должны отражать URL-адрес службы управления, а не веб-сервера, на котором размещен веб-API.

- Убедитесь, что каждая операция возвращает правильные коды состояния для различных сочетаний входных данных. Например:
	- Если запрос выполнен успешно, она должна возвращать код состояния 200 (ОК)
	- Если ресурс не найден, операция должна возвращать код состояния HTTP 404 (не найдено).
	- Если клиент отправляет запрос, который успешно удаляет ресурс, код состояния должен быть 204 (нет содержимого).
	- Если клиент отправляет запрос, который создает ресурс, код состояния должен быть 201 (создано).

Следует внимательно отслеживать неожиданные ответы с кодами состояния в диапазоне 5xx. Обычно эти сообщения отправляются сервером размещения для указания того, что ему не удалось выполнить допустимый запрос.

- Проверьте различные сочетания заголовков запроса, которые клиентское приложение может указывать, и убедитесь, что веб-API возвращает в ответных сообщениях ожидаемые данные.

- Проверьте строки запроса. Если операция может принимать необязательные параметры (такие как запросы разбивки на страницы), протестируйте различные комбинации параметров и порядок их указания.

- Убедитесь, что асинхронные операции завершаются успешно. Если веб-API поддерживает потоковую передачу запросов, которые возвращают большие двоичные объекты (например, видео или аудио), убедитесь, что клиентские запросы не блокируются во время потоковой передачи данных. Если веб-API реализует опрос для длительных операций изменения данных, убедитесь, что операций надлежащим образом сообщают о своем состоянии во время выполнения.

Необходимо также создать и запустить тесты производительности для проверки того, что веб-API работает удовлетворительно в принудительном режиме. С помощью Visual Studio Ultimate можно создать проект нагрузочного теста и веб-теста производительности. Дополнительные сведения см. на странице [Запуск тестов производительности в приложении](https://msdn.microsoft.com/library/dn250793.aspx) на веб-сайте Майкрософт.

## Публикация и управление веб-API с помощью службы управления API Azure

Azure предоставляет [службу управления API](https://azure.microsoft.com/documentation/services/api-management/), которую можно использовать для публикации и управления веб-API. С помощью этого средства можно создать службу, которая выступает в роли оболочки (façade) для одного или нескольких веб-API. Сама служба представляет собой масштабируемую веб-службу, которую можно создать и настроить с помощью портала управления Azure. Эту службу можно использовать для публикации и управления веб-API, как указано ниже.

1. Разверните веб-API для веб-сайта, облачной службы Azure или виртуальной машины Azure.

2. Подключите службу управления API к веб-API. Запросы, отправленные на URL-адрес API управления, сопоставляются с URI в веб-API. Эта же служба управления API может направить запросы в несколько веб-API. Это позволяет объединить несколько веб-API в рамках одной службы управления. Аналогичным образом, на один и тот же веб-API можно ссылаться из нескольких служб управления API, если необходимо ограничить или разделить функциональные возможности, доступные для различных приложений.

	> [AZURE.NOTE] URI в ссылках HATEOAS, созданных в ответе на запросы HTTP GET, должны ссылаться на URL-адрес службы управления API, а не на веб-сервер, на котором размещен веб-API.

3. Для каждого веб-API укажите операции HTTP, предоставляемые веб-API вместе с любыми дополнительными параметрами, которые операция может принимать в качестве входных. Можно также указать, следует ли службе управления API кэшировать ответ, полученный от веб-API, для оптимизации повторных запросов тех же данных. Запишите сведения об ответах HTTP, которые может создавать каждая операция. Эта информация используется для создания документации для разработчиков, поэтому важно, чтобы она была точной и полной.

	Операции можно задать либо вручную с помощью мастеров, имеющихся на портале управления Azure, либо импортировать их из файла, содержащего определения в формате WADL или Swagger.

4. Настройте параметры безопасности для взаимодействия службы управления API с веб-сервером, на котором размещен веб-API. Служба управления API в настоящее время поддерживает обычную проверку подлинности и взаимную проверку подлинности с использованием сертификатов, а также проверку подлинности пользователей OAuth 2.0.

5. Создайте продукт. Продукт — это единица публикации; можно добавить веб-API, ранее подключенные вами к службе управления для продукта. После публикации продукта веб-API становятся доступными для разработчиков.

	> [AZURE.NOTE] Перед публикацией продукта можно также определить группы пользователей, которые могут получить доступ к продукту, и добавить пользователей в эти группы. Это позволит вам получить контроль над разработчиками и приложениями, использующими веб-API. Если веб-API необходимо утвердить, то прежде чем получить доступ к нему разработчик должен отправить запрос администратору продукта. Администратор может предоставить или запретить доступ для разработчика. В случае если обстоятельства изменились, можно также заблокировать существующих разработчиков.

6.	Настройте политики для каждого веб-API. Политики управляют такими аспектами, как выполнение междоменных вызовов, способ проверки подлинности клиентов, выполнение прозрачного преобразования между форматами данных XML и JSON, ограничение вызовов из заданного диапазона IP-адресов, квоты на использование, а также ограничение скорости вызова. Политики могут применяться глобально для всего продукта, для одного веб-API в продукте или для отдельных операций в веб-API.

Подробные сведения о выполнении этих задач см. на странице [Управление API](https://azure.microsoft.com/services/api-management/) на веб-сайте Майкрософт. Службы управления API Azure также предоставляют собственный интерфейс REST, что позволяет создавать настраиваемый интерфейс для упрощения процесса настройки веб-API. Дополнительные сведения см. на странице [Справочник по API REST управления API Azure](https://msdn.microsoft.com/library/azure/dn776326.aspx) на веб-сайте Майкрософт.

> [AZURE.TIP] Azure предоставляет диспетчер трафика Azure, который позволяет реализовать отказоустойчивость и балансировку нагрузки, а также уменьшить задержку между несколькими экземплярами веб-сайта, размещенного в различных географических регионах. Диспетчер трафика Azure можно использовать в сочетании со службой управления API; последняя может направлять запросы в экземпляры веб-сайта через диспетчер трафика Azure. Дополнительные сведения см. на странице [О методах балансировки нагрузки диспетчера трафика](../traffic-manager/traffic-manager-load-balancing-methods.md) на веб-сайте Майкрософт.

> В этой структуре при использовании пользовательских DNS-имен для веб-сайтов необходимо настроить соответствующую запись CNAME для каждого веб-сайта, которая должна указывать на DNS-имя веб-сайта диспетчера трафика Azure.

## Поддержка для разработчиков, создающих клиентские приложения
Для разработчиков, занимающихся созданием клиентских приложений, обычно требуются сведения о том, как получить доступ к веб-API, и документация, касающаяся параметров, типов данных, возвращаемых типов и кодов возврата, которые описывают различные запросы и ответы между веб-службой и клиентским приложением.

### Документирование операции REST для веб-API
В состав службы управления API Azure входит портал для разработчиков, на котором представлены описания операций REST, предоставляемых веб-API. Если продукт был опубликован, он отображается на этом портале. Разработчики могут использовать этот портал для регистрации доступа; после чего администратор может утвердить или отклонить запрос. Если разработчик утвержден, ему назначается ключ подписки, который используется для проверки подлинности вызовов из разрабатываемых им клиентских приложений. Этот ключ необходимо предоставлять при каждом вызове веб-API, в противном случае вызов будет отклонен.

На этом портале также предоставлено следующее:

- документация по продукту, список операций, которые он предоставляет, необходимые параметры и разные ответы, которые могут быть возвращены; обратите внимание, что эта информация формируется из сведений, указанных на шаге 3 в списке в разделе [Публикация и управление веб-API с помощью службы управления API Azure](#publishing-a-web-API);

- фрагменты кода, которые показывают, как вызывать операции на нескольких языках программирования, включая JavaScript, C#, Java, Ruby, Python и PHP;

- консоль разработчика, с помощью которой разработчики могут отправлять запрос HTTP для проверки каждой операции в продукте и просмотра результатов;

- страница, где разработчик может сообщить об обнаруженных ошибках и проблемах.

На портале управления Azure можно настроить портал разработчика: можно изменить стиль оформления и макет с учетом фирменной символики организации.

### Реализация клиентского пакета SDK
Для создания клиентского приложения, которое вызывает запросы REST на доступ к веб-API, требуется значительный объем кода для написания каждого запроса и форматирования его соответствующим образом, отправки запроса на сервер, на котором размещена веб-службы, синтаксического анализа ответа, вычисляющего то, успешно ли был выполнен запрос или завершился сбоем, а также извлечения всех возвращенных данных. Чтобы исключить в клиентском приложении эти проблемы, можно предоставить пакет SDK, который служит оболочкой для интерфейса REST и абстрагирует эти низкоуровневые элементы внутри более функционального набора методов. Клиентское приложение использует эти методы, которые прозрачно преобразовывают вызовы в запросы REST, а ответы — обратно в возвращаемые методом значения. Это распространенный метод, реализуемый многими службами, включая пакет Azure SDK.

Создание клиентского пакета SDK — довольно сложная задача, поскольку его следует согласованно и тщательно реализовывать и тестировать. Однако большая часть этого процесса может выполняться механически, а многие поставщики предлагают средства, позволяющие автоматизировать выполнение многих из этих задач.

## Наблюдение за веб-API

В зависимости от способа публикации и развертывания веб-API можно отслеживать веб-API напрямую или организовать сбор сведений об использовании и работоспособности путем анализа трафика, проходящего через службу управления API.

### Наблюдение за веб-API напрямую
При реализации веб-API с помощью шаблона веб-API ASP.NET (либо в качестве проекта веб-API, либо в виде веб-роли в облачной службе Azure) и Visual Studio 2013 вы можете организовать сбор данных о доступности, производительности и использовании данных с помощью ASP.NET Application Insights. Application Insights — это пакет, который прозрачно отслеживает и записывает сведения о запросах и ответах, когда веб-API развернут в облаке. После установки и настройки пакета вам не нужно вносить изменения в код веб-API, чтобы использовать его. При развертывании веб-API на веб-сайте Azure проверяется весь трафик, и собирается следующая статистика:

- время ответа от сервера;

- число запросов к серверу и сведения о каждом запросе;

- самые медленные запросы по среднему времени ответа;

- сведения обо всех неудачных запросах;

- число сеансов, инициализированных в различных браузерах и различными агентами пользователя;

- наиболее часто просматриваемые страницы (в основном полезно для веб-приложений, а не для веб-API);

- сведения о различных ролях пользователей, работающих с веб-API.

Эти данные можно просмотреть в режиме реального времени на портале управления Azure. Можно также создать веб-тесты, наблюдающие за работоспособностью веб-API. Веб-тест периодически отправляет запрос на указанный URI в веб-API и записывает ответ. Можно указать определение успешного ответа (например, код состояния HTTP 200), и если запрос не возвращает этот ответ, можно настроить оповещение для отправки администратору. При необходимости администратор может перезапустить сервер, на котором размещен веб-API, если произошел сбой.

Дополнительные сведения см. на странице [Application Insights — начните отслеживать работоспособность и использование приложения](app-insights-start-monitoring-app-health-usage/) на веб-сайте Майкрософт.

### Наблюдение за веб-API через службу управления API

Если веб-API был опубликован с помощью службы управления API, то на странице "Управление API" на портале управления Azure имеется панель мониторинга, с помощью которой можно ознакомиться с общей картиной производительности службы. На странице аналитики можно детализировать подробные сведения об использовании продукта. На этой странице представлены следующие вкладки:

- **Использование.** На этой вкладке содержатся сведения о количестве вызовов API и пропускной способности, необходимой для обработки этих вызовов по времени. Можно отфильтровать сведения об использовании по продуктам, API и операциям.

- **Работоспособность.** На этой вкладке можно просмотреть результаты запросов API (возвращенные коды состояния HTTP), сведения об эффективности политики кэширования, данные о времени ответа API и времени ответа службы. На этой вкладке можно так же фильтровать данные работоспособности по продуктам, API и операциям.

- **Действия.** На этой вкладке представлена текстовая сводка о количестве успешных вызовов, вызовов, завершившихся сбоем, заблокированных вызовов, данные о среднем времени отклика и времени отклика для каждых продукта, веб-API и операции. На этой странице также указано количество вызовов, совершенных каждым разработчиком.

- **Краткий обзор.** На этой вкладке представлена сводка по данным производительности, включая сведения о разработчиках, ответственных за совершение большинства вызовов API, а также информация о продуктах, веб-API и операциях, которые получили эти вызовы.

Эти сведения можно использовать для определения того, является ли определенный веб-API или операция узким местом, чтобы при необходимости можно было масштабировать среду размещения и добавить дополнительные серверы. Можно также получить представление о том, имеются ли приложения, которые используют неограниченный объем ресурсов, и применить соответствующие политики для установления квот и ограничений на скорость вызова.

> [AZURE.NOTE] Можно изменить данные для опубликованных продуктов. Изменения при этом вступают в силу сразу же. Например, можно добавить или удалить операции из веб-API без необходимости повторной публикации продукта, который содержит этот веб-API.

## Связанные шаблоны
- Шаблон [façade](http://en.wikipedia.org/wiki/Facade_pattern)описывает порядок предоставления интерфейса для веб-API.

## Дополнительные сведения
- На странице [Сведения о веб-API ASP.NET](http://www.asp.net/web-api) на веб-сайте Майкрософт представлены подробные сведения о создании веб-служб RESTful с помощью веб-API.
- На странице [Маршрутизация в веб-API ASP.NET](http://www.asp.net/web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api) на веб-сайте Майкрософт описывается принцип работы маршрутизации на основе соглашений в платформе веб-API ASP.NET.
- Дополнительные сведения о маршрутизации на основе атрибута см. на странице, посвященной [маршрутизации на основе атрибута в веб-API 2](http://www.asp.net/web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2), на веб-сайте Майкрософт.
- На странице [Основы](http://www.odata.org/getting-started/basic-tutorial/) на веб-сайте OData представлены ознакомительные сведения о возможностях протокола OData.
- На странице, посвященной [протоколу OData веб-API ASP.NET](http://www.asp.net/web-api/overview/odata-support-in-aspnet-web-api), на веб-сайте Майкрософт представлены примеры и дополнительные сведения о реализации веб-API OData с помощью ASP.NET.
- На странице [Реализация поддержки пакетных операций в веб-API и веб-API OData](http://blogs.msdn.com/b/webdev/archive/2013/11/01/introducing-batch-support-in-web-api-and-web-api-odata.aspx) на веб-сайте Майкрософт описывается порядок реализации пакетных операций в веб-API с помощью OData.
- В статье, посвященной [шаблонам идемпотентности](http://blog.jonathanoliver.com/idempotency-patterns/), в блоге Джонатана Оливера (Jonathan Oliver) представлен обзор идемпотентности и его связь с операциями по управлению данными.
- На странице [определений кодов состояния](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) на веб-сайте консорциума W3C представлен полный список кодов состояния HTTP.
- Подробные сведения об обработке исключений HTTP с помощью веб-API ASP.NET см. на странице [Обработка исключений в ASP.NET Web API](http://www.asp.net/web-api/overview/error-handling/exception-handling) на веб-сайте Майкрософт.
- В статье [Глобальная обработка ошибок с помощью веб-API](http://www.asp.net/web-api/overview/error-handling/web-api-global-error-handling) на веб-сайте Майкрософт описывается реализация глобальной обработки ошибок и стратегия ведения журнала для веб-API.
- На странице [Использование веб-заданий для выполнения фоновых задач на веб-сайтах Microsoft Azure](web-sites-create-web-jobs.md) на веб-сайте Майкрософт представлены дополнительные сведения и примеры использования веб-заданий для выполнения фоновых задач на веб-сайте Azure.
- На странице [Уведомление пользователей посредством центров уведомлений](notification-hubs-aspnet-backend-windows-dotnet-notify-users/) на веб-сайте Майкрософт демонстрируется порядок использования центра уведомления Azure для отправки асинхронных ответов клиентским приложениям.
- На странице [Управление API](https://azure.microsoft.com/services/api-management/) на веб-сайте Майкрософт описывается порядок публикации продукта, который предоставляет управляемый и безопасный доступ к веб-API.
- На странице [Справочник по API REST управления API Azure](https://msdn.microsoft.com/library/azure/dn776326.aspx) на веб-сайте Майкрософт описывается порядок использования API REST управления API для создания настраиваемых приложений управления.
- На странице [О методах балансировки нагрузки диспетчера трафика](../traffic-manager/traffic-manager-load-balancing-methods.md) на веб-сайте Майкрософт представлены сводные сведения о том, как диспетчер трафика Azure можно использовать для балансировки нагрузки запросов в нескольких экземплярах веб-сайта, на котором размещен веб-API.
- На странице [Application Insights — начните отслеживать работоспособность и использование приложения](app-insights-start-monitoring-app-health-usage.md) на веб-сайте Майкрософт предоставлены подробные сведения об установке и настройке Application Insights в проекте веб-API ASP.NET.
- На странице [Проверка кода при помощи модульных тестов](https://msdn.microsoft.com/library/dd264975.aspx) на веб-сайте Майкрософт предоставлены подробные сведения о создании модульных тестов и управлении ими с помощью Visual Studio.
- На странице [Запуск тестов производительности в приложении](https://msdn.microsoft.com/library/dn250793.aspx) на веб-сайте Майкрософт описывается порядок использования Visual Studio Ultimate для создания веб-тестов производительности и загрузки тестового проекта.

<!---HONumber=AcomDC_0316_2016-->