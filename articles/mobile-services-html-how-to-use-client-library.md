<properties linkid="mobile-services-how-to-html-client" urlDisplayName="HTML-клиент" pageTitle="Как использовать HTML-клиент - Мобильные службы Azure" metaKeywords="Мобильные службы Azure, HTML-клиент мобильных служб, HTML-клиент" description="Сведения об использовании HTML-клиента для мобильных служб Azure." metaCanonical="" services="" documentationCenter="Mobile" title="Использование клиента HTML/JavaScript для мобильных служб Azure" authors=""  solutions="" writer="krisragh" manager="" editor=""  />


# Использование клиента HTML/JavaScript для мобильных служб Azure

<div class="dev-center-tutorial-selector sublanding"> 
  <a href="/ru-ru/develop/mobile/how-to-guides/work-with-net-client-library/" title=".NET Framework">.NET Framework</a><a href="/ru-ru/develop/mobile/how-to-guides/work-with-html-js-client/" title="HTML/JavaScript" class="current">HTML/JavaScript</a><a href="/ru-ru/develop/mobile/how-to-guides/work-with-ios-client-library/" title="iOS">iOS</a><a href="/ru-ru/develop/mobile/how-to-guides/work-with-android-client-library/" title="Android">Android</a><a href="/ru-ru/develop/mobile/how-to-guides/work-with-xamarin-client-library/" title="Xamarin">Xamarin</a>
</div>


В этом руководстве показано, как реализовать типичные сценарии с использованием клиента HTML/JavaScript для мобильных служб Azure. В сценарии входят запрос данных, вставка, обновление и удаление данных, проверка подлинности пользователей и обработка ошибок. Если вы впервые работаете с мобильными службами, рекомендуем сначала проработать учебники [Windows Store JavaScript quickstart] или [HTML quickstart]. Учебник quickstart поможет вам настроить учетную запись и создать свою первую мобильную службу.


## Оглавление

- [Что такое мобильные службы]
- [Основные понятия]
- [Практическое руководство. Создание клиента мобильных служб]
- [Практическое руководство. Запрос данных от мобильной службы]
	- [Фильтрация возвращаемых данных]
    - [Сортировка возвращаемых данных]
	- [Возврат данных на страницах]
	- [Выбор определенных столбцов]
	- [Поиск данных по идентификатору]
- [Практическое руководство. Вставка данных в мобильную службу]
- [Практическое руководство. Изменение данных в мобильной службе]
- [Практическое руководство. Удаление данных в мобильной службе]
- [Практическое руководство. Отображение данных в пользовательском интерфейсе]
- [Практическое руководство. Проверка подлинности пользователей]
- [Практическое руководство. Обработка ошибок]
- [Практическое руководство. Использование обещаний]
- [Практическое руководство. Настройка заголовков запроса]
- [Практическое руководство. Общий доступ к ресурсам независимо от источника]
- [Дальнейшие действия]

[WACOM.INCLUDE [mobile-services-concepts](../includes/mobile-services-concepts.md)]

<h2><a name="create-client"></a><span class="short-header">Создание клиента мобильных служб</span>Практическое руководство. Создание клиента мобильных служб</h2>

Следующий код создает экземпляр объекта клиента мобильных служб. 

В веб-редакторе откройте HTML-файл проекта index.html и добавьте следующее выражение в ссылки сценария на страницу:

	        <script src='http://ajax.aspnetcdn.com/ajax/mobileservices/MobileServices.Web-1.1.2.min.js'></script>

В редакторе откройте или создайте файл JavaScript и добавьте следующий код, который определяет переменную `MobileServiceClient`, и укажите URL-адрес и ключ приложения мобильной службы в конструкторе `MobileServiceClient` в указанном порядке: Необходимо заменить заполнитель `AppUrl` на URL-адрес приложения мобильной службы и `AppKey` на ключ приложения. Чтобы узнать, как получить URL-адрес приложения и ключ приложения для мобильной службы, изучите учебник [Приступая к работе с данными в Магазине Windows JavaScript] или [Приступая к работе с данными в HTML/JavaScript].

			var MobileServiceClient = WindowsAzure.MobileServiceClient;
		    var client = new MobileServiceClient('AppUrl', 'AppKey');

<h2><a name="querying"></a><span class="short-header">Запрос данных</span>Практическое руководство. Запрос данных от мобильной службы</h2>

Весь код, который обращается к данным или изменяет данные в таблице базы данных SQL, вызывает функции для объекта `MobileServiceTable`. Ссылку на таблицу можно получить, вызвав функцию `getTable()` для экземпляра `MobileServiceClient`.
	
		    var todoItemTable = client.getTable('todoitem');



### <a name="filtering"></a>Практическое руководство. Фильтрация возвращаемых данных

Следующий код иллюстрирует способ фильтрации данных, включая предложение `where` в запросе. Он возвращает все элементы из `todoItemTable`, поле complete которого равно `false`. `todoItemTable` – это ссылка на таблицу мобильной службы, которая была создана ранее. Функция where применяет предикат фильтрации строк для запросов к таблице. Он принимает в качестве аргумента объект JSON, который определяет фильтр строк и возвращает запрос, который можно компоновать далее. 
	
			var query = todoItemTable.where({
			    complete: false
			}).read().done(function (results) {
			    alert(JSON.stringify(results));
			}, function (err) {
			    alert("Error: " + err);
			});

Добавляя вызов `where` для объекта запроса и передавая объект в качестве параметра, мы инструктируем мобильные службы вернуть только те строки, в которых столбец `complete` содержит значение `false`. Кроме того, посмотрите на приведенный ниже URI запроса и обратите внимание на изменение самой строки запроса:

			GET /tables/todoitem?$filter=(complete+eq+false) HTTP/1.1			

Можно просмотреть URI запроса, отправленного в мобильную службу, с помощью программы проверки сообщений, включая средства разработчика браузера и Fiddler.

На стороне сервера такой запрос обычно должен преобразовываться примерно в такой запрос SQL:
			
			SELECT * 
			FROM TodoItem 			
			WHERE ISNULL(complete, 0) = 0

Объект, который передается в метод `where`, может иметь произвольное число параметров, и все они будут интерпретироваться как предложения AND в запросе. Например, следующая строка:

			query.where({
			   complete: false,
			   assignee: "david",
			   difficulty: "medium"
			}).read().done(function (results) {
			   alert(JSON.stringify(results));
			}, function (err) {
			   alert("Error: " + err);
			});

Будет преобразована (для того же запроса, приведенного выше) примерно в
			
			SELECT * 
			FROM TodoItem 
			WHERE ISNULL(complete, 0) = 0
			      AND assignee = 'david'
			      AND difficulty = 'medium'

Приведенная выше инструкция `where` и запрос SQL содержат незавершенные элементы, назначенные элементу david средней сложности (medium).

Однако существует другой способ составления того же запроса. Вызов `where` объекта запроса добавить выражение `AND` в предложение `WHERE`, поэтому мы могли написать его вместо этого в трех строках:

			query.where({
			   complete: false
			});
			query.where({
			   assignee: "david"
			});
			query.where({
			   difficulty: "medium"
			});

или с помощью гибкого API:

			query.where({
			   complete: false
			})
			   .where({
			   assignee: "david"
			})
			   .where({
			   difficulty: "medium"
			});

Эти два способа эквивалентны и могут быть взаимозаменяемыми. Пока все вызовы `where` принимали объект с некоторыми параметрами и сравнивались на предмет равенства с данными из базы данных. Однако есть другая перегрузка для метода запроса, который принимает функцию вместо объекта. Затем в этой функции можно составить более сложные выражения, используя операторы неравенства и другие реляционные операции. В этих функциях ключевое слово `this` привязывается к объекту сервера.

Текст функции преобразуется в логическое выражение OData, которое передается в параметр строки запроса. Можно передать функцию, которая не принимает параметров, например:

		    query.where(function () {
		       return this.assignee == "david" && (this.difficulty == "medium" || this.difficulty == "low");
		    }).read().done(function (results) {
		       alert(JSON.stringify(results));
		    }, function (err) {
		       alert("Error: " + err);
		    });


При передаче функции с параметрами любые аргументы после предложения `where` привязаны к параметрам функции в заданном порядке. Любые объекты, которые поступают из-за пределов области действия функции, ДОЛЖНЫ быть переданы в качестве параметров. Функция не может записывать любые внешние переменные. В двух следующих примерах аргумент david привязан к параметру `name`, а в первом примере аргумент meidum также привязан к параметру `level`. Кроме того, функция должна состоять из одной инструкции `return` с поддерживаемым выражением, например:
					
			 query.where(function (name, level) {
			    return this.assignee == name && this.difficulty == level;
			 }, "david", "medium").read().done(function (results) {
			    alert(JSON.stringify(results));
			 }, function (err) {
			    alert("Error: " + err);
			 });

Поэтому пока мы следуем правилам, мы можем добавить в наши запросы баз данных более сложные фильтры, например:

		    query.where(function (name) {
		       return this.assignee == name &&
		          (this.difficulty == "medium" || this.difficulty == "low");
		    }, "david").read().done(function (results) {
		       alert(JSON.stringify(results));
		    }, function (err) {
		       alert("Error: " + err);
		    });

Можно объединить `where` с `orderBy`, `take` и `skip`. подробности приведены в следующем разделе.

### <a name="sorting"></a>Практическое руководство. Сортировка возвращаемых данных

В следующем коде показано, как сортировать данные, включая в запрос функцию `orderBy` или `orderByDescending`. Он возвращает элементы из `todoItemTable`, упорядочивая их в восходящем порядке по полю `text`. По умолчанию сервер возвращает только первые 50 элементов. 

<div class="dev-callout"><strong>Примечание</strong>. <p>Для предотвращения возврата всех элементов по умолчанию используется размер страницы, управляемый сервером. Это предотвращает негативное воздействие больших наборов данных на функционирование службы. </p> </div>
>
Можно увеличить количество возвращаемых элементов путем вызова `take`, как описано в следующем разделе. `todoItemTable` – это ссылка на таблицу мобильной службы, которая была создана ранее.

			var ascendingSortedTable = todoItemTable.orderBy("text").read().done(function (results) {
			   alert(JSON.stringify(results));
			}, function (err) {
			   alert("Error: " + err);
			});

			var descendingSortedTable = todoItemTable.orderByDescending("text").read().done(function (results) {
			   alert(JSON.stringify(results));
			}, function (err) {
			   alert("Error: " + err);
			});

			var descendingSortedTable = todoItemTable.orderBy("text").orderByDescending("text").read().done(function (results) {
			   alert(JSON.stringify(results));
			}, function (err) {
			   alert("Error: " + err);
			});

### <a name="paging"></a>Практическое руководство. Возврат данных на страницах

В следующем коде показано, как реализовать разбиение возвращенных данных по страницам с помощью предложений `take` и `skip` в запросе.  При выполнении следующего запроса будут возвращены три главных элемента в таблице. 

			var query = todoItemTable.take(3).read().done(function (results) {
			   alert(JSON.stringify(results));
			}, function (err) {
			   alert("Error: " + err);
			});

Обратите внимание, что метод `take(3)` был преобразован в параметр запроса `$top=3` в URI запроса.

Следующий измененный запрос пропускает первые три результата и после этого возвращает следующие три. Это фактически вторая "страница" данных, где размер страницы составляет три элемента.

			var query = todoItemTable.skip(3).take(3).read().done(function (results) {
			   alert(JSON.stringify(results));
			}, function (err) {
			   alert("Error: " + err);
			});

И снова вы можете просмотреть URI запроса, отправленного в мобильную службу. Обратите внимание, что метод `skip(3)` был преобразован в параметр запроса `$skip=3` в URI запроса.

Это упрощенный сценарий передачи жестко запрограммированных значений разбиения по страницам в методы `take` и `skip`. В реальных приложениях можно использовать запросы, подобные вышеуказанным с постраничным навигатором или с другим совместимым пользовательским интерфейсом, позволяющим переходить на следующую страницу или возвращаться к предыдущей странице. 

### <a name="selecting"></a>Практическое руководство. Выбор определенных столбцов

Можно задать набор свойств, включаемых в результаты, добавив к запросу предложение `select`. Например, следующий код возвращает свойства `id`, `complete` и `text` из каждой строки в `todoItemTable`:

			var query = todoItemTable.select("id", "complete", "text").read().done(function (results) {
			   alert(JSON.stringify(results));
			}, function (err) {
			   alert("Error: " + err);
			})
	
Здесь параметры функции select являются именами столбцов таблицы, которые требуется вернуть. 


Все описанные функции являются суммируемыми, поэтому каждая последующая вызываемая функция будет продолжать влиять на запрос. Еще один пример:


		    query.where({
		       complete: false
		    })
		       .select('id', 'assignee')
		       .orderBy('assignee')
		       .take(10)
		       .read().done(function (results) {
		       alert(JSON.stringify(results));
		    }, function (err) {
		       alert("Error: " + err);

### <a name="lookingup"></a>Практическое руководство. Поиск данных по идентификатору

Функция `lookup` принимает только значение `id` и возвращает объект из базы данных с этим идентификатором. Таблицы базы данных создаются со столбцом `id` целочисленных или строковых значений. Столбец `id` со строковыми значениями используется по умолчанию.

			todoItemTable.lookup("37BBF396-11F0-4B39-85C8-B319C729AF6D").done(function (result) {
			   alert(JSON.stringify(result));
			}, function (err) {
			   alert("Error: " + err);
			})



<h2><a name="inserting"></a><span class="short-header">Вставка данных</span>Практическое руководство. Вставка данных в мобильную службу</h2>

В следующем коде показано, как вставить новые строки в таблицу. Клиент запрашивает вставку строки данных путем отправки запроса POST в мобильную службу. Текст запроса содержит данные, которые вставлены в качестве объекта JSON. 

			todoItemTable.insert({
			   text: "New Item",
			   complete: false
			})

Это приводит к вставке в таблицу данных из предоставленного объекта JSON. Можно также указать функцию обратного вызова, которая будет вызываться после завершения вставки:

			todoItemTable.insert({
			   text: "New Item",
			   complete: false
			}).done(function (result) {
			   alert(JSON.stringify(result));
			}, function (err) {
			   alert("Error: " + err);
			});


Мобильные службы поддерживают уникальные настраиваемые строковые значения идентификатора таблицы. Это позволяет приложениям использовать настраиваемые значения, например адреса электронной почты или имена пользователей, для столбца идентификатора таблицы мобильных служб. Например, если требуется идентифицировать каждую запись по адресу электронной почты, можно использовать следующий объект JSON.

			todoItemTable.insert({
			   id: "myemail@domain.com",				
			   text: "New Item",
			   complete: false
			})

Если значение идентификатора строки не указано при вставке новых записей в таблицу, мобильные службы создают уникальное значение идентификатора.

Поддержка строковых идентификаторов предоставляет разработчикам следующие преимущества:

+ Идентификаторы можно создавать без обмена данными с базой данных.
+ Можно легко объединять записи из разных таблиц или баз данных.
+ Значения идентификаторов можно удобно интегрировать с логикой приложения.

Серверные скрипты также можно использовать для задания значений идентификаторов. В следующем примере скрипта создается настраиваемый идентификатор GUID, который назначается идентификатору новой записи. Этот идентификатор похож на значение, создаваемое мобильными службами, если не передать значение идентификатора записи.

	//Пример создания идентификатора. Это не является обязательным, так как мобильные службы
	//приведут к созданию идентификатора, если таковой не был передан.
	item.id = item.id || newGuid();
	request.execute();

	function newGuid() {
		var pad4 = function(str) { return "0000".substring(str.length) + str; };
		var hex4 = function () { return pad4(Math.floor(Math.random() * 0x10000 /* 65536 */ ).toString(16)); };
		return (hex4() + hex4() + "-" + hex4() + "-" + hex4() + "-" + hex4() + "-" + hex4() + hex4() + hex4());
	}


Если приложение предоставляет значение для идентификатора, мобильные службы сохраняют его как есть. (В том числе с начальными или конечными пробелами.) Пробелы не удаляются из идентификатора.

Значение идентификатора должно быть уникальным и не должно содержать символы из следующих наборов:

+ Управляющие символы: [0x0000-0x001F] и [0x007F-0x009F]. Дополнительные сведения см. в статье [Управляющие коды ASCII C0 и C1].
+  Печатные символы: **"**(0x0022), **\+** (0x002B), **/** (0x002F), **?** (0x003F), **\\** (0x005C), **`** (0x0060)
+  идентификаторы "." и ".."

Также для таблиц можно использовать целочисленные идентификаторы. Для этого необходимо создать таблицу с помощью команды `mobile table create` с параметром `--integerId`. Эта команда используется в интерфейсе командной строки (CLI) Azure. Дополнительные сведения об использовании CLI см. в статье [Интерфейс командной строки для управления таблицами мобильных служб].


<h2><a name="modifying"></a><span class="short-header">Изменение данных</span>Практическое руководство. Изменение данных в мобильной службе</h2>

В следующем коде показано, как обновить данные в таблице. Клиент запрашивает обновление строки данных путем отправки запроса PATCH в мобильную службу. Текст запроса содержит определенные поля, которые должны быть обновлены в качестве объекта JSON. Обновляется существующий элемент в таблице `todoItemTable`. 

			todoItemTable.update({
			   id: idToUpdate,
			   text: newText
			})

Первый параметр указывает экземпляр для обновления в таблице, который указан в идентификаторе. 

Можно также указать функцию обратного вызова, которая будет вызываться после завершения обновления:

			todoItemTable.update({
			   id: idToUpdate,
			   text: newText
			}).done(function (result) {
			   alert(JSON.stringify(result));
			}, function (err) {
			   alert("Error: " + err);
			});
	
<h2><a name="deleting"></a><span class="short-header">Удаление данных</span>Практическое руководство. Удаление данных в мобильной службе</h2>

В следующем коде показано, как удалить данные из таблицы. Клиент запрашивает удаления строки данных путем отправки запроса POST DELETE в мобильную службу. Это приводит к удалению существующих элементов в таблице todoItemTable. 

			todoItemTable.del({
			   id: idToDelete
			})

Первый параметр указывает экземпляр для удаления в таблице, который указан в идентификаторе. 

Можно также указать функцию обратного вызова, которая будет вызываться после завершения удаления:	
	
			todoItemTable.del({
			   id: idToDelete
			}).done(function () {
			   /* Do something */
			}, function (err) {
			   alert("Error: " + err);
			});	

<h2><a name="binding"></a><span class="short-header">Отображение данных</span>Практическое руководство. Отображение данных в пользовательском интерфейсе</h2>

В этом разделе показано, как отображать возвращенные объекты данных с использованием элементов пользовательского интерфейса. Чтобы запросить элементы в `todoItemTable` и отобразить результаты в простом списке, можно выполнить следующий пример кода. Выделенные элементы отсутствуют, выполняется фильтрация и сортировка любого рода. 

			var query = todoItemTable;
		
			query.read().then(function (todoItems) {
			   // The space specified by 'placeToInsert' is an unordered list element <ul> ... </ul>
			   var listOfItems = document.getElementById('placeToInsert');
			   for (var i = 0; i < todoItems.length; i++) {
			      var li = document.createElement('li');
			      var div = document.createElement('div');
			      div.innerText = todoItems[i].text;
			      li.appendChild(div);
			      listOfItems.appendChild(li);
			   }
			}).read().done(function (results) {
			   alert(JSON.stringify(results));
			}, function (err) {
			   alert("Error: " + err);
			});

В приложении Магазина Windows результаты запроса могут быть использованы для создания объекта [WinJS.Binding.List], которые могут быть привязаны в качестве источника данных к объекту [ListView]. Дополнительные сведения см. в разделе [Привязка данных (приложения Магазина Windows с использованием JavaScript и HTML)].

<h2><a name="caching"></a><span class="short-header">Проверка подлинности</span>Практическое руководство. Проверка подлинности пользователей</h2>

Мобильные службы поддерживают проверку подлинности и авторизацию пользователей с помощью различных внешних поставщиков идентификаторов: Facebook, Google, учетная запись Майкрософт и Twitter. Можно задать разрешения таблиц, чтобы предоставить доступ к определенным операциям только пользователям, прошедшим проверку подлинности. Удостоверения пользователей, прошедших проверку подлинности, также можно применять для реализации правил авторизации в серверных скриптах. Дополнительные сведения см. в учебнике [Приступая к работе с проверкой подлинности].

Поддерживаются два потока проверки подлинности: _серверный_ и _клиентский_. Серверный поток обеспечивает самый простой способ проверки подлинности, так как он использует веб-интерфейс проверки подлинности. Клиентский поток обеспечивает более тесную интеграцию с возможностями устройства, такими как единый вход, так как использует пакеты SDK конкретного поставщика для конкретного устройства.

<h3>Серверный поток</h3>
Чтобы мобильная служба могла выполнять процесс проверки подлинности в вашем приложении для магазина Windows или для приложения HTML, необходимо зарегистрировать приложение у поставщика удостоверений. Затем в вашей мобильной службе необходимо настроить код приложения и секретный код, предоставленный поставщиком. Дополнительные сведения см. в учебнике "Приступая к работе с проверкой подлинности" ([Магазин Windows][Приступая к работе с проверкой подлинности]/[HTML][Приступая к работе с проверкой подлинности Магазина Windows]).

После регистрации у поставщика удостоверений просто вызовите [метод LoginAsync] с указанием значения [MobileServiceAuthenticationProvider] вашего поставщика. Например, для входа в систему через Facebook используйте следующий код. 

		client.login("facebook").done(function (results) {
		     alert("You are now logged in as: " + results.userId);
		}, function (err) {
		     alert("Error: " + err);
		});

Если используется поставщик удостоверений, отличный от Facebook, измените значение, переданное в приведенный выше метод `login` в один из следующих объектов: `microsoftaccount`, `facebook`, `twitter`, `google` или `windowsazureactivedirectory`.

В этом случае мобильная служба управляет потоком проверки подлинности OAuth 2.0, отображая страницу входа выбранного поставщика и генерируя маркер проверки подлинности мобильных служб после успешного соединения с поставщиком удостоверений. Функция [login] после завершения работы возвращает объект JSON (**user**), который содержит и идентификатор пользователя и маркер проверки подлинности мобильных служб в полях **userId** и **authenticationToken** соответственно. Этот маркер можно кэшировать и повторно использовать до истечения срока его действия. Дополнительные сведения см. в разделе [Кэширование маркера проверки подлинности].

<div class="dev-callout"><b>Приложение Магазина Windows</b>
<p>При использовании поставщика входа в систему учетных записей Майкрософт для проверки подлинности пользователей в вашем приложении Магазина Windows необходимо также зарегистрировать этот пакет приложения в мобильных службах. При регистрации сведений пакета приложений магазина Windows с помощью мобильных служб клиент сможет повторно использовать учетные данные для входа в учетную запись Майкрософт для осуществления единого входа. Если этого не сделать, пользователям входа учетной записи Майкрософт придется осуществлять вход в систему при каждом вызове метода входа в систему. Чтобы узнать, как зарегистрировать пакет приложения Магазина Windows, изучите документ <a href="/ru-ru/develop/mobile/how-to-guides/register-windows-store-app-package/" target="_blank">Регистрация пакета приложения Магазина Windows для проверки подлинности Майкрософт</a>. После регистрации сведений пакета в мобильных службах вызовите метод <a href="http://go.microsoft.com/fwlink/p/?LinkId=322050" target="_blank">login</a> путем предоставления значения <strong>true</strong> для параметра <em>useSingleSignOn</em> в целях повторного использования учетных данных.</p>
</div>

<h3>Клиентский поток</h3>
Приложение может также независимо связаться с поставщиком удостоверений и указать возвращаемый маркер в мобильные службы для проверки подлинности. Этот клиентский поток позволяет пользователям выполнять единый вход или получать дополнительные данные о пользователе от поставщика удостоверений. 

В следующем примере используется пакет SDK Live, поддерживающий единый вход в приложения Магазина Windows с использованием учетной записи Майкрософт:

		WL.login({ scope: "wl.basic"}).then(function (result) {
		      client.login(
		            "microsoftaccount", 
		            {"authenticationToken": result.session.authentication_token})
		      .done(function(results){
		            alert("You are now logged in as: " + results.userId);
		      },
		      function(error){
		            alert("Error: " + err);
		      });
		});

Этот упрощенный пример получает маркер из Live Connect, который предоставляется мобильным службам путем вызова функции [login]. Более полный пример использования учетной записи Майкрософт для обеспечения единого входа см. в разделе [Проверка подлинности приложения с помощью единого входа].

При использовании интерфейсов API Facebook или Google для проверки подлинности клиентов следует немного изменить пример. 

		client.login(
		     "facebook", 
		     {"access_token": token})
		.done(function (results) {
		     alert("You are now logged in as: " + results.userId);
		}, function (err) {
		     alert("Error: " + err);
		});

В этом примере предполагается, что маркер, предоставленный соответствующим поставщиком SDK, сохраняется в переменной `token`.
В настоящее время Twitter не может использоваться для проверки подлинности клиента. 

<h3>Кэширование маркера проверки подлинности</h3>
В некоторых случаях вызова способа входа в систему можно избежать первого выполнения проверки подлинности пользователя. Мы можем использовать [sessionStorage] или [localStorage] для кэширования удостоверения текущего пользователя при первом входе, а затем мы будем проверять, содержится ли удостоверение пользователя в нашем кэше. Если кэш является пустым или вызовы завершаются со сбоем (то есть истекло время текущего сеанса входа), нам необходимо пройти процедуру входа. 

        // После входа
        sessionStorage.loggedInUser = JSON.stringify(client.currentUser);

        // Вход 
        if (sessionStorage.loggedInUser) {
           client.currentUser = JSON.parse(sessionStorage.loggedInUser);
        } else {
           // Поток регулярного входа
       }

         // Выход
        client.logout();
        sessionStorage.loggedInUser = null;


<h2><a name="errors"></a><span class="short-header">Обработка ошибок</span>Практическое руководство. Обработка ошибок</h2>

Существует несколько способов выявления, проверки и устранения ошибок в мобильных службах. 

Например, серверные сценарии зарегистрированы в мобильной службе и могут использоваться для выполнения различных операций со вставляемыми и обновляемыми данными, включая проверку и изменение данных. Процесс определения и регистрации серверного сценария для проверки и изменения данных можно представить следующим образом:

			function insert(item, user, request) {
			   if (item.text.length > 10) {
				  request.respond(statusCodes.BAD_REQUEST, { error: "Text cannot exceed 10 characters" });
			   } else {
			      request.execute();
			   }
			}

Серверный сценарий проверяет длину строки данных, отправленных в мобильную службу, и отклоняет слишком длинные строки; в этом случае отклоняются строки длиной более 10 знаков.

Теперь, когда мобильная служба выполняет проверку данных и отправляет сообщения об ошибках на стороне сервера, можно обновить приложение HTML для обработки сообщений об ошибках, полученных при выполнении проверки.

		todoItemTable.insert({
		   text: itemText,
		   complete: false
		})
		   .then(function (results) {
		   alert(JSON.stringify(results));
		}, function (error) {
		   alert(JSON.parse(error.request.responseText).error);
		});


Далее можно передать обработчик ошибок в качестве второго аргумента при каждом доступе к данным: 
			
			function handleError(message) {
			   if (window.console && window.console.error) {
			      window.console.error(message);
			   }
			}

			client.getTable("tablename").read().then(function (data) { /* do something */ }, handleError);

<h2><a name="promises"></a><span class="short-header">Обещания</span>Практическое руководство. Использование обещаний</h2>

Обещания предоставляют механизм планирования выполнения работы со значением, которое еще не было вычислено. Это абстракция для управления взаимодействиями с асинхронными интерфейсами API. 

Обещание `done` выполняется, как только, предоставленная ему функция завершается как успешно, так и с ошибкой. В отличие от обещания `then` гарантируется вызов любой ошибки, которая не обрабатывается внутри функции, а после выполнения обработчиков эта функция вызывает любую ошибку, которая была возвращена в качестве обещания в состоянии ошибки. Дополнительные сведения см. в описании [done].

			promise.done(onComplete, onError);

Следующим образом:
	
			var query = todoItemTable;
			query.read().done(function (results) {
			   alert(JSON.stringify(results));
			}, function (err) {
			   alert("Error: " + err);
			});

Обещание `then` не отличается от обещания `done`, однако в отличие от обещания `then` обещание `done` гарантирует вызов ошибки, которая не обрабатывается внутри функции. Если не предоставить обработчик ошибок для обещания `then`, а операция содержит ошибку, исключение не вызывается, но возвращает обещание в состоянии ошибки. Дополнительные сведения см. в описании [then].

			promise.then(onComplete, onError).done( /* Your success and error handlers */ );

Следующим образом:

			var query = todoItemTable;
			query.read().done(function (results) {
			   alert(JSON.stringify(results));
			}, function (err) {
			   alert("Error: " + err);
			});

Обещания можно использовать различными способами. Можно выстраивать последовательности операций обещаний путем вызова `then` или `done` для обещания, которое было возвращено предыдущей функцией `then`. Используйте `then` для промежуточного этапа операции (например, `.then().then()`), а done для окончательного этапа операции (например, `.then().then().done()`).  Можно связать несколько функций `then`, так как `then` возвращает обещание. Невозможно связывать более одного метода `done`, так как возвращается неопределенное значение. [Дополнительные сведения о различиях между then и done].
	
 			todoItemTable.insert({
 			   text: "foo"
 			}).then(function (inserted) {
 			   inserted.newField = 123;
 			   return todoItemTable.update(inserted);
 			}).done(function (insertedAndUpdated) {
 			   alert(JSON.stringify(insertedAndUpdated));
 			})

<h2><a name="customizing"></a><span class="short-header">Настройка заголовков запросов</span>Практическое руководство. Настройка заголовков запроса клиента</h2>

Можно отправлять пользовательские заголовки запросов, используя функцию `withFilter`, считывая и записывая необязательные свойства запроса, которые будут отправлены в рамках фильтра. Может понадобиться добавить подобный пользовательский заголовок HTTP, если он будет востребован сценарием на стороне сервера или сможет улучшить работу этого сценария. 

			var client = new WindowsAzure.MobileServiceClient('https://your-app-url', 'your-key')
			   .withFilter(function (request, next, callback) {
			   request.headers.MyCustomHttpHeader = "Some value";
			   next(request, callback);
			});

Фильтры используются гораздо шире, чем настройка заголовков запросов. Они могут использоваться для изучения или изменения запросов, изучения или изменения ответов, обхода сетевых вызовов, отправки нескольких вызовов и т. д.

<h2><a name="hostnames"></a><span class="short-header">Использование CORS</span>Практическое руководство. Общий доступ к ресурсам независимо от источника</h2>

Чтобы управлять тем, какие веб-сайты могут взаимодействовать с вашей мобильной службой и отправлять в нее запросы, необходимо добавить имя узла веб-сайта, который используется для размещения мобильной службы, в список общего доступа к ресурсам независимо от источника (CORS) на вкладке "Настроить". При необходимости можно использовать подстановочные знаки. По умолчанию новые мобильные службы указывают браузерам разрешать доступ только с узла `localhost`, а общий доступ к ресурсам независимо от источника (CORS) позволяет коду JavaScript работать в браузере на внешнем имени узла для взаимодействия с вашей мобильной службой.  Эта конфигурация не является необходимой для приложений WinJS.

<h2><a name="nextsteps"></a>Дальнейшие действия</h2>

Теперь, когда вы закончили изучение этого концептуального раздела, узнайте более подробно, как можно выполнять дополнительные важные задачи в мобильных службах.

* [Приступая к работе с мобильными службами]
  <br/>Сведения об основах использования мобильных служб.

* [Приступая к работе с данными]
  <br/>Дополнительные сведения о хранении данных и запросах к ним при помощи мобильных служб.

* [Приступая к работе с проверкой подлинности]
  <br/>Дополнительные сведения о проверке подлинности учетных данных пользователей приложения с помощью поставщика удостоверений.

* [Проверка и изменение данных с помощью скриптов]
  <br/>Дополнительные сведения об использовании серверных скриптов в мобильных службах для проверки и изменения данных, отправляемых из приложения.

* [Уточнение запросов посредством разбиения по страницам]
  <br/>Сведения об использовании разбиения по страницам в запросах для управления объемом данных, обрабатываемым в одном запросе.

* [Авторизация пользователей с помощью скриптов]
  <br/>Сведения об использовании значения идентификатора пользователя, предоставляемого мобильными службами на основе пользователя, прошедшего проверку подлинности, для фильтрации данных, возвращаемых мобильными службами. 

<!-- Anchors. -->
[Что такое мобильные службы]: #what-is
[Основные понятия]: #concepts
[Практическое руководство. Создание клиента мобильных служб]: #create-client
[Практическое руководство. Запрос данных от мобильной службы]: #querying
[Фильтрация возвращаемых данных]: #filtering
[Сортировка возвращаемых данных]: #sorting
[Возврат данных на страницах]: #paging
[Выбор определенных столбцов]: #selecting
[Поиск данных по идентификатору]: #lookingup
[Практическое руководство. Отображение данных в пользовательском интерфейсе]: #binding
[Практическое руководство. Вставка данных в мобильную службу]: #inserting
[Практическое руководство. Изменение данных в мобильной службе]: #modifying
[Практическое руководство. Удаление данных в мобильной службе]: #deleting
[Практическое руководство. Проверка подлинности пользователей]: #caching
[Практическое руководство. Обработка ошибок]: #errors
[Практическое руководство. Использование обещаний]: #promises
[Практическое руководство. Настройка заголовков запроса]: #customizing
[Практическое руководство. Общий доступ к ресурсам независимо от источника]: #hostnames
[Дальнейшие действия]: #nextsteps



<!-- URLs. -->
[Приступая к работе с мобильными службами]: /ru-ru/develop/mobile/tutorials/get-started-html
[Пакет SDK для мобильных служб]: http://go.microsoft.com/fwlink/?LinkId=257545
[Приступая к работе с данными]: http://www.windowsazure.com/ru-ru/develop/mobile/tutorials/get-started-with-data-html/
[Приступая к работе с проверкой подлинности]: /ru-ru/develop/mobile/tutorials/get-started-with-users-html
[Приступая к работе с проверкой подлинности Магазина Windows]: /ru-ru/develop/mobile/tutorials/get-started-with-users-js
[then]: http://msdn.microsoft.com/ru-ru/library/windows/apps/br229728.aspx
[done]: http://msdn.microsoft.com/ru-ru/library/windows/apps/hh701079.aspx
[Дополнительные сведения о различиях между then и done]: http://msdn.microsoft.com/ru-ru/library/windows/apps/hh700334.aspx
[обработка ошибок в обещаниях]: http://msdn.microsoft.com/ru-ru/library/windows/apps/hh700337.aspx

[sessionStorage]: http://msdn.microsoft.com/ru-ru/library/cc197062(v=vs.85).aspx
[localStorage]: http://msdn.microsoft.com/ru-ru/library/cc197062(v=vs.85).aspx

[ListView]: http://msdn.microsoft.com/ru-ru/library/windows/apps/br211837.aspx
[Привязка данных (приложения Магазина Windows с использованием JavaScript и HTML)]: http://msdn.microsoft.com/ru-ru/library/windows/apps/hh758311.aspx
[Quickstart по Магазину Windows с использованием JavaScript]: http://www.windowsazure.com/ru-ru/develop/mobile/tutorials/get-started
[Краткое руководство по HTML]: http://www.windowsazure.com/ru-ru/develop/mobile/tutorials/get-started-html
[Приступая к работе с данными в Магазине Windows JavaScript]: http://www.windowsazure.com/ru-ru/develop/mobile/tutorials/get-started-with-data-js
[Приступая к работе с данными в HTML/JavaScript]: http://www.windowsazure.com/ru-ru/develop/mobile/tutorials/get-started-with-data-html/
[Здесь можно просмотреть полный пример использования этого сценария]: http://www.windowsazure.com/ru-ru/develop/mobile/tutorials/single-sign-on-windows-8-js/
[Приступая к работе с данными]: /ru-ru/develop/mobile/tutorials/get-started-with-data-html
[Проверка и изменение данных с помощью скриптов]: /ru-ru/develop/mobile/tutorials/validate-modify-and-augment-data-html
[Уточнение запросов посредством разбиения по страницам]: /ru-ru/develop/mobile/tutorials/add-paging-to-data-html
[Авторизация пользователей с помощью скриптов]: /ru-ru/develop/mobile/tutorials/authorize-users-in-scripts-html
[вход]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554236.aspx
[Проверка подлинности приложения с помощью единого входа]: /ru-ru/develop/mobile/tutorials/single-sign-on-windows-8-dotnet/
[Управляющие коды ASCII C0 и C1]: http://en.wikipedia.org/wiki/Data_link_escape_character#C1_set
[Интерфейс командной строки для управления таблицами мобильных служб]: http://www.windowsazure.com/ru-ru/manage/linux/other-resources/command-line-tools/#Mobile_Tables
