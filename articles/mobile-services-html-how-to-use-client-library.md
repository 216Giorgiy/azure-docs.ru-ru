<properties urlDisplayName="HTML Client" pageTitle="Как использовать клиент HTML для мобильных служб Azure" metaKeywords="Azure Mobile Services, Mobile Service HTML client, HTML client" description="Learn how to use an HTML client for Azure Mobile Services." metaCanonical="" services="mobile-services" documentationCenter="Mobile" title="How to use an HTML/JavaScript client for Azure Mobile Services" authors="glenga" solutions="" manager="dwrede" editor="" />

<tags ms.service="mobile-services" ms.workload="mobile" ms.tgt_pltfrm="mobile-html" ms.devlang="javascript" ms.topic="article" ms.date="11/21/2014" ms.author="glenga" />


# Использование клиента HTML/JavaScript для мобильных служб Azure

<div class="dev-center-tutorial-selector sublanding">
  <a href="/ru-ru/develop/mobile/how-to-guides/work-with-net-client-library/" title=".NET Framework">.NET Framework</a><a href="/ru-ru/develop/mobile/how-to-guides/work-with-html-js-client/" title="HTML/JavaScript" class="current">HTML/JavaScript</a><a href="/ru-ru/develop/mobile/how-to-guides/work-with-ios-client-library/" title="iOS">iOS</a><a href="/ru-ru/develop/mobile/how-to-guides/work-with-android-client-library/" title="Android">Android</a><a href="/ru-ru/develop/mobile/how-to-guides/work-with-xamarin-client-library/" title="Xamarin">Xamarin</a>
</div>


В этом руководстве показано, как реализовать типичные сценарии с использованием клиента HTML и JavaScript для мобильных служб Azure. В сценарии входят запрос данных, вставка, обновление и удаление данных, проверка подлинности пользователей и обработка ошибок. Если вы впервые работаете с мобильными службами, рекомендуем сначала проработать учебники [Быстрое начало работы (JavaScript для Магазина Windows)] или [Быстрое начало работы (HTML)]. Учебник quickstart поможет вам настроить учетную запись и создать свою первую мобильную службу.


## Оглавление

- [Что такое мобильные службы?]
- [Основные понятия]
- [Практическое руководство. Создание клиента мобильных служб]
- [Практическое руководство. Запрос данных из мобильной службы]
	- [Фильтрация возвращаемых данных]
    - [Сортировка возвращаемых данных]
	- [Возврат данных на страницах]
	- [Выбор определенных столбцов]
	- [Поиск данных по идентификатору]
	- [Выполнение операции запроса OData]
- [Практическое руководство. Вставка данных в мобильную службу]
- [Практическое руководство. Изменение данных в мобильной службе]
- [Практическое руководство. Удаление данных в мобильной службе]
- [Практическое руководство. Отображение данных в пользовательском интерфейсе]
- [Практическое руководство. Аутентификация пользователей]
- [Практическое руководство. Обработка ошибок]
- [Практическое руководство. Использование обещаний]
- [Практическое руководство. Настройка заголовков запроса]
- [Практическое руководство. Использование общего доступа к ресурсам независимо от источника]
- [Дальнейшие действия]

[WACOM.INCLUDE [mobile-services-concepts](../includes/mobile-services-concepts.md)]

##<a name="create-client"></a>Практическое руководство: Создание клиента мобильных служб



В веб-редакторе откройте HTML-файл проекта index.html и добавьте следующее выражение в ссылки сценария на страницу:

    <script src='http://ajax.aspnetcdn.com/ajax/mobileservices/MobileServices.Web-1.1.2.min.js'></script>

>[WACOM.NOTE]Для приложения для Магазина Windows, написанного на JavaScript или HTML, к проекту необходимо добавить только пакет NuGet **WindowsAzure.MobileServices.WinJS**.

В редакторе откройте или создайте файл JavaScript и добавьте следующий код, который определяет переменную "MobileServiceClient", и укажите URL-адрес и ключ приложения мобильной службы в конструкторе "MobileServiceClient" в указанном порядке:

	var MobileServiceClient = WindowsAzure.MobileServiceClient;
    var client = new MobileServiceClient('AppUrl', 'AppKey');

Необходимо заменить заполнитель "AppUrl" на URL-адрес приложения мобильной службы и "AppKey" на ключ приложения. Чтобы узнать, как получить URL-адрес приложения и ключ приложения для мобильной службы, изучите учебник [Приступая к работе с данными в Магазине Windows JavaScript] или [Приступая к работе с данными в HTML/JavaScript].

##<a name="querying"></a>Практическое руководство: Запрос данных из мобильной службы

Весь код, который обращается к данным или изменяет данные в таблице базы данных SQL, вызывает функции для объекта "MobileServiceTable". Чтобы получить ссылку на таблицу, вызовите функцию "getTable()" для экземпляра "MobileServiceClient".

    var todoItemTable = client.getTable('todoitem');


### <a name="filtering"></a>Практическое руководство: Фильтрация возвращаемых данных

Следующий код иллюстрирует способ фильтрации данных, включая предложение where в запросе. Он возвращает все элементы из todoItemTable, значение поля complete равно false. todoItemTable - это ссылка на таблицу мобильной службы, которая была создана ранее. Функция where применяет предикат фильтрации строк для запросов к таблице. Он принимает в качестве аргумента объект JSON, который определяет фильтр строк и возвращает запрос, который можно компоновать далее.

	var query = todoItemTable.where({
	    complete: false
	}).read().done(function (results) {
	    alert(JSON.stringify(results));
	}, function (err) {
	    alert("Error: " + err);
	});

Добавляя вызов where для объекта запроса и передавая объект в качестве параметра, мы инструктируем мобильные службы вернуть только те строки, в которых столбец complete содержит значение false. Кроме того, посмотрите на приведенный ниже URI запроса и обратите внимание на изменение самой строки запроса:

	GET /tables/todoitem?$filter=(complete+eq+false) HTTP/1.1

Можно просмотреть URI запроса, отправленного в мобильную службу, с помощью программы проверки сообщений, включая средства разработчика браузера и Fiddler.

На стороне сервера такой запрос обычно должен преобразовываться примерно в такой запрос SQL:

	SELECT *
	FROM TodoItem
	WHERE ISNULL(complete, 0) = 0

Объект, который передается в метод where, может иметь произвольное число параметров, и все они будут интерпретироваться как предложения AND в запросе. Например, следующая строка:

	query.where({
	   complete: false,
	   assignee: "david",
	   difficulty: "medium"
	}).read().done(function (results) {
	   alert(JSON.stringify(results));
	}, function (err) {
	   alert("Error: " + err);
	});

Будет преобразована (для того же запроса, приведенного выше) примерно в

	SELECT *
	FROM TodoItem
	WHERE ISNULL(complete, 0) = 0
	      AND assignee = 'david'
	      AND difficulty = 'medium'

Приведенная выше инструкция where и запрос SQL содержат незавершенные элементы, назначенные элементу david средней сложности (medium).

Однако существует другой способ составления того же запроса. Вызов where объекта запроса добавить выражение AND в предложение WHERE, поэтому мы могли написать его вместо этого в трех строках:

	query.where({
	   complete: false
	});
	query.where({
	   assignee: "david"
	});
	query.where({
	   difficulty: "medium"
	});

или с помощью гибкого API:

	query.where({
	   complete: false
	})
	   .where({
	   assignee: "david"
	})
	   .where({
	   difficulty: "medium"
	});

Эти два способа эквивалентны и могут быть взаимозаменяемыми. Пока все вызовы where принимали объект с некоторыми параметрами и сравнивались на предмет равенства с данными из базы данных. Однако есть другая перегрузка для метода запроса, который принимает функцию вместо объекта. Затем в этой функции можно составить более сложные выражения, используя операторы неравенства и другие реляционные операции. В этих функциях ключевое слово this привязывается к объекту сервера.

Тело функции преобразуется в логическое выражение Open Data Protocol (OData), которое передается в параметр строки запроса. Можно передать функцию, которая не принимает параметров, например:

    query.where(function () {
       return this.assignee == "david" && (this.difficulty == "medium" || this.difficulty == "low");
    }).read().done(function (results) {
       alert(JSON.stringify(results));
    }, function (err) {
       alert("Error: " + err);
    });


При передаче функции с параметрами любые аргументы после предложения where привязаны к параметрам функции в заданном порядке. Любые объекты, которые поступают из-за пределов области действия функции, ДОЛЖНЫ быть переданы в качестве параметров. Функция не может записывать любые внешние переменные. В двух следующих примерах аргумент david привязан к параметру name, а в первом примере аргумент meidum также привязан к параметру level. Кроме того, функция должна состоять из одной инструкции return с поддерживаемым выражением, например:

	 query.where(function (name, level) {
	    return this.assignee == name && this.difficulty == level;
	 }, "david", "medium").read().done(function (results) {
	    alert(JSON.stringify(results));
	 }, function (err) {
	    alert("Error: " + err);
	 });

Поэтому пока мы следуем правилам, мы можем добавить в наши запросы баз данных более сложные фильтры, например:

    query.where(function (name) {
       return this.assignee == name &&
          (this.difficulty == "medium" || this.difficulty == "low");
    }, "david").read().done(function (results) {
       alert(JSON.stringify(results));
    }, function (err) {
       alert("Error: " + err);
    });

Можно объединить "where" с "orderBy", "take" и "skip". подробности приведены в следующем разделе.

### <a name="sorting"></a>Практическое руководство: Сортировка возвращаемых данных

Следующий код показывает, как сортировать данные, включая функции запроса "orderBy" или "orderByDescending". Он возвращает элементы из "todoItemTable", упорядочивая их в восходящем порядке по полю "text". По умолчанию сервер возвращает только первые 50 элементов.

<div class="dev-callout"><strong>Примечание.</strong> <p>Чтобы предотвратить возврат всех элементов, по умолчанию используется размер страницы, управляемый сервером. Это предотвращает негативное воздействие больших наборов данных на функционирование службы. </p> </div>
>
Можно увеличить количество возвращаемых элементов путем вызова take, как описано в следующем разделе. todoItemTable - это ссылка на таблицу мобильной службы, которая была создана ранее.

	var ascendingSortedTable = todoItemTable.orderBy("text").read().done(function (results) {
	   alert(JSON.stringify(results));
	}, function (err) {
	   alert("Error: " + err);
	});

	var descendingSortedTable = todoItemTable.orderByDescending("text").read().done(function (results) {
	   alert(JSON.stringify(results));
	}, function (err) {
	   alert("Error: " + err);
	});

	var descendingSortedTable = todoItemTable.orderBy("text").orderByDescending("text").read().done(function (results) {
	   alert(JSON.stringify(results));
	}, function (err) {
	   alert("Error: " + err);
	});

### <a name="paging"></a>Практическое руководство: Возврат данных на страницах

В следующем коде показано, как реализовать разбиение возвращенных данных по страницам с помощью предложений take и skip в запросе.  При выполнении следующего запроса будут возвращены три главных элемента в таблице.

	var query = todoItemTable.take(3).read().done(function (results) {
	   alert(JSON.stringify(results));
	}, function (err) {
	   alert("Error: " + err);
	});

Обратите внимание, что метод "take(3)" был преобразован в параметр запроса "$top=3" в универсальном коде ресурса запроса.

Следующий измененный запрос пропускает первые три результата и после этого возвращает следующие три. Это фактически вторая "страница" данных, где размер страницы составляет три элемента.

	var query = todoItemTable.skip(3).take(3).read().done(function (results) {
	   alert(JSON.stringify(results));
	}, function (err) {
	   alert("Error: " + err);
	});

И снова вы можете просмотреть URI запроса, отправленного в мобильную службу. Обратите внимание, что метод "skip(3)" был преобразован в параметр запроса "$skip=3" в универсальном коде ресурса запроса.

Это упрощенный сценарий передачи жестко запрограммированных значений разбиения по страницам в методы take и skip. В реальных приложениях можно использовать запросы, подобные вышеуказанным с постраничным навигатором или с другим совместимым пользовательским интерфейсом, позволяющим переходить на следующую страницу или возвращаться к предыдущей странице.

### <a name="selecting"></a>Практическое руководство: Выбор определенных столбцов

Можно задать набор свойств, включаемых в результаты, добавив к запросу предложение select. Например, следующий код возвращает свойства "id", "complete" и "text" из каждой строки в "todoItemTable":

	var query = todoItemTable.select("id", "complete", "text").read().done(function (results) {
	   alert(JSON.stringify(results));
	}, function (err) {
	   alert("Error: " + err);
	})

Здесь параметры функции select являются именами столбцов таблицы, которые требуется вернуть.


Все описанные функции являются суммируемыми, поэтому каждая последующая вызываемая функция будет продолжать влиять на запрос. Еще один пример:

    query.where({
       complete: false
    })
       .select('id', 'assignee')
       .orderBy('assignee')
       .take(10)
       .read().done(function (results) {
       alert(JSON.stringify(results));
    }, function (err) {
       alert("Error: " + err);

### <a name="lookingup"></a>Практическое руководство: Поиск данных по идентификатору

Функция lookup принимает только значение id и возвращает объект из базы данных с этим идентификатором. Таблицы базы данных создаются со столбцом id целочисленных или строковых значений. Столбец id со строковыми значениями используется по умолчанию.

	todoItemTable.lookup("37BBF396-11F0-4B39-85C8-B319C729AF6D").done(function (result) {
	   alert(JSON.stringify(result));
	}, function (err) {
	   alert("Error: " + err);
	})

##<a name="odata-query"></a>Выполнение операции запроса OData

Для создания и выполнения запросов REST мобильные службы используют соглашения об универсальных кодах ресурса (URI) запросов OData.  С помощью встроенных функций запросов невозможно создать некоторые запросы OData, особенно такие сложные операции фильтрации, как поиск подстроки в свойстве. Для таких сложных запросов можно передать строку параметра какого-либо действительного запроса OData в функцию "read", как показано ниже.

	function refreshTodoItems() {
	    todoItemTable.read("$filter=substringof('search_text',text)").then(function(items) {
	        var itemElements = $.map(items, createUiForTodoItem);
	        $("#todo-items").empty().append(itemElements);
	        $("#no-items").toggle(items.length === 0);
	    }, handleError);
	}

>[WACOM.NOTE]При передаче строки с параметром необработанного запроса OData в функцию "read" в этом запросе невозможно использовать методы создания запросов. В этом случае необходимо создать весь запрос в виде строки запроса OData. Дополнительную информацию о параметрах системы запросов OData см. в [справочнике по параметрам системных запросов OData].

<h2><a name="inserting"></a>Практическое руководство: Вставка данных в мобильную службу</h2>

В следующем коде показано, как вставить новые строки в таблицу. Клиент запрашивает вставку строки данных путем отправки запроса POST в мобильную службу. Текст запроса содержит данные, которые вставлены в качестве объекта JSON.

	todoItemTable.insert({
	   text: "New Item",
	   complete: false
	})

Это приводит к вставке в таблицу данных из предоставленного объекта JSON. Можно также указать функцию обратного вызова, которая будет вызываться после завершения вставки:

	todoItemTable.insert({
	   text: "New Item",
	   complete: false
	}).done(function (result) {
	   alert(JSON.stringify(result));
	}, function (err) {
	   alert("Error: " + err);
	});


Мобильные службы поддерживают уникальные настраиваемые строковые значения идентификатора таблицы. Это позволяет приложениям использовать настраиваемые значения, например, адреса электронной почты или имена пользователей, для столбца идентификатора таблицы мобильных служб. Например, если требуется идентифицировать каждую запись по адресу электронной почты, можно использовать следующий объект JSON.

			todoItemTable.insert({
			   id: "myemail@domain.com",
			   text: "New Item",
			   complete: false
			})

Если значение идентификатора строки не указано при вставке новых записей в таблицу, мобильные службы создают уникальное значение идентификатора.

Поддержка строковых идентификаторов предоставляет разработчикам следующие преимущества:

+ Идентификаторы можно создавать без обмена данными с базой данных.
+ Можно легко объединять записи из разных таблиц или баз данных.
+ Значения идентификаторов можно удобно интегрировать с логикой приложения.

Серверные скрипты также можно использовать для задания значений идентификаторов. В следующем примере скрипта создается настраиваемый идентификатор GUID, который назначается идентификатору новой записи. Этот идентификатор похож на значение, создаваемое мобильными службами, если не передать значение идентификатора записи.

	//Example of generating an id. This is not required since Mobile Services
	//will generate an id if one is not passed in.
	item.id = item.id || newGuid();
	request.execute();

	function newGuid() {
		var pad4 = function(str) { return "0000".substring(str.length) + str; };
		var hex4 = function () { return pad4(Math.floor(Math.random() * 0x10000 /* 65536 */ ).toString(16)); };
		return (hex4() + hex4() + "-" + hex4() + "-" + hex4() + "-" + hex4() + "-" + hex4() + hex4() + hex4());
	}


Если приложение предоставляет значение для идентификатора, мобильные службы сохраняют его как есть. (В том числе с начальными или конечными пробелами.) Пробелы не удаляются из идентификатора.

Значение идентификатора должно быть уникальным и не должно содержать символы из следующих наборов:

+ Управляющие символы: [0x0000-0x001F] и [0x007F-0x009F]. Дополнительную информацию см. в статье [Управляющие коды ASCII C0 и C1].
+  Печатные символы: **"**(0x0022), **\+** (0x002B), **/** (0x002F), **?** (0x003F), **\\** (0x005C), **`** (0x0060)
+  Идентификаторы "." и ".."

Также для таблиц можно использовать целочисленные идентификаторы. Для этого необходимо создать таблицу с помощью команды mobile table create с параметром --integerId. Эта команда используется в интерфейсе командной строки (CLI) Azure. Дополнительную информацию об использовании CLI см. в статье [Интерфейс командной строки для управления таблицами мобильных служб].


<h2><a name="modifying"></a>Практическое руководство: Изменение данных в мобильной службе</h2>

В следующем коде показано, как обновить данные в таблице. Клиент запрашивает обновление строки данных путем отправки запроса PATCH в мобильную службу. Текст запроса содержит определенные поля, которые должны быть обновлены в качестве объекта JSON. Обновляется существующий элемент в таблице "todoItemTable".

			todoItemTable.update({
			   id: idToUpdate,
			   text: newText
			})

Первый параметр указывает экземпляр для обновления в таблице, который указан в идентификаторе.

Можно также указать функцию обратного вызова, которая будет вызываться после завершения обновления:

			todoItemTable.update({
			   id: idToUpdate,
			   text: newText
			}).done(function (result) {
			   alert(JSON.stringify(result));
			}, function (err) {
			   alert("Error: " + err);
			});

<h2><a name="deleting"></a>Практическое руководство: Удаление данных в мобильной службе</h2>

В следующем коде показано, как удалить данные из таблицы. Клиент запрашивает удаления строки данных путем отправки запроса POST DELETE в мобильную службу. Это приводит к удалению существующих элементов в таблице todoItemTable.

			todoItemTable.del({
			   id: idToDelete
			})

Первый параметр указывает экземпляр для удаления в таблице, который указан в идентификаторе.

Можно также указать функцию обратного вызова, которая будет вызываться после завершения удаления:

			todoItemTable.del({
			   id: idToDelete
			}).done(function () {
			   /* Do something */
			}, function (err) {
			   alert("Error: " + err);
			});

<h2><a name="binding"></a>Практическое руководство: Отображение данных в пользовательском интерфейсе</h2>

В этом разделе показано, как отображать возвращенные объекты данных с использованием элементов пользовательского интерфейса. Чтобы запросить элементы в "todoItemTable" и отобразить результаты в простом списке, можно выполнить следующий пример кода. Выделенные элементы отсутствуют, выполняется фильтрация и сортировка любого рода.

			var query = todoItemTable;

			query.read().then(function (todoItems) {
			   // The space specified by 'placeToInsert' is an unordered list element <ul> ... </ul>
			   var listOfItems = document.getElementById('placeToInsert');
			   for (var i = 0; i < todoItems.length; i++) {
			      var li = document.createElement('li');
			      var div = document.createElement('div');
			      div.innerText = todoItems[i].text;
			      li.appendChild(div);
			      listOfItems.appendChild(li);
			   }
			}).read().done(function (results) {
			   alert(JSON.stringify(results));
			}, function (err) {
			   alert("Error: " + err);
			});

В приложении для Магазина Windows результаты запроса могут быть использованы для создания объекта [WinJS.Binding.List], который может быть привязан в качестве источника данных к объекту [ListView]. Дополнительную информацию см. в разделе [Привязка данных (приложения Магазина Windows с использованием JavaScript и HTML)].

<h2><a name="caching"></a>Практическое руководство: Аутентификация пользователей</h2>

Мобильные службы поддерживают аутентификацию и авторизацию пользователей с помощью различных внешних поставщиков удостоверений: Facebook, Google, учетной записи Майкрософт и Twitter. Можно задать разрешения таблиц, чтобы предоставить доступ к определенным операциям только пользователям, прошедшим проверку подлинности. Удостоверения пользователей, прошедших проверку подлинности, также можно применять для реализации правил авторизации в серверных скриптах. Дополнительную информацию см. в учебнике [Приступая к работе с аутентификацией].

Поддерживаются два потока проверки подлинности: _серверный_ и _клиентский_. Серверный поток обеспечивает самый простой способ проверки подлинности, так как он использует веб-интерфейс проверки подлинности. Клиентский поток обеспечивает более тесную интеграцию с возможностями устройства, такими как единый вход, так как использует пакеты SDK конкретного поставщика для конкретного устройства.

<h3>Серверный поток</h3>
Чтобы мобильная служба могла выполнять процесс проверки подлинности в вашем приложении для магазина Windows или для приложения HTML 5, необходимо зарегистрировать приложение у поставщика удостоверений. Затем в вашей мобильной службе необходимо настроить код приложения и секретный код, предоставленный поставщиком. Дополнительную информацию см. в учебнике "Приступая к работе с аутентификацией" ([Магазин Windows][Get started with authentication Windows Store]/[HTML][Get started with authentication]).

После регистрации у поставщика удостоверений просто вызовите [метод LoginAsync] с указанием значения [MobileServiceAuthenticationProvider] вашего поставщика. Например, для входа в систему через Facebook используйте следующий код.

		client.login("facebook").done(function (results) {
		     alert("You are now logged in as: " + results.userId);
		}, function (err) {
		     alert("Error: " + err);
		});

Если используется поставщик удостоверений, отличный от Facebook, измените значение, передаваемое в метод "login" выше, на одно из следующих: microsoftaccount, facebook, twitter, google или windowsazureactivedirectory.

В этом случае мобильная служба управляет потоком проверки подлинности OAuth 2.0, отображая страницу входа выбранного поставщика и генерируя маркер проверки подлинности мобильных служб после успешного соединения с поставщиком удостоверений. Функция [login] после завершения работы возвращает объект JSON (**user**), который содержит и идентификатор пользователя и маркер проверки аутентификации мобильных служб в полях **userId** и **authenticationToken** соответственно. Этот маркер можно кэшировать и повторно использовать до истечения срока его действия. Дополнительную информацию см. в разделе [Кэширование маркера аутентификации].

<div class="dev-callout"><b>Приложение Магазина Windows</b>
<p>Если вы используете поставщик входа в систему учетных записей Майкрософт для аутентификации пользователей в приложении для Магазина Windows, необходимо также зарегистрировать этот пакет приложения в мобильных службах. При регистрации сведений пакета приложений магазина Windows с помощью мобильных служб клиент сможет повторно использовать учетные данные для входа в учетную запись Майкрософт для осуществления единого входа. Если этого не сделать, пользователям входа учетной записи Майкрософт придется осуществлять вход в систему при каждом вызове метода входа в систему. Чтобы узнать, как зарегистрировать пакет приложения для Магазина Windows, см. <a href="/ru-ru/develop/mobile/how-to-guides/register-windows-store-app-package/" target="_blank">Регистрация пакета приложения для магазина Windows для проверки подлинности Microsoft</a>. После регистрации пакета приложения в мобильных службах, вызовите метод <a href="http://go.microsoft.com/fwlink/p/?LinkId=322050" target="_blank">вход</a> , указав значение <strong>true</strong> для <em>useSingleSignOn</em> , чтобы использовать учетные данные повторно.</p>
</div>

<h3>Клиентский поток</h3>
Приложение может также независимо связаться с поставщиком удостоверений и указать возвращаемый маркер в мобильные службы для проверки подлинности. Этот клиентский поток позволяет пользователям выполнять единый вход или получать дополнительные данные о пользователе от поставщика удостоверений.

В следующем примере используется пакет SDK Live, поддерживающий единый вход в приложения Магазина Windows с использованием учетной записи Майкрософт:

		WL.login({ scope: "wl.basic"}).then(function (result) {
		      client.login(
		            "microsoftaccount",
		            {"authenticationToken": result.session.authentication_token})
		      .done(function(results){
		            alert("You are now logged in as: " + results.userId);
		      },
		      function(error){
		            alert("Error: " + err);
		      });
		});

Этот упрощенный пример получает маркер из Live Connect, который предоставляется мобильным службам путем вызова функции [login]. Более полный пример использования учетной записи Майкрософт для обеспечения единого входа см. в разделе [Аутентификация приложения для Магазина Windows с помощью единого входа].

При использовании интерфейсов API Facebook или Google для проверки подлинности клиентов следует немного изменить пример.

		client.login(
		     "facebook",
		     {"access_token": token})
		.done(function (results) {
		     alert("You are now logged in as: " + results.userId);
		}, function (err) {
		     alert("Error: " + err);
		});

В этом примере предполагается, что маркер, предоставленный соответствующим поставщиком SDK, сохраняется в переменной token.
В настоящее время Twitter не может использоваться для проверки подлинности клиента.

<h3>Кэширование маркера аутентификации</h3>
В некоторых случаях вызова способа входа в систему можно избежать первого выполнения проверки подлинности пользователя. Мы можем использовать [sessionStorage] или [localStorage] для кэширования удостоверения текущего пользователя при первом входе, а затем будем проверять, содержится ли удостоверение этого пользователя в кэше. Если кэш является пустым или вызовы завершаются со сбоем (то есть истекло время текущего сеанса входа), нам необходимо пройти процедуру входа.

        // After logging in
        sessionStorage.loggedInUser = JSON.stringify(client.currentUser);

        // Log in
        if (sessionStorage.loggedInUser) {
           client.currentUser = JSON.parse(sessionStorage.loggedInUser);
        } else {
           // Regular login flow
       }

         // Log out
        client.logout();
        sessionStorage.loggedInUser = null;


<h2><a name="errors"></a>Практическое руководство: Обработка ошибок</h2>

Существует несколько способов выявления, проверки и устранения ошибок в мобильных службах.

Например, серверные сценарии зарегистрированы в мобильной службе и могут использоваться для выполнения различных операций со вставляемыми и обновляемыми данными, включая проверку и изменение данных. Процесс определения и регистрации серверного сценария для проверки и изменения данных можно представить следующим образом:

			function insert(item, user, request) {
			   if (item.text.length > 10) {
				  request.respond(statusCodes.BAD_REQUEST, { error: "Text cannot exceed 10 characters" });
			   } else {
			      request.execute();
			   }
			}

Серверный сценарий проверяет длину строки данных, отправленных в мобильную службу, и отклоняет слишком длинные строки; в этом случае отклоняются строки длиной более 10 знаков.

Теперь, когда мобильная служба выполняет проверку данных и отправляет сообщения об ошибках на стороне сервера, можно обновить приложение HTML для обработки сообщений об ошибках, полученных при выполнении проверки.

		todoItemTable.insert({
		   text: itemText,
		   complete: false
		})
		   .then(function (results) {
		   alert(JSON.stringify(results));
		}, function (error) {
		   alert(JSON.parse(error.request.responseText).error);
		});


Далее можно передать обработчик ошибок в качестве второго аргумента при каждом доступе к данным:

			function handleError(message) {
			   if (window.console && window.console.error) {
			      window.console.error(message);
			   }
			}

			client.getTable("tablename").read().then(function (data) { /* do something */ }, handleError);

<h2><a name="promises"></a>Практическое руководство: Использование обещаний</h2>

Обещания предоставляют механизм планирования выполнения работы со значением, которое еще не было вычислено. Это абстракция для управления взаимодействиями с асинхронными интерфейсами API.

Обещание done выполняется, как только, предоставленная ему функция завершается как успешно, так и с ошибкой. В отличие от обещания then гарантируется вызов любой ошибки, которая не обрабатывается внутри функции, а после выполнения обработчиков эта функция вызывает любую ошибку, которая была возвращена в качестве обещания в состоянии ошибки. Дополнительную информацию см. в описании [done].

			promise.done(onComplete, onError);

Следующим образом:

			var query = todoItemTable;
			query.read().done(function (results) {
			   alert(JSON.stringify(results));
			}, function (err) {
			   alert("Error: " + err);
			});

Обещание then не отличается от обещания done, однако в отличие от обещания then обещание done гарантирует вызов ошибки, которая не обрабатывается внутри функции. Если не предоставить обработчик ошибок для обещания then, а операция содержит ошибку, исключение не вызывается, но возвращает обещание в состоянии ошибки. Дополнительную информацию см. в описании [then].

			promise.then(onComplete, onError).done( /* Your success and error handlers */ );

Следующим образом:

			var query = todoItemTable;
			query.read().done(function (results) {
			   alert(JSON.stringify(results));
			}, function (err) {
			   alert("Error: " + err);
			});

Обещания можно использовать различными способами. Можно выстраивать последовательности операций обещаний путем вызова then или done для обещания, которое было возвращено предыдущей функцией then. Используйте then для промежуточного этапа операции (например, ".then().then()"), а done для окончательного этапа операции (например, ".then().then().done()").  Можно связать несколько функций then, так как then возвращает обещание. Невозможно связывать более одного метода done, так как возвращается неопределенное значение. [Дополнительная информация о различиях между then и done].

 			todoItemTable.insert({
 			   text: "foo"
 			}).then(function (inserted) {
 			   inserted.newField = 123;
 			   return todoItemTable.update(inserted);
 			}).done(function (insertedAndUpdated) {
 			   alert(JSON.stringify(insertedAndUpdated));
 			})

<h2><a name="customizing"></a>Практическое руководство: Настройка заголовков запроса клиента</h2>

Можно отправлять пользовательские заголовки запросов, используя функцию withFilter, считывая и записывая необязательные свойства запроса, которые будут отправлены в рамках фильтра. Может понадобиться добавить подобный пользовательский заголовок HTTP, если он будет востребован сценарием на стороне сервера или сможет улучшить работу этого сценария.

			var client = new WindowsAzure.MobileServiceClient('https://your-app-url', 'your-key')
			   .withFilter(function (request, next, callback) {
			   request.headers.MyCustomHttpHeader = "Some value";
			   next(request, callback);
			});

Фильтры используются гораздо шире, чем настройка заголовков запросов. Они могут использоваться для изучения или изменения запросов, изучения или изменения ответов, обхода сетевых вызовов, отправки нескольких вызовов и т. д.

<h2><a name="hostnames"></a>Практическое руководство: Использование общего доступа к ресурсам независимо от источника</h2>

Чтобы управлять тем, каким веб-сайтам разрешено взаимодействовать с мобильной службой и отправлять в нее запросы, необходимо добавить имя узла веб-сайта, на котором размещена мобильная служба, в список общего доступа к ресурсам независимо от источника (CORS) на вкладке "Настроить". При необходимости можно использовать подстановочные знаки. По умолчанию новые мобильные службы указывают браузерам разрешать доступ только с узла localhost, а общий доступ к ресурсам независимо от источника (CORS) позволяет коду JavaScript работать в браузере на внешнем имени узла для взаимодействия с вашей мобильной службой.  Эта конфигурация не является необходимой для приложений WinJS.

<h2><a name="nextsteps"></a>Дальнейшие действия</h2>

Теперь, когда вы закончили изучение этого концептуального раздела, узнайте более подробно, как можно выполнять дополнительные важные задачи в мобильных службах.

* [Приступая к работе с мобильными службами]
  <br/>Сведения об основах использования мобильных служб.

* [Приступая к работе с данными]
  <br/>Дополнительная информация о хранении данных и запросах к ним при помощи мобильных служб.

* [Приступая к работе с аутентификацией]
  <br/>Дополнительные сведения о проверке подлинности пользователей приложения с использованием поставщика удостоверений.

* [Проверка и изменение данных с помощью сценариев]
  <br/>Дополнительные сведения об использовании серверных скриптов в мобильных службах для проверки и изменения данных, отправляемых из приложения.

* [Уточнение запросов посредством разбиения по страницам]
  <br/>Сведения об использовании разбиения по страницам в запросах для управления объемом данных, обрабатываемым в одном запросе.

* [Авторизация пользователей с помощью сценариев]
  <br/>Сведения об использовании значения идентификатора пользователя, предоставляемого мобильными службами на основе пользователя, прошедшего проверку подлинности, для фильтрации данных, возвращаемых мобильными службами.

<!-- Anchors. -->
[Что такое мобильные службы?]: #what-is
[Основные понятия]: #concepts
[Практическое руководство. Создание клиента мобильных служб]: #create-client
[Практическое руководство. Запрос данных из мобильной службы]: #querying
[Фильтрация возвращаемых данных]: #filtering
[Сортировка возвращаемых данных]: #sorting
[Возврат данных на страницах]: #paging
[Выбор определенных столбцов]: #selecting
[Поиск данных по идентификатору]: #lookingup
[Практическое руководство. Отображение данных в пользовательском интерфейсе]: #binding
[Практическое руководство. Вставка данных в мобильную службу]: #inserting
[Практическое руководство. Изменение данных в мобильной службе]: #modifying
[Практическое руководство. Удаление данных в мобильной службе]: #deleting
[Практическое руководство. Аутентификация пользователей]: #caching
[Практическое руководство. Обработка ошибок]: #errors
[Практическое руководство. Использование обещаний]: #promises
[Практическое руководство. Настройка заголовков запроса]: #customizing
[Практическое руководство. Использование общего доступа к ресурсам независимо от источника]: #hostnames
[Дальнейшие действия]: #nextsteps
[Выполнение операции запроса OData]: #odata-query



<!-- URLs. -->
[Приступая к работе с мобильными службами]: /ru-ru/develop/mobile/tutorials/get-started-html
[Пакет SDK для мобильных служб]: http://go.microsoft.com/fwlink/?LinkId=257545
[Приступая к работе с данными]: http://www.windowsazure.com/ru-ru/develop/mobile/tutorials/get-started-with-data-html/
[Приступая к работе с аутентификацией]: /ru-ru/develop/mobile/tutorials/get-started-with-users-html
[Приступая к работе с аутентификацией (Магазин Windows)]: /ru-ru/develop/mobile/tutorials/get-started-with-users-js
[then]: http://msdn.microsoft.com/ru-ru/library/windows/apps/br229728.aspx
[done]: http://msdn.microsoft.com/ru-ru/library/windows/apps/hh701079.aspx
[Дополнительная информация о различиях между then и done]: http://msdn.microsoft.com/ru-ru/library/windows/apps/hh700334.aspx
[обработка ошибок в обещаниях]: http://msdn.microsoft.com/ru-ru/library/windows/apps/hh700337.aspx

[sessionStorage]: http://msdn.microsoft.com/ru-ru/library/cc197062(v=vs.85).aspx
[localStorage]: http://msdn.microsoft.com/ru-ru/library/cc197062(v=vs.85).aspx

[ListView]: http://msdn.microsoft.com/ru-ru/library/windows/apps/br211837.aspx
[Привязка данных (приложения Магазина Windows с использованием JavaScript и HTML)]: http://msdn.microsoft.com/ru-ru/library/windows/apps/hh758311.aspx
[Краткое руководство по Магазину Windows с использованием JavaScript]: http://www.windowsazure.com/ru-ru/develop/mobile/tutorials/get-started
[Краткое руководство по HTML]: http://www.windowsazure.com/ru-ru/develop/mobile/tutorials/get-started-html
[Приступая к работе с данными в Магазине Windows с использованием JavaScript]: http://www.windowsazure.com/ru-ru/develop/mobile/tutorials/get-started-with-data-js
[Приступая к работе с данными в HTML/JavaScript]: http://www.windowsazure.com/ru-ru/develop/mobile/tutorials/get-started-with-data-html/
[Здесь можно просмотреть полный пример использования этого сценария]: http://www.windowsazure.com/ru-ru/develop/mobile/tutorials/single-sign-on-windows-8-js/
[Приступая к работе с данными]: /ru-ru/develop/mobile/tutorials/get-started-with-data-html
[Проверка и изменение данных с помощью сценариев]: /ru-ru/develop/mobile/tutorials/validate-modify-and-augment-data-html
[Уточнение запросов посредством разбиения по страницам]: /ru-ru/develop/mobile/tutorials/add-paging-to-data-html
[Авторизация пользователей с помощью сценариев]: /ru-ru/develop/mobile/tutorials/authorize-users-in-scripts-html
[вход]: http://msdn.microsoft.com/ru-ru/library/windowsazure/jj554236.aspx
[Аутентификация приложения с помощью единого входа]: /ru-ru/develop/mobile/tutorials/single-sign-on-windows-8-dotnet/
[Управляющие коды ASCII C0 и C1]: http://en.wikipedia.org/wiki/Data_link_escape_character#C1_set
[Интерфейс командной строки для управления таблицами мобильных служб]: http://www.windowsazure.com/ru-ru/manage/linux/other-resources/command-line-tools/#Mobile_Tables
[Справочник по параметрам системного запроса OData]: http://go.microsoft.com/fwlink/p/?LinkId=444502

<!--HONumber=35_1-->
