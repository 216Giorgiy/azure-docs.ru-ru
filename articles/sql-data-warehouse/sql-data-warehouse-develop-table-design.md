<properties
   pageTitle="Проектирование таблиц в хранилище данных SQL | Microsoft Azure"
   description="Советы по проектированию таблиц в хранилище данных SQL Azure для разработки решений."
   services="sql-data-warehouse"
   documentationCenter="NA"
   authors="jrowlandjones"
   manager="barbkess"
   editor=""/>

<tags
   ms.service="sql-data-warehouse"
   ms.devlang="NA"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="data-services"
   ms.date="05/14/2016"
   ms.author="jrj;barbkess;sonyama"/>

# Проектирование таблиц в хранилище данных SQL #
Хранилище данных SQL является распределенной системой баз данных с массовой параллельной обработкой (MPP). Она хранит данные во множестве разных расположений, которые называются **распределениями**. Каждое **распределение** — как контейнер, в нем хранится уникальное подмножество данных в хранилище данных. Распределяя данные и возможности обработки между несколькими узлами, хранилище данных SQL может предложить огромную масштабируемость — намного больше любой единой системы.

При создании таблицы в хранилище данных SQL она фактически распределяется по всем распределениям.

В этой статье рассматриваются следующие темы:

- Поддерживаемые типы данных.
- Принципы распределения данных.
- Циклическое распределение.
- Хэш-распределение.
- Секционирование таблиц.
- Статистика
- Неподдерживаемые функции.

## Поддерживаемые типы данных
Хранилище данных SQL поддерживает общие типы бизнес-данных:

- **bigint**
- **binary**
- **bit**
- **char**
- **date**
- **datetime**
- **datetime2**
- **datetimeoffset**
- **decimal**
- **float**
- **int**
- **money**
- **nchar**
- **nvarchar**
- **real**
- **smalldatetime**
- **smallint**
- **smallmoney**
- **sysname**
- **time**
- **tinyint**
- **uniqueidentifier**
- **varbinary**
- **varchar**

С помощью следующего запроса в хранилище данных можно определить столбцы, которые содержат несовместимые типы:

```sql
SELECT  t.[name]
,       c.[name]
,       c.[system_type_id]
,       c.[user_type_id]
,       y.[is_user_defined]
,       y.[name]
FROM sys.tables  t
JOIN sys.columns c on t.[object_id]    = c.[object_id]
JOIN sys.types   y on c.[user_type_id] = y.[user_type_id]
WHERE y.[name] IN
                (   'geography'
                ,   'geometry'
                ,   'hierarchyid'
                ,   'image'
                ,   'ntext'
                ,   'sql_variant'
                ,   'text'
                ,   'timestamp'
                ,   'xml'
                )
AND  y.[is_user_defined] = 1
;

```

Запрос включает любые пользовательские типы данных, которые не поддерживаются. Ниже приведены некоторые альтернативы, которые можно использовать вместо неподдерживаемых типов данных.

Используйте такую замену:

- Вместо **geometry** используйте varbinary.
- Вместо **geography** используйте varbinary.
- Вместо **hierarchyid** используйте не собственный тип данных CLR.
- Вместо **image**, **text**, **ntext** (для текста) используйте varchar/nvarchar (чем меньше, тем лучше).
- Не используйте **sql\_variant**. Вместо этого разделите столбец на несколько строго типизированных столбцов.
- **table** преобразуйте во временные таблицы.
- Не используйте **timestamp**, но переработайте код, чтобы использовать datetime2 и функцию `CURRENT_TIMESTAMP`. Примечание. Вы не можете использовать current\_timestamp как ограничение по умолчанию. Значение не обновляется автоматически. Если надо перенести значения rowversion из типизированного столбца timestamp, используйте binary(8) или varbinary(8) для значений версии строки NOT NULL или NULL.
- Преобразуйте **user defined types** обратно в их исходный тип, если это возможно.
- Вместо **xml** используйте varchar(max) или меньшую версию для лучшей производительности.

Для повышения производительности:

- Вместо **nvarchar(max)** используйте nvarchar(4000) или меньшую версию для лучшей производительности.
- Вместо **nvarchar(max)** используйте varchar(8000) или меньшую версию для лучшей производительности.

Частичная поддержка:

- Ограничения по умолчанию поддерживает только литералы и константы. Недетерминированные выражения или функции, такие как `GETDATE()` или `CURRENT_TIMESTAMP`, не поддерживаются.

> [AZURE.NOTE] Если для загрузки таблиц используется Polybase, настройте таблицы, чтобы максимальный размер строки, включая полную длину столбцов переменной длины, не превышал 32 767 байт. Вы можете задать строку с данными переменной длины, размер которой превышает это значение, и загрузить строки с помощью BCP, но вы не сможете использовать Polybase для их загрузки. Вскоре в Polybase будет добавлена поддержка широких строк. Кроме того, попробуйте ограничить размер столбцов переменной длины, чтобы еще больше повысить пропускную способность, нужную для выполнения запросов.

## Принципы распределения данных

Существует два варианта распределения данных в хранилище данных SQL:

1. Распределение данных равномерно, но случайным образом.
2. Распределение данных на основании хэширования значений из одного столбца.

Распределение данных определяется на уровне таблицы. Все таблицы распределяются. Вы назначите распределение для каждой таблицы в своей базе данных хранилища данных SQL.

Первый вариант называется **циклическим** распределением. Иногда его называют случайным хэшем. Можно считать этот вариант используемым по умолчанию или отказоустойчивым.

Второй вариант называется **хэш**-распределением. Его можно считать оптимизированной версией распределения данных. Он предпочтителен, когда кластеры таблиц используют общие критерии соединения или агрегирования.

## Циклическое распределение

Циклическое распределение — это метод равномерного распределения данных по всем распределениям. Буферы, содержащие строки данных, по очереди выделяются (отсюда и название — «циклическое») для каждого распределения. Этот процесс повторяется, пока не будут выделены все буферы данных. Данные в таблице, распределенной циклически, не сортируются и не упорядочиваются. По этой причине циклическое распределение иногда называют случайным хэшем. Данные равномерно распределяются между распределениями.

Ниже приведен пример циклически распределенной таблицы:

```sql
CREATE TABLE [dbo].[FactInternetSales]
(   [ProductKey]            int          NOT NULL
,   [OrderDateKey]          int          NOT NULL
,   [CustomerKey]           int          NOT NULL
,   [PromotionKey]          int          NOT NULL
,   [SalesOrderNumber]      nvarchar(20) NOT NULL
,   [OrderQuantity]         smallint     NOT NULL
,   [UnitPrice]             money        NOT NULL
,   [SalesAmount]           money        NOT NULL
)
WITH
(   CLUSTERED COLUMNSTORE INDEX
,   DISTRIBUTION = ROUND_ROBIN
)
;
```

Вот еще пример циклически распределенной таблицы:

```sql
CREATE TABLE [dbo].[FactInternetSales]
(   [ProductKey]            int          NOT NULL
,   [OrderDateKey]          int          NOT NULL
,   [CustomerKey]           int          NOT NULL
,   [PromotionKey]          int          NOT NULL
,   [SalesOrderNumber]      nvarchar(20) NOT NULL
,   [OrderQuantity]         smallint     NOT NULL
,   [UnitPrice]             money        NOT NULL
,   [SalesAmount]           money        NOT NULL
)
WITH
(   CLUSTERED COLUMNSTORE INDEX
)
;
```

> [AZURE.NOTE] Обратите внимание, что во втором примере не упоминается ключ распределения. Циклический перебор используется по умолчанию, поэтому ключ абсолютно не нужен. Тем не менее, явное указание считается хорошей практикой, так как гарантирует, что коллеги будут знать о ваших намерениях при просмотре структуры таблицы.

Если нет очевидного ключевого столбца для хэширования данных, обычно используется этот тип таблицы. Он может также использоваться для таблиц меньшего размера или значения, где стоимость перемещения может быть не очень выгодной.

Загрузка данных в распределенную циклически таблицу обычно происходит быстрее, чем загрузка в хэш-распределенную таблицу. При использовании циклически распределенной таблицы нет необходимости понимать данные или выполнить хэширование перед загрузкой. По этой причине циклические таблицы часто являются удобными целями для загрузки.

> [AZURE.NOTE] Если данные распределяются циклически, они выделяется в распределения на уровне *буферов*.

### Рекомендации

Рассмотрите возможность использования циклического распределения для таблицы в следующих сценариях:

- Если нет очевидного ключа соединения.
- Если потенциальный ключ хэш-распределения неизвестен.
- Если таблица не используют общий ключ соединения с другими таблицами.
- Если соединение менее важно, чем других соединения в запросе.
- Если таблица является таблицей начальной загрузки.

## Хэш-распределение

Хэш-распределение использует внутреннюю функцию для явного распределения данных путем хэширования одного столбца. При хэшировании данных нет явного порядка выделения данных для распределения. Тем не менее, само хэширование является детерминированным процессом. Это делает результаты хэширования прогнозируемыми. Например, хэширование целочисленного столбца, содержащего значение 10, всегда будет давать одно значение хэша. Это означает, что ***любой*** хэшированный целочисленный столбец, содержащий значение 10, будет выделен в одно и то же распределение. Это справедливо даже для нескольких таблиц.

Предсказуемость хэша очень важна. Это означает, что хэш-распределение данных может привести к повышению производительности при чтении данных и соединении таблиц друг с другом.

Как будет показано ниже, хэш-распределение может быть очень эффективным для оптимизации запросов. Именно поэтому оно считается оптимизированной формой распределения данных.

> [AZURE.NOTE] Помните! Хэш включает не только значения данных. Хэш — это комбинация значений и типа данных.

Ниже приведена таблица, хэш-распределенная по ProductKey.

```sql
CREATE TABLE [dbo].[FactInternetSales]
(   [ProductKey]            int          NOT NULL
,   [OrderDateKey]          int          NOT NULL
,   [CustomerKey]           int          NOT NULL
,   [PromotionKey]          int          NOT NULL
,   [SalesOrderNumber]      nvarchar(20) NOT NULL
,   [OrderQuantity]         smallint     NOT NULL
,   [UnitPrice]             money        NOT NULL
,   [SalesAmount]           money        NOT NULL
)
WITH
(   CLUSTERED COLUMNSTORE INDEX
,   DISTRIBUTION = HASH([ProductKey])
)
;
```

> [AZURE.NOTE] Если данные распределяются по хэшу, они выделяется в распределения на уровне строк.

## Разделы таблицы
Секции таблицы поддерживаются, и их легко определить.

Пример секционирования хранилища данных SQL с помощью команды `CREATE TABLE`:

```sql
CREATE TABLE [dbo].[FactInternetSales]
(
    [ProductKey]            int          NOT NULL
,   [OrderDateKey]          int          NOT NULL
,   [CustomerKey]           int          NOT NULL
,   [PromotionKey]          int          NOT NULL
,   [SalesOrderNumber]      nvarchar(20) NOT NULL
,   [OrderQuantity]         smallint     NOT NULL
,   [UnitPrice]             money        NOT NULL
,   [SalesAmount]           money        NOT NULL
)
WITH
(   CLUSTERED COLUMNSTORE INDEX
,   DISTRIBUTION = HASH([ProductKey])
,   PARTITION   (   [OrderDateKey] RANGE RIGHT FOR VALUES
                    (20000101,20010101,20020101
                    ,20030101,20040101,20050101
                    )
                )
)
;
```

Обратите внимание, что в определении нет функции или схемы секционирования. В хранилище данных SQL используется упрощенное определение секций, которое несколько отличается от аналогичного определения в SQL Server. Вам нужно только указать граничные точки для секционированного столбца.

## Статистика

Хранилище данных SQL использует распределенный оптимизатор запросов для создания соответствующего плана запросов, когда пользователи отправляют запросы к таблицам. После создания план запросов содержит стратегию и метод, используемые базой данных для доступа к данным и выполнения запроса пользователя. Оптимизатор запросов хранилища данных SQL основан на стоимости. Другими словами, он сравнивает различные варианты (планы) на основе их относительной стоимости и выбирает наиболее эффективный доступный план. Следовательно, хранилищу данных SQL нужно много информации, чтобы принимать обоснованные решения на основе затрат. Оно содержит статистические данные о таблице (для размера таблицы) и хранит их в объектах базы данных, называемых `STATISTICS`.

Статистика хранится для одного или нескольких столбцов, индексов или таблиц. Они предоставляют оптимизатору на основе затрат важную информацию о кардинальности и избирательности значений. Это особенно интересно, когда оптимизатор должен оценить предложения JOIN, GROUP BY, HAVING и WHERE в запросе. Поэтому очень важно, чтобы информация в этих объектах статистики *точно* отражала текущее состояние таблицы. Важно понимать — это точность затрат, что немаловажно. Если статистика точно отражает состояние таблицы, то можно сравнивать планы для низких затрат. Если они не точны, хранилище данных SQL может выбрать неправильный план.

Статистика уровня столбцов в хранилище данных SQL определяется пользователем.

Другими словами, нам нужно создать ее самим. Как мы знаем, этим не стоит пренебрегать. Это важное отличие между SQL Server и хранилищем данных SQL. SQL Server автоматически создает статистику при запросе столбцов. Кроме того, по умолчанию SQL Server автоматически обновляет статистику. А в хранилище данных SQL статистику надо создавать вручную и управлять ею тоже вручную.

### Рекомендации

Используйте следующие рекомендации для создания статистики:

1. Создавайте одностолбцовую статистику для столбцов, используемых в предложениях `WHERE`, `JOIN`, `GROUP BY`, `ORDER BY` и `DISTINCT`.
2. Создавайте многостолбцовую статистику для составных предложений.
3. Периодически обновляйте статистику. Помните, что это не выполняется автоматически!

>[AZURE.NOTE] Нередко для обновления статистики столбцов хранилище данных SQL Server полагается исключительно на `AUTOSTATS`. Это не рекомендуется даже для хранилищ данных SQL Server. `AUTOSTATS` инициируются скоростью изменения в 20 %, а этого может оказаться недостаточно для больших таблиц с миллионами и миллиардами строк. Это поэтому всегда следует следить за обновлением статистики, чтобы обеспечить точное отражение кардинальности таблицы.

## Неподдерживаемые функции
Хранилище данных SQL не использует и не поддерживает такие функции:

| Функция | Возможное решение |
| --- | --- |
| удостоверения; | [Назначение суррогатных ключей] |
| первичные ключи; | Недоступно |
| внешние ключи; | Недоступно |
| проверочные ограничения; | Недоступно |
| уникальные ограничения; | Недоступно |
| уникальные индексы; | Недоступно |
| вычисляемые столбцы; | Недоступно |
| разреженные столбцы; | Недоступно |
| пользовательские типы; | Недоступно |
| индексированные представления; | Недоступно |
| последовательности; | Недоступно |
| триггеры; | Недоступно |
| синонимы. | Недоступно |

## Дальнейшие действия
Дополнительные советы по разработке см. в статье [Общие сведения о разработке][]. Дополнительные рекомендации см. в статье [Рекомендации по использованию хранилища данных SQL][].

<!--Image references-->

<!--Article references-->
[Общие сведения о разработке]: sql-data-warehouse-overview-develop.md
[Назначение суррогатных ключей]: https://blogs.msdn.microsoft.com/sqlcat/2016/02/18/assigning-surrogate-key-to-dimension-tables-in-sql-dw-and-aps/
[Рекомендации по использованию хранилища данных SQL]: sql-data-warehouse-best-practices.md

<!--MSDN references-->

<!--Other Web references-->

<!---HONumber=AcomDC_0518_2016-->