<properties
   pageTitle="Транзакции в хранилище данных SQL | Microsoft Azure"
   description="Советы по реализации транзакций Transact-SQL в хранилище данных SQL Azure для разработки решений."
   services="sql-data-warehouse"
   documentationCenter="NA"
   authors="jrowlandjones"
   manager="barbkess"
   editor=""/>

<tags
   ms.service="sql-data-warehouse"
   ms.devlang="NA"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="data-services"
   ms.date="06/26/2015"
   ms.author="JRJ@BigBangData.co.uk;barbkess"/>

# Транзакции в хранилище данных SQL

Как и следовало ожидать, хранилище данных SQL обеспечивает поддержку всех свойств транзакций. Однако, чтобы производительность хранилища данных SQL оставалась на уровне, по сравнению с SQL Server некоторые возможности ограничены. Эта статья посвящена отличиям этого продукта.

## Уровни изоляции транзакций
Хранилище данных SQL реализует транзакции ACID. Однако поддержка изоляции транзакций ограничена `READ UNCOMMITTED`, и это не может быть изменено. Можно реализовать ряд методов программирования, чтобы предотвратить чтение «грязных» данных, если для вас это является проблемой. В наиболее популярных методах используется CTAS и переключение секций таблицы (часто это называют шаблоном скользящего окна), чтобы не дать пользователям запрашивать данные, которые еще готовятся. Также популярны представления, которые предварительно фильтруют данные.

## Состояние транзакции
Хранилище данных SQL применяет функцию XACT_STATE(), чтобы сообщить о неудачной транзакции, используя значение -2. Это означает, что произошел сбой транзакции и она помечена только для отката.

> [AZURE.NOTE]Использование функцией XACT_STATE значения -2 для обозначения неудачной транзакции отличается от поведения в SQL Server. SQL Server для представления нефиксируемой транзакции использует значение -1. SQL Server может допускать некоторые ошибки внутри транзакции, не помечая ее как нефиксируемую. Например, SELECT 1/0 вызовет ошибку, но не приведет к переходу транзакции в состояние нефиксируемой. SQL Server также разрешает чтение в нефиксируемой транзакции. Однако в SQLDW это не так. При возникновении ошибки внутри транзакции SQLDW она автоматически перейдет в состояние -2 (включая ошибки SELECT 1/0). Поэтому важно проверить код приложения, чтобы определить, используется ли в нем XACT_STATE().

В SQL Server может быть фрагмент кода, который выглядит следующим образом:

```
BEGIN TRAN
    BEGIN TRY
        DECLARE @i INT;
        SET     @i = CONVERT(int,'ABC');
    END TRY
    BEGIN CATCH

        DECLARE @xact smallint = XACT_STATE();

        SELECT  ERROR_NUMBER()    AS ErrNumber
        ,       ERROR_SEVERITY()  AS ErrSeverity
        ,       ERROR_STATE()     AS ErrState
        ,       ERROR_PROCEDURE() AS ErrProcedure
        ,       ERROR_MESSAGE()   AS ErrMessage
        ;

        ROLLBACK TRAN;

    END CATCH;
```

Обратите внимание, что инструкция `SELECT` предшествует инструкции `ROLLBACK`. Также обратите внимание, что для задания переменной `@xact` используется DECLARE, а не `SELECT`.

В хранилище данных SQL код должен выглядеть следующим образом:

```
BEGIN TRAN
    BEGIN TRY
        DECLARE @i INT;
        SET     @i = CONVERT(int,'ABC');
    END TRY
    BEGIN CATCH

        ROLLBACK TRAN;

        DECLARE @xact smallint = XACT_STATE();

        SELECT  ERROR_NUMBER()    AS ErrNumber
        ,       ERROR_SEVERITY()  AS ErrSeverity
        ,       ERROR_STATE()     AS ErrState
        ,       ERROR_PROCEDURE() AS ErrProcedure
        ,       ERROR_MESSAGE()   AS ErrMessage
        ;
    END CATCH;

SELECT @xact;
```

Обратите внимание, что откат транзакции должен произойти до чтения информации об ошибке в блоке `CATCH`.

## Функция Error_Line()
Также следует отметить, что хранилище данных SQL не реализует и не поддерживает функцию ERROR_LINE(). Если она используется в вашем коде, ее необходимо будет удалить, чтобы обеспечить совместимость с хранилищем данных SQL. Вместо этого используйте в коде метки запросов, чтобы реализовать эквивалентную функциональность. Ознакомьтесь со статьей [Метки запросов], чтобы получить дополнительную информацию об этой функции.

## Использование THROW и RAISERROR
THROW — это более современная реализация вызова исключений в хранилище данных SQL, но также поддерживается и RAISERROR. Тем не менее, существует ряд различий, которые заслуживают внимания.

- Для THROW номера определяемых пользователем сообщений об ошибках не могут быть в диапазоне от 100 000 до 150 000.
- Номера сообщений об ошибках RAISERROR не должны превышать 50 000.
- Не поддерживается использование sys.messages.

## Ограничения
В Хранилище данных SQL есть несколько ограничений, относящихся к транзакциям.

Вот они:

- не поддерживаются распределенные транзакции;
- вложенные транзакции не разрешены;
- не допускается точки сохранения.

## Дальнейшие действия
Дополнительные советы по разработке см. в статье [Общие сведения о разработке][].

<!--Image references-->

<!--Article references-->
[Общие сведения о разработке]: sql-data-warehouse-overview-develop.md

<!--MSDN references-->

<!--Other Web references-->

<!---HONumber=July15_HO4-->