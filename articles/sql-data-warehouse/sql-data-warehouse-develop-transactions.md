<properties
   pageTitle="Транзакции в хранилище данных SQL | Microsoft Azure"
   description="Советы по реализации транзакций Transact-SQL в хранилище данных SQL Azure для разработки решений."
   services="sql-data-warehouse"
   documentationCenter="NA"
   authors="jrowlandjones"
   manager="barbkess"
   editor=""/>

<tags
   ms.service="sql-data-warehouse"
   ms.devlang="NA"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="data-services"
   ms.date="03/03/2016"
   ms.author="jrj;barbkess;sonyama"/>

# Транзакции в хранилище данных SQL

Как и следовало ожидать, хранилище данных SQL обеспечивает поддержку всех свойств транзакций. Однако, чтобы производительность хранилища данных SQL оставалась на уровне, по сравнению с SQL Server некоторые возможности ограничены. Эта статья посвящена отличиям этого продукта от аналогичных систем.

## Уровни изоляции транзакций
Хранилище данных SQL реализует транзакции ACID. Однако поддержка изоляции транзакций ограничена `READ UNCOMMITTED`, и это не может быть изменено. Можно реализовать ряд методов программирования, чтобы предотвратить чтение «грязных» данных, если для вас это является проблемой. В наиболее популярных методах используется CTAS и переключение секций таблицы (часто это называют шаблоном скользящего окна), чтобы не дать пользователям запрашивать данные, которые еще готовятся. Также популярны представления, которые предварительно фильтруют данные.

## Размер транзакции
Размер одной транзакции, изменяющей данные, ограничен. Сегодня действует ограничение "по распределению". Поэтому, чтобы получить общую картину, необходимо умножить величину ограничения на размер распределения. Чтобы приблизительно определить максимальное количество строк в транзакции, разделите величину ограничения распределения на общий размер каждого столбца. Для столбцов переменной длины рекомендуется брать среднюю длину столбца, а не максимальный размер.

В таблице ниже были сделаны следующие допущения:
* выполнено равномерное распределение данных; 
* средняя длина строки составляет 250 байтов.

| DWU | Ограничение распределения (ГиБ) | Число распределений | Максимальный размер транзакции (ГиБ) | Число строк в распределении | Максимальное число строка на транзакцию |
| ------ | -------------------------- | ----------------------- | -------------------------- | ----------------------- | ------------------------ |
| DW100 | 1 | 60 | 60 | 4 000 000 | 240 000 000 |
| DW200 | 1\.5 | 60 | 90 | 6 000 000 | 360 000 000 |
| DW300 | 2\.25 | 60 | 135 | 9 000 000 | 540 000 000 |
| DW400 | 3 | 60 | 180 | 12 000 000 | 720 000 000 |
| DW500 | 3,75 | 60 | 225 | 15 000 000 | 900 000 000 |
| DW600 | 4\.5. | 60 | 270 | 18 000 000 | 1 080 000 000 |
| DW1000 | 7\.5 | 60 | 450 | 30 000 000 | 1 800 000 000 |
| DW1200 | 9 | 60 | 540 | 36 000 000 | 2 160 000 000 |
| DW1500 | 11,25 | 60 | 675 | 45 000 000 | 2 700 000 000 |
| DW2000 | 15 | 60 | 900 | 60 000 000 | 3 600 000 000 |

Ограничение размера транзакции накладывается на транзакцию или операцию. Оно не применяется к совокупности параллельных транзакций. Поэтому каждая транзакция может записать такой объем данных в журнал.

Для оптимизации и сведения к минимуму объема данных, записываемых в журнал, см. статью о [рекомендациях по транзакциям][].

> [AZURE.WARNING] Максимальный размер транзакции может быть достигнут только для распределенных таблиц HASH или ROUND\_ROBIN, где распределение данных равномерно. Если транзакция неравномерно записывает данные в распределения, то вполне вероятно, что ограничение будет достигнуто до того, как размер транзакции станет максимальным.
<!--REPLICATED_TABLE-->

## Состояние транзакции
Хранилище данных SQL применяет функцию XACT\_STATE(), чтобы сообщить о неудачной транзакции, используя значение -2. Это означает, что произошел сбой транзакции и она помечена только для отката.

> [AZURE.NOTE] Использование функцией XACT\_STATE значения -2 для обозначения неудачной транзакции отличается от поведения в SQL Server. SQL Server для представления нефиксируемой транзакции использует значение -1. SQL Server может допускать некоторые ошибки внутри транзакции, не помечая ее как нефиксируемую. Например, SELECT 1/0 вызовет ошибку, но не приведет к переходу транзакции в состояние нефиксируемой. SQL Server также разрешает чтение в нефиксируемой транзакции. Однако в SQLDW это не так. При возникновении ошибки внутри транзакции SQLDW она автоматически перейдет в состояние -2 (включая ошибки SELECT 1/0). Поэтому важно проверить код приложения, чтобы определить, используется ли в нем XACT\_STATE().

В SQL Server может быть фрагмент кода, который выглядит следующим образом:

```
BEGIN TRAN
    BEGIN TRY
        DECLARE @i INT;
        SET     @i = CONVERT(int,'ABC');
    END TRY
    BEGIN CATCH

        DECLARE @xact smallint = XACT_STATE();

        SELECT  ERROR_NUMBER()    AS ErrNumber
        ,       ERROR_SEVERITY()  AS ErrSeverity
        ,       ERROR_STATE()     AS ErrState
        ,       ERROR_PROCEDURE() AS ErrProcedure
        ,       ERROR_MESSAGE()   AS ErrMessage
        ;

        ROLLBACK TRAN;

    END CATCH;
```

Обратите внимание, что инструкция `SELECT` предшествует инструкции `ROLLBACK`. Также обратите внимание, что для задания переменной `@xact` используется DECLARE, а не `SELECT`.

В хранилище данных SQL код должен выглядеть следующим образом:

```
BEGIN TRAN
    BEGIN TRY
        DECLARE @i INT;
        SET     @i = CONVERT(int,'ABC');
    END TRY
    BEGIN CATCH

        ROLLBACK TRAN;

        DECLARE @xact smallint = XACT_STATE();

        SELECT  ERROR_NUMBER()    AS ErrNumber
        ,       ERROR_SEVERITY()  AS ErrSeverity
        ,       ERROR_STATE()     AS ErrState
        ,       ERROR_PROCEDURE() AS ErrProcedure
        ,       ERROR_MESSAGE()   AS ErrMessage
        ;
    END CATCH;

SELECT @xact;
```

Обратите внимание, что откат транзакции должен произойти до чтения информации об ошибке в блоке `CATCH`.

## Функция Error\_Line()
Также следует отметить, что хранилище данных SQL не реализует и не поддерживает функцию ERROR\_LINE(). Если она используется в вашем коде, ее необходимо будет удалить, чтобы обеспечить совместимость с хранилищем данных SQL. Вместо этого используйте в коде метки запросов, чтобы реализовать эквивалентную функциональность. Ознакомьтесь со статьей [Метки запросов], чтобы получить дополнительную информацию об этой функции.

## Использование THROW и RAISERROR
THROW — это более современная реализация вызова исключений в хранилище данных SQL, но также поддерживается и RAISERROR. Тем не менее, существует ряд различий, которые заслуживают внимания.

- Для THROW номера определяемых пользователем сообщений об ошибках не могут быть в диапазоне от 100 000 до 150 000.
- Номера сообщений об ошибках RAISERROR не должны превышать 50 000.
- Не поддерживается использование sys.messages.

## Ограничения
В Хранилище данных SQL есть несколько ограничений, относящихся к транзакциям.

Вот они:

- не поддерживаются распределенные транзакции;
- вложенные транзакции не разрешены;
- не допускается точки сохранения.

## Дальнейшие действия
Дополнительные советы по разработке см. в статье [Общие сведения о разработке][].

<!--Image references-->

<!--Article references-->
[Общие сведения о разработке]: sql-data-warehouse-overview-develop.md
[рекомендациях по транзакциям]: sql-data-warehouse-develop-best-practices-transactions.md

<!--MSDN references-->

<!--Other Web references-->

<!---HONumber=AcomDC_0323_2016-->