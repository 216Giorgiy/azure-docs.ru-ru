<properties
   pageTitle="Управление параллелизмом и рабочей нагрузкой в хранилище данных SQL | Microsoft Azure"
   description="Общие сведения управлении параллелизмом и рабочей нагрузкой в хранилище данных SQL Azure для разработки решений."
   services="sql-data-warehouse"
   documentationCenter="NA"
   authors="jrowlandjones"
   manager="barbkess"
   editor=""/>

<tags
   ms.service="sql-data-warehouse"
   ms.devlang="NA"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="data-services"
   ms.date="07/15/2016"
   ms.author="jrj;barbkess;sonyama"/>

# Управление параллелизмом и рабочей нагрузкой в хранилище данных SQL

Для обеспечения прогнозируемой высокой производительности в хранилище данных SQL реализованы механизмы, которые позволяют пользователям управлять уровнем параллелизма и выделением ресурсов, например выделением памяти и определением приоритетов ЦП. В этой статье рассматриваются понятия параллелизма и управления рабочей нагрузкой и объясняется, каким образом реализованы эти функции и как управлять ими в хранилище данных. Управление рабочей нагрузкой в хранилище данных SQL обеспечивает поддержку многопользовательских сред, но не поддерживает мультитенантные рабочие нагрузки.

## Пределы параллелизма

Хранилище данных SQL поддерживает до 1024 одновременных подключений. Все эти подключения могут одновременно отправлять запросы. Тем не менее, чтобы оптимизировать пропускную способность, хранилище данных SQL может помещать некоторые запросы в очередь. Это гарантирует, что на выполнение каждого запроса выделяется минимальный объем памяти. Постановка в очередь происходит во время выполнения запроса. При достижении пределов параллелизма хранилище данных SQL может повысить общую пропускную способность, обеспечивая активным запросам доступ к необходимым ресурсам памяти.

Предельные границы параллелизма в хранилище данных SQL зависят от двух значений: **количества одновременных запросов** и **количества слотов выдачи**. Запрос выполняется, если не превышено пороговое значение одновременных запросов и достаточно выделенного количества слотов выдачи.

- **Количество одновременных запросов** — это количество запросов, выполняемых в одно и то же время. Хранилище данных SQL с высоким значением DWU (DW1000 и выше) поддерживает до 32 **одновременных запросов**. Так как количество одновременных запросов соотносится с количеством предоставленных единиц использования хранилища данных (DWU), в таблице ниже описаны ограничения по количеству выделенных DWU.
- **Количество слотов выдачи** — это более динамическое понятие. Каждый запрос может использовать один или несколько слотов. Точное количество слотов, используемых при выполнении запроса, зависит от размера хранилища данных SQL и используемого [класса ресурсов](#resource-classes).

В таблице ниже приведены ограничения для количества одновременных запросов и слотов выдачи.

### Пределы параллелизма

| | DW100 | DW200 | DW300 | DW400 | DW500 | DW600 | DW1000 | DW1200 | DW1500 | DW2000 | DW3000 | DW6000 |
| :--------------------------- | ----: | ----: | ----: | ----: | ----: | ----: | -----: | -----: | -----: | -----: | -----: | -----: |
| Макс. число одновременных запросов | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 |
| Макс. число слотов выдачи | 4\. | 8 | 12 | 16 | 20 | 24 | 40 | 48 | 60 | 80 | 120 | 240 |

Когда эти пороговые значения достигаются, последующие запросы помещаются в очередь. Запросы в очереди выполняются по принципу очередности по мере выполнения предыдущих запросов и нормализации числа запросов и слотов выдачи.

> [AZURE.NOTE]  Запросы SELECT, выполняемые исключительно с динамическими административными представлениями или представлениями каталогов, **не** регулируются пороговым значением параллельных запросов. Это позволяет пользователям следить за системой независимо от того, какое количество запросов выполняется в системе.

## Классы ресурсов

Классы ресурсов составляют неотъемлемую часть управления рабочей нагрузкой в хранилище данных SQL, так как они управляют памятью и циклами ЦП, выделяемыми для запроса. Существует четыре разных класса ресурсов, каждый из которых может назначаться пользователю в виде **роли базы данных**: **smallrc, mediumrc, largerc и xlargerc**. Для пользователей, которые относятся к классу ресурсов smallrc, выделяется меньший объем памяти, что, в свою очередь, приводит к более высокому параллелизму. В то же время для пользователей, которым назначен класс ресурсов xlargerc, выделяется больший объем памяти, и, следовательно, меньше запросов могут выполняться параллельно.

По умолчанию каждый пользователь является членом малого класса ресурсов — smallrc. Для повышения класса ресурсов используется процедура `sp_addrolemember`, а для уменьшения — `sp_droprolemember`. Например, следующая команда позволяет повысить класс ресурса loaduser до класса largerc:

```sql
EXEC sp_addrolemember 'largerc', 'loaduser'
```

Рекомендуется сразу назначать пользователям постоянный класс ресурсов и избегать его изменения. Например, если выделен большой объем памяти, во время добавления данных в кластеризованные таблицы Columnstore создаются индексы более высокого качества. Чтобы для операций добавления данных выделялся большой объем памяти, необходимо создать пользователя, предназначенного для этой операции, и назначить ему более высокий класс ресурсов.

Существует несколько типов запросов, для выполнения которых не требуется большой объем памяти. Система не будет учитывать выделенные ресурсы в соответствующем классе и всегда будет выполнять эти запросы в классе с небольшими ресурсами. Таким образом, эти запросы смогут выполняться при нехватке слотов выдачи и не будут потреблять больше слотов, чем необходимо. [Исключения классов ресурсов](#resource-class-exceptions) рассматриваются ниже в этой статье.

Ниже приведены дополнительные сведения о классах ресурсов.

- Чтобы изменить назначенный пользователю класс ресурсов, требуется разрешение `ALTER ROLE`.
- Пользователя можно добавить в один или несколько классов ресурсов, но при этом будут использоваться атрибуты самого высокого из них. Это означает, что если пользователю назначены классы ресурсов largerc и mediumrc, преимущество будет у более высокого класса — largerc.
- Класс ресурсов для пользователя с правами системного администратора изменить нельзя.
 
Примеры и дополнительные сведения о создании пользователей и назначении для них классов ресурсов см. в разделе [Управление пользователями](#Managing-users) в конце этой статьи.

## Выделение памяти

Повышение класса ресурсов имеет свои преимущества и недостатки. Если назначить для пользователя более высокий класс ресурсов, то для запросов будет выделяться больший объем памяти, а значит, они смогут выполняться быстрее. Кроме того, повышение класса ресурсов позволяет уменьшить количество одновременно выполняемых запросов. Компромисс заключается в том, что при выделении большого объема памяти для одного запроса снижается количество одновременных запросов, для которых также требуется определенный объем памяти. Если одному пользователю выделено много памяти для запроса, то другие пользователи не будут иметь доступ к этой памяти для выполнения своих запросов.

В следующей таблице объем памяти, выделенный для каждого распределения, сопоставлен по количеству DWU и классу ресурсов. В хранилище данных SQL используется 60 распределений для каждой базы данных. Например, для запроса, который выполняется при DW2000 с классом ресурсов xlarge, в каждой из 60 распределенных баз данных выделяется по 6400 МБ.

### Выделение памяти на распределение (МБ)

| | DW100 | DW200 | DW300 | DW400 | DW500 | DW600 | DW1000 | DW1200 | DW1500 | DW2000 | DW3000 | DW6000 |
| :------------- | ----: | ----: | ----: | ----: | ----: | ----: | -----: | -----: | -----: | -----: | -----: | -----: |
| smallrc | 100 | 100 | 100 | 100 | 100 | 100 | 100 | 100 | 100 | 100 | 100 | 100 |
| mediumrc | 100 | 200 | 200 | 400 | 400 | 400 | 800 | 800 | 800 | 1 600 | 1 600 | 3200 |
| largerc | 200 | 400 | 400 | 800 | 800 | 800 | 1 600 | 1 600 | 1 600 | 3200 | 3200 | 6400 |
| xlargerc | 400 | 800 | 800 | 1 600 | 1 600 | 1 600 | 3200 | 3200 | 3200 | 6400 | 6400 | 12 800 |


Исходя из вышеупомянутого примера, для системного запроса, который выполняется при DW2000 с классом ресурсов xlarge, всего выделяется 375 ГБ памяти (6400 МБ * 60 распределений / 1024 (чтобы преобразовать в ГБ)).

### Выделение памяти для всей системы (ГБ)

| | DW100 | DW200 | DW300 | DW400 | DW500 | DW600 | DW1000 | DW1200 | DW1500 | DW2000 | DW3000 | DW6000 |
| :------------- | ----: | ----: | ----: | ----: | ----: | ----: | -----: | -----: | -----: | -----: | -----: | -----: |
|smallrc | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 |
|mediumrc | 6 | 12 | 12 | 23 | 23 | 23 | 47 | 47 | 47 | 94 | 94 | 188 |
|largerc | 12 | 23 | 23 | 47 | 47 | 47 | 94 | 94 | 94 | 188 | 188 | 375 |
|xlargerc | 23 | 47 | 47 | 94 | 94 | 94 | 188 | 188 | 188 | 375 | 375 | 750 |

## Использование слотов выдачи

Как уже говорилось, чем выше назначенный пользователю класс ресурсов, тем больше ему выделяется памяти. Так как память является фиксированным ресурсом, то чем больше памяти выделяется на выполнение одного запроса, тем ниже параллелизм. В следующей таблице все вышесказанное сведено в одно представление. В нем приведено количество слотов выдачи, доступное для определенного значения DWU, а также показатель их использования по классам ресурсов.

### Выделение и использование слотов выдачи

| | DW100 | DW200 | DW300 | DW400 | DW500 | DW600 | DW1000 | DW1200 | DW1500 | DW2000 | DW3000 | DW6000 |
| :---------------------- | ----: | ----: | ----: | ----: | ----: | ----: | -----: | -----: | -----: | -----: | -----: | -----: |
| **Выделение** | | | | | | | | | | | | |
| Макс. число одновременных запросов | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 |
| Макс. число слотов выдачи | 4\. | 8 | 12 | 16 | 20 | 24 | 40 | 48 | 60 | 80 | 120 | 240 |
| **Использование слотов** | | | | | | | | | | | | |
| smallrc | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| mediumrc | 1 | 2 | 2 | 4 | 4 | 4 | 8 | 8 | 8 | 16 | 16 | 32 |
| largerc | 2 | 4 | 4 | 8 | 8 | 8 | 16 | 16 | 16 | 32 | 32 | 64 |
| xlargerc | 4\. | 8 | 8 | 16 | 16 | 16 | 32 | 32 | 32 | 64 | 64 | 128 |

В этой таблице можно увидеть, что хранилище данных SQL при использовании DW1000 предлагает всего 40 слотов выдачи и может обрабатывать до 32 параллельных запросов. Если все пользователи работают в классе с небольшими ресурсами, то будет разрешено выполнять 32 параллельных запроса, так как каждый запрос использует 1 слот выдачи. Если бы все пользователи работали в классе о средними ресурсами, то каждому пользователю было бы выделено по 800 МБ на распределения, то есть всего было бы выделено 47 ГБ памяти, и параллельно работать смогли бы только 8 таких пользователей.

## Приоритет при выполнении запросов

Для управления поведением классов ресурсов существует восемь групп рабочей нагрузки. Однако только четыре из них не зависят от значения DWU. Это связано с тем, что каждая группа рабочей нагрузки назначается только одному из четырех классов ресурсов. Этот аспект важно учитывать, так как некоторым группам рабочей нагрузки назначается более высокий **приоритет**. Значение приоритета используется при планировании распределения ресурсов ЦП. Запросы, которым назначен высокий приоритет, получают в 3 раза больше циклов ЦП, чем запросы со средним приоритетом. Поэтому сопоставление слотов выдачи также определяет приоритет ЦП. Если для выполнения запроса используется 16 или больше слотов, он помечается как запрос с высоким приоритетом.

Ниже приведены сведения о приоритете для каждой группы рабочей нагрузки.

| Группы рабочей нагрузки | Сопоставление слотов выдачи | Приоритет |
| :------------------  | :----------------------: | :----------------- |
| SloDWGroupC00 | 1 | Средний |
| SloDWGroupC01 | 2 | Средний |
| SloDWGroupC02 | 4 | Средний |
| SloDWGroupC03 | 8 | Средний |
| SloDWGroupC04 | 16 | Высокий |
| SloDWGroupC05 | 32 | Высокий |
| SloDWGroupC06 | 64 | Высокий |
| SloDWGroupC07 | 128 | Высокий |

Если для хранилища данных SQL используется DW500, то активные группы рабочей нагрузки сопоставляются с классами ресурсов следующим образом:

| Класс ресурсов | Группа рабочей нагрузки | Число используемых слотов выдачи | Важность |
| :--------------- | :------------- | :--------------------:   | :--------- |
| smallrc | SloDWGroupC00 | 1 | Средний |
| mediumrc | SloDWGroupC02 | 4 | Средний |
| largerc | SloDWGroupC03 | 8 | Средний |
| xlargerc | SloDWGroupC04 | 16 | Высокий |


Используйте следующий запрос динамического административного представления, чтобы увидеть различия в распределении ресурсов памяти с точки зрения регулятора ресурсов. Этот запрос также подходит для анализа текущего и предыдущего использования групп рабочей нагрузки при устранении неполадок.

```sql
WITH rg
AS
(   SELECT  
     pn.name						AS node_name
    ,pn.[type]						AS node_type
    ,pn.pdw_node_id					AS node_id
    ,rp.name						AS pool_name
    ,rp.max_memory_kb*1.0/1024				AS pool_max_mem_MB
    ,wg.name						AS group_name
    ,wg.importance					AS group_importance
    ,wg.request_max_memory_grant_percent		AS group_request_max_memory_grant_pcnt
    ,wg.max_dop						AS group_max_dop
    ,wg.effective_max_dop				AS group_effective_max_dop
    ,wg.total_request_count				AS group_total_request_count
    ,wg.total_queued_request_count			AS group_total_queued_request_count
    ,wg.active_request_count				AS group_active_request_count
    ,wg.queued_request_count				AS group_queued_request_count
    FROM    sys.dm_pdw_nodes_resource_governor_workload_groups wg
    JOIN    sys.dm_pdw_nodes_resource_governor_resource_pools rp    
            ON  wg.pdw_node_id  = rp.pdw_node_id
    	    AND wg.pool_id      = rp.pool_id
    JOIN    sys.dm_pdw_nodes pn	
            ON	wg.pdw_node_id	= pn.pdw_node_id
    WHERE   wg.name like 'SloDWGroup%'
        AND     rp.name = 'SloDWPool'
)
SELECT	pool_name
,		pool_max_mem_MB
,		group_name
,		group_importance
,		(pool_max_mem_MB/100)*group_request_max_memory_grant_pcnt AS max_memory_grant_MB
,		node_name
,		node_type
,       group_total_request_count
,       group_total_queued_request_count
,       group_active_request_count
,       group_queued_request_count
FROM	rg
ORDER BY
	node_name
,	group_request_max_memory_grant_pcnt
,	group_importance
;
```

## Исключения классов ресурсов

Большинство запросов учитывают классы ресурсов, однако возникают некоторые исключения. Обычно это происходит при нехватке ресурсов, необходимых для выполнения нужного действия. Таким образом, исключения обычно возникают, когда для выполнения запроса не требуется большой объем памяти, выделенный высоким классом ресурсов. В таких случаях используется класс ресурсов по умолчанию или малый класс ресурсов (smallrc), независимо от того, какой класс ресурсов назначен пользователю. Например, `CREATE LOGIN` всегда будет работать в классе smallrc. Для выполнения этой задачи не требуются значительные ресурсы, поэтому нет смысла включать этот запрос в модель слотов выдачи. Для этого действия было бы расточительным использовать предварительно выделяемый объем памяти. Путем исключения `CREATE LOGIN` из модели слотов выдачи хранилище данных SQL может использоваться значительно эффективнее.

Следующие инструкции **не** учитывают классы ресурсов:

- CREATE или DROP TABLE;
- ALTER TABLE ... SWITCH, SPLIT или MERGE PARTITION;
- ALTER INDEX DISABLE
- DROP INDEX
- CREATE, UPDATE или DROP STATISTICS;
- TRUNCATE TABLE
- ALTER AUTHORIZATION
- CREATE LOGIN
- CREATE, ALTER или DROP USER;
- CREATE, ALTER или DROP PROCEDURE;
- CREATE или DROP VIEW;
- INSERT VALUES
- SELECT (из системных представлений и динамических административных представлений);
- EXPLAIN
- DBCC

<!--
Removed as these two are not confirmed / supported under SQLDW
- CREATE REMOTE TABLE AS SELECT
- CREATE EXTERNAL TABLE AS SELECT
- REDISTRIBUTE
-->

### Запросы, учитывающие пределы параллелизма

Важно помнить, что большинство запросов конечных пользователей, вероятно, будут управляться при помощи классов ресурсов. Как правило, рабочая нагрузка активного запроса должна опираться на пороговые значения для одновременных запросов и слотов выделения, если она не входит в конкретный список исключений платформы. Будучи конечным пользователем, вы не можете самостоятельно принять решение об исключении запроса из модели слотов выделения. В случае превышения любого из этих порогов запросы помещаются в очередь. Запросы в очереди выполняются в порядке приоритета, который определяется временем их подачи.

Следующие инструкции не **учитывают** классы ресурсов:

- INSERT SELECT
- UPDATE
- УДАЛИТЬ
- SELECT (при запросе таблиц пользователя)
- ALTER INDEX REBUILD
- ALTER INDEX REORGANIZE
- ALTER TABLE REBUILD
- CREATE INDEX
- CREATE CLUSTERED COLUMNSTORE INDEX
- CREATE TABLE AS SELECT
- Загрузка данных
- Операции перемещения данных, осуществляемые службой Data Movement Service (DMS)


## Управление пользователями

1. **Создание имени входа**. Откройте подключение к базе данных **master** для хранилища данных SQL и выполните следующие команды.
	
	```sql
	CREATE LOGIN newperson WITH PASSWORD = 'mypassword';
	CREATE USER newperson for LOGIN newperson;
	```

	> [AZURE.NOTE] Рекомендуется создать пользователей для входа в базу данных master при работе с базой данных Azure SQL и хранилищем данных SQL. На этом уровне доступны две роли сервера, требующих наличия пользователя в базе данных master для имени для входа, чтобы предоставить членство. Это роли `Loginmanager` и `dbmanager`. Как в базе данных Azure SQL, так и в хранилище данных SQL эти роли предоставляют права на управление именами для входа и создание баз данных. В этом отличие от SQL Server. Дополнительные сведения см. в статье [Проверка подлинности и авторизация в базе данных SQL: предоставление доступа][].

2. **Создание учетной записи пользователя**. Откройте подключение к **базе данных хранилища данных SQL** и выполните следующую команду.

	```sql
	CREATE USER newperson FOR LOGIN newperson;
	```

3. **Предоставление разрешений**. В следующем примере предоставляется разрешение `CONTROL` для базы данных хранилища данных SQL. Разрешение `CONTROL` на уровне базы данных соответствует роли db\_owner в SQL Server.

	```sql
	GRANT CONTROL ON DATABASE::MySQLDW to newperson;
	```

4. **Повышение класса ресурсов**. Чтобы добавить пользователя к повышенной роли управления рабочей нагрузкой, используйте следующий запрос.

	```sql
	EXEC sp_addrolemember 'largerc', 'newperson'
	```

5. **Снижение класса ресурсов**. Чтобы удалить пользователя из роли управления рабочей нагрузкой, используйте следующий запрос.

	```sql
	EXEC sp_droprolemember 'largerc', 'newperson';
	```

	> [AZURE.NOTE] Невозможно удалить пользователя из роли smallrc.

## Представление, используемое для определения запросов, поставленных в очередь, и другие динамические административные представления

Определить запросы, попавшие в параллельную очередь, можно с помощью динамического административного представления `sys.dm_pdw_exec_requests`.

```sql
SELECT 	 r.[request_id]				 AS Request_ID
	,r.[status]				 AS Request_Status
	,r.[submit_time]			 AS Request_SubmitTime
	,r.[start_time]				 AS Request_StartTime
        ,DATEDIFF(ms,[submit_time],[start_time]) AS Request_InitiateDuration_ms
        ,r.resource_class                         AS Request_resource_class
FROM    sys.dm_pdw_exec_requests r;
```

Чтобы просмотреть роли управления рабочей нагрузкой, можно использовать представление `sys.database_principals`.

```sql
SELECT  ro.[name]           AS [db_role_name]
FROM    sys.database_principals ro
WHERE   ro.[type_desc]      = 'DATABASE_ROLE'
AND     ro.[is_fixed_role]  = 0;
```

Следующий запрос позволяет определить, в какие роли добавлены пользователи.

```sql
SELECT	r.name AS role_principal_name
,		m.name AS member_principal_name
FROM	sys.database_role_members rm
JOIN	sys.database_principals AS r			ON rm.role_principal_id		= r.principal_id
JOIN	sys.database_principals AS m			ON rm.member_principal_id	= m.principal_id
WHERE	r.name IN ('mediumrc','largerc', 'xlargerc');
```

В хранилище данных SQL предусмотрены следующие типы ожиданий.

- LocalQueriesConcurrencyResourceType относится к запросам, которые не входят в систему слотов выдачи. В качестве примеров таких запросов можно привести запросы и системные функции динамических административных представлений, такие как `SELECT @@VERSION`.
- UserConcurrencyResourceType относится к запросам, которые входят в систему слотов выдачи. В качестве примеров использования этого типа ресурсов можно привести запросы к таблицам конечного пользователя.
- DmsConcurrencyResourceType относится к ожиданиям, связанным с операциями перемещения данных.
- BackupConcurrencyResourceType может использоваться при создании резервной копии базы данных. Максимальное значение для этого типа ресурсов равно 1. При одновременном запросе сразу нескольких резервных копий все остальные запросы помещаются в очередь.

Определить, какие ресурсы необходимы для запроса, можно при помощи динамического административного представления `sys.dm_pdw_waits`.

```sql
SELECT  w.[wait_id]
,       w.[session_id]
,       w.[type]			AS Wait_type
,       w.[object_type]
,       w.[object_name]
,       w.[request_id]
,       w.[request_time]
,       w.[acquire_time]
,       w.[state]
,       w.[priority]
,	SESSION_ID()			AS Current_session
,	s.[status]			AS Session_status
,	s.[login_name]
,	s.[query_count]
,	s.[client_id]
,	s.[sql_spid]
,	r.[command]			AS Request_command
,	r.[label]
,	r.[status]			AS Request_status
,	r.[submit_time]
,	r.[start_time]
,	r.[end_compile_time]
,	r.[end_time]
,	DATEDIFF(ms,r.[submit_time],r.[start_time])		AS Request_queue_time_ms
,	DATEDIFF(ms,r.[start_time],r.[end_compile_time])	AS Request_compile_time_ms
,	DATEDIFF(ms,r.[end_compile_time],r.[end_time])		AS Request_execution_time_ms
,	r.[total_elapsed_time]
FROM    sys.dm_pdw_waits w
JOIN    sys.dm_pdw_exec_sessions s  ON w.[session_id] = s.[session_id]
JOIN    sys.dm_pdw_exec_requests r  ON w.[request_id] = r.[request_id]
WHERE	w.[session_id] <> SESSION_ID();
```

Динамическое административное представление `sys.dm_pdw_resource_waits` показывает время ожидания ресурса по конкретному запросу. Время ожидания ресурсов — это время, в течение которого запросы ожидают предоставления ресурсов, а время ожидания сигнала — время, необходимое базовому экземпляру SQL Server, чтобы спланировать выделение запросу ресурсов процессора.

```sql
SELECT  [session_id]
,       [type]
,       [object_type]
,       [object_name]
,       [request_id]
,       [request_time]
,       [acquire_time]
,       DATEDIFF(ms,[request_time],[acquire_time])  AS acquire_duration_ms
,       [concurrency_slots_used]                    AS concurrency_slots_reserved
,       [resource_class]
,       [wait_id]                                   AS queue_position
FROM    sys.dm_pdw_resource_waits
WHERE	[session_id] <> SESSION_ID();
```

Для анализа тенденций по времени ожидания за прошедший период используется динамическое административное представление `sys.dm_pdw_wait_stats`.

```sql
SELECT	w.[pdw_node_id]
,		w.[wait_name]
,		w.[max_wait_time]
,		w.[request_count]
,		w.[signal_time]
,		w.[completed_count]
,		w.[wait_time]
FROM	sys.dm_pdw_wait_stats w;
```

## Дальнейшие действия

Дополнительные сведения об управлении пользователями и защите базы данных см. в статье [Защита базы данных в хранилище данных SQL][]. Дополнительные сведения о повышении качества кластеризованных индексов Columnstore за счет повышения класса ресурсов см. в статье [Индексирование таблиц в хранилище данных SQL].

<!--Image references-->

<!--Article references-->
[Защита базы данных в хранилище данных SQL]: ./sql-data-warehouse-overview-manage-security.md
[Индексирование таблиц в хранилище данных SQL]: ./sql-data-warehouse-tables-index.md#rebuilding-indexes-to-improve-segment-quality

<!--MSDN references-->
[Проверка подлинности и авторизация в базе данных SQL: предоставление доступа]: https://msdn.microsoft.com/library/azure/ee336235.aspx

<!--Other Web references-->

<!---HONumber=AcomDC_0720_2016-->