---
title: Управление параллелизмом и рабочей нагрузкой в хранилище данных SQL | Microsoft Docs
description: Общие сведения управлении параллелизмом и рабочей нагрузкой в хранилище данных SQL Azure для разработки решений.
services: sql-data-warehouse
documentationcenter: NA
author: sonyam
manager: barbkess
editor: ''

ms.service: sql-data-warehouse
ms.devlang: NA
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: data-services
ms.date: 09/27/2016
ms.author: sonyama;barbkess;jrj

---
# Управление параллелизмом и рабочей нагрузкой в хранилище данных SQL
Чтобы обеспечить прогнозируемую и соответствующую масштабу производительность, хранилище данных SQL Microsoft Azure помогает пользователям управлять уровнями параллелизма и выделением ресурсов, например выделением памяти и определением приоритетов ЦП. В этой статье рассматриваются понятия параллелизма и управления рабочей нагрузкой и объясняется, каким образом реализованы эти функции и как управлять ими в хранилище данных. Управление рабочей нагрузкой в хранилище данных SQL обеспечивает поддержку многопользовательских сред, но не поддерживает мультитенантные рабочие нагрузки.

## Пределы параллелизма
Хранилище данных SQL поддерживает до 1024 одновременных подключений. Все эти подключения могут одновременно отправлять запросы. Тем не менее, чтобы оптимизировать пропускную способность, хранилище данных SQL может помещать некоторые запросы в очередь. Это гарантирует, что на выполнение каждого запроса выделяется минимальный объем памяти. Постановка в очередь происходит во время выполнения запроса. При достижении пределов параллелизма хранилище данных SQL может повысить общую пропускную способность, обеспечивая активным запросам доступ к необходимым ресурсам памяти.

Предельные границы параллелизма в хранилище данных SQL зависят от двух значений: *количества одновременных запросов* и *количества слотов выдачи*. Запрос выполняется, если не превышено пороговое значение количества одновременных запросов и достаточно выделенного количества слотов выдачи.

* Количество одновременных запросов — это количество запросов, выполняемых в одно и то же время. Хранилище данных SQL поддерживает до 32 одновременных запросов для больших значений DWU.
* Слоты выдачи выделяются на основе DWU. Каждые 100 DWU обеспечивают 4 слота. Например, для DW100 выделяется 4 слота, а для DW1000 — 40 слотов. Каждый запрос использует один или несколько слотов выдачи. Это зависит от [класса ресурсов](#resource-classes) запроса. Запросы, выполняемые с классом ресурсов smallrc, используют один слот выдачи. Запросы, выполняемые с более высоким классом ресурсов, будут использовать больше слотов выдачи.

В таблице ниже приведены ограничения для количества одновременных запросов и слотов выдачи для разных размеров DWU.

### Пределы параллелизма
| DWU | Максимальное число одновременных запросов | Число выделенных слотов выдачи |
|:--- |:---:|:---:|
| DW100 |4\. |4\. |
| DW200 |8 |8 |
| DW300 |12 |12 |
| DW400 |16 |16 |
| DW500 |20 |20 |
| DW600 |24 |24 |
| DW1000 |32 |40 |
| DW1200 |32 |48 |
| DW1500 |32 |60 |
| DW2000 |32 |80 |
| DW3000 |32 |120 |
| DW6000 |32 |240 |

При достижении одного из этих пороговых значений, новые запросы помещаются в очередь и выполняются в порядке поступления. Когда запрос выполняется и количество запросов и слотов уменьшается, запросы извлекаются из очереди.

> [!NOTE]
> Запросы SELECT, выполняемые исключительно с динамическими административными представлениями или представлениями каталогов, *не* регулируются пороговыми значениями параллелизма. Вы можете следить за системой независимо от количества выполняемых в ней запросов.
> 
> 

## Классы ресурсов
Классы ресурсов позволяют управлять выделением памяти и циклов ЦП для заданного запроса. Пользователю можно назначить четыре класса ресурсов в виде *ролей базы данных*. Это классы **smallrc**, **mediumrc**, **largerc** и **xlargerc**. Для пользователей, использующих класс ресурсов smallrc, выделяется меньший объем памяти, и предоставляются большие возможности параллелизма. В то же время для пользователей, которым назначен класс ресурсов xlargerc, выделяется больший объем памяти, и, следовательно, меньше их запросов могут выполняться параллельно.

По умолчанию каждый пользователь является членом малого класса ресурсов — smallrc. Для повышения класса ресурсов используется процедура `sp_addrolemember`, а для уменьшения — `sp_droprolemember`. Например, следующая команда позволяет повысить класс ресурса loaduser до класса largerc.

```sql
EXEC sp_addrolemember 'largerc', 'loaduser'
```

Рекомендуется сразу назначать пользователям постоянный класс ресурсов и избегать его изменения. Например, если выделен большой объем памяти, то во время добавления данных в кластеризованные таблицы columnstore создаются индексы более высокого качества. Чтобы для операций добавления данных выделялся большой объем памяти, необходимо создать пользователя, предназначенного для этой операции, и назначить ему более высокий класс ресурсов.

Существует несколько типов запросов, которые не смогут воспользоваться преимуществами большего выделения памяти. Система будет игнорировать их параметры выделения в соответствии с классом ресурсов и всегда будет выполнять эти запросы, применяя малый класс ресурсов. Если эти запросы выполняются в малом классе ресурсов, то они смогут выполняться при нехватке слотов выдачи и не будут использовать больше слотов, чем требуется. Дополнительные сведения см. в разделе [Исключения классов ресурсов](#query-exceptions-to-concurrency-limits).

Ниже приведены дополнительные сведения о классах ресурсов.

* Чтобы изменить назначенный пользователю класс ресурсов, требуется разрешение на *изменение роли*.
* Пользователя можно добавить в один или несколько более высоких классов ресурсов, но при этом будут использоваться атрибуты самого высокого из них. Это означает, что если пользователю назначены классы ресурсов largerc и mediumrc, то преимущество будет у более высокого класса — largerc.
* Класс ресурсов для пользователя с правами системного администратора изменить нельзя.

Подробное описание примера см. в разделе [Пример изменения класса ресурсов пользователя](#changing-user-resource-class-example).

## Выделение памяти
Повышение класса ресурсов имеет свои преимущества и недостатки. Если повысить класс ресурсов для пользователя, для его запросов будет выделяться больший объем памяти, а значит, они смогут выполняться быстрее. Однако повышение класса ресурсов приводит к уменьшению количества одновременно выполняемых запросов. Нужно найти компромисс между выделением большого объема памяти для одного запроса и одновременным выполнением других запросов, для которых также требуется определенный объем памяти. Если одному пользователю выделено много памяти для запроса, то другие пользователи не будут иметь доступ к этой памяти для выполнения своих запросов.

В следующей таблице объем памяти, выделенный для каждого распределения, сопоставлен по количеству DWU и классу ресурсов.

### Выделение памяти на распределение (МБ)
| DWU | smallrc | mediumrc | largerc | xlargerc |
|:--- |:---:|:---:|:---:|:---:|
| DW100 |100 |100 |200 |400 |
| DW200 |100 |200 |400 |800 |
| DW300 |100 |200 |400 |800 |
| DW400 |100 |400 |800 |1 600 |
| DW500 |100 |400 |800 |1 600 |
| DW600 |100 |400 |800 |1 600 |
| DW1000 |100 |800 |1 600 |3200 |
| DW1200 |100 |800 |1 600 |3200 |
| DW1500 |100 |800 |1 600 |3200 |
| DW2000 |100 |1 600 |3200 |6400 |
| DW3000 |100 |1 600 |3200 |6400 |
| DW6000 |100 |3200 |6400 |12 800 |

Как видно из представленной выше таблицы, для запроса, который выполняется при DW2000 с классом ресурсов xlargerc, в каждой из 60 распределенных баз данных выделяется по 6400 МБ памяти. В хранилище данных SQL используется 60 распределений. Таким образом, чтобы вычислить, сколько памяти в целом выделяется на запросы в указанном классе ресурсов, приведенные выше значения следует умножить на 60.

### Выделение памяти для всей системы (ГБ)
| DWU | smallrc | mediumrc | largerc | xlargerc |
|:--- |:---:|:---:|:---:|:---:|
| DW100 |6 |6 |12 |23 |
| DW200 |6 |12 |23 |47 |
| DW300 |6 |12 |23 |47 |
| DW400 |6 |23 |47 |94 |
| DW500 |6 |23 |47 |94 |
| DW600 |6 |23 |47 |94 |
| DW1000 |6 |47 |94 |188 |
| DW1200 |6 |47 |94 |188 |
| DW1500 |6 |47 |94 |188 |
| DW2000 |6 |94 |188 |375 |
| DW3000 |6 |94 |188 |375 |
| DW6000 |6 |188 |375 |750 |

Как видно из таблицы выделения памяти для всей системы, для запроса, который выполняется при DW2000 с классом ресурсов xlargerc, всего выделяется 375 ГБ памяти (6400 МБ * 60 распределений/1024 (чтобы преобразовать в ГБ)) во всем хранилище данных SQL.

## Использование слотов выдачи
Хранилище данных SQL предоставляет больше памяти запросам, выполняемым при более высоких классах ресурсов. Память — фиксированный ресурс. Таким образом чем больше памяти выделяется на один запрос, тем меньше параллельных запросов можно выполнять. В следующей таблице все вышесказанное сведено в одно представление. В нем приведено количество слотов выдачи, доступное для определенного значения DWU, а также показатель их использования по классам ресурсов.

### Выделение и использование слотов выдачи
| DWU | Максимальное число одновременных запросов | Число выделенных слотов выдачи | Слоты, используемые smallrc | Слоты, используемые mediumrc | Слоты, используемые largerc | Слоты, используемые xlargerc |
|:--- |:---:|:---:|:---:|:---:|:---:|:---:|
| DW100 |4\. |4\. |1 |1 |2 |4\. |
| DW200 |8 |8 |1 |2 |4 |8 |
| DW300 |12 |12 |1 |2 |4 |8 |
| DW400 |16 |16 |1 |4 |8 |16 |
| DW500 |20 |20 |1 |4 |8 |16 |
| DW600 |24 |24 |1 |4 |8 |16 |
| DW1000 |32 |40 |1 |8 |16 |32 |
| DW1200 |32 |48 |1 |8 |16 |32 |
| DW1500 |32 |60 |1 |8 |16 |32 |
| DW2000 |32 |80 |1 |16 |32 |64 |
| DW3000 |32 |120 |1 |16 |32 |64 |
| DW6000 |32 |240 |1 |32 |64 |128 |

В этой таблице можно увидеть, что хранилище данных SQL при использовании DW1000 обрабатывает до 32 параллельных запросов и может выделить 40 слотов выдачи. Если все пользователи работают с классом smallrc, то будет разрешено выполнять 32 параллельных запроса, так как каждый запрос использует 1 слот выдачи. Если бы все пользователи при использовании DW1000 работали с классом mediumrc, то для каждого запроса было бы выделено по 800 МБ на распределение, то есть всего было бы выделено 47 ГБ памяти на запрос, и параллельно работать смогли бы только 5 таких пользователей (40 слотов выдачи / 8 слотов на пользователя с классом ресурсов mediumrc).

## Приоритет при выполнении запросов
Классы ресурсов в хранилище данных SQL реализованы с помощью групп рабочей нагрузки. Для управления поведением классов ресурсов для различных размеров DWU используются восемь групп рабочей нагрузки. Для любого значения DWU хранилище данных SQL использует только четыре группы рабочей нагрузки из восьми. Это связано с тем, что каждая группа рабочей нагрузки назначается только одному из четырех классов ресурсов: smallrc, mediumrc, largerc или xlargerc. Этот аспект важно учитывать, так как некоторым группам рабочей нагрузки назначается более высокий *приоритет*. Значение приоритета используется при планировании распределения ресурсов ЦП. Запросы, которым назначен высокий приоритет, получают в три раза больше циклов ЦП, чем запросы со средним приоритетом. Поэтому сопоставление слотов выдачи также определяет приоритет ЦП. Если для выполнения запроса используется 16 или больше слотов, он помечается как запрос с высоким приоритетом.

В таблице ниже приведены сведения о приоритете для каждой группы рабочей нагрузки.

### Сопоставление групп рабочей нагрузки со слотами выдачи и приоритетами
| Группы рабочей нагрузки | Сопоставление слотов выдачи | МБ/распределение | Приоритет |
|:--- |:---:|:---:|:--- |
| SloDWGroupC00 |1 |100 |Средний |
| SloDWGroupC01 |2 |200 |Средний |
| SloDWGroupC02 |4 |400 |Средний |
| SloDWGroupC03 |8 |800 |Средний |
| SloDWGroupC04 |16 |1 600 |Высокий |
| SloDWGroupC05 |32 |3200 |Высокий |
| SloDWGroupC06 |64 |6400 |Высокий |
| SloDWGroupC07 |128 |12 800 |Высокий |

На диаграмме **Выделение и использование слотов выдачи** видно, что DW500 использует 1, 4, 8 или 16 слотов выдачи для классов smallrc, mediumrc, largerc и xlargerc, соответственно. Вы можете ознакомиться с этими значениями на предыдущей диаграмме, чтобы узнать приоритет каждого класса ресурсов.

### Сопоставление классов ресурсов с приоритетами для DW500
| Класс ресурсов | Группа рабочей нагрузки | Число используемых слотов выдачи | МБ/распределение | Важность |
|:--- |:--- |:---:|:---:|:--- |
| smallrc |SloDWGroupC00 |1 |100 |Средний |
| mediumrc |SloDWGroupC02 |4 |400 |Средний |
| largerc |SloDWGroupC03 |8 |800 |Средний |
| xlargerc |SloDWGroupC04 |16 |1 600 |Высокий |

С помощью приведенного ниже запроса к динамическому административному представлению можно увидеть различия в распределении ресурсов памяти с точки зрения регулятора ресурсов. Этот запрос также подходит для анализа текущего и предыдущего использования групп рабочей нагрузки при устранении неполадок.

```sql
WITH rg
AS
(   SELECT  
     pn.name                        AS node_name
    ,pn.[type]                        AS node_type
    ,pn.pdw_node_id                    AS node_id
    ,rp.name                        AS pool_name
    ,rp.max_memory_kb*1.0/1024                AS pool_max_mem_MB
    ,wg.name                        AS group_name
    ,wg.importance                    AS group_importance
    ,wg.request_max_memory_grant_percent        AS group_request_max_memory_grant_pcnt
    ,wg.max_dop                        AS group_max_dop
    ,wg.effective_max_dop                AS group_effective_max_dop
    ,wg.total_request_count                AS group_total_request_count
    ,wg.total_queued_request_count            AS group_total_queued_request_count
    ,wg.active_request_count                AS group_active_request_count
    ,wg.queued_request_count                AS group_queued_request_count
    FROM    sys.dm_pdw_nodes_resource_governor_workload_groups wg
    JOIN    sys.dm_pdw_nodes_resource_governor_resource_pools rp    
            ON  wg.pdw_node_id  = rp.pdw_node_id
            AND wg.pool_id      = rp.pool_id
    JOIN    sys.dm_pdw_nodes pn
            ON    wg.pdw_node_id    = pn.pdw_node_id
    WHERE   wg.name like 'SloDWGroup%'
        AND     rp.name = 'SloDWPool'
)
SELECT    pool_name
,        pool_max_mem_MB
,        group_name
,        group_importance
,        (pool_max_mem_MB/100)*group_request_max_memory_grant_pcnt AS max_memory_grant_MB
,        node_name
,        node_type
,       group_total_request_count
,       group_total_queued_request_count
,       group_active_request_count
,       group_queued_request_count
FROM    rg
ORDER BY
    node_name
,    group_request_max_memory_grant_pcnt
,    group_importance
;
```

## Запросы, учитывающие пределы параллелизма
Большинство запросов управляются классами ресурсов. Эти запросы не должны выходить за пороговые значения количества параллельных запросов и слотов выдачи. Пользователь не может самостоятельно исключить запрос из модели слотов выдачи.

Обратите внимание, что приведенные ниже инструкции учитывают классы ресурсов:

* INSERT SELECT
* UPDATE
* УДАЛИТЬ
* SELECT (при запросе таблиц пользователя)
* ALTER INDEX REBUILD
* ALTER INDEX REORGANIZE
* ALTER TABLE REBUILD
* CREATE INDEX
* CREATE CLUSTERED COLUMNSTORE INDEX
* CREATE TABLE AS SELECT (CTAS)
* Загрузка данных
* Операции перемещения данных, осуществляемые службой Data Movement Service (DMS)

## Исключения для запросов в отношении ограничений параллелизма
Некоторые запросы не учитывают класс ресурсов, которой назначен пользователю. Эти исключения в отношении ограничения параллелизма допускаются, когда не хватает ресурсов памяти, нужных для выполнения определенной команды, так как нередко команда является операцией с метаданными. Такие исключения позволяют избежать выделения большого объема памяти для запросов, которым она никогда не понадобится. В таких случаях используется класс небольших ресурсов по умолчанию (smallrc), независимо от того, какой класс ресурсов назначен пользователю. Например, `CREATE LOGIN` всегда будет работать с классом smallrc. Для выполнения этой задачи не требуются значительные ресурсы, поэтому нет смысла включать этот запрос в модель слотов выдачи. Эти запросы также не ограничивается пределом в 32 одновременных запроса на пользователя. Может быть выполнено неограниченное количество этих запросов в пределах максимального числа сеансов, равного 1024.

Приведенные ниже инструкции не учитывают классы ресурсов:

* CREATE или DROP TABLE;
* ALTER TABLE ... SWITCH, SPLIT или MERGE PARTITION;
* ALTER INDEX DISABLE
* DROP INDEX
* CREATE, UPDATE или DROP STATISTICS;
* TRUNCATE TABLE
* ALTER AUTHORIZATION
* CREATE LOGIN
* CREATE, ALTER или DROP USER;
* CREATE, ALTER или DROP PROCEDURE;
* CREATE или DROP VIEW;
* INSERT VALUES
* SELECT (из системных представлений и динамических административных представлений);
* EXPLAIN
* DBCC

<!--
Removed as these two are not confirmed / supported under SQLDW
- CREATE REMOTE TABLE AS SELECT
- CREATE EXTERNAL TABLE AS SELECT
- REDISTRIBUTE
-->

## Пример изменения класса ресурсов пользователя
1. **Создание имени для входа**. Откройте подключение к базе данных **master** на сервере SQL Server, на котором размещена база данных хранилища данных SQL, и выполните следующие команды.
   
    ```sql
    CREATE LOGIN newperson WITH PASSWORD = 'mypassword';
    CREATE USER newperson for LOGIN newperson;
    ```
   
   > [!NOTE]
   > Рекомендуется создать в базе данных master учетную запись для пользователей хранилища данных SQL Azure. Это позволит пользователям входить в систему с помощью таких инструментов, как среда SSMS, без указания имени базы данных. Кроме того, это позволяет использовать обозреватель объектов для просмотра всех баз данных в SQL Server. Дополнительные сведения о создании пользователей и управлении ими см. в разделе [Защита базы данных в хранилище данных SQL][Защита базы данных в хранилище данных SQL].
   > 
   > 
2. **Создание учетной записи пользователя хранилища данных SQL**. Откройте подключение к базе данных **хранилища данных SQL** и выполните следующую команду.
   
    ```sql
    CREATE USER newperson FOR LOGIN newperson;
    ```
3. **Предоставление разрешений**. В следующем примере предоставляется разрешение `CONTROL` для базы данных **хранилища данных SQL**. Разрешение `CONTROL` на уровне базы данных соответствует роли db\_owner в SQL Server.
   
    ```sql
    GRANT CONTROL ON DATABASE::MySQLDW to newperson;
    ```
4. **Повышение класса ресурсов**. Чтобы добавить пользователя к роли управления более высокой рабочей нагрузкой, используйте следующий запрос.
   
    ```sql
    EXEC sp_addrolemember 'largerc', 'newperson'
    ```
5. **Понижение класса ресурсов**. Чтобы удалить пользователя из роли управления рабочей нагрузкой, используйте следующий запрос.
   
    ```sql
    EXEC sp_droprolemember 'largerc', 'newperson';
    ```
   
   > [!NOTE]
   > Невозможно удалить пользователя из smallrc.
   > 
   > 

## Представление, используемое для определения запросов, поставленных в очередь, и другие динамические административные представления
Определить запросы, попавшие в очередь параллельной обработки, можно с помощью динамического административного представления `sys.dm_pdw_exec_requests`. Запросы, ожидающие выделения слота выдачи, будет находиться в **приостановленном** состоянии.

```sql
SELECT      r.[request_id]                 AS Request_ID
        ,r.[status]                 AS Request_Status
        ,r.[submit_time]             AS Request_SubmitTime
        ,r.[start_time]                 AS Request_StartTime
        ,DATEDIFF(ms,[submit_time],[start_time]) AS Request_InitiateDuration_ms
        ,r.resource_class                         AS Request_resource_class
FROM    sys.dm_pdw_exec_requests r;
```

Чтобы просмотреть роли управления рабочей нагрузкой, можно использовать представление `sys.database_principals`.

```sql
SELECT  ro.[name]           AS [db_role_name]
FROM    sys.database_principals ro
WHERE   ro.[type_desc]      = 'DATABASE_ROLE'
AND     ro.[is_fixed_role]  = 0;
```

Следующий запрос позволяет определить, в какие роли добавлены пользователи.

```sql
SELECT     r.name AS role_principal_name
        ,m.name AS member_principal_name
FROM    sys.database_role_members rm
JOIN    sys.database_principals AS r            ON rm.role_principal_id        = r.principal_id
JOIN    sys.database_principals AS m            ON rm.member_principal_id    = m.principal_id
WHERE    r.name IN ('mediumrc','largerc', 'xlargerc');
```

В хранилище данных SQL предусмотрены следующие типы ожиданий.

* **LocalQueriesConcurrencyResourceType** относится к запросам, которые не входят в платформу слотов выдачи. В качестве примеров таких запросов можно привести запросы и системные функции динамических административных представлений, такие как `SELECT @@VERSION`.
* **UserConcurrencyResourceType** относится к запросам, которые входят в платформу слотов выдачи. В качестве примеров использования этого типа ресурсов можно привести запросы к таблицам пользователя.
* **DmsConcurrencyResourceType** относится к ожиданиям, связанным с операциями перемещения данных.
* **BackupConcurrencyResourceType** может использоваться при создании резервной копии базы данных. Максимальное значение для этого типа ресурсов равно 1. При одновременном запросе сразу нескольких резервных копий все остальные запросы помещаются в очередь.

Определить, какие ресурсы необходимы для запроса, можно при помощи динамического административного представления `sys.dm_pdw_waits`.

```sql
SELECT  w.[wait_id]
,       w.[session_id]
,       w.[type]            AS Wait_type
,       w.[object_type]
,       w.[object_name]
,       w.[request_id]
,       w.[request_time]
,       w.[acquire_time]
,       w.[state]
,       w.[priority]
,    SESSION_ID()            AS Current_session
,    s.[status]            AS Session_status
,    s.[login_name]
,    s.[query_count]
,    s.[client_id]
,    s.[sql_spid]
,    r.[command]            AS Request_command
,    r.[label]
,    r.[status]            AS Request_status
,    r.[submit_time]
,    r.[start_time]
,    r.[end_compile_time]
,    r.[end_time]
,    DATEDIFF(ms,r.[submit_time],r.[start_time])        AS Request_queue_time_ms
,    DATEDIFF(ms,r.[start_time],r.[end_compile_time])    AS Request_compile_time_ms
,    DATEDIFF(ms,r.[end_compile_time],r.[end_time])        AS Request_execution_time_ms
,    r.[total_elapsed_time]
FROM    sys.dm_pdw_waits w
JOIN    sys.dm_pdw_exec_sessions s  ON w.[session_id] = s.[session_id]
JOIN    sys.dm_pdw_exec_requests r  ON w.[request_id] = r.[request_id]
WHERE    w.[session_id] <> SESSION_ID();
```

Динамическое административное представление `sys.dm_pdw_resource_waits` показывает только время ожидания ресурса по конкретному запросу. Время ожидания ресурсов — это время, в течение которого запросы ожидают предоставления ресурсов, а время ожидания сигнала — время, необходимое базовому экземпляру SQL Server, чтобы спланировать выделение запросу ресурсов ЦП.

```sql
SELECT  [session_id]
,       [type]
,       [object_type]
,       [object_name]
,       [request_id]
,       [request_time]
,       [acquire_time]
,       DATEDIFF(ms,[request_time],[acquire_time])  AS acquire_duration_ms
,       [concurrency_slots_used]                    AS concurrency_slots_reserved
,       [resource_class]
,       [wait_id]                                   AS queue_position
FROM    sys.dm_pdw_resource_waits
WHERE    [session_id] <> SESSION_ID();
```

Для анализа тенденций времени ожидания за прошедший период используется динамическое административное представление `sys.dm_pdw_wait_stats`.

```sql
SELECT    w.[pdw_node_id]
,        w.[wait_name]
,        w.[max_wait_time]
,        w.[request_count]
,        w.[signal_time]
,        w.[completed_count]
,        w.[wait_time]
FROM    sys.dm_pdw_wait_stats w;
```

## Дальнейшие действия
Дополнительные сведения об управлении пользователями и безопасностью базы данных см. в статье [Защита базы данных в хранилище данных SQL][Защита базы данных в хранилище данных SQL]. Дополнительные сведения о повышении качества кластеризованных индексов columnstore за счет повышения класса ресурсов см. в статье [Индексирование таблиц в хранилище данных SQL].

<!--Image references-->

<!--Article references-->
[Secure a database in SQL Data Warehouse]: ./sql-data-warehouse-overview-manage-security.md
[Индексирование таблиц в хранилище данных SQL]: ./sql-data-warehouse-tables-index.md#rebuilding-indexes-to-improve-segment-quality
[Защита базы данных в хранилище данных SQL]: ./sql-data-warehouse-overview-manage-security.md

<!--MSDN references-->
[Managing Databases and Logins in Azure SQL Database]: https://msdn.microsoft.com/library/azure/ee336235.aspx

<!--Other Web references-->

<!---HONumber=AcomDC_0928_2016-->