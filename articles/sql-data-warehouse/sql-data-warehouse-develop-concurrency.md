<properties
   pageTitle="Управление параллелизмом и рабочей нагрузкой в хранилище данных SQL | Microsoft Azure"
   description="Общие сведения управлении параллелизмом и рабочей нагрузкой в хранилище данных SQL Azure для разработки решений."
   services="sql-data-warehouse"
   documentationCenter="NA"
   authors="jrowlandjones"
   manager="barbkess"
   editor=""/>

<tags
   ms.service="sql-data-warehouse"
   ms.devlang="NA"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="data-services"
   ms.date="08/02/2016"
   ms.author="jrj;barbkess;sonyama"/>

# Управление параллелизмом и рабочей нагрузкой в хранилище данных SQL

Для обеспечения прогнозируемой высокой производительности в хранилище данных SQL реализованы механизмы, которые позволяют пользователям управлять уровнем параллелизма и выделением ресурсов, например выделением памяти и определением приоритетов ЦП. В этой статье рассматриваются понятия параллелизма и управления рабочей нагрузкой и объясняется, каким образом реализованы эти функции и как управлять ими в хранилище данных. Управление рабочей нагрузкой в хранилище данных SQL обеспечивает поддержку многопользовательских сред, но не поддерживает мультитенантные рабочие нагрузки.

## Пределы параллелизма

Хранилище данных SQL поддерживает до 1024 одновременных подключений. Все эти подключения могут одновременно отправлять запросы. Тем не менее, чтобы оптимизировать пропускную способность, хранилище данных SQL может помещать некоторые запросы в очередь. Это гарантирует, что на выполнение каждого запроса выделяется минимальный объем памяти. Постановка в очередь происходит во время выполнения запроса. При достижении пределов параллелизма хранилище данных SQL может повысить общую пропускную способность, обеспечивая активным запросам доступ к необходимым ресурсам памяти.

Предельные границы параллелизма в хранилище данных SQL зависят от двух значений: **количества одновременных запросов** и **количества слотов выдачи**. Запрос выполняется, если не превышено пороговое значение количества одновременных запросов и достаточно выделенного количества слотов выдачи.

- **Количество одновременных запросов** — это количество запросов, выполняемых в одно и то же время. Хранилище данных SQL поддерживает до 32 одновременных запросов.
- **Слоты выдачи** выделяются на основе DWU. Каждые 100 DWU обеспечивают 4 слота. Например, для DW100 выделяется 4 слота, а для DW1000 — 40 слотов. Каждый запрос использует один или несколько слотов выдачи. Это зависит от [класса ресурсов](#resource-classes) запроса. Запросы, выполняемые с классом ресурсов smallrc, используют один слот выдачи. Запросы, выполняемые с более высоким классом ресурсов, будут использовать больше слотов выдачи.

В таблице ниже приведены ограничения для количества одновременных запросов и слотов выдачи для разных размеров DWU.

### Пределы параллелизма

| DWU | Макс. число одновременных запросов | Число выделенных слотов выдачи |
| :----  | :---------------------: | :-------------------------: |
| DW100 | 32 | 4\. |
| DW200 | 32 | 8 |
| DW300 | 32 | 12 |
| DW400 | 32 | 16 |
| DW500 | 32 | 20 |
| DW600 | 32 | 24 |
| DW1000 | 32 | 40 |
| DW1200 | 32 | 48 |
| DW1500 | 32 | 60 |
| DW2000 | 32 | 80 |
| DW3000 | 32 | 120 |
| DW6000 | 32 | 240 |

Когда эти пороговые значения достигаются, последующие запросы помещаются в очередь. Запросы в очереди выполняются по принципу очередности по мере выполнения предыдущих запросов и нормализации числа запросов и слотов выдачи.

> [AZURE.NOTE]  Запросы SELECT, выполняемые исключительно с динамическими административными представлениями или представлениями каталогов, **не** регулируются пороговым значением параллельных запросов. Это позволяет пользователям следить за системой независимо от того, какое количество запросов выполняется в системе.

## Классы ресурсов

Классы ресурсов позволяют управлять выделением памяти и циклов ЦП для заданного запроса. Существует четыре разных класса ресурсов, каждый из которых может назначаться пользователю в виде **роли базы данных**: **smallrc, mediumrc, largerc и xlargerc**. Для пользователей, которые относятся к классу ресурсов smallrc, выделяется меньший объем памяти, что, в свою очередь, приводит к более высокому параллелизму. В то же время для пользователей, которым назначен класс ресурсов xlargerc, выделяется больший объем памяти, и, следовательно, меньше запросов могут выполняться параллельно.

По умолчанию каждый пользователь является членом малого класса ресурсов — smallrc. Для повышения класса ресурсов используется процедура `sp_addrolemember`, а для уменьшения — `sp_droprolemember`. Например, следующая команда позволяет повысить класс ресурса loaduser до класса largerc:

```sql
EXEC sp_addrolemember 'largerc', 'loaduser'
```

Рекомендуется сразу назначать пользователям постоянный класс ресурсов и избегать его изменения. Например, если выделен большой объем памяти, во время добавления данных в кластеризованные таблицы Columnstore создаются индексы более высокого качества. Чтобы для операций добавления данных выделялся большой объем памяти, необходимо создать пользователя, предназначенного для этой операции, и назначить ему более высокий класс ресурсов.

Существует несколько типов запросов, для выполнения которых не требуется большой объем памяти. Система не будет учитывать выделенные ресурсы в соответствующем классе и всегда будет выполнять эти запросы в классе с небольшими ресурсами. Таким образом, эти запросы смогут выполняться при нехватке слотов выдачи и не будут потреблять больше слотов, чем необходимо. [Исключения классов ресурсов](#query-exceptions-to-concurrency-limits) рассматриваются ниже в этой статье.

Ниже приведены дополнительные сведения о классах ресурсов.

- Чтобы изменить назначенный пользователю класс ресурсов, требуется разрешение `ALTER ROLE`.
- Пользователя можно добавить в один или несколько классов ресурсов, но при этом будут использоваться атрибуты самого высокого из них. Это означает, что если пользователю назначены классы ресурсов largerc и mediumrc, преимущество будет у более высокого класса — largerc.
- Класс ресурсов для пользователя с правами системного администратора изменить нельзя.
 
Подробное описание примера см. в разделе [Пример изменения класса ресурсов пользователя](#changing-user-resource-class-example) в конце этой статьи.

## Выделение памяти

Повышение класса ресурсов имеет свои преимущества и недостатки. Если назначить для пользователя более высокий класс ресурсов, то для запросов будет выделяться больший объем памяти, а значит, они смогут выполняться быстрее. Кроме того, повышение класса ресурсов позволяет уменьшить количество одновременно выполняемых запросов. Компромисс заключается в том, что при выделении большого объема памяти для одного запроса снижается количество одновременных запросов, для которых также требуется определенный объем памяти. Если одному пользователю выделено много памяти для запроса, то другие пользователи не будут иметь доступ к этой памяти для выполнения своих запросов.

В следующей таблице объем памяти, выделенный для каждого распределения, сопоставлен по количеству DWU и классу ресурсов. В хранилище данных SQL используется 60 распределений. Например, для запроса, который выполняется при DW2000 с классом ресурсов xlarge, в каждой из 60 распределенных баз данных выделяется по 6400 МБ памяти.

### Выделение памяти на распределение (МБ)

| DWU | smallrc | mediumrc | largerc | xlargerc |
| :----- | :-----: | :------: | :-----: | :------: |
| DW100 | 100 | 100 | 200 | 400 |
| DW200 | 100 | 200 | 400 | 800 |
| DW300 | 100 | 200 | 400 | 800 |
| DW400 | 100 | 400 | 800 | 1 600 |
| DW500 | 100 | 400 | 800 | 1 600 |
| DW600 | 100 | 400 | 800 | 1 600 |
| DW1000 | 100 | 800 | 1 600 | 3200 |
| DW1200 | 100 | 800 | 1 600 | 3200 |
| DW1500 | 100 | 800 | 1 600 | 3200 |
| DW2000 | 100 | 1 600 | 3200 | 6400 |
| DW3000 | 100 | 1 600 | 3200 | 6400 |
| DW6000 | 100 | 3200 | 6400 | 12 800 |

Исходя из вышеупомянутого примера, для запроса, который выполняется при DW2000 с классом ресурсов xlarge, всего выделяется 375 ГБ памяти (6400 МБ * 60 распределений / 1024 (чтобы преобразовать в ГБ)) во всем хранилище данных SQL.

### Выделение памяти для всей системы (ГБ)

| DWU | smallrc | mediumrc | largerc | xlargerc |
| :----- | :-----: | :------: | :-----: | :------: |
| DW100 | 6 | 6 | 12 | 23 |
| DW200 | 6 | 12 | 23 | 47 |
| DW300 | 6 | 12 | 23 | 47 |
| DW400 | 6 | 23 | 47 | 94 |
| DW500 | 6 | 23 | 47 | 94 |
| DW600 | 6 | 23 | 47 | 94 |
| DW1000 | 6 | 47 | 94 | 188 |
| DW1200 | 6 | 47 | 94 | 188 |
| DW1500 | 6 | 47 | 94 | 188 |
| DW2000 | 6 | 94 | 188 | 375 |
| DW3000 | 6 | 94 | 188 | 375 |
| DW6000 | 6 | 188 | 375 | 750 |


## Использование слотов выдачи

Запросам, выполняемым с более высоким классом ресурсов, предоставляется больше памяти. Так как память является фиксированным ресурсом, то чем больше памяти выделяется на выполнение одного запроса, тем ниже параллелизм. В следующей таблице все вышесказанное сведено в одно представление. В нем приведено количество слотов выдачи, доступное для определенного значения DWU, а также показатель их использования по классам ресурсов.

### Выделение и использование слотов выдачи

| DWU | Макс. число одновременных запросов | Число выделенных слотов выдачи | Слоты, используемые smallrc | Слоты, используемые mediumrc | Слоты, используемые largerc | Слоты, используемые xlargerc |
| :----  | :---------------------: | :-------------------------: | :-----: | :------: | :-----: | :------: |
| DW100 | 32 | 4 | 1 | 1 | 2 | 4\. |
| DW200 | 32 | 8 | 1 | 2 | 4 | 8 |
| DW300 | 32 | 12 | 1 | 2 | 4 | 8 |
| DW400 | 32 | 16 | 1 | 4 | 8 | 16 |
| DW500 | 32 | 20 | 1 | 4 | 8 | 16 |
| DW600 | 32 | 24 | 1 | 4 | 8 | 16 |
| DW1000 | 32 | 40 | 1 | 8 | 16 | 32 |
| DW1200 | 32 | 48 | 1 | 8 | 16 | 32 |
| DW1500 | 32 | 60 | 1 | 8 | 16 | 32 |
| DW2000 | 32 | 80 | 1 | 16 | 32 | 64 |
| DW3000 | 32 | 120 | 1 | 16 | 32 | 64 |
| DW6000 | 32 | 240 | 1 | 32 | 64 | 128 |


В этой таблице можно увидеть, что хранилище данных SQL при использовании DW1000 обрабатывает до 32 параллельных запросов и может выделить 40 слотов выдачи. Если все пользователи работают с классом небольших ресурсов, то будет разрешено выполнять 32 параллельных запроса, так как каждый запрос использует 1 слот выдачи. Если бы все пользователи при использовании DW1000 работали с классом средних ресурсов, то для каждого запроса было бы выделено по 800 МБ на распределение, то есть всего было бы выделено 47 ГБ памяти на запрос, и параллельно работать смогли бы только 5 таких пользователей (40 слотов выдачи / 8 слотов на пользователя с классом ресурсов mediumrc).

## Приоритет при выполнении запросов

На самом деле классы ресурсов реализованы с помощью групп рабочей нагрузки. Для управления поведением классов ресурсов для различных размеров DWU используются восемь групп рабочей нагрузки. Однако для любого размера DWU используются только четыре из них. Это связано с тем, что каждая группа рабочей нагрузки назначается только одному из четырех классов ресурсов: smallrc, mediumrc, largerc или xlargerc. Этот аспект важно учитывать, так как некоторым группам рабочей нагрузки назначается более высокий **приоритет**. Значение приоритета используется при планировании распределения ресурсов ЦП. Запросы, которым назначен **высокий** приоритет, получают в 3 раза больше циклов ЦП, чем запросы со **средним** приоритетом. Поэтому сопоставление слотов выдачи также определяет приоритет ЦП. Если для выполнения запроса используется 16 или больше слотов, он помечается как запрос с высоким приоритетом.

Ниже приведены сведения о приоритете для каждой группы рабочей нагрузки.

### Сопоставление групп рабочей нагрузки со слотами выдачи и приоритетами

| Группы рабочей нагрузки | Сопоставление слотов выдачи | Приоритет |
| :-------------- | :----------------------: | :----------------- |
| SloDWGroupC00 | 1 | Средний |
| SloDWGroupC01 | 2 | Средний |
| SloDWGroupC02 | 4 | Средний |
| SloDWGroupC03 | 8 | Средний |
| SloDWGroupC04 | 16 | Высокий |
| SloDWGroupC05 | 32 | Высокий |
| SloDWGroupC06 | 64 | Высокий |
| SloDWGroupC07 | 128 | Высокий |

На диаграмме **Выделение и использование слотов выдачи** видно, что DW500 использует 1, 4, 8 или 16 слотов выдачи для smallrc, mediumrc, largerc и xlargerc, соответственно. Мы можем найти эти значения на диаграмме выше, чтобы узнать приоритет каждого класса ресурсов.

### Сопоставление классов ресурсов с приоритетами для DW500

| Класс ресурсов | Группа рабочей нагрузки | Число используемых слотов выдачи | Важность |
| :------------- | :------------- | :--------------------: | :--------- |
| smallrc | SloDWGroupC00 | 1 | Средний |
| mediumrc | SloDWGroupC02 | 4 | Средний |
| largerc | SloDWGroupC03 | 8 | Средний |
| xlargerc | SloDWGroupC04 | 16 | Высокий |


Используйте следующий запрос динамического административного представления, чтобы увидеть различия в распределении ресурсов памяти с точки зрения регулятора ресурсов. Этот запрос также подходит для анализа текущего и предыдущего использования групп рабочей нагрузки при устранении неполадок.

```sql
WITH rg
AS
(   SELECT  
     pn.name						AS node_name
    ,pn.[type]						AS node_type
    ,pn.pdw_node_id					AS node_id
    ,rp.name						AS pool_name
    ,rp.max_memory_kb*1.0/1024				AS pool_max_mem_MB
    ,wg.name						AS group_name
    ,wg.importance					AS group_importance
    ,wg.request_max_memory_grant_percent		AS group_request_max_memory_grant_pcnt
    ,wg.max_dop						AS group_max_dop
    ,wg.effective_max_dop				AS group_effective_max_dop
    ,wg.total_request_count				AS group_total_request_count
    ,wg.total_queued_request_count			AS group_total_queued_request_count
    ,wg.active_request_count				AS group_active_request_count
    ,wg.queued_request_count				AS group_queued_request_count
    FROM    sys.dm_pdw_nodes_resource_governor_workload_groups wg
    JOIN    sys.dm_pdw_nodes_resource_governor_resource_pools rp    
            ON  wg.pdw_node_id  = rp.pdw_node_id
    	    AND wg.pool_id      = rp.pool_id
    JOIN    sys.dm_pdw_nodes pn	
            ON	wg.pdw_node_id	= pn.pdw_node_id
    WHERE   wg.name like 'SloDWGroup%'
        AND     rp.name = 'SloDWPool'
)
SELECT	pool_name
,		pool_max_mem_MB
,		group_name
,		group_importance
,		(pool_max_mem_MB/100)*group_request_max_memory_grant_pcnt AS max_memory_grant_MB
,		node_name
,		node_type
,       group_total_request_count
,       group_total_queued_request_count
,       group_active_request_count
,       group_queued_request_count
FROM	rg
ORDER BY
	node_name
,	group_request_max_memory_grant_pcnt
,	group_importance
;
```

## Запросы, учитывающие пределы параллелизма

Большинство запросов управляются классами ресурсов. Эти запросы не должны выходить за пороговые значения количества параллельных запросов и слотов выдачи. Пользователь не может самостоятельно исключить запрос из модели слотов выдачи.

Обратите внимание, что приведенные ниже инструкции **учитывают** классы ресурсов.

- INSERT SELECT
- UPDATE
- УДАЛИТЬ
- SELECT (при запросе таблиц пользователя)
- ALTER INDEX REBUILD
- ALTER INDEX REORGANIZE
- ALTER TABLE REBUILD
- CREATE INDEX
- CREATE CLUSTERED COLUMNSTORE INDEX
- CREATE TABLE AS SELECT (CTAS)
- Загрузка данных
- Операции перемещения данных, осуществляемые службой Data Movement Service (DMS)

## Исключения для запросов в отношении ограничений параллелизма

Некоторые запросы не учитывают класс ресурсов, которой назначен пользователю. Эти исключения в отношении ограничения параллелизма допускаются, когда не хватает ресурсов памяти, нужных для выполнения определенной команды, так как нередко команда является операцией с метаданными. Благодаря этим исключениям можно избежать выделения большого объема памяти для запросов, которым она никогда не понадобится. В таких случаях используется класс небольших ресурсов по умолчанию (smallrc), независимо от того, какой класс ресурсов назначен пользователю. Например, `CREATE LOGIN` всегда будет работать с классом smallrc. Для выполнения этой задачи не требуются значительные ресурсы, поэтому нет смысла включать этот запрос в модель слотов выдачи. Для этого действия было бы расточительным использовать предварительно выделяемый объем памяти. Путем исключения `CREATE LOGIN` из модели слотов выдачи хранилище данных SQL может использоваться значительно эффективнее.

Следующие инструкции **не** учитывают классы ресурсов:

- CREATE или DROP TABLE;
- ALTER TABLE ... SWITCH, SPLIT или MERGE PARTITION;
- ALTER INDEX DISABLE
- DROP INDEX
- CREATE, UPDATE или DROP STATISTICS;
- TRUNCATE TABLE
- ALTER AUTHORIZATION
- CREATE LOGIN
- CREATE, ALTER или DROP USER;
- CREATE, ALTER или DROP PROCEDURE;
- CREATE или DROP VIEW;
- INSERT VALUES
- SELECT (из системных представлений и динамических административных представлений);
- EXPLAIN
- DBCC

<!--
Removed as these two are not confirmed / supported under SQLDW
- CREATE REMOTE TABLE AS SELECT
- CREATE EXTERNAL TABLE AS SELECT
- REDISTRIBUTE
-->

## Пример изменения класса ресурсов пользователя

1. **Создание имени входа**. Откройте подключение к базе данных **master** для хранилища данных SQL и выполните следующие команды.
	
	```sql
	CREATE LOGIN newperson WITH PASSWORD = 'mypassword';
	CREATE USER newperson for LOGIN newperson;
	```

	> [AZURE.NOTE] Рекомендуется создать пользователей для входа в базу данных master при работе с базой данных Azure SQL и хранилищем данных SQL. На этом уровне доступны две роли сервера, требующих наличия пользователя в базе данных master для имени для входа, чтобы предоставить членство. Это роли `Loginmanager` и `dbmanager`. Как в базе данных Azure SQL, так и в хранилище данных SQL эти роли предоставляют права на управление именами для входа и создание баз данных. В этом отличие от SQL Server. Дополнительные сведения см. в статье [Проверка подлинности и авторизация в базе данных SQL: предоставление доступа][].

2. **Создание учетной записи пользователя**. Откройте подключение к **базе данных хранилища данных SQL** и выполните следующую команду.

	```sql
	CREATE USER newperson FOR LOGIN newperson;
	```

3. **Предоставление разрешений**. В следующем примере предоставляется разрешение `CONTROL` для базы данных хранилища данных SQL. Разрешение `CONTROL` на уровне базы данных соответствует роли db\_owner в SQL Server.

	```sql
	GRANT CONTROL ON DATABASE::MySQLDW to newperson;
	```

4. **Повышение класса ресурсов**. Чтобы добавить пользователя к роли управления более высокой рабочей нагрузкой, используйте следующий запрос.

	```sql
	EXEC sp_addrolemember 'largerc', 'newperson'
	```

5. **Снижение класса ресурсов**. Чтобы удалить пользователя из роли управления рабочей нагрузкой, используйте следующий запрос.

	```sql
	EXEC sp_droprolemember 'largerc', 'newperson';
	```

	> [AZURE.NOTE] Невозможно удалить пользователя из роли smallrc.

## Представление, используемое для определения запросов, поставленных в очередь, и другие динамические административные представления

Определить запросы, попавшие в параллельную очередь, можно с помощью динамического административного представления `sys.dm_pdw_exec_requests`. Запросы, ожидающие выделения слота выдачи, будет находиться в **приостановленном** состоянии.

```sql
SELECT 	 r.[request_id]				 AS Request_ID
	,r.[status]				 AS Request_Status
	,r.[submit_time]			 AS Request_SubmitTime
	,r.[start_time]				 AS Request_StartTime
        ,DATEDIFF(ms,[submit_time],[start_time]) AS Request_InitiateDuration_ms
        ,r.resource_class                         AS Request_resource_class
FROM    sys.dm_pdw_exec_requests r;
```

Чтобы просмотреть роли управления рабочей нагрузкой, можно использовать представление `sys.database_principals`.

```sql
SELECT  ro.[name]           AS [db_role_name]
FROM    sys.database_principals ro
WHERE   ro.[type_desc]      = 'DATABASE_ROLE'
AND     ro.[is_fixed_role]  = 0;
```

Следующий запрос позволяет определить, в какие роли добавлены пользователи.

```sql
SELECT	r.name AS role_principal_name
,		m.name AS member_principal_name
FROM	sys.database_role_members rm
JOIN	sys.database_principals AS r			ON rm.role_principal_id		= r.principal_id
JOIN	sys.database_principals AS m			ON rm.member_principal_id	= m.principal_id
WHERE	r.name IN ('mediumrc','largerc', 'xlargerc');
```

В хранилище данных SQL предусмотрены следующие типы ожиданий.

- LocalQueriesConcurrencyResourceType относится к запросам, которые не входят в систему слотов выдачи. В качестве примеров таких запросов можно привести запросы и системные функции динамических административных представлений, такие как `SELECT @@VERSION`.
- UserConcurrencyResourceType относится к запросам, которые входят в систему слотов выдачи. В качестве примеров использования этого типа ресурсов можно привести запросы к таблицам конечного пользователя.
- DmsConcurrencyResourceType относится к ожиданиям, связанным с операциями перемещения данных.
- BackupConcurrencyResourceType может использоваться при создании резервной копии базы данных. Максимальное значение для этого типа ресурсов равно 1. При одновременном запросе сразу нескольких резервных копий все остальные запросы помещаются в очередь.

Определить, какие ресурсы необходимы для запроса, можно при помощи динамического административного представления `sys.dm_pdw_waits`.

```sql
SELECT  w.[wait_id]
,       w.[session_id]
,       w.[type]			AS Wait_type
,       w.[object_type]
,       w.[object_name]
,       w.[request_id]
,       w.[request_time]
,       w.[acquire_time]
,       w.[state]
,       w.[priority]
,	SESSION_ID()			AS Current_session
,	s.[status]			AS Session_status
,	s.[login_name]
,	s.[query_count]
,	s.[client_id]
,	s.[sql_spid]
,	r.[command]			AS Request_command
,	r.[label]
,	r.[status]			AS Request_status
,	r.[submit_time]
,	r.[start_time]
,	r.[end_compile_time]
,	r.[end_time]
,	DATEDIFF(ms,r.[submit_time],r.[start_time])		AS Request_queue_time_ms
,	DATEDIFF(ms,r.[start_time],r.[end_compile_time])	AS Request_compile_time_ms
,	DATEDIFF(ms,r.[end_compile_time],r.[end_time])		AS Request_execution_time_ms
,	r.[total_elapsed_time]
FROM    sys.dm_pdw_waits w
JOIN    sys.dm_pdw_exec_sessions s  ON w.[session_id] = s.[session_id]
JOIN    sys.dm_pdw_exec_requests r  ON w.[request_id] = r.[request_id]
WHERE	w.[session_id] <> SESSION_ID();
```

Динамическое административное представление `sys.dm_pdw_resource_waits` показывает только время ожидания ресурса по конкретному запросу. Время ожидания ресурсов — это время, в течение которого запросы ожидают предоставления ресурсов, а время ожидания сигнала — время, необходимое базовому экземпляру SQL Server, чтобы спланировать выделение запросу ресурсов процессора.

```sql
SELECT  [session_id]
,       [type]
,       [object_type]
,       [object_name]
,       [request_id]
,       [request_time]
,       [acquire_time]
,       DATEDIFF(ms,[request_time],[acquire_time])  AS acquire_duration_ms
,       [concurrency_slots_used]                    AS concurrency_slots_reserved
,       [resource_class]
,       [wait_id]                                   AS queue_position
FROM    sys.dm_pdw_resource_waits
WHERE	[session_id] <> SESSION_ID();
```

Для анализа тенденций времени ожидания за прошедший период используется динамическое административное представление `sys.dm_pdw_wait_stats`.

```sql
SELECT	w.[pdw_node_id]
,		w.[wait_name]
,		w.[max_wait_time]
,		w.[request_count]
,		w.[signal_time]
,		w.[completed_count]
,		w.[wait_time]
FROM	sys.dm_pdw_wait_stats w;
```

## Дальнейшие действия

Дополнительные сведения об управлении пользователями и защите базы данных см. в статье [Защита базы данных в хранилище данных SQL][]. Дополнительные сведения о повышении качества кластеризованных индексов columnstore за счет повышения класса ресурсов см. в статье [Индексирование таблиц в хранилище данных SQL].

<!--Image references-->

<!--Article references-->
[Защита базы данных в хранилище данных SQL]: ./sql-data-warehouse-overview-manage-security.md
[Индексирование таблиц в хранилище данных SQL]: ./sql-data-warehouse-tables-index.md#rebuilding-indexes-to-improve-segment-quality

<!--MSDN references-->
[Проверка подлинности и авторизация в базе данных SQL: предоставление доступа]: https://msdn.microsoft.com/library/azure/ee336235.aspx

<!--Other Web references-->

<!---HONumber=AcomDC_0810_2016-->