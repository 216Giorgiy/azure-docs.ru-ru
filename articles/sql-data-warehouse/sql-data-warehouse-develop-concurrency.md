<properties
   pageTitle="Управление параллелизмом и рабочей нагрузкой в хранилище данных SQL | Microsoft Azure"
   description="Общие сведения управлении параллелизмом и рабочей нагрузкой в хранилище данных SQL Azure для разработки решений."
   services="sql-data-warehouse"
   documentationCenter="NA"
   authors="jrowlandjones"
   manager="barbkess"
   editor=""/>

<tags
   ms.service="sql-data-warehouse"
   ms.devlang="NA"
   ms.topic="article"
   ms.tgt_pltfrm="NA"
   ms.workload="data-services"
   ms.date="06/26/2015"
   ms.author="JRJ@BigBangData.co.uk;barbkess"/>

# Управление параллелизмом и рабочей нагрузкой в хранилище данных SQL
Для обеспечения прогнозируемой высокой производительности в хранилище данных SQL реализованы механизмы распределения рабочей нагрузки и выделения вычислительных ресурсов.

В этой статье рассматриваются понятия параллелизма и управления рабочей нагрузкой и объясняется, каким образом реализованы эти функции и как управлять ими в хранилище данных.

## Параллелизм
Важно понимать, что параллелизмом в хранилище данных SQL управляют два фактора: **количество одновременных запросов** и **количество слотов выдачи**.

Количество одновременных запросов — это количество запросов, выполняемых в одно и то же время. Хранилище данных SQL поддерживает до 32 **одновременных запросов**. Выполнение каждого запроса считается одним запросом независимо от того, выполняется ли он последовательно (один поток) или параллельно (несколько потоков). Это фиксированное ограничение, которое действует на всех уровнях обслуживания.

Количество слотов выдачи — более динамическое понятие, соотносимое с количеством предоставленных вам единиц использования хранилища данных (DWU). Чем больше DWU выделяется хранилищу данных SQL, тем больше вычислительных ресурсов ему предоставляется. В то же время с увеличением DWU растет и число доступных **слотов выдачи**.

При настройке хранилища данных SQL необходимо учитывать каждое из этих ограничений. В случае одновременного выполнения более 32 запросов или превышения количества слотов выдачи запрос помещается в очередь до тех пор, пока не будут выполнены оба ограничения.

Каждый выполняемый одновременно запрос задействует один или несколько слотов выдачи. Точное количество слотов зависит от двух факторов:

1. Значение DWU для хранилища данных SQL.
2. **Класс ресурсов**, к которому относится пользователь. 

<!--
| Concurrency Slot Consumption | DW100 | DW200 | DW300 | DW400 | DW500 | DW600 | DW1000 | DW1200 | DW1500 | DW2000 | DW3000 | DW6000 |
| :--------------------------- | :---- | :---- | :---- | :---- | :---- | :---- | :----- | :----- | :----- | :----- | :----- | :----- |
| Max Concurrent Queries       | 32    | 32    | 32    | 32    | 32    | 32    | 32     | 32     | 32     | 32     | 32     | 32     |
| Max Concurrency Slots        | 4     | 8     | 12    | 16    | 20    | 24    | 32     | 32     | 32     | 32     | 32    | 32     |
-->

| Использование слотов выдачи | DW100 | DW200 | DW300 | DW400 | DW500 | DW600 | DW1000 | DW1200 | DW1500 | DW2000 |
| :--------------------------- | :---- | :---- | :---- | :---- | :---- | :---- | :----- | :----- | :----- | :----- | 
| Макс. число одновременных запросов | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 
| Макс. число слотов выдачи | 4\. | 8 | 12 | 16 | 20 | 24 | 32 | 32 | 32 | 32 | 

Классы ресурсов составляют неотъемлемую часть рабочей нагрузки по управлению хранилищем данных SQL, поскольку определяют объем вычислительных ресурсов, выделяемых для каждого запроса. Они рассматриваются ниже, в разделе об управлении рабочей нагрузкой.

## Управление рабочей нагрузкой

Хранилище данных SQL предоставляет четыре разных класса ресурсов в виде **ролей баз данных**, входящих в систему управления рабочей нагрузкой.

Вот эти роли:

- smallrc
- mediumrc
- largerc
- xlargerc

По умолчанию каждый пользователь является членом малого класса ресурсов — smallrc, однако любого пользователя можно добавить в один или несколько классов ресурсов более высокого уровня. Для выполнения запросов хранилище данных SQL требует принадлежности к самой высокой роли. Добавление пользователя в более высокий класс ресурсов означает, что этот пользователь будет получать больше ресурсов и в то же время использовать больше слотов выдачи, что может ограничить параллелизм системы. Это связано с тем, что предоставление дополнительных ресурсов для выполнения одного запроса требует ограничения ресурсов, доступных другим запросам. За все приходится платить.

Наиболее важным ресурсом, который регулируется более высоким классом, является память. В большинстве размещенных в хранилище данных таблиц любого значимого размера используются кластеризованные индексы columnstore. Это означает, что таблицы активно используют память, что, как правило, позволяет сделать рабочую нагрузку на хранилище данных максимально эффективной. Зачастую для операций по управлению данными, таких как перестроение индекса, выгодно назначать более высокие классы ресурсов.

Чтобы увеличить память, просто добавьте своего пользователя базы данных в одну из указанных выше ролей или один из классов ресурсов.

Добавлять и удалять себя из роли базы данных по управлению рабочей нагрузкой можно с помощью процедур `sp_addrolemember` и `sp_droprolemember`. Обратите внимание, что для этого требуется разрешение `ALTER ROLE`. Синтаксис ALTER ROLE DDL в данном случае не работает. Используйте хранимые процедуры, указанные выше.

> [AZURE.NOTE]Вместо добавления пользователя в группу управления рабочей нагрузкой и его удаления из этой группы зачастую бывает проще использовать для запуска ресурсоемких операций отдельный логин или отдельного пользователя, назначенного более высокому классу ресурсов на постоянной основе.

В следующей таблице показано, на сколько может быть увеличен объем памяти, доступной для каждого запроса, с учетом того, какой класс ресурсов применен к пользователю, выполняющему этот запрос:

<!--
| Memory Available (per dist) | Priority | DW100  | DW200  | DW300  | DW400   | DW500   | DW600   | DW1000  | DW1200  | DW1500  | DW2000  | DW3000  | DW6000   |
| :-------------------------- | :------- | :----  | :----- | :----- | :------ | :------ | :------ | :------ | :------ | :------ | :------ | :------ | :------- |
| smallrc(default) (s)        | Medium   | 100 MB | 100 MB | 100 MB | 100  MB | 100 MB  | 100 MB  | 100 MB  | 100 MB  | 100 MB  | 100 MB  | 100  MB | 100   MB |
| mediumrc (m)                | Medium   | 100 MB | 200 MB | 200 MB | 400  MB | 400 MB  | 400 MB  | 800 MB  | 800 MB  | 800 MB  | 1600 MB | 1600 MB | 3200  MB |
| largerc (l)                 | High     | 200 MB | 400 MB | 400 MB | 800  MB | 800 MB  | 800 MB  | 1600 MB | 1600 MB | 1600 MB | 3200 MB | 3200 MB | 6400  MB |
| xlargerc (xl)               | High     | 400 MB | 800 MB | 800 MB | 1600 MB | 1600 MB | 1600 MB | 3200 MB | 3200 MB | 3200 MB | 6400 MB | 6400 MB | 12800 MB |
-->

<!--
| Memory Available (per dist) | Priority | DW100  | DW200  | DW300  | DW400   | DW500   | DW600   | DW1000  | DW1200  | DW1500  | DW2000  |
| :-------------------------- | :------- | :----  | :----- | :----- | :------ | :------ | :------ | :------ | :------ | :------ | :------ |
| smallrc(default) (s)        | Medium   | 100 MB | 100 MB | 100 MB | 100  MB | 100 MB  | 100 MB  | 100 MB  | 100 MB  | 100 MB  | 100 MB  |
| mediumrc (m)                | Medium   | 100 MB | 200 MB | 200 MB | 400  MB | 400 MB  | 400 MB  | 800 MB  | 800 MB  | 800 MB  | 1600 MB |
| largerc (l)                 | High     | 200 MB | 400 MB | 400 MB | 800  MB | 800 MB  | 800 MB  | 1600 MB | 1600 MB | 1600 MB | 3200 MB |
| xlargerc (xl)               | High     | 400 MB | 800 MB | 800 MB | 1600 MB | 1600 MB | 1600 MB | 3200 MB | 3200 MB | 3200 MB | 6400 MB |
-->

| Доступная память (на запрос) | DW100 | DW200 | DW300 | DW400 | DW500 | DW600 | DW1000 | DW1200 | DW1500 | DW2000 |
| :-------------------------- | :----  | :----- | :----- | :------ | :------ | :------ | :------ | :------ | :------ | :------ |
| smallrc(default) (s) | 100 МБ | 100 МБ | 100 МБ | 100 МБ | 100 МБ | 100 МБ | 100 МБ | 100 МБ | 100 МБ | 100 МБ |
| mediumrc (m) | 100 МБ | 200 МБ | 200 МБ | 400 МБ | 400 МБ | 400 МБ | 800 МБ | 800 МБ | 800 МБ | 1600 МБ |
| largerc (l) | 200 МБ | 400 МБ | 400 МБ | 800 МБ | 800 МБ | 800 МБ | 1600 МБ | 1600 МБ | 1600 МБ | 3200 МБ |
| xlargerc (l) | 400 МБ | 800 МБ | 800 МБ | 1600 МБ | 1600 МБ | 1600 МБ | 3200 МБ | 3200 МБ | 3200 МБ | 6400 МБ |

При этом нужно помнить о том, что, как уже говорилось, чем выше назначенный пользователю класс ресурсов, тем больше слотов выдачи он использует. В следующей таблице показано использование слотов выдачи запросами определенного класса ресурсов:

<!--
| Concurrency slot consumption | DW100 | DW200 | DW300 | DW400 | DW500 | DW600 | DW1000 | DW1200 | DW1500 | DW2000 | DW3000 | DW6000 |
| :--------------------------- | :---- | :---- | :---- | :---- | :---- | :---- | :----- | :----- | :----- | :----- | :----- | :----- |
| Max Concurrent Queries       | 32    | 32    | 32    | 32    | 32    | 32    | 32     | 32     | 32     | 32     | 32     | 32     |
| Max Concurrency Slots        | 4     | 8     | 12    | 16    | 20    | 24    | 40     | 48     | 60     | 80     | 120    | 240    |
| smallrc(default) (s)         | 1     | 1     | 1     | 1     | 1     | 1     | 1      | 1      | 1      | 1      | 1      | 1      |
| mediumrc (m)                 | 1     | 2     | 2     | 4     | 4     | 4     | 8      | 8      | 8      | 16     | 16     | 32     |
| largerc (l)                  | 2     | 4     | 4     | 8     | 8     | 8     | 16     | 16     | 16     | 32     | 32     | 64     |
| xlargerc (xl)                | 4     | 8     | 8     | 16    | 16    | 16    | 32     | 32     | 32     | 64     | 64     | 128    |
-->

| Использование слотов выдачи | DW100 | DW200 | DW300 | DW400 | DW500 | DW600 | DW1000 | DW1200 | DW1500 | DW2000 |
| :--------------------------- | :---- | :---- | :---- | :---- | :---- | :---- | :----- | :----- | :----- | :----- |
| Макс. число одновременных запросов | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 | 32 |
| Макс. число слотов выдачи | 4\. | 8 | 12 | 16 | 20 | 24 | 40 | 48 | 60 | 80 |
| smallrc(default) (s) | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| mediumrc (m) | 1 | 2 | 2 | 4 | 4 | 4 | 8 | 8 | 8 | 16 |
| largerc (l) | 2 | 4 | 4 | 8 | 8 | 8 | 16 | 16 | 16 | 32 |
| xlargerc (l) | 4 | 8 | 8 | 16 | 16 | 16 | 32 | 32 | 32 | 64 |

Важно помнить, что активная рабочая нагрузка должна соответствовать ограничениям как на количество одновременных запросов, так и на число слотов выдачи. В случае превышения любого из этих порогов запросы помещаются в очередь. Запросы в очереди выполняются в порядке приоритета, который определяется временем их подачи.

На самом деле все не так просто. Классы ресурсов динамически сопоставляются с универсальным набором групп управления рабочей нагрузкой в регуляторе ресурсов. Используемые группы зависят от значения DWU для хранилища данных. Однако хранилище данных SQL использует восемь групп рабочей нагрузки. К ним относятся:

- SloDWGroupC00
- SloDWGroupC01
- SloDWGroupC02
- SloDWGroupC03
- SloDWGroupC04
- SloDWGroupC05
- SloDWGroupC06
- SloDWGroupC07

Эти восемь групп сопоставляются с использованием слотов выдачи

| Группа рабочей нагрузки | Сопоставление слотов выдачи | Приоритет сопоставления |
| :------------  | :----------------------- | :--------------- |
| SloDWGroupC00 | 1 | Средний |
| SloDWGroupC01 | 2 | Средний |
| SloDWGroupC02 | 4 | Средний |
| SloDWGroupC03 | 8 | Средний |
| SloDWGroupC04 | 16 | Высокий |
| SloDWGroupC05 | 32 | Высокий |
| SloDWGroupC06 | 64 | Высокий |
| SloDWGroupC07 | 128 | Высокий |

Так, например, если текущий параметр DWU для хранилища данных SQL — DW500, то активные группы рабочей нагрузки сопоставляются с классами ресурсов следующим образом:

| Класс ресурсов | Группа рабочей нагрузки | Число используемых слотов выдачи | Важность |
| :------------- | :------------- | :---------------------   | :--------- |
| smallrc | SloDWGroupC00 | 1 | Средний |
| mediumrc | SloDWGroupC02 | 4 | Средний |
| largerc | SloDWGroupC03 | 8 | Средний |
| xlargerc | SloDWGroupC04 | 16 | Высокий |

Чтобы просмотреть подробные сведения о различиях в распределении ресурсов памяти с точки зрения регулятора ресурсов, используйте следующий запрос:

```
WITH rg
AS
(   SELECT  pn.name									AS node_name
	,		pn.[type]								AS node_type
	,		pn.pdw_node_id							AS node_id
	,		rp.name									AS pool_name
    ,       rp.max_memory_kb*1.0/1024				AS pool_max_mem_MB
    ,       wg.name									AS group_name
    ,       wg.importance							AS group_importance
    ,       wg.request_max_memory_grant_percent		AS group_request_max_memory_grant_pcnt
    ,       wg.max_dop								AS group_max_dop
    ,       wg.effective_max_dop					AS group_effective_max_dop
	,		wg.total_request_count					AS group_total_request_count
	,		wg.total_queued_request_count			AS group_total_queued_request_count
	,		wg.active_request_count					AS group_active_request_count
	,		wg.queued_request_count					AS group_queued_request_count
    FROM    sys.dm_pdw_nodes_resource_governor_workload_groups wg
    JOIN    sys.dm_pdw_nodes_resource_governor_resource_pools rp    ON  wg.pdw_node_id  = rp.pdw_node_id
															        AND wg.pool_id      = rp.pool_id
	JOIN	sys.dm_pdw_nodes pn										ON	wg.pdw_node_id	= pn.pdw_node_id
	WHERE   wg.name like 'SloDWGroup%'
	AND     rp.name = 'SloDWPool'
) 
SELECT	pool_name
,		pool_max_mem_MB
,		group_name
,		group_importance
,		(pool_max_mem_MB/100)*group_request_max_memory_grant_pcnt AS max_memory_grant_MB
,		node_name
,		node_type
,       group_total_request_count
,       group_total_queued_request_count
,       group_active_request_count
,       group_queued_request_count
FROM	rg
ORDER BY 
	node_name
,	group_request_max_memory_grant_pcnt
,	group_importance
;
```

> [AZURE.NOTE]Приведенный выше запрос также можно использовать для анализа текущего и предыдущего использования групп рабочей нагрузки при устранении неполадок

## Примеры управления рабочей нагрузкой

Чтобы получить доступ к хранилищу данных SQL, пользователь должен сначала войти в систему.

Откройте подключение к базе данных master для хранилища данных SQL и выполните следующие команды:

```
CREATE LOGIN newperson WITH PASSWORD = 'mypassword'

CREATE USER newperson for LOGIN newperson
```

[AZURE.NOTE]рекомендуется создать пользователей для входа в базу данных master при одновременной работе с базой данных Azure SQL и хранилищем данных SQL. На этом уровне доступны две роли сервера, требующих наличия пользователя в базе данных master для имени для входа, чтобы предоставить членство. Это роли `Loginmanager` и `dbmanager`. Как в базе данных Azure SQL, так и в хранилище данных SQL эти роли предоставляют права на управление именами для входа и создание баз данных. В этом отличие от SQL Server. Дополнительные сведения можно найти в статье [Управление базами данных, именами для входа и пользователями в Базе данных SQL Azure].
 
После создания имени для входа необходимо добавить учетную запись пользователя.

Откройте подключение к базе данных хранилища данных SQL и выполните следующую команду:

```
CREATE USER newperson FOR LOGIN newperson
```

После этого потребуется предоставить пользователю разрешения. В примере ниже предоставляется разрешение `CONTROL` для базы данных хранилища данных SQL. Разрешение `CONTROL` на уровне базы данных равносильно db\_owner в SQL Server.

```
GRANT CONTROL ON DATABASE::MySQLDW to newperson
```

Чтобы просмотреть роли управления рабочей нагрузкой, используйте следующий запрос:

```
SELECT  ro.[name]           AS [db_role_name]
FROM    sys.database_principals ro
WHERE   ro.[type_desc]      = 'DATABASE_ROLE'
AND     ro.[is_fixed_role]  = 0
;
```

Чтобы добавить пользователя к роли управления увеличения рабочей нагрузки, используйте следующий запрос:

``` 
EXEC sp_addrolemember 'largerc', 'newperson' 
```

Чтобы удалить пользователя из роли управления рабочей нагрузки, используйте следующий запрос:

``` 
EXEC sp_droprolemember 'largerc', 'newperson' 
```
> [AZURE.NOTE]Невозможно удалить пользователя из роли smallrc.

Чтобы увидеть пользователей определенной роли, используйте следующий запрос: ```
SELECT	r.name AS role_principal_name
,		m.name AS member_principal_name
FROM	sys.database_role_members rm
JOIN	sys.database_principals AS r			ON rm.role_principal_id		= r.principal_id
JOIN	sys.database_principals AS m			ON rm.member_principal_id	= m.principal_id
WHERE	r.name IN ('mediumrc','largerc', 'xlargerc')
;
```

## Определение запросов, поставленных в очередь
Для выявления запросов, попавших в параллельную очередь, используйте динамическое административное представление `sys.dm_pdw_exec_requests`.

```
SELECT 	 r.[request_id]									AS Request_ID
		,r.[status]										AS Request_Status
		,r.[submit_time]								AS Request_SubmitTime
		,r.[start_time]									AS Request_StartTime
        ,DATEDIFF(ms,[submit_time],[start_time])		AS Request_InitiateDuration_ms
        ,r.resource_class                               AS Request_resource_class
FROM    sys.dm_pdw_exec_requests r
;
```

В хранилище данных SQL предусмотрены особые типы ожиданий для измерения параллелизма.

К ним относятся:
 
- LocalQueriesConcurrencyResourceType
- UserConcurrencyResourceType
- DmsConcurrencyResourceType
- BackupConcurrencyResourceType

LocalQueriesConcurrencyResourceType относится к запросам, которые не входят в систему слотов выдачи. В качестве примеров таких запросов можно привести запросы и системные функции динамических административных представлений, такие как `SELECT @@VERSION`.

UserConcurrencyResourceType относится к запросам, которые входят в систему слотов выдачи. В качестве примеров использования этого типа ресурсов можно привести запросы к таблицам конечного пользователя.

DmsConcurrencyResourceType относится к ожиданиям, связанным с операциями перемещения данных.

BackupConcurrencyResourceType может использоваться при создании резервной копии базы данных. Максимальное значение для этого типа ресурсов равно 1. При одновременном запросе сразу нескольких резервных копий все остальные запросы помещаются в очередь.


Для анализа поставленных в очередь запросов и определения необходимых ресурсов используйте динамическое административное представление `sys.dm_pdw_waits`.

```
SELECT  w.[wait_id]
,       w.[session_id]
,       w.[type]											AS Wait_type
,       w.[object_type]
,       w.[object_name]
,       w.[request_id]
,       w.[request_time]
,       w.[acquire_time]
,       w.[state]
,       w.[priority]
,		SESSION_ID()										AS Current_session
,		s.[status]											AS Session_status
,		s.[login_name]
,		s.[query_count]
,		s.[client_id]
,		s.[sql_spid]
,		r.[command]											AS Request_command
,		r.[label]
,		r.[status]											AS Request_status
,		r.[submit_time]
,		r.[start_time]
,		r.[end_compile_time]
,		r.[end_time]
,		DATEDIFF(ms,r.[submit_time],r.[start_time])			AS Request_queue_time_ms
,		DATEDIFF(ms,r.[start_time],r.[end_compile_time])	AS Request_compile_time_ms
,		DATEDIFF(ms,r.[end_compile_time],r.[end_time])		AS Request_execution_time_ms
,		r.[total_elapsed_time]
FROM    sys.dm_pdw_waits w
JOIN    sys.dm_pdw_exec_sessions s  ON w.[session_id] = s.[session_id]
JOIN    sys.dm_pdw_exec_requests r  ON w.[request_id] = r.[request_id]
WHERE	w.[session_id] <> SESSION_ID()
;
```

Для просмотра ресурса, ожидаемого конкретным запросом, используйте динамическое административное представление `sys.dm_pdw_resource_waits`. Время ожидания ресурсов указывает только на время, в течение которого запросы ожидают предоставления ресурсов, а время ожидания сигнала — время, необходимое базовому экземпляру SQL Server, чтобы спланировать выделение запросу ресурсов процессора.

```
SELECT  [session_id]
,       [type]
,       [object_type]
,       [object_name]
,       [request_id]
,       [request_time]
,       [acquire_time]
,       DATEDIFF(ms,[request_time],[acquire_time])  AS acquire_duration_ms
,       [concurrency_slots_used]                    AS concurrency_slots_reserved
,       [resource_class]
,       [wait_id]                                   AS queue_position
FROM    sys.dm_pdw_resource_waits
WHERE	[session_id] <> SESSION_ID()
;
```

И, наконец, для анализа тенденций по времени ожидания за прошедший период используйте динамическое административное представление `sys.dm_pdw_wait_stats`.

```
SELECT	w.[pdw_node_id]
,		w.[wait_name]
,		w.[max_wait_time]
,		w.[request_count]
,		w.[signal_time]
,		w.[completed_count]
,		w.[wait_time]
FROM	sys.dm_pdw_wait_stats w
;
```

## Дальнейшие действия
Дополнительные советы по разработке см. в статье [Общие сведения о разработке][].

<!--Image references-->

<!--Article references-->
[Общие сведения о разработке]: sql-data-warehouse-overview-develop.md

<!--MSDN references-->
[Управление базами данных, именами для входа и пользователями в Базе данных SQL Azure]: https://msdn.microsoft.com/ru-ru/library/azure/ee336235.aspx

<!--Other Web references-->

<!---HONumber=August15_HO6-->