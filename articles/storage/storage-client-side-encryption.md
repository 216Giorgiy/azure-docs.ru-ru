<properties 
	pageTitle="Начало работы с шифрованием на стороне клиента для службы хранилища Microsoft Azure (предварительная версия) | Microsoft Azure" 
	description="Предварительная версия клиентской библиотеки хранилища Azure для .NET обеспечивает поддержку шифрования на стороне клиента, а также интеграцию с хранилищем ключей Azure. Шифрование на стороне клиента обеспечивает максимальную безопасность приложений хранилища Azure, поскольку ключи доступа недоступны для службы. Шифрование на стороне клиента доступно для больших двоичных объектов, очередей и таблиц." 
	services="storage" 
	documentationCenter=".net" 
	authors="tamram" 
	manager="carolz" 
	editor=""/>

<tags 
	ms.service="storage" 
	ms.workload="storage" 
	ms.tgt_pltfrm="na" 
	ms.devlang="na" 
	ms.topic="article" 
	ms.date="06/18/2015" 
	ms.author="tamram"/>


# Начало работы с шифрованием на стороне клиента для службы хранилища Microsoft Azure (предварительная версия)

## Обзор

Добро пожаловать на страницу с описанием [предварительной версии новой клиентской библиотеки хранилища Azure для .NET](https://www.nuget.org/packages/WindowsAzure.Storage/4.4.1-preview). Эта предварительная версия библиотеки содержит новые функции, позволяющие разработчикам шифровать данные в клиентских приложениях перед их загрузкой в хранилище Azure и расшифровывать их во время выгрузки. Предварительная версия библиотеки также поддерживает интеграцию с [хранилищем ключей](http://azure.microsoft.com/services/key-vault/) Azure для управления ключами учетной записи хранения.

## Шифрование и расшифровка методом конвертов

Для шифрования и расшифровки используется конвертный метод.

### Шифрование конвертным методом

Шифрование конвертным методом выполняется следующим образом.

1. Клиентская библиотека хранилища Azure создает ключ шифрования содержимого (CEK), который является симметричным ключом для однократного использования.
2. Данные пользователя шифруются с помощью этого ключа CEK.
3. Ключ CEK, в свою очередь, шифруется с помощью ключа шифрования ключа KEK. KEK определяется идентификатором ключа и может быть парой асимметричных ключей или симметричным ключом. Им можно управлять локально, а также хранить его в хранилище ключей Azure. 
	
	Сама клиентская библиотека хранилища не имеет доступа к ключу KEK. Библиотека вызывает алгоритм шифрования ключа, который обеспечивается хранилищем ключей. Пользователи могут при необходимости использовать настраиваемые поставщики для шифрования и расшифровки ключа.

4. Зашифрованные данные затем передаются в службу хранилища Azure. Зашифрованный ключ вместе с дополнительными метаданными шифрования хранится как метаданные (в большом двоичном объекте) или вставляется в зашифрованные данные (сообщения в очереди и табличные сущности).

### Расшифровка конвертным методом

Расшифровка конвертным методом выполняется следующим образом.

1. Клиентская библиотека предполагает, что пользователь управляет ключом шифрования ключа KEK локально или через хранилище ключей Azure. Пользователь может не знать, какой именно ключ использовался для шифрования. Вместо этого достаточно настроить и использовать сопоставитель ключей, который будет распознавать разные идентификаторы ключей.
2. Клиентская библиотека скачивает зашифрованные данные вместе с данными шифрования, которые хранятся в службе.
3. Зашифрованный ключ шифрования содержимого CEK расшифровывается с помощью ключа шифрования ключа KEK. Клиентская библиотека не имеет доступа к ключу KEK. Клиентская библиотека вызывает пользовательский алгоритм или алгоритм расшифровки поставщика хранилища ключей.
4. Затем ключ шифрования содержимого CEK используется для расшифровки зашифрованных пользовательских данных.

## Механизм шифрования

Клиентская библиотека хранилища использует алгоритм [AES](http://en.wikipedia.org/wiki/Advanced_Encryption_Standard) для шифрования данных пользователя. Говоря более конкретно, это режим [цепочки цифровых блоков или CBC](http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher-block_chaining_.28CBC.29) вместе с AES. Каждая служба работает по-разному, поэтому каждая служба рассматривается отдельно.

### BLOB-объекты

В предварительной версии клиентская библиотека поддерживает шифрование только больших двоичных объектов полностью. В частности, шифрование поддерживается при использовании методов **UploadFrom*** или **BlobWriteStream**. Что касается загрузок, то поддерживаются как полные, так и диапазонные загрузки.

Во время шифрования клиентская библиотека создает случайный вектор инициализации IV размером 16 байт, случайный ключ шифрования содержимого CEK размером 32 байта и выполняет конвертное шифрование данных большого двоичного объекта, используя полученную информацию. Затем зашифрованный ключ CEK и дополнительные метаданные шифрования сохраняются в службе как метаданные большого двоичного объекта вместе с зашифрованным большим двоичным объектом.

> [AZURE.WARNING]Если вы изменяете или загружаете собственные метаданные для большого двоичного объекта, нужно убедиться, что данные сохранены. Если загрузить новые метаданные без этих метаданных, зашифрованный ключ CEK, ключ IV и другие метаданные будут утеряны, а без них получить содержимое большого двоичного объекта невозможно.

Скачивание зашифрованного большого двоичного объекта предполагает получение содержимого большого двоичного объекта полностью с помощью методов **DownloadTo***/**BlobReadStream**. Зашифрованный ключ CEK расшифровывается и используется вместе с ключом IV (который в данном случае хранится как метаданные большого двоичного объекта) для передачи расшифрованных данных обратно пользователям.

Скачивание произвольного диапазона (с помощью методов **DownloadRange***) из зашифрованного большого двоичного объекта предполагает настройку диапазона на стороне пользователя, чтобы получить небольшой объем дополнительных данных, которые помогут расшифровать запрошенный диапазон.

Все типы больших двоичных объектов (блочные и страничные) могут быть зашифрованы и расшифрованы с помощью этой схемы.

### Очереди

Поскольку очередь сообщений может иметь любой формат, клиентская библиотека определяет нестандартный формат, который включает вектор инициализации IV и зашифрованный ключ шифрования содержимого CEK в текст сообщения.

Во время шифрования клиентская библиотека создает случайный ключ IV размером 16 байт, случайный ключ CEK размером 32 байта и выполняет конвертное шифрование текста сообщения очереди, используя полученную информацию. Зашифрованный ключ CEK и дополнительные метаданные шифрования добавляются в зашифрованное сообщение очереди. Это измененное сообщение (показано ниже) сохраняется в службе.

	<MessageText>{"EncryptedMessageContents":"6kOu8Rq1C3+M1QO4alKLmWthWXSmHV3mEfxBAgP9QGTU++MKn2uPq3t2UjF1DO6w","EncryptionData":{…}}</MessageText>

Во время расшифровки зашифрованный ключ извлекается из сообщения очереди и расшифровывается. Ключ IV также извлекается из сообщения очереди и используется вместе с расшифрованным ключом для расшифровки данных сообщения очереди. Обратите внимание, что размер метаданных шифрования очень мал (не более 500 байт), поэтому, хотя этот их размер учитывается при подсчете максимального размера в 64 КБ для сообщения очереди, этим размером данных можно пренебречь.

### Таблицы

В предварительной версии клиентская библиотека поддерживает шифрование свойств сущности для операций вставки и замены.

>[AZURE.NOTE]Слияние в настоящее время не поддерживается. Поскольку подмножество свойств могло уже быть зашифровано с помощью другого ключа, простое слияние новых свойств и обновление метаданных приведет к потере данных. Для слияния требуется либо сначала прочитать данные существующей сущности в службе, либо использовать новый ключ для каждого свойства, однако оба способа не подходят из-за низкой эффективности.

Шифрование табличных данных выполняется следующим образом.

1. Пользователи указывают свойства, которые следует зашифровать.
2. Клиентская библиотека создает случайный вектор инициализации IV размером 16 байт и произвольный ключ шифрования содержимого CEK размером 32 байта для каждой сущности и выполняет конвертное шифрование для отдельных свойств, которые следует зашифровать путем создания нового ключа IV для каждого свойства.
3. Затем зашифрованный ключ CEK и дополнительные метаданные шифрования сохраняются в виде двух дополнительных зарезервированных свойств. Первое зарезервированное свойство (_ClientEncryptionMetadata1) — это строковое свойство, которое содержит информацию о ключе IV, версию и зашифрованный ключ. Другое зарезервированное свойство (_ClientEncryptionMetadata2) — это двоичное свойство, которое содержит информацию о зашифрованных свойствах.
4. Из-за этих двух дополнительных зарезервированных свойств, необходимых для шифрования, пользователи могут иметь только 250 пользовательских свойств вместо 252. Общий размер сущности должен быть меньше 1 МБ.

Обратите внимание, что зашифрованы могут быть только строковые свойства. Если необходимо зашифровать другие типы свойств, их необходимо преобразовать в строки.

Что касается таблиц, то в дополнение к политике шифрования пользователи должны указать свойства, которые необходимо зашифровать. Это можно сделать путем указания атрибута [PropertyAttribute] (для сущностей POCO, которые являются производными от TableEntity) или с помощью сопоставителя шифрования в параметрах запроса. Сопоставитель шифрования — это делегат, который получает ключ секции, ключ строки и имя свойства, а затем возвращает логическое значение, которое указывает, следует ли это свойство шифровать. Во время шифрования клиентская библиотека использует эти сведения, чтобы решить, следует ли шифровать свойство перед отправкой. Делегат также обеспечивает возможность логики в отношении того, как шифруются свойства. (Например, если значение равно X, то шифровать свойство А; в противном случае шифровать свойства А и В.) Обратите внимание, что нет необходимости предоставлять эти сведения при чтении или выполнении запросов к сущностям.

### Пакетные операции

В пакетных операциях один ключ KEK используется для всех строк операции, поскольку клиентская библиотека допускает использование только одного объекта параметров (и, следовательно, одну политику или ключ KEK) на одну пакетную операцию. Однако клиентская библиотека создает новый случайный ключ IV и случайный ключ CEK на каждую строку в пакете. Пользователи могут также выбрать шифрование других свойств для каждой операции в пакете, определив это поведение в сопоставителе шифрования.

### Запросы

Чтобы выполнять операции запроса, следует указать сопоставитель ключа, который способен распознавать все ключи в результирующем наборе. Если сущность в результате запроса не может быть разрешена для поставщика, клиентская библиотека выдаст ошибку. Для запроса, который обращается к серверу, клиентская библиотека добавляет по умолчанию специальные свойства метаданных шифрования (_ClientEncryptionMetadata1 и _ClientEncryptionMetadata2) к выбранным столбцам.

## Хранилище ключей Azure

Хранилище ключей Azure (предварительная версия) помогает защитить криптографические ключи и секреты, используемые облачными приложениями и службами. Хранилище ключей Azure позволяет шифровать ключи и секреты (например, ключи проверки подлинности, ключи учетных записей хранения, ключи шифрования данных, PFX-файлы и пароли), используя ключи, защищенные аппаратными модулями безопасности. Дополнительные сведения см. в статье [Что такое хранилище ключей Azure?](../articles/key-vault-whatis.md).

Клиентская библиотека хранилища использует основную библиотеку хранилища ключей для обеспечения общей платформы для управления ключами в Azure. Пользователи также получают дополнительное преимущество от использования библиотеки хранилища ключей. Библиотека расширений предоставляет полезные функции для локальных и облачных поставщиков ключей с простым и симметричным алгоритмом (RSA), а также функции агрегирования и кэширования.

### Интерфейс и зависимости

Существует три пакета хранилища ключей:

- Microsoft.Azure.KeyVault.Core содержит IKey и IKeyResolver. Это небольшой пакет без зависимостей. Клиентские библиотеки хранилища для .NET и Windows Phone указывают, что им необходим этот пакет.
- Microsoft.Azure.KeyVault содержит клиентское REST-приложение хранилища ключей.
- Microsoft.Azure.KeyVault.Extensions содержит код расширения, который включает реализации криптографических алгоритмов, а также ключи RSAKey и SymmetricKey. Пакет зависит от пространств имен Core и KeyVault и обеспечивает функции, которые позволяют определить составной сопоставитель (когда пользователи используют несколько поставщиков ключей) и сопоставитель ключа кэширования. Клиентская библиотека хранилища не зависит напрямую от этого пакета, однако, если пользователь хочет использовать хранилище ключей Azure для хранения ключей или расширения хранилища ключей для работы с локальными и облачными поставщиками служб шифрования, потребуется этот пакет.

Хранилище ключей разработано для главных ключей, и ограничения регулирования, связанные с хранилищем ключей, учитывают это. При выполнении шифрования на стороне клиента с помощью хранилища ключей предпочтительный способ — использовать симметричные главные ключи, которые хранятся в качестве секретов в хранилище ключей, и кэшировать их локально. Рекомендуется придерживаться следующих правил.

1. Создайте секрет без подключения к сети и загрузите его в хранилище ключей.
2. Используйте базовый идентификатор секрета в качестве параметра для разрешения текущей версии секрета для шифрования и кэшируйте эту информацию локально. Используйте параметр CachingKeyResolver для кэширования; пользователи не должны реализовывать собственную логику кэширования.
3. Во время создания политики шифрования используйте кэширующий сопоставитель в качестве входных данных.

Дополнительные сведения об использовании хранилища ключей см. в разделе [примеры кода шифрования](https://github.com/Azure/azure-storage-net/tree/preview/Samples/GettingStarted/EncryptionSamples).

### Рекомендации

Шифрование поддерживается только клиентскими библиотеками хранилища для .NET и Windows Phone. Среда выполнения Windows в настоящее время не поддерживает шифрование. Кроме того, расширения хранилища ключей в настоящее время не поддерживаются для Windows Phone. Если необходимо использовать шифрование клиента хранилища на телефоне, придется реализовать собственного поставщика ключей. Кроме того, из-за ограничений платформы .NET на Windows Phone шифрование страничных BLOB-объектов в настоящее время не поддерживается на Windows Phone.

>[AZURE.IMPORTANT]Учтите следующие важные моменты при использовании предварительной версии библиотеки:
>
>- Не используйте предварительную версию библиотеки для рабочих данных. Будущие изменения библиотеки повлияют на используемые схемы. Расшифровка данных, которые были зашифрованы с помощью предварительной версии библиотеки, в будущих версиях не гарантируется.  
>- При чтении или записи в зашифрованном большом двоичном объекте используйте команды загрузки полного большого двоичного объекта и команды диапазонной либо полной выгрузки. Избегайте написания зашифрованного большого двоичного объекта с помощью операций протокола, таких как Put Block, Put Block List, Write Pages или Clear Pages, иначе это может привести к повреждению зашифрованного большого двоичного объекта, что сделает его нечитабельным.
>- Для таблиц существуют аналогичные ограничения. Будьте внимательны и не обновляйте зашифрованные свойства без обновления метаданных шифрования.
>- Если задать метаданные в зашифрованном большом двоичном объекте, могут быть перезаписаны метаданные, относящиеся к шифрованию и необходимые для расшифровки, поскольку настройку метаданных добавить нельзя. Это также касается моментальных снимков. Не указывайте метаданные во время создания моментального снимка зашифрованного большого двоичного объекта.


## API-интерфейс клиента / интерфейс

При создании объекта EncryptionPolicy пользователи могут предоставить только ключ (который реализует IKey), только сопоставитель (который реализует IKeyResolver) или оба этих объекта. IKey — это базовый тип ключа, который идентифицируется с помощью идентификатора ключа и который обеспечивает логику для шифрования и расшифровки. IKeyResolver используется для сопоставления ключа во время расшифровки. IKeyResolver определяет метод, который возвращает IKey в зависимости от идентификатора ключа. В результате пользователи могут выбирать между несколькими ключами, которые хранятся в разных местах.

- Для шифрования ключ используется всегда, при этом отсутствие ключа приведет к возникновению ошибки.
- Для расшифровки:
	- Сопоставитель ключа вызывается, если он нужен для получения ключа. Если сопоставитель указан, но он не имеет данных, сопоставимых с идентификатором ключа, возникает ошибка.
	- Если сопоставитель не указан, но указан ключ, идентификатор ключа соответствует тому, что хранится в службе.

[Образцы шифрования](https://github.com/Azure/azure-storage-net/tree/preview/Samples/GettingStarted/EncryptionSamples) показывают более подробный сценарий для больших двоичных объектов, очередей и таблиц вместе с интеграцией хранилища ключей.

### BLOB-объекты

Пользователи создают объект **BlobEncryptionPolicy** и задают его в параметрах запроса (для каждого приложения API или на уровне клиента с помощью параметра **DefaultRequestOptions**). Все остальные задачи решаются клиентской библиотекой.

	// Create the IKey used for encryption.
 	RsaKey key = new RsaKey("private:key1" /* key identifier */);
  
 	// Create the encryption policy to be used for upload and download.
 	BlobEncryptionPolicy policy = new BlobEncryptionPolicy(key, null);
  
 	// Set the encryption policy on the request options.
 	BlobRequestOptions options = new BlobRequestOptions() { EncryptionPolicy = policy };
  
 	// Upload the encrypted contents to the blob.
 	blob.UploadFromStream(stream, size, null, options, null);
  
 	// Download and decrypt the encrypted contents from the blob.
 	MemoryStream outputStream = new MemoryStream();
 	blob.DownloadToStream(outputStream, null, options, null);

### Очереди

Пользователи создают объект **QueueEncryptionPolicy** и задают его в параметрах запроса (для каждого приложения API или на уровне клиента с помощью параметра **DefaultRequestOptions**). Все остальные задачи решаются клиентской библиотекой.


	// Create the IKey used for encryption.
 	RsaKey key = new RsaKey("private:key1" /* key identifier */);
  
 	// Create the encryption policy to be used for upload and download.
 	QueueEncryptionPolicy policy = new QueueEncryptionPolicy(key, null);
  
 	// Add message
 	QueueRequestOptions options = new QueueRequestOptions() { EncryptionPolicy = policy };
 	queue.AddMessage(message, null, null, options, null);
  
 	// Retrieve message
 	CloudQueueMessage retrMessage = queue.GetMessage(null, options, null);

### Таблицы

Помимо создания политики шифрования и настройки параметров запроса, необходимо указать **EncryptionResolver** в параметрах **TableRequestOptions** или задать атрибуты для сущности.

#### Использование сопоставителя


	// Create the IKey used for encryption.
 	RsaKey key = new RsaKey("private:key1" /* key identifier */);
  
 	// Create the encryption policy to be used for upload and download.
 	TableEncryptionPolicy policy = new TableEncryptionPolicy(key, null);
  
 	TableRequestOptions options = new TableRequestOptions() 
 	{ 
    	EncryptionResolver = (pk, rk, propName) =>
     	{
        	if (propName == "foo")
         	{
            	return true;
         	}
         	return false;
     	},
     	EncryptionPolicy = policy
 	};
  
 	// Insert Entity
 	currentTable.Execute(TableOperation.Insert(ent), options, null);
  
 	// Retrieve Entity
 	// No need to specify an encryption resolver for retrieve
 	TableRequestOptions retrieveOptions = new TableRequestOptions() 
 	{
    	EncryptionPolicy = policy
 	};
  
 	TableOperation operation = TableOperation.Retrieve(ent.PartitionKey, ent.RowKey);
 	TableResult result = currentTable.Execute(operation, retrieveOptions, null);

#### Использование атрибутов

Как было показано выше, если сущность реализует TableEntity, свойства можно определить с помощью атрибута [EncryptProperty], а не с помощью EncryptionResolver.

	[EncryptProperty]
 	public string EncryptedProperty1 { get; set; }

## Дальнейшие действия

[Шифрование на стороне клиента для службы хранилища Microsoft Azure — предварительная версия](http://blogs.msdn.com/b/windowsazurestorage/archive/2015/04/28/client-side-encryption-for-microsoft-azure-storage-preview.aspx) Скачайте [клиентскую библиотеку хранилища Azure для пакета .NET NuGet](http://www.nuget.org/packages/WindowsAzure.Storage/4.4.0-preview) Скачайте [клиентскую библиотеку хранилища Azure для исходного кода .NET](https://github.com/Azure/azure-storage-net/tree/preview) из GitHub Скачайте пакеты NuGet [Core](http://www.nuget.org/packages/Microsoft.Azure.KeyVault.Core/) для хранилища ключей Azure, [клиентское приложение](http://www.nuget.org/packages/Microsoft.Azure.KeyVault/) и [расширения](http://www.nuget.org/packages/Microsoft.Azure.KeyVault.Extensions/) Просмотрите [документацию по хранилищу ключей Azure](../articles/key-vault-whatis.md)

<!---HONumber=July15_HO2-->