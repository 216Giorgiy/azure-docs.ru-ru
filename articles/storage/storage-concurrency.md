<properties 
	pageTitle="Управление параллелизмом в службе хранилища Microsoft Azure" 
	description="Как управлять параллелизмом для служб BLOB-объектов, очередей, таблиц и файлов" 
	services="storage" 
	documentationCenter="" 
	authors="tamram" 
	manager="adinah" 
	editor=""/>

<tags 
	ms.service="storage" 
	ms.workload="storage" 
	ms.tgt_pltfrm="na" 
	ms.devlang="dotnet" 
	ms.topic="article" 
	ms.date="02/26/2015" 
	ms.author="tamram"/>

# Управление параллелизмом в службе хранилища Microsoft Azure

## Обзор 

В современных интернет-приложениях данные могут одновременно просматриваться и обновляться несколькими пользователями. Это требует от разработчиков приложений тщательного подхода для обеспечения предсказуемого взаимодействия с конечным пользователем, в частности для сценариев с одновременным обновлением данных несколькими пользователями. Обычно разработчики рассматривают три следующие основные стратегии конфликтов данных:  


1.	Оптимистический параллелизм - обновляемое приложение при обновлении определяет, произошли ли изменения данных с момента последнего считывания данных приложением. Например, если два пользователя просматривают и вносят изменения в одну и ту же вики-страницу, платформа вики должна обеспечить возможность для первого обновления не быть перезаписанным вторым, а пользователи должны понять, удачно ли прошло их обновление. Стратегия наиболее часто применяется в веб-приложениях.
2.	Пессимистичный параллелизм - до начала обновления приложение блокирует доступ к объекту, не позволяя пользователю изменить данные до снятия блокировки. Например, в сценарии репликации данных ведущий/ведомый, где данные обновляются только ведущим, ведущий применяет монопольную блокировку данных на длительный период времени для предотвращения его изменений кем-либо еще.
3.	Сохраняются изменения, внесенные последними - подход, позволяющий обновлять данные, не определяя, произошли ли изменения данных с момента последнего считывания их приложением. Эта стратегия (или отсутствие формальной стратегии) применяется обычно при таком разделении данных, которое не позволяет доступ нескольким пользователям к одним и тем же данным. Она также применяется при обработке кратковременных потоков данных.  

В статье описывается, как платформа службы хранилища Azure облегчает разработки, предоставляя первоклассную поддержку всем трем стратегиям параллелизма.  

## Служба хранилища Azure - упрощает облачные разработки
Служба хранилища Azure поддерживает все три стратегии, хотя отличается возможностью полной поддержки оптимистического и пессимистичного параллелизма. Она разработана для поддержания модели строгой согласованности, при которой при вводе или обновлении данных в службе хранилища пользователям, получившим дальнейший доступ к данным, будут гарантированно показаны последние введенные данные. Платформы службы хранилища, иногда применяющие модель согласованности, имеют небольшой интервал между записью данных одним пользователем и возможностью другим пользователем видеть обновленные данные. Это усложняет разработку клиентских приложений с целью предотвращения воздействия несоответствий на конечных пользователей.  

Кроме выбора соответствующей стратегии параллелизма разработчики должны иметь представление о том, как платформа службы хранилища изолирует изменения, в частности, изменения одних и тех же объектов между транзакциями. Служба хранилища Azure использует изоляцию моментального снимка, чтобы позволить одновременное выполнение операций чтения и записи в рамках одного раздела. В отличие от других уровней изоляции, изоляция моментального снимка гарантирует видимость операциям чтения только согласованных моментальных снимков данных даже при их обновлении, возвращая, по сути, в процессе обновления последние фиксированные значения.  

## Управление параллелизмом в службе BLOB-объектов
Вы можете выбрать модель оптимистического или пессимистичного параллелизма для управления доступа к BLOB-объектам и контейнерам службы BLOB-объектов. Если вы не указываете стратегию, то применяется стратегия по умолчанию "Сохраняются изменения, внесенные последними".  

### Оптимистичный параллелизм для BLOB-объектов и контейнеров  

Служба хранилища присваивает идентификатор каждому сохраненному объекту. Идентификатор обновляется при каждом обновлении объекта. Идентификатор возвращается клиенту в качестве ответа HTTP GET с помощью заголовка ETag (тег объекта), определенного в протоколе HTTP. Пользователь, вносящий изменение в объект, может отправить оригинальный ETag с условным заголовком, чтобы удостовериться в том, что обновление произойдет только при удовлетворении определенного условия: в этом случае условие - заголовок "If-Match", который требует, чтобы значение ETag, определенное в запросе на обновление, соответствовало сохраненному в службе хранилища.  

Для этой команды используется следующая структура:  

1.	Извлеките BLOB-объект из службы хранилища, ответ содержит значение заголовка HTTP ETag, указывающее текущую версию объекта в службе хранилища.
2.	При обновлении большого двоичного объекта включите полученное после выполнения шага 1 значение ETag в условный заголовок **If-Match** запроса, отправляемого в службу.
3.	Служба сравнивает значение ETag запроса с текущим значением ETag BLOB-объекта.
4.	Если текущее значение ETag большого двоичного объекта отличается от ETag в условном заголовке запроса **If-Match**, служба возвращает клиенту ошибку 412. Это указывает клиенту на то, что после извлечения клиентом BLOB-объекта он был обновлен другим процессом.
5.	Если версия текущего значения ETag большого двоичного объекта совпадает с версией значения ETag в условном заголовке запроса **If-Match**, служба выполняет запрошенную операцию и обновляет текущее значение ETag большого двоичного объекта, указывая тем самым на создание новой версии.  

Следующий фрагмент кода C# (с использованием клиентской библиотеки хранилища версии 4.2.0) является простым примером того, как построить **If-Match AccessCondition** на основе значения ETag, получаемом из свойств извлеченного или вставленного до этого большого двоичного объекта. Затем он использует объект **AccessCondition** при обновлении большого двоичного объекта: объект **AccessCondition** добавляет в запрос заголовок **If-Match**. Если произошло обновление BLOB-объекта другим процессом, служба возвращает сообщение о состоянии HTTP 412 (Необходимое условие не выполнено). Полный пример можно скачать [здесь](http://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114).  

	// Retrieve the ETag from the newly created blob
	// Etag is already populated as UploadText should cause a PUT Blob call 
	// to storage blob service which returns the etag in response.
	string orignalETag = blockBlob.Properties.ETag;
	 
	// This code simulates an update by a third party.
	string helloText = "Blob updated by a third party.";
	 
	// No etag, provided so orignal blob is overwritten (thus generating a new etag)
	blockBlob.UploadText(helloText);
	Console.WriteLine("Blob updated. Updated ETag = {0}", 
	blockBlob.Properties.ETag);
	 
	// Now try to update the blob using the orignal ETag provided when the blob was created
	try
	{
	    Console.WriteLine("Trying to update blob using orignal etag to generate if-match access condition");
	    blockBlob.UploadText(helloText,accessCondition:
	    AccessCondition.GenerateIfMatchCondition(orignalETag));
	}
	catch (StorageException ex)
	{
	    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
	    {
	        Console.WriteLine("Precondition failure as expected. Blob's orignal etag no longer matches");
	        // TODO: client can decide on how it wants to handle the 3rd party updated content.
	    }
	    else
	        throw;
	}  

Служба хранилища также поддерживает дополнительные условные заголовки, такие как **If-Modified-Since**, **If-Unmodified-Since** и **If-None-Match**, а также их комбинации. Дополнительную информацию см. в разделе [Указание условных заголовков для операций службы BLOB-объектов](http://msdn.microsoft.com/library/azure/dd179371.aspx) на сайте MSDN.  

В приведенной таблице содержится сводка по операциям с контейнерами, принимающих в запросе такие условные заголовки, как **If-Match**, и возвращающих в ответе значение ETag.  

Операция	|Возврат значения ETag для контейнера|	Принятие дополнительных заголовков|
------------|-----------------------|------------------------------------|
Create Container (Создание контейнера)|	Да|	Нет|
Get Container Properties (Получение свойств контейнера)|	Да|	Нет|
Get Container Metadata (Получение метаданных контейнера)|	Да|	Нет|
Set Container Metadata (Определение метаданных контейнера)|	Да|	Да|
Get Container ACL (Получение списка управления доступом для контейнера)|	Да|	Нет|
Set Container ACL (Задание списка управления доступом для контейнера)|	Да|	Да (*)|
Delete Container (Удаление контейнера)|	Нет|	Да|
Lease Container (Аренда контейнера)|	Да|	Да|
List Blobs (Отображение списка BLOB-объектов)|	Нет|	Нет  

(*) Разрешения, определенные SetContainerACL, кэшируются, а обновление разрешений занимает 30 секунд, в течение которых нельзя гарантировать согласованность обновлений.  

В приведенной таблице содержится сводка по операциям с большими двоичными объектами, принимающих в запросе такие условные заголовки, как **If-Match**, и возвращающих в ответе значение ETag.  

Операция	|Returns ETag value (Возврат значения ETag)	|Принятие дополнительных заголовков|
-----------|-------------------|----------------------------|
Put BLOB (Вставка BLOB-объекта)|	Да|	Да|
Get BLOB (Получение BLOB-объекта)|	Да|	Да|
Get BLOB Properties (Получение свойств BLOB-объекта)|	Да|	Да|
Set BLOB Properties (Задание свойств службы BLOB-объекта)|	Да|	Да|
Get BLOB Metadata (Получение метаданных BLOB-объекта)|	Да|	Да|
Set BLOB Metadata (Задание метаданных BLOB-объекта)|	Да|	Да|
Lease Blob (Аренда BLOB-объекта) (*)|	Да|	Да|
Создание моментального снимка большого двоичного объекта|	Да|	Да|
Копирование BLOB-объекта|	Да|	Да (для исходного и целевого большого двоичного объекта)|
Прерывание копирования большого двоичного объекта|	Нет|	Нет|
Delete BLOB (Удаление BLOB-объекта)|	Нет|	Да|
Put Block (Вставка блокировки)|	Нет|	Нет|
Put Block List (Вставка списка блокировки)|	Да|	Да|
Get Block List (Получение списка блокировки)|	Да|	Нет|
Put Page (Вставка страницы)|	Да|	Да|
Get Page Ranges (Получение диапазона страницы)|	Да|	Да

(*) Аренда большого двоичного объекта не изменяет ETag для него.  

### Пессимистичный параллелизм для BLOB-объектов
Чтобы заблокировать большой двоичный объект для монопольного использования, вы можете [арендовать](http://msdn.microsoft.com/library/azure/ee691972.aspx) его. При получении его в аренду вы можете определить, на какой срок она вам нужна: 15-60 секунд или на неограниченный период, что равносильно монопольной блокировке. Вы можете обновить ограниченную аренду, продлив ее, а также освободиться от нее, если она вам более не нужна. Служба BLOB-объектов автоматически освобождается от ограниченной аренды после завершения ее срока.  

Аренда разрешает поддержку различных стратегий синхронизации, включая монопольную запись / общее чтение, монопольная запись / монопольное чтение и общую запись / монопольное чтение. При наличии аренды служба хранилища включает монопольное чтение (операции put, set и delete), однако, чтобы сделать возможным монопольное чтение, разработчику необходимо обеспечить использование всеми клиентскими приложениями идентификатора аренды, а также наличие действительного идентификатора аренды одновременно только у одного клиента. Операции чтения, не имеющие идентификатора аренды, окажутся в общем чтении.  

Следующий фрагмент C#-кода является примером получения на 30 секунд монопольной аренды на BLOB-объект, обновления содержимого BLOB-объекта и освобождения от аренды. Если на BLOB-объекте уже есть действительная аренда, а вы пытаетесь получить новую аренду, служба BLOB-объектов возвращает статус "HTTP (409) Conflict" (HTTP (409) - конфликт) Фрагмент, приведенный ниже, использует объект **AccessCondition** для инкапсуляции данных аренды при направлении запроса на обновление больших двоичных объектов в службе хранилища. Полный пример можно скачать [здесь](http://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114).  

	// Acquire lease for 15 seconds
	string lease = blockBlob.AcquireLease(TimeSpan.FromSeconds(15), null);
	Console.WriteLine("Blob lease acquired. Lease = {0}", lease);
	 
	// Update blob using lease. This operation will succeed
	const string helloText = "Blob updated";
	var accessCondition = AccessCondition.GenerateLeaseCondition(lease);
	blockBlob.UploadText(helloText, accessCondition: accessCondition);
	Console.WriteLine("Blob updated using an exclusive lease");
	 
	//Simulate third party update to blob without lease
	try
	{
	    // Below operation will fail as no valid lease provided
	    Console.WriteLine("Trying to update blob without valid lease");
	    blockBlob.UploadText("Update without lease, will fail");
	}
	catch (StorageException ex)
	{
	    if (ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.PreconditionFailed)
	        Console.WriteLine("Precondition failure as expected. Blob's lease does not match");
	    else
	        throw;
	}  

Если вы пытаетесь совершить операцию записи на арендованном BLOB-объекте, не идентифицировав аренду, неудавшийся запрос возвращается с ошибкой 412. Обратите внимание, что если срок аренды истекает до вызова метода **UploadText**, но вы все еще проходите идентификацию аренды, запрос также завершается неудачей с ошибкой **412**. Дополнительную информацию об управлении сроками аренды и идентификаторами аренды см. в документации REST по [аренде больших двоичных объектов](http://msdn.microsoft.com/library/azure/ee691972.aspx).  

Для управления пессимистичным параллелизмом аренда может использоваться в следующих операциях с BLOB-объектами:  


-   Put BLOB (Вставка BLOB-объекта)
-	Get BLOB (Получение BLOB-объекта)
-	Get BLOB Properties (Получение свойств BLOB-объекта)
-	Set BLOB Properties (Задание свойств службы BLOB-объекта)
-	Get BLOB Metadata (Получение метаданных BLOB-объекта)
-	Set BLOB Metadata (Задание метаданных BLOB-объекта)
-	Delete BLOB (Удаление BLOB-объекта)
-	Put Block (Вставка блокировки)
-	Put Block List (Вставка списка блокировки)
-	Get Block List (Получение списка блокировки)
-	Put Page (Вставка страницы)
-	Get Page Ranges (Получение диапазона страницы)
-	Создание моментального снимка большого двоичного объекта - идентификатор аренды не обязателен, если есть аренда
-	Копирование большого двоичного объекта - необходим идентификатор аренды, если есть аренда целевого большого двоичного объекта
-	Прерывание копирования большого двоичного объекта - необходим идентификатор аренды, если есть неограниченная аренда целевого большого двоичного объекта
-	Lease Blob (Аренда BLOB-объекта)  

### Пессимистичный параллелизм для контейнеров
Аренда на контейнеры разрешает поддержку тех же стратегий синхронизации, что и на BLOB-объектах (монопольная запись / общее чтение, монопольная запись / монопольное чтение и общая запись / монопольное чтение), однако, в отличие от BLOB-объектов, служба хранилища применяет монополию только к операциям удаления (delete operations). Для удаления контейнера с активной арендой клиент наряду с запросом на удаление должен ввести активный идентификатор аренды. Остальные операции по контейнерам выполняются без введения идентификатора аренды, являясь общими операциями. Если требуется монополия на операции обновления (put или set) или чтения, разработчик должен обеспечить всех клиентов возможностью использования идентификатора аренды, а также наличие действительного идентификатора аренды одновременно только у одного клиента.  

Для управления пессимистичным параллелизмом аренда может использоваться в следующих операциях с контейнерами:  

-	Delete Container (Удаление контейнера)
-	Get Container Properties (Получение свойств контейнера)
-	Get Container Metadata (Получение метаданных контейнера)
-	Set Container Metadata (Определение метаданных контейнера)
-	Get Container ACL (Получение списка управления доступом для контейнера)
-	Set Container ACL (Задание списка управления доступом для контейнера)
-	Lease Container (Аренда контейнера)  

Дополнительные сведения см. в разделах:  

- [Указание условных заголовков для операций службы BLOB-объектов](http://msdn.microsoft.com/library/azure/dd179371.aspx)
- [Аренда контейнера](http://msdn.microsoft.com/library/azure/jj159103.aspx)
- [Lease Blob (Аренда BLOB-объекта)](http://msdn.microsoft.com/library/azure/ee691972.aspx) 

## Управление параллелизмом в службе таблиц
Когда вы работаете с сущностями, служба таблиц использует по умолчанию проверку оптимистичного параллелизма в отличие от службы BLOB-объектов, где вы должны монопольно выбирать проверку оптимистичного параллелизма. Другое отличие служб таблиц и BLOB-объектов заключается в том, что вы можете управлять параллельным поведением только сущностей, в то время как в службе BLOB-объектов можно управлять параллелизмом контейнеров и BLOB-объектов.  

Чтобы использовать оптимистичный параллелизм и проверить, модифицировал ли какой-либо процесс сущность с момента его извлечения из службы табличного хранилища, вы можете использовать значение ETag, которое вы получите при возвращении службой таблиц сущности. Для этой команды используется следующая структура:  

1.	Извлеките сущность из службы табличного хранилища. Ответ включает значение ETag, определяющее текущий идентификатор, ассоциирующийся с этой сущностью в службе хранилища.
2.	При обновлении сущности включите полученное после выполнения шага 1 значение ETag в обязательный заголовок **If-Match** запроса, отправляемого в службу.
3.	Служба сравнивает значение ETag запроса с текущим значением ETag сущности.
4.	Если текущее значение ETag сущности отличается от ETag в обязательном заголовке запроса **If-Match**, служба возвращает клиенту ошибку 412. Это указывает клиенту на то, что после извлечения клиентом сущности он был обновлен другим процессом.
5.	Если текущее значение сущности совпадает со значением ETag в обязательном заголовке запроса **If-Match** или заголовок **If-Match** содержит подстановочный знак (*), служба выполняет запрошенную операцию и обновляет текущее значение ETag сущности, указывая тем самым на ее обновление.  

Обратите внимание, что в отличие от службы BLOB-объектов служба таблиц требует от клиента включать заголовок **If-Match** в запросы обновления. Однако можно принудительно применить безусловное обновление (стратегия "Сохраняются изменения, внесенные последними") и избежать проверки параллелизма, если клиент устанавливает в заголовке **If-Match** подстановочный знак (*), когда делает запрос.  

Следующий фрагмент C#-кода показывает пользователю сущность, предварительно созданную или извлеченную, с обновленным электронным адресом. Начальная операция по вводу или извлечению сохраняет значение ETag в объекте пользователя, а так как образец использует тот же экземпляр при операции замены, он автоматически отправляет значение ETag назад в службу таблиц, вызывая проверку на нарушение параллелизма. Если произошло обновление сущности в службе хранилища другим процессом, служба возвращает сообщение о состоянии HTTP 412 (Необходимое условие не выполнено). Полный пример можно скачать [здесь](http://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114).  

	try
	{
	    customer.Email = "updatedEmail@contoso.org";
	    TableOperation replaceCustomer = TableOperation.Replace(customer);
	    customerTable.Execute(replaceCustomer);
	    Console.WriteLine("Replace operation succeeded.");
	}
	catch (StorageException ex)
	{
	    if (ex.RequestInformation.HttpStatusCode == 412)
	        Console.WriteLine("Optimistic concurrency violation - entity has changed since it was retrieved.");
	    else
	        throw; 
	}  

Чтобы явно отключить проверку на параллелизм, вам следует задать свойство **ETag** объекта **employee** равное "*", прежде чем выполнять операцию замены.  

customer.ETag = "*";  

Таблица показывает, как операции сущности в таблице используют значения ETag:  

Операция	|Returns ETag value (Возврат значения ETag)	|Requires If-Match request header (Требует заголовок запроса If-Match)|
------------|-------------------|--------------------------------|
Query Entities (Сущности запроса)|	Да|	Нет|
Insert Entity (Вставка сущности )|	Да|	Нет|
Update Entity (Обновление сущности)|	Да|	Да|
Merge Entity (Слияние сущностей)|	Да|	Да|
Delete Entity (Удаление сущности)|	Нет|	Да|
Insert or Replace Entity (Вставка или замена сущности)|	Да|	Нет|
Insert or Merge Entity (Вставка или слияние сущностей)|	Да|	Нет 

Обратите внимание на то, что операции **Insert or Replace Entity** и **Insert or Merge Entity** *not* проверяют параллелизм, так как они не отправляют значение ETag в службу таблиц.  

В основном разработчики, использующие таблицы, при разработке масштабируемых приложений должны полагаться на оптимистичный параллелизм. При необходимости в пессимистической блокировке, разработчики при получении доступа к таблицам могут сделать следующее: назначить для каждой таблицы определенный BLOB-объект и попытаться арендовать BLOB-объект до операции на таблице. Этот подход требует, чтобы приложение обеспечило путям доступа ко всем данным возможность получить аренду до операций на таблице. Вам следует обратить внимание на то, что минимальный срок аренды составляет 15 секунд, что необходимо тщательно изучить для масштабируемости.  

Дополнительные сведения см. в разделах:  

- [Операции с сущностями](http://msdn.microsoft.com/library/azure/dd179375.aspx)  

## Управление параллелизмом в службе очередей
Одним из сценариев, в котором параллелизм является проблемой, является служба очередей, в которой из очереди получают сообщения несколько клиентов. Когда сообщение извлекается из очереди, ответ включает в себя сообщение и значение подтверждения получения, необходимое для удаления очереди. Сообщение не удаляется из очереди автоматически, но после извлечения оно становится невидимым для других клиентов на интервал времени, установленный параметрами visibilitytimeout (время ожидания видимости). Предполагается, что клиент, извлекший сообщение, удалит его после обработки до времени, указанного элементом ответа TimeNextVisible и рассчитанного на основе значения параметра visibilitytimeout. Значение visibilitytimeout добавляется ко времени, за которое извлекается сообщение, для определения значения TimeNextVisible.  

Служба очередей не имеет поддержки ни оптимистического, ни пессимистичного параллелизма, поэтому клиент, обрабатывающий сообщение, извлеченное из очереди, должен обеспечить обработку сообщения идемпотентным образом. Стратегия "Сохраняются изменения, внесенные последними" используется для обновления операций, таких как SetQueueServiceProperties, SetQueueMetaData, SetQueueACL и UpdateMessage.  

Дополнительные сведения см. в разделах:  

- [REST API службы очередей](http://msdn.microsoft.com/library/azure/dd179363.aspx)
- [Получение сообщений](http://msdn.microsoft.com/library/azure/dd179474.aspx)  

## Управление параллелизмом в файловой службе
Доступ к файловой службе можно получить с помощью двух протоколов конечной точки - SMB и REST. Служба REST не поддерживает ни оптимистическую, ни пессимистическую блокировки, и все обновления происходят по стратегии "Сохраняются изменения, внесенные последними". Клиент SMB, монтирующий общий ресурс, может использовать механизм блокировки файловой системы для управления доступом к общим файлам, включая возможность пессимистической блокировки. При открытии файла клиентом SMB он определяет как доступ к файлам, так и режим общего доступа. Параметры доступа к файлам "Write" или "Read/Write" ("Для записи" или "Для чтения и записи"), а также режима совместного использования файлам "None" ("Ни один") приводят к блокировке файла клиентом SMB до закрытия файла. Если попытаться осуществить операцию REST на файле, заблокированном клиентом, SMB служба REST вернет код состояния 409 (конфликт) с кодом ошибки SharingViolation.  

При открытии клиентом SMB файла для удаления она отмечает файл как "ожидающий удаления" до тех пор, пока все остальные клиенты SMB, открывшие дескрипторы на файл, закроются. Пока файл отмечен как "ожидающий удаления", любая операция REST на этом файле вернется кодом состояния 409 (конфликт) и с кодом ошибки SMBDeletePending. Код состояния 404 (не найден) не возвращается, так как клиент SMB не может удалить флажок "ожидающий удаления" с файла до его закрытия. Иными словами, получение кода состояния 404 (не найден) возможно только после удаления файла. Заметьте, что пока файл находится в состоянии "ожидающий удаления" SMB, он не будет быть включен в результаты операции "Перечислить файлы". Обратите также внимание на то, что операции REST Delete File (Удалить файлы) и REST Delete Directory (удалить папку) выполняются атомарным образом и не ведут к состоянию "ожидающий удаления".  

Дополнительные сведения см. в разделах:  

- [Управление блокировкой файлов](http://msdn.microsoft.com/library/azure/dn194265.aspx)  

## Сводка и дальнейшие действия
Служба хранилища Microsoft Azure разработана для удовлетворения потребностей большинства сложных интерактивных приложений, при этом не принуждает разработчиков нарушать или пересматривать ключевые допущения в разработках, такие как параллелизм и согласованность данных, которые уже учтены.  

Полный образец приложения, упомянутый в блоге:  

- [Управление параллелизмом с помощью службы хранилища Azure: пример приложения](http://code.msdn.microsoft.com/windowsazure/Managing-Concurrency-using-56018114)  

Подробнее о службе хранения Azure:  

- [Домашняя страница службы хранилища Microsoft Azure](http://azure.microsoft.com/services/storage/)
- [Введение в хранилище Azure](http://azure.microsoft.com/documentation/articles/storage-introduction/)
- Знакомство с хранилищем для [BLOB-объектов](http://azure.microsoft.com/documentation/articles/storage-dotnet-how-to-use-blobs/), [таблиц](http://azure.microsoft.com/documentation/articles/storage-dotnet-how-to-use-tables/) и [очередей](http://azure.microsoft.com/documentation/articles/storage-dotnet-how-to-use-queues/)
- Архитектура хранилища - [Хранилище Microsoft Azure. Высокодоступная служба облачного хранения с развитой системой согласованности](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)


<!--HONumber=47-->
 