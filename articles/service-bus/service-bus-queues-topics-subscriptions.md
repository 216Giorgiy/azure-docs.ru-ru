<properties 
   pageTitle="Очереди, разделы и подписки служебной шины | Microsoft Azure"
   description="Общие сведения о сущностях обмена сообщениями в служебной шине."
   services="service-bus"
   documentationCenter="na"
   authors="sethmanheim"
   manager="timlt"
   editor="tysonn" />
<tags 
   ms.service="service-bus"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="12/09/2015"
   ms.author="sethm" />

# Очереди, разделы и подписки служебной шины

Служебная шина Microsoft Azure поддерживает набор облачных технологий промежуточного уровня, ориентированных на обработку сообщений. Эти технологии представлены надежными очередями сообщений, а также возможностями публикации и подписки в рамках обмена сообщениями. Эти возможности обмена сообщениями через посредника могут рассматриваться как разделенные функции обмена сообщениями, поддерживающие публикацию и подписку, временное разделение, а также сценарии балансировки нагрузки с использованием фабрики обмена сообщениями служебной шины. Разделенный обмен данными имеет множество преимуществ. Например, клиенты и серверы могут подключаться по необходимости, выполняя свои операции в асинхронном режиме.

Сущности обмена сообщениями, образующие основные возможности обмена сообщениями через посредника в служебной шине, представлены очередями, разделами и подписками, правилами и действиями, а также концентраторами событий.

## Очереди

Очереди предлагают доставку сообщений конкурирующим потребителям FIFO. То есть обычно получатели принимают и обрабатывают сообщения в том порядке, в котором они были добавлены в очередь. При этом каждое сообщение принимается и обрабатывается только одним потребителем сообщений. Основное преимущество использования очередей — временное разделение компонентов приложений. Другими словами, производителям (отправителям) и потребителям (получателям) не приходится отправлять и получать сообщения в одно и то же время, поскольку сообщения надежно хранятся в очереди. Более того, производителю не нужно ждать ответ от потребителя, чтобы продолжить обработку и отправку дальнейших сообщений.

Сопутствующее преимущество заключается в выравнивании нагрузки — оно позволяет производителям и потребителям отправлять и получать сообщения с разной скоростью. Во многих приложениях уровень системной нагрузки со временем меняется, однако длительность обработки каждой единицы работы, как правило, остается постоянной. Обмен сообщениями между производителем и потребителем с использованием очереди предусматривает подготовку потребляющего приложения к обработке средней, а не пиковой нагрузки. При колебаниях входящей нагрузки просто изменяется глубина очереди. Это позволяет существенно сократить расходы на инфраструктуру, необходимую для обработки нагрузки приложения. По мере возрастания нагрузки могут потребоваться дополнительные рабочие процессы для чтения из очереди. Каждое сообщение обрабатывается одним рабочим процессом. Кроме того, балансировка нагрузки по запросу обеспечивает оптимальное использование рабочих компьютеров с разной вычислительной мощностью, позволяя извлекать сообщения с максимально доступной скоростью. Такой подход часто называют моделью конкурирующих потребителей.

Использование очередей в качестве посредника между производителями и потребителями сообщений уменьшает зависимость между компонентами. Так как производители и потребители не зависят друг от друга, обновление потребителя не оказывает влияния на производителя.

Создание очереди является многоэтапным процессом. Выполнять операции управления для сущностей обмена сообщениями служебной шины (очередей и разделов) можно с использованием класса [Microsoft.ServiceBus.NamespaceManager](https://msdn.microsoft.com/library/azure/microsoft.servicebus.namespacemanager.aspx). Этот класс создается путем предоставления базового адреса пространства имен служебной шины и учетных данных пользователя. Класс [NamespaceManager](https://msdn.microsoft.com/library/azure/microsoft.servicebus.namespacemanager.aspx) предоставляет методы для создания, перечисления и удаления сущностей обмена сообщениями. Создав объект [Microsoft.ServiceBus.TokenProvider](https://msdn.microsoft.com/library/azure/microsoft.servicebus.tokenprovider.aspx) на основе имени и ключа SAS, а также объект управления пространством имен службы, можно создать очередь, используя метод [Microsoft.ServiceBus.NamespaceManager.CreateQueue](https://msdn.microsoft.com/library/azure/hh293157.aspx). Например:

```
// Create management credentials
TokenProvider credentials = TokenProvider. CreateSharedAccessSignatureTokenProvider(sasKeyName,sasKeyValue);
// Create namespace client
NamespaceManager namespaceClient = new NamespaceManager(ServiceBusEnvironment.CreateServiceUri("sb", ServiceNamespace, string.Empty), credentials);
```

Затем можно создать объект очереди и фабрику обмена сообщениями с помощью URI служебной шины в качестве аргумента. Например:

```
QueueDescription myQueue;
myQueue = namespaceClient.CreateQueue("TestQueue");
MessagingFactory factory = MessagingFactory.Create(ServiceBusEnvironment.CreateServiceUri("sb", ServiceNamespace, string.Empty), credentials); 
QueueClient myQueueClient = factory.CreateQueueClient("TestQueue");
```

После этого можно отправлять сообщения в очередь. Например, если имеется список сообщений, передаваемых через посредника, с именем `MessageList`, код будет выглядеть приблизительно так:

```
for (int count = 0; count < 6; count++)
{
    var issue = MessageList[count];
    issue.Label = issue.Properties["IssueTitle"].ToString();
    myQueueClient.Send(issue);
}
```

Можно затем получить сообщения из очереди, как показано ниже:

```
while ((message = myQueueClient.Receive(new TimeSpan(hours: 0, minutes: 0, seconds: 5))) != null)
    {
        Console.WriteLine(string.Format("Message received: {0}, {1}, {2}", message.SequenceNumber, message.Label, message.MessageId));
        message.Complete();

        Console.WriteLine("Processing message (sleeping...)");
        Thread.Sleep(1000);
    }
```

В режиме [ReceiveAndDelete](https://msdn.microsoft.com/library/azure/microsoft.servicebus.messaging.receivemode.aspx) получение является одиночной операцией. Это значит, что, когда служебная шина получает запрос, сообщение помечается как использованное и возвращается в приложение. Режим [ReceiveAndDelete](https://msdn.microsoft.com/library/azure/microsoft.servicebus.messaging.receivemode.aspx) представляет собой самую простую модель. Наиболее эффективен он в сценариях, когда приложение допускает отсутствие обработки сообщения в случае сбоя. Чтобы это понять, рассмотрим сценарий, в котором объект-получатель выдает запрос на получение и выходит из строя до его обработки. Служебная шина помечает сообщение как использованное. Следовательно, когда после перезапуска приложение снова начнет обрабатывать сообщения, оно пропустит сообщение, использованное до сбоя.

В режиме [PeekLock](https://msdn.microsoft.com/library/azure/microsoft.servicebus.messaging.receivemode.aspx) процесс получения становится двухэтапной операцией. Это позволяет поддерживать приложения, которые не допускают пропуск сообщений. Получив запрос, служебная шина находит следующее сообщение, блокирует его, чтобы другие потребители не могли его принять, а затем возвращает его приложению. Когда приложение завершает обработку сообщения (или надежно сохраняет его для последующей обработки), оно завершает второй этап процесса получения, вызывая метод [Complete](https://msdn.microsoft.com/library/azure/microsoft.servicebus.messaging.brokeredmessage.complete.aspx) для полученного сообщения. Когда служебная шина фиксирует вызов [Complete](https://msdn.microsoft.com/library/azure/microsoft.servicebus.messaging.brokeredmessage.complete.aspx), сообщение помечается как используемое.

Если приложение по каким-либо причинам не может обработать сообщение, оно может вызвать для полученного сообщения метод [Abandon](https://msdn.microsoft.com/library/azure/hh181837.aspx) (вместо метода [Complete](https://msdn.microsoft.com/library/azure/microsoft.servicebus.messaging.brokeredmessage.complete.aspx)). После этого служебная шина разблокирует сообщение в очереди, сделав его доступным для приема тем же или другим конкурирующим потребителем. Кроме того, блокирование связано с определенным временем ожидания. Если приложение не сможет обработать сообщение до истечения времени ожидания (например, при сбое приложения), служебная шина автоматически разблокирует сообщение, сделав его снова доступным для получения.

Если сбой приложения происходит после обработки сообщения, но перед отправкой запроса [Complete](https://msdn.microsoft.com/library/azure/microsoft.servicebus.messaging.brokeredmessage.complete.aspx), такое сообщение будет повторно доставлено в приложение после перезапуска. Такой подход предполагает концепцию обработки сообщения *хотя бы один раз*. Тем не менее в некоторых случаях это же сообщение может быть доставлено повторно. Если сценарий не допускает повторную обработку, для обнаружения дубликатов требуется дополнительная логика в приложении. Это реализуется с помощью свойства сообщения **MessageId**, которое остается постоянным в ходе разных попыток доставки. Такой подход предполагает концепцию обработки *только один раз*.

Дополнительные сведения и рабочий пример создания и отправки сообщений в очередь и из нее см. в статье [Учебное пособие по обмену сообщениями .NET через посредника в служебной шине](https://msdn.microsoft.com/library/azure/hh367512.aspx).

## Разделы и подписки

В отличие от очередей, в которых каждое сообщение обрабатывается одним потребителем, разделы и подписки предоставляют более универсальный вид связи («один ко многим») в рамках шаблона *публикации или подписки*. Каждое опубликованное сообщение становится доступным в рамках каждой подписки, зарегистрированной в разделе. Это особенно удобно при масштабировании с учетом большого количества получателей. Сообщения отправляются в раздел и доставляются в одну или несколько связанных подписок в зависимости от правил фильтрации, которые могут быть заданы для каждой подписки. Подписки могут использовать дополнительные фильтры для ограничения получаемых сообщений. Сообщения отправляются в раздел так же, как и в очередь; при этом непосредственно из раздела получить их нельзя. Их можно получить из подписок. Подписка раздела напоминает виртуальную очередь, которая получает копии сообщений, отправленных в раздел. Сообщения извлекаются из подписки так же, как и из очереди.

Продолжая сравнение, можно сказать о функциональном соответствии процесса отправки сообщений в очередь и раздел, а также процесса извлечения сообщений из подписки. Помимо прочего, это означает, что подписки также поддерживают схемы для очередей, описанные ранее в этом разделе, в том числе конкуренцию потребителей, временное разделение, а также выравнивание и балансировку нагрузки.

Создание раздела аналогично созданию очереди, как показано в примере, приведенном в предыдущей главе. Создайте URI службы, а затем с помощью класса [NamespaceManager](https://msdn.microsoft.com/library/azure/microsoft.servicebus.namespacemanager.aspx) создайте клиент пространства имен. Затем можно создать раздел с помощью метода [CreateTopic](https://msdn.microsoft.com/library/azure/hh293080.aspx). Например:

```
TopicDescription dataCollectionTopic = namespaceClient.CreateTopic("DataCollectionTopic");
```

Затем добавьте требуемые подписки:

```
SubscriptionDescription myAgentSubscription = namespaceClient.CreateSubscription(myTopic.Path, "Inventory");
SubscriptionDescription myAuditSubscription = namespaceClient.CreateSubscription(myTopic.Path, "Dashboard");
```

Теперь можно создать клиент раздела. Например:

```
MessagingFactory factory = MessagingFactory.Create(serviceUri, tokenProvider);
TopicClient myTopicClient = factory.CreateTopicClient(myTopic.Path)
```

С помощью отправителя сообщений можно отправлять сообщения в раздел и извлекать их из раздела, как описано выше. Например:

```
foreach (BrokeredMessage message in messageList)
{
    myTopicClient.Send(message);
    Console.WriteLine(
    string.Format("Message sent: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
}
```

Как и в случае с очередью, сообщения извлекаются из подписки с помощью объекта [SubscriptionClient](https://msdn.microsoft.com/library/azure/microsoft.servicebus.messaging.subscriptionclient.aspx), используемого вместо объекта [QueueClient](https://msdn.microsoft.com/library/azure/microsoft.servicebus.messaging.queueclient.aspx). Создайте клиент подписки, передав в качестве параметров имя раздела, имя подписки и (необязательно) режим получения. Пример с подпиской **Inventory**:

```
// Create the subscription client
MessagingFactory factory = MessagingFactory.Create(serviceUri, tokenProvider); 

SubscriptionClient agentSubscriptionClient = factory.CreateSubscriptionClient("IssueTrackingTopic", "Inventory", ReceiveMode.PeekLock);
SubscriptionClient auditSubscriptionClient = factory.CreateSubscriptionClient("IssueTrackingTopic", "Dashboard", ReceiveMode.ReceiveAndDelete); 

while ((message = agentSubscriptionClient.Receive(TimeSpan.FromSeconds(5))) != null)
{
    Console.WriteLine("\nReceiving message from Inventory...");
    Console.WriteLine(string.Format("Message received: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
    message.Complete();
}          

// Create a receiver using ReceiveAndDelete mode
while ((message = auditSubscriptionClient.Receive(TimeSpan.FromSeconds(5))) != null)
{
    Console.WriteLine("\nReceiving message from Dashboard...");
    Console.WriteLine(string.Format("Message received: Id = {0}, Body = {1}", message.MessageId, message.GetBody<string>()));
}
```

### Правила и действия

Во многих ситуациях сообщения с определенными характеристиками должны обрабатываться разными способами. Для этого можно настроить подписки, обеспечивающие поиск сообщений с нужными свойствами, после чего можно выполнить определенные изменения этих свойств. Хотя подписки служебной шины регистрируют все сообщения, отправленные в раздел, в виртуальную очередь подписки можно скопировать только часть этих сообщений. Это возможно благодаря использованию фильтров подписок. Такие изменения называются *действиями фильтров*. При создании подписки можно указать выражение фильтра, которое работает со свойствами сообщения, включая системные свойства (например, **Label**) и свойства пользовательского приложения (например, **StoreName**). В этом случае SQL-выражение фильтра является необязательным. Без него все определенные в подписке действия фильтра будут выполняться по отношению ко всем сообщениям в рамках этой подписки.

Используя предыдущий пример, вы можете создать подписку Dashboard для фильтрации сообщений, приходящих только от **Store1**.

```
namespaceManager.CreateSubscription("IssueTrackingTopic", "Dashboard", new SqlFilter("StoreName = 'Store1'"));
```

Благодаря этому фильтру подписки в виртуальную очередь для подписки `Dashboard` копируются только сообщения со свойством `StoreName`, которому присвоено значение `Store1`.

Дополнительные сведения о возможных значениях фильтров см. в документации по классам [SqlFilter](https://msdn.microsoft.com/library/azure/microsoft.servicebus.messaging.sqlfilter.aspx) и [SqlRuleAction](https://msdn.microsoft.com/library/azure/microsoft.servicebus.messaging.sqlruleaction.aspx). Также см. пример [Brokered Messaging : Advanced Filters](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749).

## Концентраторы событий

[Концентраторы событий](http://azure.microsoft.com/services/event-hubs/) — это служба обработки событий, используемая для крупномасштабной передачи входящих событий и данных телеметрии в Azure. Работа службы характеризуется низкой задержкой и высокой надежностью. При использовании вместе с другими подчиненными службами это решение особенно полезно для инструментирования приложений, обеспечения удобства работы пользователя или функционирования рабочих процессов, а также «Интернета вещей» (IoT).

Концентраторы событий — это служба потоковой передачи сообщений. Может показаться, что концентраторы событий похожи на очереди или разделы, однако их характеристики существенно отличаются. Например, концентраторы событий не предоставляют сведения в рамках традиционного обмена сообщениями через посредника (в том числе сведения о сроке жизни сообщений (TTL)), недоставленных сообщениях, транзакциях и подтверждениях, поскольку это не входит в функции потоковой передачи. Концентраторы событий выполняют другие функции, связанные с потоковой передачей, в том числе секционирование, сохранение порядка и воспроизведение потока.

## Дальнейшие действия

Дополнительные сведения и примеры использования сущностей обмена сообщениями через посредника в служебной шине см. в следующих дополнительных статьях.

- [Основные сведения об обмене сообщениями через служебную шину](service-bus-messaging-overview.md)
- [Учебное пособие по обмену сообщениями .NET через посредника в служебной шине](service-bus-brokered-tutorial-dotnet.md)
- [Руководство по обмену сообщениями через посредника служебной шины на основе REST](service-bus-brokered-tutorial-rest.md)
- [Руководство разработчика по концентраторам событий](../event-hubs/event-hubs-programming-guide.md)
- [Обмен сообщениями через посредника: расширенные фильтры](http://code.msdn.microsoft.com/Brokered-Messaging-6b0d2749)

<!---HONumber=AcomDC_1217_2015-->