<properties title="Query with DocumentDB SQL" pageTitle="Query with DocumentDB SQL | Azure" description="DocumentDB supports querying of documents using SQL-like grammar over hierarchical JSON documents without requiring explicit schema or creation of secondary indexes." metaKeywords="" services="documentdb"  documentationCenter="" solutions="data-management" authors="bradsev" manager="jhubbard" editor="cgronlun" videoId="" scriptId="" />

<tags ms.service="documentdb" ms.workload="data-services" ms.tgt_pltfrm="na" ms.devlang="na" ms.topic="article" ms.date="08/20/2014" ms.author="bradsev"></tags>

# Запросы DocumentDB

Azure DocumentDB поддерживает запросы документов с использованием хорошо знакомого языка SQL (Structured Query Language) к иерархическим документам JSON. DocumentDB действительно не имеет схемы. В силу своей приверженности к модели данных JSON непосредственно внутри базы данных, что обеспечивает автоматическое индексирование документов JSON, не требуя явной схемы или создания вторичных индексов.
При проектировании языка запросов для DocumentDB перед нами стояло две цели:

-   **Воспользоваться SQL**. Вместо того чтобы изобретать новый язык запросов, мы хотели использовать существующий язык SQL. Ведь SQL — один из самых популярных и хорошо известных языков формирования запросов. Язык SQL для Azure DocumentDB предоставляет формальную модель программирования для функционально богатых запросов документов JSON.
-   **Расширить SQL**. Мы хотели использовать модель программирования JavaScript в качестве основы для нашего языка SQL запросов, поэтому ядро базы способно выполнять JavaScript непосредственно для документов JSON. Язык запросов SQL Azure DocumentDB основывается на системе типов, вычисления выражений и вызовов функций JavaScript. Это, в свою очередь, обеспечивает естественную модель программирования для реляционных проекций, иерархической навигации через документов JSON, внутренних соединений, вызовов пользовательских функций (UDF), написанных полностью на JavaScript, среди других особенностей.

Мы считаем, что эти возможности являются ключевыми для уменьшения рассогласованности между приложением и базой данных и имеют решающее значение для производительности разработчика.

В этом уроке мы кратко расскажем о возможностях языка запросов DocumentDB и его грамматике на примерах. Мы также рассмотрим, как можно формировать запросы к DocumentDB, используя API REST и пакеты SDK (в том числе LINQ).

# Приступая к работе

Чтобы увидеть DocumentDB SQL на деле, мы начнем с нескольких простых JSON документов и пройдемся через некоторые простые запросы к ним. Рассмотрим эти два JSON документа о двух семьях. Обратите внимание, что при работе с DocumentDB нам не нужно явно создавать никаких схем или вторичных индексов. Нам просто нужно вставить документы JSON в коллекцию DocumentDB и впоследствии сформировать запросы.
Рассмотрим простой документ JSON для семьи Андерсен, состоящий из сущностей: родители, дети (и их домашние питомцы), адреса и регистрационная информация. У документа имеются строковые, числовые и логические данные, массивы и вложенные свойства.

**Документ**

    {
        "id": "AndersenFamily",
        "lastName": "Andersen",
        "parents": [
           { "firstName": "Thomas" },
           { "firstName": "Mary Kay"}
        ],
        "children": [
           {
               "firstName": "Henriette Thaulow", "gender": "female", "grade": 5,
               "pets": [{ "givenName": "Fluffy" }]
           }
        ],
        "address": { "state": "WA", "county": "King", "city": "seattle" },
        "isRegistered": true
    }

Вот второй документ с одним различием в заголовке: `givenName` и `familyName` используются вместо `firstName` и `lastName`.

**Документ**

    {
        "id": "WakefieldFamily",
        "parents": [
            { "familyName": "Wakefield", "givenName": "Robin" },
            { "familyName": "Miller", "givenName": "Ben" }
        ],
        "children": [
            {
                "familyName": "Merriam", 
                 "givenName": "Jesse", 
                "gender": "female", "grade": 1,
                "pets": [
                    { "givenName": "Goofy" },
                    { "givenName": "Shadow" }
                ]
            },
            { 
                "familyName": "Miller", 
                 "givenName": "Lisa", 
                 "gender": "female", 
                 "grade": 8 }
        ],
        "address": { "state": "NY", "county": "Manhattan", "city": "NY" },
        "isRegistered": false
    }

Давайте попробуем сформировать несколько запросов на этом массиве данных, чтобы понять некоторые основные принципы SQL для DocumentDB. Например, следующий запрос вернет документы, в которых поле идентификатора совпадает с `AndersenFamily`. Так как это `SELECT *`, результат выполнения запроса является сформированным документом JSON:

**Запрос**

    SELECT * 
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Результат**

    [{
        "id": "AndersenFamily",
        "lastName": "Andersen",
        "parents": [
           { "firstName": "Thomas" },
           { "firstName": "Mary Kay"}
        ],
        "children": [
           {
               "firstName": "Henriette Thaulow", "gender": "female", "grade": 5,
               "pets": [{ "givenName": "Fluffy" }]
           }
        ],
        "address": { "state": "WA", "county": "King", "city": "seattle" },
        "isRegistered": true
    }]

Теперь рассмотрим случай, когда нам необходимо переформатировать вывод JSON в другую форму. Этот запрос отображает новый объект JSON с двумя выбранными полями, имя и город, когда город в адресе совпадает с названием штата. В этом случае совпадут NY и NY.

**Запрос**

    SELECT {"Name":f.id, "City":f.address.city} AS Family 
    FROM Families f 
    WHERE f.address.city = f.address.state

**Результат**

    [{
        "Family": {
            "Name": "WakefieldFamily", 
            "City": "NY"
        }
    }]

Следующий запрос возвращает все заданные имена детей в семье, чей идентификатор совпадает с `WakefieldFamily`.

**Запрос**

    SELECT c.givenName 
    FROM Families f 
    JOIN c IN f.children 
    WHERE f.id = 'WakefieldFamily'

**Результат**

    [
      { "givenName": "Jesse" }, 
      { "givenName": "Lisa"}
    ]

Мы хотели бы обратить внимание на несколько примечательных аспектов языка запросов DocumentDB на примерах, которые мы уже рассмотрели:

-   В DocumentDB язык SQL работает со значениями JSON, т. е. имеет дело с сущностями в виде деревьев, а не со строками и столбцами. Таким образом, язык позволяет обращаться к узлам дерева любой произвольной вложенности, как `Node1.Node2.Node3…..Nodem`, что похоже на реляционный SQL со ссылкой, состоящей из двух частей `<table>.<column>`.
-   Язык работает с данными, не имеющими схемы. Таким образом, система типов должна быть динамически связанной. Одно и то же выражение может возвращать различные типы на разных документах. Результат выполнения запроса является допустимым значением JSON, но не будет гарантированно соответствовать фиксированной схеме.
-   DocumentDB поддерживает только документы, строго соответствующие JSON. Это означает, что система типов и выражения могут обрабатывать только типы JSON. Пожалуйста, обратитесь к [спецификации JSON] (<http://www.json.org/>) для более подробной информации.
-   Коллекция DocumentDB является контейнером документов JSON, не имеющим схемы. Отношения между сущностями данных внутри документов и между документами в коллекции неявно захвачены сдерживанием, а не базируются на основе отношений PK-FK. Это является важным аспектом, на котором нужно заострить внимание, в свете внутренних соединений документа, которые будут обсуждаться позже в этой статье.

# Индексирование DocumentDB

Прежде чем мы перейдем к знакомству с языком DocumentDB SQL, стоит рассмотреть принципы индексирования в DocumentDB.

Цель индексов базы данных заключается в обслуживании запросов в их различных формах с минимальным потреблением ресурсов (например, времени процессора, операций ввода-вывода), обеспечивая при этом хорошую пропускную способность и низкие задержки. Часто, чтобы сделать правильный выбор индекса (-ов) для запроса к базе данных, требуется много планирования и экспериментов. Такой подход ставит представляет препятствие для баз данных, не имеющих схем, где данные не соответствуют строгим схемам и быстро развиваются.

Поэтому при разработке подсистемы индексирования DocumentDB, нами были поставлены следующие цели.

-   Индексация документов не должна требовать наличия схемы: подсистема индексации не требует информации о схеме и не делает никаких априорных предположений о схеме документов.

-   Поддержка эффективных, иерархических развитых и реляционных запросов: индекс эффективно поддерживает язык запросов DocumentDB, в том числе иерархические и реляционные проекции.

-   Поддержка согласованных запросов при устойчивом объеме записи: в случае высоких нагрузок записи данных с согласованными запросами индекс обновляется постепенно, эффективно и оперативно при устойчивом объеме записи. Последовательное обновление индекса имеет решающее значение для удовлетворения запросов с уровнем согласованности, настроенным пользователем для службы документов.

-   Поддержка мультитенантности: учитывая модель резервирования для управления ресурсами для всех клиентов, обновления индекса выполняются в рамках бюджета системных ресурсов (процессор, память, IOPS), выделенных на реплики.

-   Эффективное использование хранилища: для повышения эффективности затрат накладные расходы дискового пространства при индексировании являются ограниченными и предсказуемыми. Это очень важно, потому что DocumentDB позволяет разработчику прийти к компромиссу между эффективностью запросов и накладными расходами.

См. [DocumentDB samples] (<http://code.msdn.microsoft.com/Azure-DocumentDB-NET-Code-6b3da8af#content>) на MSDN для получения сведений о настройке политики индексирования для коллекции. Давайте теперь перейдем к деталям языка SQL DocumentDB .

# Основы запросов DocumentDB

Каждый запрос состоит из предложения **SELECT** и необязательных предложений **FROM** и **WHERE** в соответствии со стандартами ANSI-SQL. Как правило, в каждом запросе источник в предложении FROM является перечислимым. Затем к исходному множеству применяется предложение WHERE для извлечения подмножества документов JSON. И наконец, предложение SELECT используется для проекции запрошенных значений JSON в списке выборки.

    SELECT <select_list> 
    [FROM <from_specification>] 
    [WHERE <filter_condition>]    

# Выражение FROM

Выражение `FROM <from_specification>` является необязательным, если далее в запросе исходное не фильтруется и не отображается. Назначение данного выражения заключается в указании источника данных, с которым работает запрос. Как правило, в качестве источника выступает вся коллекция, но можно указать определенное подмножество вместо целой коллекции.

Запрос типа `SELECT * FROM Families` показывает, что вся коллекция Семья является источником для перечисления. Особый идентификатор **ROOT** может использоваться для представления коллекции вместо указания ее имени.
Правила связывания принудительно применяются к запросу, как это показано ниже:

-   Псевдоним коллекции создается как в `SELECT f.id FROM Families AS f` или просто `SELECT f.id FROM Families f`. Здесь `f` — эквивалент `Families`. `AS` — необязательное ключевое слово для создания псевдонима идентификатора.

-   Обратит внимание, что после создания псевдонима оригинальный источник связывать нельзя. Например, `SELECT Familes.id FROM Families f` является синтаксически неверным, так как идентификатор «Семьи» больше не может быть разрешен.

-   Все свойства, на которые необходимо ссылаться, должны иметь **полное имя**. В отсутствие строгого следования схеме это реализуется для того, чтобы избежать любых неоднозначных привязок. Это значит, что `SELECT id FROM Families f` синтаксически неверен, так как свойство `id` не имеет привязки.

## Вложенные документы

Исходные документы могут быть включены в еще меньшее подмножество. Например, если нужно перечисление только вложенного дерева в каждом документе, корень вложенного дерева может стать источником, как в следующем примере.

**Запрос**

    SELECT * 
    FROM Families.children

**Результат**

    [
      [
        {
            "firstName": "Henriette Thaulow",
            "gender": "female",
            "grade": 5,
            "pets": [
              {
                  "givenName": "Fluffy"
              }
            ]
        }
      ],
      [
        {
            "familyName": "Merriam",
            "givenName": "Jesse",
            "gender": "female",
            "grade": 1
        },
        {
            "familyName": "Miller",
            "givenName": "Lisa",
            "gender": "female",
            "grade": 8
        }
      ]
    ]

В то время как в приведенном выше примере используется массив в качестве источника, объект также может быть использован в качестве источника, как показано в следующем примере. Любое допустимое значение JSON (кроме неопределенного), которое можно найти в источнике, будет рассматриваться для включения в результат запроса. Если в некоторых семействах отсутствует значение `address.state`, то они не попадут в результат запроса.

**Запрос**

    SELECT * 
    FROM Families.address.state

**Результат**

    [
      "WA", 
      "NY"
    ]

# Выражение WHERE

Выражение WHERE (**`WHERE <filter_condition>`**) не является обязательным. Оно определяет условие (условия), которым должны удовлетворять исходные документы JSON для того, чтобы быть включенными в результат. Любой документ JSON должен при вычислении указанных условий возвращать истинное значение, чтобы быть включенным в результат. Выражение WHERE используется слоем индексирования для определения наименьшего подмножества исходных документов, которые могут входить в результат.

Следующий запрос выводит документы, которые содержат свойство имени и его значение равно `AndersenFamily`. Все остальные документы, которые не содержат свойства имени или его значение не соответствует `AndersenFamily`.

**Запрос**

    SELECT f.address
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Результат**

    [{
      "address": {
        "state": "WA", 
        "county": "King", 
        "city": "seattle"
      }
    }]

В предыдущем примере показан простой запрос с условием равенства. SQL для DocumentDB также поддерживает различные скалярные выражения. Наиболее часто используются бинарные и унарные выражения Ссылки на свойства исходного объекта JSON также являются допустимыми выражениями.

В настоящий момент поддерживаются следующие бинарные операторы, они могут быть использованы в запросах, как показано в следующих примерах:

<table>

<tr>

<td>
Арифметические

</td>

<td>
+,-,\*,/,%

</td>

</tr>

<tr>

<td>
Побитовые

</td>

<td>
|, &, ^

</td>

</tr>

<tr>

<td>
Логические

</td>

<td>
AND, OR

</td>

</tr>

<tr>

<td>
Сравнение

</td>

<td>
=, !=, \>, \>=, \<, \<=, \<\>

</td>

</tr>

<tr>

<td>
Строка

</td>

<td>
|| (конкатенация)

</td>

</tr>

</table>
</p>
Давайте рассмотрим примеры запросов с бинарными операторами.

    SELECT * 
    FROM Families.children[0] c
    WHERE c.grade % 2 = 1     -- matching grades == 5, 1

    SELECT * 
    FROM Families.children[0] c
    WHERE c.grade ^ 4 = 1    -- matching grades == 5

    SELECT *
    FROM Families.children[0] c
    WHERE c.grade >= 5     -- matching grades == 5

Унарные операторы **+,-, ~ и NOT** также поддерживаются и могут использоваться в запросах, как показано ниже:

    SELECT *
    FROM Families.children[0] c
    WHERE NOT(c.grade = 5)  -- matching grades == 1

    SELECT *
    FROM Families.children[0] c
    WHERE (-c.grade = -5)  -- matching grades == 5

Кроме бинарных и унарных операторов, также разрешены ссылки на свойства. Например, `SELECT * FROM Families f WHERE f.isRegistered` вернет документы JSON, имеющие свойство `isRegistered` со значением, равным значению JSON `true`. Все прочие значения (ложь, null, не определено, <number>, <string>, <object>, <array> и т. д.) приведут исключению исходного документа из результата.

## Операторы равенства и сравнения

Ниже приведена таблица, в которой собраны результаты сравнения равенства в SQL для DocumentDB между любыми двумя типами JSON.

<table style="width:300px">

<tbody>

<tr>

<td valign="top">
 **Оператор**

</td>

<td valign="top">
 **Не определено**

</td>

<td valign="top">
 **Null**

</td>

<td valign="top">
 **Логический**

</td>

<td valign="top">
 **Число**

</td>

<td valign="top">
 **Строка**

</td>

<td valign="top">
 **Объект**

</td>

<td valign="top">
 **Массив**

</td>

</tr>

<tr>

<td valign="top">
 <strong>Не определено<strong>

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

</tr>

<tr>

<td valign="top">
 <strong>Null<strong>

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 **OK**

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

</tr>

<tr>

<td valign="top">
 <strong>Логический<strong>

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 **OK**

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

</tr>

<tr>

<td valign="top">
 <strong>Число<strong>

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 **OK**

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

</tr>

<tr>

<td valign="top">
 <strong>Строка<strong>

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 **OK**

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

</tr>

<tr>

<td valign="top">
 <strong>Объект<strong>

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 **OK**

</td>

<td valign="top">
 Не определено

</td>

</tr>

<tr>

<td valign="top">
 <strong>Массив<strong>

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 Не определено

</td>

<td valign="top">
 **OK**

</td>

</tr>

</tbody>

</table>
</p>
Для прочих операторов сравнения \>, \>=, !=, \< и \<=

-   Сравнение типов приводит к неопределенному результату.
-   Сравнение двух объектов или двух массивов приводит к неопределенному результату.

Если результат скалярного выражения в фильтре не определен, соответствующий документ не будет включен в результат, так как значение «не определено» не равно логически значению «истина».

## Логические операторы (AND, OR или NOT)

Эти операторы работают с логическими значениями. Таблицы истинности для данных операторов приведены ниже.

<table>
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><p><strong>ИЛИ</strong></p></td>
<td align="left"><p><strong>Истина</strong></p></td>
<td align="left"><p><strong>Ложь</strong></p></td>
<td align="left"><p><strong>Не определено</strong></p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>Истина</strong></p></td>
<td align="left"><p>Истина</p></td>
<td align="left"><p>Истина</p></td>
<td align="left"><p>Истина</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>Ложь</strong></p></td>
<td align="left"><p>Истина</p></td>
<td align="left"><p>Ложь</p></td>
<td align="left"><p>Не определено</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>Не определено</strong></p></td>
<td align="left"><p>Истина</p></td>
<td align="left"><p>Не определено</p></td>
<td align="left"><p>Не определено</p></td>
</tr>
</tbody>
</table>

<table>
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><p><strong>И</strong></p></td>
<td align="left"><p><strong>Истина</strong></p></td>
<td align="left"><p><strong>Ложь</strong></p></td>
<td align="left"><p><strong>Не определено</strong></p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>Истина</strong></p></td>
<td align="left"><p>Истина</p></td>
<td align="left"><p>Ложь</p></td>
<td align="left"><p>Не определено</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>Ложь</strong></p></td>
<td align="left"><p>Ложь</p></td>
<td align="left"><p>Ложь</p></td>
<td align="left"><p>Ложь</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>Не определено</strong></p></td>
<td align="left"><p>Не определено</p></td>
<td align="left"><p>Ложь</p></td>
<td align="left"><p>Не определено</p></td>
</tr>
</tbody>
</table>

<table>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left"><p><strong>НЕ</strong></p></td>
<td align="left"><p></p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>Истина</strong></p></td>
<td align="left"><p>Ложь</p></td>
</tr>
<tr class="odd">
<td align="left"><p><strong>Ложь</strong></p></td>
<td align="left"><p>Истина</p></td>
</tr>
<tr class="even">
<td align="left"><p><strong>Не определено</strong></p></td>
<td align="left"><p>Не определено</p></td>
</tr>
</tbody>
</table>

# Выражение SELECT

Предложение SELECT (**`SELECT <select_list>`**) является обязательным и определяет, какие значения будут извлечены из запроса, так же как и в ANSI SQL. Подмножество, которое было отфильтрован на верхней части исходных документов, передаются на фазе проекции, где указанные значения JSON извлекаются и строится новый объект JSON, на него осуществляется передача для каждого входа.

Пример ниже иллюстрирует типичный запрос SELECT:

**Запрос**

    SELECT f.address
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Результат**

    [{
      "address": {
        "state": "WA", 
        "county": "King", 
        "city": "seattle"
      }
    }]

## Вложенные свойства

В следующем примере мы отображаем два вложенных свойства — `f.address.state` и `f.address.city`:

**Запрос**

    SELECT f.address.state, f.address.city
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Результат**

    [{
      "state": "WA", 
      "city": "seattle"
    }]

Проекция также поддерживает выражения JSON, как показано в следующем примере.

**Запрос**

    SELECT { "state": f.address.state, "city": f.address.city, "name": f.id }
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Результат**

    [{
      "$1": {
        "state": "WA", 
        "city": "seattle", 
        "name": "AndersenFamily"
      }
    }]

Давайте посмотри, какую роль играет `$1`. `SELECT` необходим для создания объекта JSON, и так как ни один из ключей не предоставлен, мы используем имена неявных переменных аргументов, начиная с `$1`. Например, этот запрос возвращает 2 неявные переменные аргументов, помеченных как `$1` и `$2`.

**Запрос**

    SELECT { "state": f.address.state, "city": f.address.city }, 
           { "name": f.id }
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Результат**

    [{
      "$1": {
        "state": "WA", 
        "city": "seattle"
      }, 
      "$2": {
        "name": "AndersenFamily"
      }
    }]

## Псевдонимы

Теперь давайте расширим пример выше с явным использованием псевдонимов. **AS** — ключевое слово, используемое для создания псевдонимов. Обратите внимание, что оно не является обязательным при отображении второго значения, как показано `NameInfo`.

Если в запросе имеются два свойства с совпадающими именами, то должны использоваться псевдонимы для переименования одного или обоих свойств, чтобы устранить неоднозначность в отображаемом результате.

**Запрос**

    SELECT 
           { "state": f.address.state, "city": f.address.city } AS AddressInfo, 
           { "name": f.id } NameInfo
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Результат**

    [{
      "AddressInfo": {
        "state": "WA", 
        "city": "seattle"
      }, 
      "NameInfo": {
        "name": "AndersenFamily"
      }
    }]

## Скалярные выражения

Кроме ссылок на свойства, выражение **SELECT** также поддерживает скалярные выражения, такие как константы, арифметические выражения, логические выражения и т. д. Например, вот простой «Hello World» запрос.

**Запрос**

    SELECT "Hello World"

**Результат**

    [{
      "$1": "Hello World"
    }]

Вот более сложный пример с использованием скалярного выражения:

**Запрос**

    SELECT ((2 + 11 % 7)-2)/3   

**Результат**

    [{
      "$1": 1.33333
    }]

В следующем примере результатом скалярного выражения является логическое.

**Запрос**

    SELECT f.address.city = f.address.state AS AreFromSameCityState
    FROM Families f 

**Результат**

    [
      {
        "AreFromSameCityState": false
      }, 
      {
        "AreFromSameCityState": true
      }
    ]

## Создание объектов и массивов

Еще одной ключевой возможностью языка SQL для DocumentDB является создание объектов и массивов. Обратите внимание, что мы создали новый объект JSON в предыдущем примере. Кроме того, можно также создавать массивы, как показано ниже.

**Запрос**

    SELECT [f.address.city, f.address.state] AS CityState 
    FROM Families f 

**Результат**

    [
      {
        "CityState": [
          "seattle", 
          "WA"
        ]
      }, 
      {
        "CityState": [
          "NY", 
          "NY"
        ]
      }
    ]

## Ключевое слово VALUE

Ключевое слово **VALUE** обеспечивает способ для возврата значения JSON. Например, этот запрос возвращает скалярное значение `"Hello World"` вместо `{$1: "Hello World"}`.

**Запрос**

    SELECT VALUE "Hello World"

**Результат**

    [
      "Hello World"
    ]

Следующий запрос возвращает значение JSON без метки `"address"` в результатах.

**Запрос**

    SELECT VALUE f.address
    FROM Families f 

**Результат**

    [
      {
        "state": "WA", 
        "county": "King", 
        "city": "seattle"
      }, 
      {
        "state": "NY", 
        "county": "Manhattan", 
        "city": "NY"
      }
    ]

Следующий пример это расширяет, чтобы показать, как вернуть примитивные значения JSON, то есть на уровне листьев дерева JSON.

**Запрос**

    SELECT VALUE f.address.state
    FROM Families f 

**Результат**

    [
      "WA",
      "NY"
    ]

## Оператор \*

Для отображения документа без изменений поддерживается специальный оператор (\*). При его использовании должно быть единственное отображаемое поле. Хотя запрос наподобие `SELECT * FROM Families f` допустим, `SELECT VALUE * FROM Families f` и `SELECT *, f.id FROM Families f` недопустимы.

**Запрос**

    SELECT * 
    FROM Families f 
    WHERE f.id = "AndersenFamily"

**Результат**

    [{
        "id": "AndersenFamily",
        "lastName": "Andersen",
        "parents": [
           { "firstName": "Thomas" },
           { "firstName": "Mary Kay"}
        ],
        "children": [
           {
               "firstName": "Henriette Thaulow", "gender": "female", "grade": 5,
               "pets": [{ "givenName": "Fluffy" }]
           }
        ],
        "address": { "state": "WA", "county": "King", "city": "seattle" },
        "isRegistered": true
    }]

# Дополнительные понятия

## Итерация

Мы добавили новую конструкцию, чтобы обеспечить поддержку перебора массивов JSON с помощью ключевого слова **IN** в SQL DocumentDB. Исходное выражение FROM поддерживает итерацию. Начнем с такого примера:

**Запрос**

    SELECT * 
    FROM Families.children

**Результат**

    [
      [
        {
          "firstName": "Henriette Thaulow", 
          "gender": "female", 
          "grade": 5, 
          "pets": [{ "givenName": "Fluffy"}]
        }
      ], 
      [
        {
            "familyName": "Merriam", 
            "givenName": "Jesse", 
            "gender": "female", 
            "grade": 1
        }, 
        {
            "familyName": "Miller", 
            "givenName": "Lisa", 
            "gender": "female", 
            "grade": 8
        }
      ]
    ]

Теперь давайте посмотрим на другой запрос, который выполняет итерации над членами коллекции. Обратите внимание на различия в результирующем массиве. Этот пример разбивает `children` и собирает результаты в единый массив.

**Запрос**

    SELECT * 
    FROM c IN Families.children

**Результат**

    [
      {
          "firstName": "Henriette Thaulow",
          "gender": "female",
          "grade": 5,
          "pets": [{ "givenName": "Fluffy" }]
      },
      {
          "familyName": "Merriam",
          "givenName": "Jesse",
          "gender": "female",
          "grade": 1
      },
      {
          "familyName": "Miller",
          "givenName": "Lisa",
          "gender": "female",
          "grade": 8
      }
    ]

Это можно в дальнейшем использовать для фильтрации каждой конкретной записи массива, как показано в следующем примере.

**Запрос**

    SELECT c.givenName
    FROM c IN Families.children
    WHERE c.grade = 8

**Результат**

    [{
      "givenName": "Lisa"
    }]

## Соединения

В реляционных базах данных возможность соединения таблиц является чрезвычайно важной. Это всего логическое следствие проектирования нормализованных схем. В противоположность этому, DocumentDB работает с денормализованной моделью данных документов без схемы. Это является логическим аналогом «автообъединения».

Синтаксис, поддерживаемый языком:<from_source1> JOIN<from_source2> JOIN ... JOIN <from_sourcen>. В целом будет возвращаться набор **N**-кортежей (кортежей с **N** значениями). Каждый кортеж будет иметь значения, полученные путем итерации всех псевдонимов коллекции среди их наборов. Другими словами, это полное векторное произведение множеств, участвующих в соединении.

Ниже приведены примеры, иллюстрирующие работу соединений. В приведенном ниже примере результат пуст, так как векторное произведение каждого документа из исходного и пустого множества дает пустое множество.

**Запрос**

    SELECT f.id
    FROM Families f
    JOIN f.NonExistent

**Результат**

    [{
    }]

В следующем примере показано соединение между корнем документа и подкорнем `children`. Это векторное произведение между двумя объектами JSON. Дочерние элементы этого массива не оказывают влияния в JOIN, так как мы имеем дело с одним корнем, который является массивом дочерних элементов. Отсюда и результат содержит только два результата, так как векторное произведение каждого документа с массивом дает точно только один документ.

**Запрос**

    SELECT f.id
    FROM Families f
    JOIN f.children

**Результат**

    [
      {
        "id": "AndersenFamily"
      }, 
      {
        "id": "WakefieldFamily"
      }
    ]

Следующий пример является более традиционным присоединением:

**Запрос**

    SELECT f.id
    FROM Families f
    JOIN c IN f.children 

**Результат**

    [
      {
        "id": "AndersenFamily"
      }, 
      {
        "id": "WakefieldFamily"
      }, 
      {
        "id": "WakefieldFamily"
      }
    ]

Обратите внимание, что `from_source` в **JOIN** здесь — итератор. В этом случае поток выглядит следующим образом:

-   Развернуть все дочерние элементы **c** в массиве.
-   Применить векторное произведение корня документа **f** с каждым дочерним элементом**c**, развернутом на первом шаге.
-   В конце проецировать только имя свойства объекта корневого документа **f**.

Первый документ (`AndersenFamily`) содержит только один дочерний элемент, так что результирующий набор содержит только один соответствующий этому документу объект. Второй документ (`WakefieldFamily`) имеет два дочерних объекта. Так, векторное произведение создает отдельный объект для каждого дочернего, в результате получаются два объекта, по одному для каждого дочернего, соответствующего этому документу. Обратите внимание, что корневые поля в обоих этих документах будут такими же, как и следовало ожидать при векторном произведении.

Реальное применение соединения заключается в формировании кортежей из векторного произведения в форме, которую отобразить иначе сложно. Кроме того, как мы увидим в следующем примере, можно фильтровать сочетания кортежа, что позволяет пользователю выбрать условие, которому удовлетворяют кортежи в целом.

**Запрос**

    SELECT 
        f.id AS familyName,
        c.givenName AS childGivenName,
        c.firstName AS childFirstName,
        p.givenName AS petName 
    FROM Families f 
    JOIN c IN f.children 
    JOIN p IN c.pets

**Результат**

    [
      {
        "familyName": "AndersenFamily", 
        "childFirstName": "Henriette Thaulow", 
        "petName": "Fluffy"
      }, 
      {
        "familyName": "WakefieldFamily", 
        "childGivenName": "Jesse", 
        "petName": "Goofy"
      }, 
      {
       "familyName": "WakefieldFamily", 
       "childGivenName": "Jesse", 
       "petName": "Shadow"
      }
    ]

Этот пример является естественным продолжением предыдущего и выполняет двойное соединение. Векторное произведение можно просмотреть в виде следующего псевдокода.

    for-each(Family f in Families)
    {   
        for-each(Child c in f.children)
        {
            for-each(Pet p in c.pets)
            {
                return (Tuple(f.id AS familyName, 
                  c.givenName AS childGivenName, 
                  c.firstName AS childFirstName,
                  p.givenName AS petName));
            }
        }
    }

У `AndersenFamily` имеется один ребенок, у которого имеется один питомец. Векторное произведение представляет собой одну строку (1*1*1) в случае этого семейства. Однако семейство Wakefield включает двух детей, но только у одного ребенка «Джесси» есть питомцы. У нее 2 питомца. Векторное произведение представляет собой две строки (1*1*2 = 2) в случае этого семейства.

В следующем примере введен дополнительный фильтр по `pet`. Будут исключены все кортежи, у которых имя питомца не равно «Shadow». Обратите внимание, что мы можем построить кортежи из массивов, установить фильтр на любой из элементов набора и проецировать любую комбинацию из элементов.

**Запрос**

    SELECT 
        f.id AS familyName,
        c.givenName AS childGivenName,
        c.firstName AS childFirstName,
        p.givenName AS petName 
    FROM Families f 
    JOIN c IN f.children 
    JOIN p IN c.pets
    WHERE p.givenName = "Shadow"

**Результат**

    [
      {
       "familyName": "WakefieldFamily", 
       "childGivenName": "Jesse", 
       "petName": "Shadow"
      }
    ]

# Интеграция JavaScript

DocumentDB обеспечивает модель программирования для реализации логики приложения на основе JavaScript непосредственно в коллекциях в виде хранимых процедур и триггеров. Это позволяет:

-   получить возможность создания высокопроизводительных транзакционных CRUD и запросов к документам в коллекции благодаря глубокой интеграции выполнения JavaScript непосредственно в базы данных.
-   Добиться естественного моделирования потока управления, областей видимости переменных, присвоения и интеграции обработки исключений примитивов с транзакциями базы данных. Для получения более подробной информации о поддержке DocumentDB для интеграции JavaScript, пожалуйста, обратитесь к документации по программированию для серверного JavaScript.

## Определяемые пользователем функции (UDF)

Наряду с указанными выше типами SQL DocumentDB обеспечивает поддержку пользовательских функций (UDF). В частности, поддерживаются скалярные пользовательские функции, где разработчики могут передавать или ни одного, или несколько аргументов и получить один результат. Каждый из этих аргументов проверяется на соответствие допустимым значениям JSON.

Грамматика SQL DocumentDB расширяется за счет использования этих пользовательских функций для поддержки пользовательской логики приложения. Пользовательские функции могут быть зарегистрированы в Azure DocumentDB, а затем на них можно ссылаться как на часть SQL-запроса. На самом деле пользовательские функции специально предназначены для вызовов из запросов. Как следствие этого выбора, UDF не имеют доступа к объекту контекста, какой имеется у других типов JavaScript (хранимых процедуры, триггеров). Поскольку запросы выполняются только для чтения, они могут работать как на первичной, так на вторичной репликах. Поэтому UDF предназначены для работы на вторичных репликах, в отличие от других типов JavaScript.

Ниже приведен пример того, как UDF могут быть зарегистрированы в базе данных DocumentDB, специально для коллекции с большим количеством документов.

       UserDefinedFunction sqrtUdf = new UserDefinedFunction
       {
           Name = "SQRT",
           Body = @"function(number) { 
                       return Math.sqrt(number);
                   };",
       };
       UserDefinedFunction createdUdf = client.CreateUserDefinedFunctionAsync(
           collectionSelfLink/* link of the parent collection*/, 
           sqrtUdf).Result;  
                                                                             

Приведенный выше пример создает UDF с именем `SQRT`. Она принимает одно значение JSON `number` и вычисляет квадратный корень из числа, используя библиотеку Math.

Теперь мы можем использовать эту UDF в запросе в проекции.

**Запрос**

    SELECT SQRT(c.grade)
    FROM c IN Families.children

**Результат**

    [
      {
        "$1": 2.23606797749979
      }, 
      {
        "$1": 1
      }, 
      {
        "$1": 2.8284271247461903
      }
    ]

UDF также может быть использована внутри фильтра, как показано в примере ниже:

**Запрос**

    SELECT c.grade
    FROM c IN Familes.children
    WHERE SQRT(c.grade) = 1

**Результат**

    [{
        "grade": 1
    }]

В сущности, UDF являются корректными скалярными выражениями и могут быть использованы в проекциях и фильтрах.

Для расширения понимания возможностей пользовательских функций, давайте посмотрим на другой пример с условной логикой:

       UserDefinedFunction seaLevelUdf = new UserDefinedFunction()
       {
           Name = "SEALEVEL",
           Body = @"function(city) {
                switch (city) {
                    case 'seattle':
                        return 520;
                    case 'NY':
                        return 410;
                    case 'Chicago':
                        return 673;
                    default:
                        return -1;
                    }"
            };

            UserDefinedFunction createdUdf = await client.CreateUserDefinedFunctionAsync(collection.SelfLink, seaLevelUdf);

Ниже приведен пример осуществления UDF.

**Запрос**

    SELECT f.address.city, SEALEVEL(f.address.city) AS seaLevel
    FROM Families f 

**Результат**

     [
      {
        "city": "seattle", 
        "seaLevel": 520
      }, 
      {
        "city": "NY", 
        "seaLevel": 410
      }
    ]

Как показывают приведенные выше примеры, UDF объединяет мощь языка JavaScript и SQL DocumentDB, чтобы обеспечить богатый программируемый интерфейс для реализации сложной процедурной, условной логики с помощью встроенных возможностей исполнения JavaScript.

На современном этапе обработки UDF SQL DocumentDB передает аргументы в пользовательские функции для каждого документа в источнике (выражение WHERE или SELECT). Результаты включены в общий поток выполнения. Если свойства, на которые ссылаются параметры UDF, недоступны в значениях JSON, параметр рассматривается как неопределенный, и, следовательно, вызов UDF полностью пропускается. Аналогично, если результат UDF не определен, он не включается в результат.

Таким образом, UDF являются отличным средством для реализации сложной бизнес-логики как части запроса.

## Оценивание операторов

DocumentDB, в силу того что это база данных JSON, проводит параллели с операторами JavaScript и его оценочной семантики. В то время как DocumentDB старается сохранить семантику JavaScript в плане поддержки JSON, оценка операторов в некоторых случаях не совпадает.

В языке запросов SQL DocumentDB, в отличие от традиционного SQL, типы значений зачастую неизвестны до тех пор, пока значения фактически не извлекаются из базы данных. Для того чтобы эффективно выполнять запросы, большинство операторов имеют строгие требования к типам.

SQL в DocumentDB не выполняет неявные преобразования, в отличие от JavaScript. Например, запрос `SELECT * FROM Person p WHERE p.Age = 21` выберет документы со свойством «Возраст», равным 21. Все прочие документы, в которых свойство «Возраст» свойство соответствует строке «21» или
другим бесконечным возможным вариациям, таким как «021», «21,0», «0021», «00021» и т. д., не будут соответствовать.
В этом заключается отличие от JavaScript, где строковые значения неявно преобразуются в числа (на основе оператора, исключая: ==). Этот выбор имеет решающее значение для эффективного согласования индексов в SQL DocumentDB.

# LINQ в SQL DocumentDB

LINQ является моделью программирования .NET, которая выражает вычисления в виде запросов потоков объектов. DocumentDB обеспечивает клиентскую библиотеку для взаимодействия с LINQ путем облегчения преобразования между JSON и объектами .NET и отображения из подмножества запросов LINQ на запросы DocumentDB.

На рисунке ниже показана архитектура поддержки запросов LINQ при использовании DocumentDB. Используя клиент DocumentDB, разработчики могут создать объект **IQueryable**, который будет направлять запросы к поставщику запросов DocumentDB, который затем транслирует запросы LINQ в запросы DocumentDB. Затем запрос передается на сервер DocumentDB для получения набора результатов в формате JSON. Возвращаемые результаты десериализуются в поток объектов .NET на стороне клиента.

![][]

## Сопоставление .NET и JSON

Сопоставление между объектами .NET и документами JSON естественно: каждый член поля данных отображаются на объект JSON, где имя поля отображается на «ключевой» части объекта, а часть «значений» рекурсивно отображается на части значений объекта. Рассмотрим пример. Объект «Семья» создан и сопоставлен документу JSON, как показано ниже. И наоборот, документ JSON в свою очередь сопоставлен объекту .NET.

**Класс C\#**

    public class Family
    {
        [JsonProperty(PropertyName="id")]
        public string Id;
        public Parent[] parents;
        public Child[] children;
        public bool isRegistered;
    };

    public struct Parent
    {
        public string familyName;
        public string givenName;
    };

    public class Child
    {
        public string familyName;
        public string givenName;
        public string gender;
        public int grade;
        public List<Pet> pets;
    };

    public class Pet
    {
        public string givenName;
    };

    public class Address
    {
        public string state;
        public string county;
        public string city;
    };

    // create a Family object
    Parent mother = new Parent { familyName= "Wakefield", givenName="Robin" };
    Parent father = new Parent { familyName = "Miller", givenName = "Ben" };
    Child child = new Child { familyName="Merriam", givenName="Jesse", gender="female", grade=1 };
    Pet pet = new Pet { givenName = "Fluffy" };
    Address address = new Address { state = "NY", county = "Manhattan", city = "NY" };
    Family family = new Family { Id = "WakefieldFamily", parents = new Parent [] { mother, father}, children = new Child[] { child }, isRegistered = false };

**JSON**

    {
        "id": "WakefieldFamily",
        "parents": [
            { "familyName": "Wakefield", "givenName": "Robin" },
            { "familyName": "Miller", "givenName": "Ben" }
        ],
        "children": [
            {
                "familyName": "Merriam", 
                "givenName": "Jesse", 
                "gender": "female", 
                "grade": 1,
                "pets": [
                    { "givenName": "Goofy" },
                    { "givenName": "Shadow" }
                ]
            },
            { 
              "familyName": "Miller", 
              "givenName": "Lisa", 
              "gender": "female", 
              "grade": 8 
            }
        ],
        "address": { "state": "NY", "county": "Manhattan", "city": "NY" },
        "isRegistered": false
    };

## Трансляция из LINQ в SQL

Поставщик запросов DocumentDB пытается как можно правильнее отобразить соответствие запроса LINQ запросу SQL DocumentDB. В дальнейшем мы предполагаем, что у читателя имеются базовые знания о LINQ.

Во-первых, для системы типов; мы поддерживаем все примитивные типы JSON: числовые типы, логические, строковые и NULL. Поддерживаются только эти типы JSON. Поддерживаются следующие скалярные выражения.

-   Постоянные значения. Включают в себя постоянные значения примитивных типов данных, которые вычисляются на момент.

-   Выражения свойств/индексов массивов. Относятся к свойствам объекта или элемента массива.

        family.Id;
        family.children[0].familyName;
        family.children[0].grade;
        family.children[n].grade; //n is an int variable

-   Арифметические выражения. К ним относятся общие арифметические выражения на основе численных и логических значений. Для получения полного списка обратитесь к спецификации SQL, указанной выше.

        2 * family.children[0].grade;
        x + y;

-   Выражение сравнения строк. Включает сравнение строкового значения с некоторым постоянным строковым значением.

        mother.familyName == "Smith";
        child.givenName == s; //s is a string variable

-   Выражение создания объекта/массива. Возвращают объект комбинированного типа, или анонимного типа, или массив таких объектов. Эти значения могут быть вложенными.

        new Parent { familyName = "Smith", givenName = "Joe" };
        new { first = 1, second = 2 }; //an anonymous type with 2 fields              
        new int[] { 3, child.grade, 5 };

## Операторы запроса

Вот несколько примеров, которые иллюстрируют, как некоторые из стандартных операторов запросов LINQ транслируются в запросы DocumentDB.

### Оператор Select

Синтаксис: `input.Select(x => f(x))`, здесь `f` — скалярное выражение.

**Лямбда-выражение LINQ**

    input.Select(family => family.parents[0].familyName);

**SQL**

    SELECT VALUE f.parents[0].familyName
    FROM Families f

**Лямбда-выражение LINQ**

    input.Select(family => family.children[0].grade + c); // c is an int variable

**SQL**

    SELECT VALUE f.children[0].grade + c
    FROM Families f 

**Лямбда-выражение LINQ**

    input.Select(family => new
    {
        name = family.children[0].familyName,
        grade = family.children[0].grade + 3
    });

**SQL**

    SELECT VALUE {"name":f.children[0].familyName, 
                  "grade": f.children[0].grade + 3 }
    FROM Families f

### Оператор SelectMany

Синтаксис: `input.SelectMany(x => f(x))`, здесь `f` — скалярное выражение, возвращающее тип коллекции.

**Лямбда-выражение LINQ**

    input.SelectMany(family => family.children);

**SQL**

    SELECT VALUE child
    FROM child IN Families.children

### Оператор Where

Синтаксис: `input.Where(x => f(x))`, здесь `f` — скалярное выражение, возвращающее логический тип.

**Лямбда-выражение LINQ**

    input.Where(family=> family.parents[0].familyName == "Smith");

**SQL**

    SELECT *
    FROM Families f
    WHERE f.parents[0].familyName = "Smith" 

**Лямбда-выражение LINQ**

    input.Where(
        family => family.parents[0].familyName == "Smith" && 
        family.children[0].grade < 3);

**SQL**

    SELECT *
    FROM Families f
    WHERE f.parents[0].familyName = "Smith"
    AND f.children[0].grade < 3

## Составные запросы

Вышеуказанные операторы могут комбинироваться, чтобы формировать более расширенные запросы. Так как DocumentDB поддерживает вложенные коллекции, такая композиция может быть либо объединением, либо вложением.

### Объединение

Синтаксис: `input(.|.SelectMany())(.Select()|.Where())*`. Объединенный запрос может начинаться с необязательного оператора, `SelectMany`, за которым идет несколько операторов `Select` или `Where`.

**Лямбда-выражение LINQ**

    input.Select(family=>family.parents[0])
        .Where(familyName == "Smith");

**SQL**

    SELECT *
    FROM Families f
    WHERE f.parents[0].familyName = "Smith"

**Лямбда-выражение LINQ**

    input.Where(family => family.children[0].grade > 3)
        .Select(family => family.parents[0].familyName);

**SQL**

    SELECT VALUE f.parents[0].familyName
    FROM Families f
    WHERE f.children[0].grade > 3

**Лямбда-выражение LINQ**

    input.Select(family => new { grade=family.children[0].grade}).
        Where(anon=> anon.grade < 3);
            

**SQL**

    SELECT *
    FROM Families f
    WHERE ({grade: f.children[0].grade}.grade > 3)

**Лямбда-выражение LINQ**

    input.SelectMany(family => family.parents)
        .Where(parent => parents.familyName == "Smith");

**SQL**

    SELECT *
    FROM p IN Families.parents
    WHERE p.familyName = "Smith"

### Вложенные операторы

Синтаксис: `input.SelectMany(x=>x.Q())`, здесь Q — оператор `Select`, `SelectMany` или `Where`.

Во вложенных запросах внутренний запрос применяется к каждому элементу внешнего отбора. Одной из важных особенностей является то, что внутренний запрос может ссылаться на поля элементов во внешней коллекции как к самостоятельно присоединенной.

**Лямбда-выражение LINQ**

    input.SelectMany(family=> 
        family.parents.Select(p => p.familyName));

**SQL**

    SELECT VALUE p.familyName
    FROM Families f
    JOIN p IN f.parents

**Лямбда-выражение LINQ**

    input.SelectMany(family => 
        family.children.Where(child => child.familyName == "Jeff"));
            

**SQL**

    SELECT *
    FROM Families f
    JOIN c IN f.children
    WHERE c.familyName = "Jeff"

**Лямбда-выражение LINQ**

    input.SelectMany(family => family.children.Where(
        child => child.familyName == family.parents[0].familyName));

**SQL**

    SELECT *
    FROM Families f
    JOIN c IN f.children
    WHERE c.familyName = f.parents[0].familyName

# Выполнение запросов

Azure DocumentDB предоставляет ресурсы через интерфейс API REST, который можно вызвать с помощью любого языка, позволяющего отправлять запросы HTTP или HTTPS. Кроме того, Azure DocumentDB предлагает программные библиотеки для некоторых популярных языков программирования, таких как NET, Node.js, JavaScript и Python. Интерфейс REST API и различные библиотеки поддерживают запросы через SQL. Пакет SDL .NET помимо SQL поддерживает запросы LINQ.

Следующие примеры показывают, как создать запрос и выполнить его в учетной записи базы данных DocumentDB.

## Интерфейс REST API

DocumentDB предлагает простую и открытую модель программирования RESTful поверх HTTP. Учетные записи баз данных могут быть подготовлены с использованием подписки Azure. Модель ресурсов DocumentDB состоит из наборов ресурсов под учетной записью базы данных, каждый из которых адресуется логическим постоянным URI. Набор ресурсов в данном документе называется каналом. Учетная запись базы данных может состоять из набора баз данных, каждая из которых содержит несколько коллекций, каждая из которых, в свою очередь, содержит хранимые процедуры, триггеры, определяемые пользователем функции, документы и соответствующие вложения.

Базовая модель взаимодействия с этими ресурсами осуществляется через команды HTTP GET, PUT, POST и DELETE в их стандартной интерпретации. Команда POST используется как для создания нового ресурса, выполнения хранимой процедуры, так и для выполнения SQL-запроса. Запросы всегда включают только операции чтения без побочных эффектов.

Следующие примеры показывают, как сформировать запрос с командой POST для DocumentDB к коллекции, содержащей два образца документа, который мы рассматривали ранее. Запрос имеет простой фильтр по свойству имени JSON. Обратите внимание на использование заголовков `x-ms-documentdb-isquery` и Content-Type: `application/sql` для указания на то, что операция — запрос.

**Запрос**

    POST https://<REST URI>/docs HTTP/1.1
    ...
    x-ms-documentdb-isquery: True
    Content-Type: application/sql

    SELECT * FROM Families f WHERE f.id = "AndersenFamily"

**Результат**

    HTTP/1.1 200 Ok
    x-ms-activity-id: 8b4678fa-a947-47d3-8dd3-549a40da6eed
    x-ms-item-count: 1
    x-ms-request-charge: 0.32

    <indented for readability, results highlighted>

    {  
       "_rid":"u1NXANcKogE=",
       "Documents":[  
          {  
             "id":"AndersenFamily",
             "lastName":"Andersen",
             "parents":[  
                {  
                   "firstName":"Thomas"
                },
                {  
                   "firstName":"Mary Kay"
                }
             ],
             "children":[  
                {  
                   "firstName":"Henriette Thaulow",
                   "gender":"female",
                   "grade":5,
                   "pets":[  
                      {  
                         "givenName":"Fluffy"
                      }
                   ]
                }
             ],
             "address":{  
                "state":"WA",
                "county":"King",
                "city":"seattle"
             },
             "_rid":"u1NXANcKogEcAAAAAAAAAA==",
             "_ts":1407691744,
             "_self":"dbs\/u1NXAA==\/colls\/u1NXANcKogE=\/docs\/u1NXANcKogEcAAAAAAAAAA==\/",
             "_etag":"00002b00-0000-0000-0000-53e7abe00000",
             "_attachments":"_attachments\/"
          }
       ],
       "count":1
    }

Второй пример показывает более сложный запрос, который возвращает несколько соединенных результатов.

**Запрос**

    POST https://<REST URI>/docs HTTP/1.1
    ...
    x-ms-documentdb-isquery: True
    Content-Type: application/sql

    SELECT 
         f.id AS familyName, 
         c.givenName AS childGivenName, 
         c.firstName AS childFirstName, 
         p.givenName AS petName 
    FROM Families f 
    JOIN c IN f.children 
    JOIN p in c.pets

**Результат**

    HTTP/1.1 200 Ok
    x-ms-activity-id: 568f34e3-5695-44d3-9b7d-62f8b83e509d
    x-ms-item-count: 1
    x-ms-request-charge: 7.84

    <indented for readability, results highlighted>

    {  
       "_rid":"u1NXANcKogE=",
       "Documents":[  
          {  
             "familyName":"AndersenFamily",
             "childFirstName":"Henriette Thaulow",
             "petName":"Fluffy"
          },
          {  
             "familyName":"WakefieldFamily",
             "childGivenName":"Jesse",
             "petName":"Goofy"
          },
          {  
             "familyName":"WakefieldFamily",
             "childGivenName":"Jesse",
             "petName":"Shadow"
          }
       ],
       "count":3
    }

Если результаты запроса не помещаются на одной странице результатов, то интерфейс API REST возвращает маркер продолжения в заголовке ответа `x-ms-continuation-token`. Клиенты могут разбивать результаты на страницы, включая заголовок в последующие результаты. Количеством результатов на одной странице также можно управлять через число `x-ms-max-item-count` в заголовке.

Для управления политикой согласованности данных используйте заголовок `x-ms-consistency-level`, как во всех запросах API REST. В целях согласованности сеансов также обязательно нужно вернуть последний заголовок cookie `x-ms-session-token` в запросе. Обратите внимание, что политика индексации запрашиваемой коллекции может также повлиять на согласованность результатов запроса. С настройками политики индексации по умолчанию для коллекций индекс всегда актуален и соответствует содержанию документов, и результаты запроса будут соответствовать выбранным для этого данным. Если задействована политика отложенной индексации, запросы могут возвращать устаревшие результаты. Дополнительные сведения см. в разделе [Уровни согласованности DocumentDB][].

Если настроенная политика индексации в коллекции не поддерживает указанный запрос, сервер DocumentDB возвращает код ошибки 400 «Bad Request». Он возвращается для запросов к путям, сконфигурированным для поиска по значениям хэшей (равенство), а также к путям, явно исключенным из индексации. Заголовок `x-ms-documentdb-query-enable-scan` можно задать в запросе для проведения сканирования в случае отсутствия индекса.

## Пакет SDK для C\#

Пакет .NET SDK поддерживает запросы как LINQ, так и SQL. В следующем примере показано, как выполнить простой фильтр для запроса, сформированного ранее в этом документе.

    foreach (var family in client.CreateDocumentQuery(collectionLink, 
        "SELECT * FROM Families f WHERE f.id = \"AndersenFamily\""))
    {
        Console.WriteLine("\tRead {0} from SQL", family);
    }

    foreach (var family in (
        from f in client.CreateDocumentQuery(collectionLink)
        where f.Id == "AndersenFamily"
        select f))
    {
        Console.WriteLine("\tRead {0} from LINQ query", family);
    }

    foreach (var family in client.CreateDocumentQuery(collectionLink)
        .Where(f => f.Id == "AndersenFamily")
        .Select(f => f))
    {
        Console.WriteLine("\tRead {0} from LINQ lambda", family);
    }

Этот пример сравнивает два свойства на равенство в каждом документе и использует анонимные проекции.

    foreach (var family in client.CreateDocumentQuery(collectionLink,
        @"SELECT {""Name"": f.id, ""City"":f.address.city} AS Family 
        FROM Families f 
        WHERE f.address.city = f.address.state"))
    {
        Console.WriteLine("\tRead {0} from SQL", family);
    }

    foreach (var family in (
        from f in client.CreateDocumentQuery<Family>(collectionLink)
        where f.address.city == f.address.state
        select new { Name = f.Id, City = f.address.city }))
    {
        Console.WriteLine("\tRead {0} from LINQ query", family);
    }

    foreach (var family in
        client.CreateDocumentQuery<Family>(collectionLink)
        .Where(f => f.address.city == f.address.state)
        .Select(f => new { Name = f.Id, City = f.address.city }))
    {
        Console.WriteLine("\tRead {0} from LINQ lambda", family);
    }

Следующий пример демонстрирует объединение, выражаемое через LINQ SelectMany.

    foreach (var pet in client.CreateDocumentQuery(collectionLink,
          @"SELECT p
            FROM Families f 
                 JOIN c IN f.children 
                 JOIN p in c.pets 
            WHERE p.givenName = ""Shadow"""))
    {
        Console.WriteLine("\tRead {0} from SQL", pet);
    }

    // Equivalent in Lambda expressions
    foreach (var pet in
        client.CreateDocumentQuery<Family>(collectionLink)
        .SelectMany(f => f.children)
        .SelectMany(c => c.pets)
        .Where(p => p.givenName == "Shadow"))
    {
        Console.WriteLine("\tRead {0} from LINQ lambda", pet);
    }

Клиент .NET автоматически перебирает все страницы результатов запроса в блоках FOREACH, как показано выше. Параметры запроса, введенные в разделе API REST, также доступны в .NET SDK с помощью классов `FeedOptions` и `FeedResponse` в методе CreateDocumentQuery. Количеством страниц можно управлять через настройку `MaxItemCount`.

Разработчики также могут явно управлять разбиением на страницы путем создания `IDocumentQueryable` с помощью объекта `IQueryable`, чтения значений `ResponseContinuationToken` и их передачи обратно как `RequestContinuationToken` в `FeedOptions`. `EnableScanInQuery` может быть установлен для того, чтобы использовать сканирование, когда подобный запрос не поддерживается для сконфигурированной политики индексации.

См. [DocumentDB .NET samples] (<http://code.msdn.microsoft.com/Azure-DocumentDB-NET-Code-6b3da8af#content>), чтобы получить другие примеры запросов.

## Интерфейс API для серверного JavaScript

DocumentDB обеспечивает модель программирования для реализации логики приложения на основе JavaScript непосредственно в коллекциях, используя хранимые процедуры и триггеры. Логика JavaScript регистрируется на уровне коллекции, может выполнять операции в базе данных над документами указанной коллекции. Эти операции оборачиваются транзакциями ACID.

В следующем примере показано, как использовать queryDocuments в интерфейсе API серверного JavaScript чтобы формировать запросы изнутри хранимых процедур и триггеров.

    function businessLogic(name, author) {
        var context = getContext();
        var collectionManager = context.getCollection();
        var collectionLink = collectionManager.getSelfLink()

        // create a new document.
        collectionManager.createDocument(collectionLink,
            { name: name, author: author },
            function (err, documentCreated) {
                if (err) throw new Error(err.message);

                // filter documents by author
                var filterQuery = "SELECT * from root r WHERE r.author = 'George R.'";
                collectionManager.queryDocuments(collectionLink,
                    filterQuery,
                    function (err, matchingDocuments) {
                        if (err) throw new Error(err.message);
    context.getResponse().setBody(matchingDocuments.length);

                        // Replace the author name for all documents that satisfied the query.
                        for (var i = 0; i < matchingDocuments.length; i++) {
                            matchingDocuments[i].author = "George R. R. Martin";
                            // we don't need to execute a callback because they are in parallel
                            collectionManager.replaceDocument(matchingDocuments[i]._self,
                                matchingDocuments[i]);
                        }
                    })
            });
    }

# Ссылки

1.  [Введение в Azure DocumentDB][]
2.  [Спецификация языка DocumentDB SQL] (<http://go.microsoft.com/fwlink/p/?LinkID=510612>)
3.  [Примеры для DocumentDB на .NET] (<http://code.msdn.microsoft.com/Azure-DocumentDB-NET-Code-6b3da8af#content>)
4.  [Уровни согласованности DocumentDB][]
5.  Стандарт ANSI SQL 2011 - [][]<http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681></a>
6.  JSON [][1]<http://json.org/></a>
7.  Спецификация JavaScript ECMA-262 [][2]<http://www.ecma-international.org/publications/standards/Ecma-262.htm></a>
8.  LINQ [][3]<http://msdn.microsoft.com/en-us/library/bb308959.aspx></a>
9.  Технология оценки выражения для больших баз данных [][4]<http://dl.acm.org/citation.cfm?id=152611></a>
10. Обработка запросов в параллельных реляционных СУБД (Query Processing in Parallel Relational Database Systems), IEEE Computer Society Press, 1994
11. Lu, Ooi, Tan, Query Processing in Parallel Relational Database Systems, IEEE Computer Society Press, 1994.
12. Christopher Olston, Benjamin Reed, Utkarsh Srivastava, Ravi Kumar, Andrew Tomkins: Pig Latin: A Not-So-Foreign Language for Data Processing, SIGMOD 2008.
13. G. Graefe. The Cascades framework for query optimization. IEEE Data Eng. Bull., 18(3): 1995.

  []: ./media/documentdb-sql-query/sql-query1.png
  [Уровни согласованности DocumentDB]: ../documentdb-consistency-levels
  [Введение в Azure DocumentDB]: ../documentdb-introduction
  []: http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=53681
  [1]: http://json.org/
  [2]: http://www.ecma-international.org/publications/standards/Ecma-262.htm
  [3]: http://msdn.microsoft.com/en-us/library/bb308959.aspx
  [4]: http://dl.acm.org/citation.cfm?id=152611
